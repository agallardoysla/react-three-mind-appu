(()=>{var A={818:function(A,g,I){(function(){"use strict";var A;function g(A){var g=0;return function(){return g<A.length?{done:!1,value:A[g++]}:{done:!0}}}var t="function"==typeof Object.defineProperties?Object.defineProperty:function(A,g,I){return A==Array.prototype||A==Object.prototype||(A[g]=I.value),A};var C=function(A){A=["object"==typeof globalThis&&globalThis,A,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof I.g&&I.g];for(var g=0;g<A.length;++g){var t=A[g];if(t&&t.Math==Math)return t}throw Error("Cannot find global object")}(this);function e(A,g){if(g)A:{var I=C;A=A.split(".");for(var e=0;e<A.length-1;e++){var B=A[e];if(!(B in I))break A;I=I[B]}(g=g(e=I[A=A[A.length-1]]))!=e&&null!=g&&t(I,A,{configurable:!0,writable:!0,value:g})}}function B(A){return(A={next:A})[Symbol.iterator]=function(){return this},A}function i(A){var I="undefined"!=typeof Symbol&&Symbol.iterator&&A[Symbol.iterator];return I?I.call(A):{next:g(A)}}function Q(A){if(!(A instanceof Array)){A=i(A);for(var g,I=[];!(g=A.next()).done;)I.push(g.value);A=I}return A}e("Symbol",(function(A){function g(A,g){this.g=A,t(this,"description",{configurable:!0,writable:!0,value:g})}if(A)return A;g.prototype.toString=function(){return this.g};var I="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",C=0;return function A(t){if(this instanceof A)throw new TypeError("Symbol is not a constructor");return new g(I+(t||"")+"_"+C++,t)}})),e("Symbol.iterator",(function(A){if(A)return A;A=Symbol("Symbol.iterator");for(var I="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),e=0;e<I.length;e++){var i=C[I[e]];"function"==typeof i&&"function"!=typeof i.prototype[A]&&t(i.prototype,A,{configurable:!0,writable:!0,value:function(){return B(g(this))}})}return A}));var o,E="function"==typeof Object.create?Object.create:function(A){function g(){}return g.prototype=A,new g};if("function"==typeof Object.setPrototypeOf)o=Object.setPrototypeOf;else{var n;A:{var s={};try{s.__proto__={a:!0},n=s.a;break A}catch(A){}n=!1}o=n?function(A,g){if(A.__proto__=g,A.__proto__!==g)throw new TypeError(A+" is not extensible");return A}:null}var a=o;function r(A,g){if(A.prototype=E(g.prototype),A.prototype.constructor=A,a)a(A,g);else for(var I in g)if("prototype"!=I)if(Object.defineProperties){var t=Object.getOwnPropertyDescriptor(g,I);t&&Object.defineProperty(A,I,t)}else A[I]=g[I];A.ea=g.prototype}function h(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function c(A){if(A.l)throw new TypeError("Generator is already running");A.l=!0}function l(A,g){A.j={U:g,V:!0},A.g=A.m||A.s}function D(A,g,I){return A.g=I,{value:g}}function u(A){this.g=new h,this.h=A}function w(A,g,I,t){try{var C=g.call(A.g.i,I);if(!(C instanceof Object))throw new TypeError("Iterator result "+C+" is not an object");if(!C.done)return A.g.l=!1,C;var e=C.value}catch(g){return A.g.i=null,l(A.g,g),d(A)}return A.g.i=null,t.call(A.g,e),d(A)}function d(A){for(;A.g.g;)try{var g=A.h(A.g);if(g)return A.g.l=!1,{value:g.value,done:!1}}catch(g){A.g.h=void 0,l(A.g,g)}if(A.g.l=!1,A.g.j){if(g=A.g.j,A.g.j=null,g.V)throw g.U;return{value:g.return,done:!0}}return{value:void 0,done:!0}}function p(A){this.next=function(g){return c(A.g),A.g.i?g=w(A,A.g.i.next,g,A.g.o):(A.g.o(g),g=d(A)),g},this.throw=function(g){return c(A.g),A.g.i?g=w(A,A.g.i.throw,g,A.g.o):(l(A.g,g),g=d(A)),g},this.return=function(g){return function(A,g){c(A.g);var I=A.g.i;return I?w(A,"return"in I?I.return:function(A){return{value:A,done:!0}},g,A.g.return):(A.g.return(g),d(A))}(A,g)},this[Symbol.iterator]=function(){return this}}function y(A,g){return g=new p(new u(g)),a&&A.prototype&&a(g,A.prototype),g}h.prototype.o=function(A){this.h=A},h.prototype.return=function(A){this.j={return:A},this.g=this.s};var G="function"==typeof Object.assign?Object.assign:function(A,g){for(var I=1;I<arguments.length;I++){var t=arguments[I];if(t)for(var C in t)Object.prototype.hasOwnProperty.call(t,C)&&(A[C]=t[C])}return A};e("Object.assign",(function(A){return A||G})),e("Promise",(function(A){function g(A){this.h=0,this.i=void 0,this.g=[],this.o=!1;var g=this.j();try{A(g.resolve,g.reject)}catch(A){g.reject(A)}}function I(){this.g=null}function t(A){return A instanceof g?A:new g((function(g){g(A)}))}if(A)return A;I.prototype.h=function(A){if(null==this.g){this.g=[];var g=this;this.i((function(){g.l()}))}this.g.push(A)};var e=C.setTimeout;I.prototype.i=function(A){e(A,0)},I.prototype.l=function(){for(;this.g&&this.g.length;){var A=this.g;this.g=[];for(var g=0;g<A.length;++g){var I=A[g];A[g]=null;try{I()}catch(A){this.j(A)}}}this.g=null},I.prototype.j=function(A){this.i((function(){throw A}))},g.prototype.j=function(){function A(A){return function(t){I||(I=!0,A.call(g,t))}}var g=this,I=!1;return{resolve:A(this.C),reject:A(this.l)}},g.prototype.C=function(A){if(A===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(A instanceof g)this.F(A);else{A:switch(typeof A){case"object":var I=null!=A;break A;case"function":I=!0;break A;default:I=!1}I?this.u(A):this.m(A)}},g.prototype.u=function(A){var g=void 0;try{g=A.then}catch(A){return void this.l(A)}"function"==typeof g?this.G(g,A):this.m(A)},g.prototype.l=function(A){this.s(2,A)},g.prototype.m=function(A){this.s(1,A)},g.prototype.s=function(A,g){if(0!=this.h)throw Error("Cannot settle("+A+", "+g+"): Promise already settled in state"+this.h);this.h=A,this.i=g,2===this.h&&this.D(),this.A()},g.prototype.D=function(){var A=this;e((function(){if(A.B()){var g=C.console;void 0!==g&&g.error(A.i)}}),1)},g.prototype.B=function(){if(this.o)return!1;var A=C.CustomEvent,g=C.Event,I=C.dispatchEvent;return void 0===I||("function"==typeof A?A=new A("unhandledrejection",{cancelable:!0}):"function"==typeof g?A=new g("unhandledrejection",{cancelable:!0}):(A=C.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,A),A.promise=this,A.reason=this.i,I(A))},g.prototype.A=function(){if(null!=this.g){for(var A=0;A<this.g.length;++A)B.h(this.g[A]);this.g=null}};var B=new I;return g.prototype.F=function(A){var g=this.j();A.J(g.resolve,g.reject)},g.prototype.G=function(A,g){var I=this.j();try{A.call(g,I.resolve,I.reject)}catch(A){I.reject(A)}},g.prototype.then=function(A,I){function t(A,g){return"function"==typeof A?function(g){try{C(A(g))}catch(A){e(A)}}:g}var C,e,B=new g((function(A,g){C=A,e=g}));return this.J(t(A,C),t(I,e)),B},g.prototype.catch=function(A){return this.then(void 0,A)},g.prototype.J=function(A,g){function I(){switch(t.h){case 1:A(t.i);break;case 2:g(t.i);break;default:throw Error("Unexpected state: "+t.h)}}var t=this;null==this.g?B.h(I):this.g.push(I),this.o=!0},g.resolve=t,g.reject=function(A){return new g((function(g,I){I(A)}))},g.race=function(A){return new g((function(g,I){for(var C=i(A),e=C.next();!e.done;e=C.next())t(e.value).J(g,I)}))},g.all=function(A){var I=i(A),C=I.next();return C.done?t([]):new g((function(A,g){function e(g){return function(I){B[g]=I,0==--i&&A(B)}}var B=[],i=0;do{B.push(void 0),i++,t(C.value).J(e(B.length-1),g),C=I.next()}while(!C.done)}))},g})),e("Object.is",(function(A){return A||function(A,g){return A===g?0!==A||1/A==1/g:A!=A&&g!=g}})),e("Array.prototype.includes",(function(A){return A||function(A,g){var I=this;I instanceof String&&(I=String(I));var t=I.length;for(0>(g=g||0)&&(g=Math.max(g+t,0));g<t;g++){var C=I[g];if(C===A||Object.is(C,A))return!0}return!1}})),e("String.prototype.includes",(function(A){return A||function(A,g){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(A instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(A,g||0)}})),e("Array.prototype.keys",(function(A){return A||function(){return function(A,g){A instanceof String&&(A+="");var I=0,t=!1,C={next:function(){if(!t&&I<A.length){var C=I++;return{value:g(C,A[C]),done:!1}}return t=!0,{done:!0,value:void 0}}};return C[Symbol.iterator]=function(){return C},C}(this,(function(A){return A}))}}));var f=this||self;function N(A,g){A=A.split(".");var I,t=f;A[0]in t||void 0===t.execScript||t.execScript("var "+A[0]);for(;A.length&&(I=A.shift());)A.length||void 0===g?t=t[I]&&t[I]!==Object.prototype[I]?t[I]:t[I]={}:t[I]=g}function F(A,g){return g=String.fromCharCode.apply(null,g),null==A?g:A+g}var R,m,k="undefined"!=typeof TextDecoder,S="undefined"!=typeof TextEncoder;function M(A){if(S)A=(m||(m=new TextEncoder)).encode(A);else{var g=void 0;g=void 0!==g&&g;for(var I=0,t=new Uint8Array(3*A.length),C=0;C<A.length;C++){var e=A.charCodeAt(C);if(128>e)t[I++]=e;else{if(2048>e)t[I++]=e>>6|192;else{if(55296<=e&&57343>=e){if(56319>=e&&C<A.length){var B=A.charCodeAt(++C);if(56320<=B&&57343>=B){e=1024*(e-55296)+B-56320+65536,t[I++]=e>>18|240,t[I++]=e>>12&63|128,t[I++]=e>>6&63|128,t[I++]=63&e|128;continue}C--}if(g)throw Error("Found an unpaired surrogate");e=65533}t[I++]=e>>12|224,t[I++]=e>>6&63|128}t[I++]=63&e|128}}A=t.subarray(0,I)}return A}var U={},K=null;function J(A,g){void 0===g&&(g=0),L(),g=U[g];for(var I=Array(Math.floor(A.length/3)),t=g[64]||"",C=0,e=0;C<A.length-2;C+=3){var B=A[C],i=A[C+1],Q=A[C+2],o=g[B>>2];B=g[(3&B)<<4|i>>4],i=g[(15&i)<<2|Q>>6],Q=g[63&Q],I[e++]=o+B+i+Q}switch(o=0,Q=t,A.length-C){case 2:Q=g[(15&(o=A[C+1]))<<2]||t;case 1:A=A[C],I[e]=g[A>>2]+g[(3&A)<<4|o>>4]+Q+t}return I.join("")}function Y(A){var g=A.length,I=3*g/4;I%3?I=Math.floor(I):-1!="=.".indexOf(A[g-1])&&(I=-1!="=.".indexOf(A[g-2])?I-2:I-1);var t=new Uint8Array(I),C=0;return function(A,g){function I(g){for(;t<A.length;){var I=A.charAt(t++),C=K[I];if(null!=C)return C;if(!/^[\s\xa0]*$/.test(I))throw Error("Unknown base64 encoding at char: "+I)}return g}L();for(var t=0;;){var C=I(-1),e=I(0),B=I(64),i=I(64);if(64===i&&-1===C)break;g(C<<2|e>>4),64!=B&&(g(e<<4&240|B>>2),64!=i&&g(B<<6&192|i))}}(A,(function(A){t[C++]=A})),t.subarray(0,C)}function L(){if(!K){K={};for(var A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),g=["+/=","+/","-_=","-_.","-_"],I=0;5>I;I++){var t=A.concat(g[I].split(""));U[I]=t;for(var C=0;C<t.length;C++){var e=t[C];void 0===K[e]&&(K[e]=C)}}}}var x,b="function"==typeof Uint8Array.prototype.slice;function H(A,g,I){return g===I?x||(x=new Uint8Array(0)):b?A.slice(g,I):new Uint8Array(A.subarray(g,I))}var q=0;function T(A,g){g=void 0!==(g=void 0===g?{}:g).v&&g.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=g,A&&v(this,A)}function v(A,g){g=g.constructor===Uint8Array?g:g.constructor===ArrayBuffer||g.constructor===Array?new Uint8Array(g):g.constructor===String?Y(g):g instanceof Uint8Array?new Uint8Array(g.buffer,g.byteOffset,g.byteLength):new Uint8Array(0),A.h=g,A.l=0,A.j=A.h.length,A.g=A.l}function V(A){for(var g=128,I=0,t=0,C=0;4>C&&128<=g;C++)I|=(127&(g=A.h[A.g++]))<<7*C;if(128<=g&&(I|=(127&(g=A.h[A.g++]))<<28,t|=(127&g)>>4),128<=g)for(C=0;5>C&&128<=g;C++)t|=(127&(g=A.h[A.g++]))<<7*C+3;if(128>g)return A=I>>>0,(t=2147483648&(g=t>>>0))&&(g=~g>>>0,0==(A=1+~A>>>0)&&(g=g+1>>>0)),A=4294967296*g+(A>>>0),t?-A:A;A.m=!0}T.prototype.reset=function(){this.g=this.l},T.prototype.i=function(){var A=this.h,g=A[this.g],I=127&g;return 128>g?(this.g+=1,I):(I|=(127&(g=A[this.g+1]))<<7,128>g?(this.g+=2,I):(I|=(127&(g=A[this.g+2]))<<14,128>g?(this.g+=3,I):(I|=(127&(g=A[this.g+3]))<<21,128>g?(this.g+=4,I):(I|=(15&(g=A[this.g+4]))<<28,128>g?(this.g+=5,I>>>0):(this.g+=5,128<=A[this.g++]&&128<=A[this.g++]&&128<=A[this.g++]&&128<=A[this.g++]&&this.g++,I)))))},T.prototype.o=function(){var A=this.h[this.g],g=this.h[this.g+1],I=this.h[this.g+2],t=this.h[this.g+3];return this.g+=4,A=2*((I=(A<<0|g<<8|I<<16|t<<24)>>>0)>>31)+1,g=I>>>23&255,I&=8388607,255==g?I?NaN:1/0*A:0==g?A*Math.pow(2,-149)*I:A*Math.pow(2,g-150)*(I+Math.pow(2,23))};var W=[];function O(){this.g=new Uint8Array(64),this.h=0}function Z(A,g){for(;127<g;)A.push(127&g|128),g>>>=7;A.push(g)}function P(A){var g={},I=void 0!==g.N&&g.N;this.o={v:void 0!==g.v&&g.v},this.N=I,g=this.o,W.length?(I=W.pop(),g&&(I.v=g.v),A&&v(I,A),A=I):A=new T(A,g),this.g=A,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}function X(A){var g=A.g;if((g=g.g==g.j)||(g=A.j)||(g=(g=A.g).m||0>g.g||g.g>g.j),g)return!1;A.m=A.g.g;var I=7&(g=A.g.i());return 0!=I&&5!=I&&1!=I&&2!=I&&3!=I&&4!=I?(A.j=!0,!1):(A.i=g,A.l=g>>>3,A.h=I,!0)}function j(A){switch(A.h){case 0:if(0!=A.h)j(A);else{for(A=A.g;128&A.h[A.g];)A.g++;A.g++}break;case 1:1!=A.h?j(A):(A=A.g).g+=8;break;case 2:if(2!=A.h)j(A);else{var g=A.g.i();(A=A.g).g+=g}break;case 5:5!=A.h?j(A):(A=A.g).g+=4;break;case 3:for(g=A.l;;){if(!X(A)){A.j=!0;break}if(4==A.h){A.l!=g&&(A.j=!0);break}j(A)}break;default:A.j=!0}}function z(A,g,I){var t=A.g.j,C=A.g.i(),e=A.g.g+C;if(A.g.j=e,I(g,A),0!==(I=e-A.g.g))throw Error("Message parsing ended unexpectedly. Expected to read "+C+" bytes, instead read "+(C-I)+" bytes, either the data ended unexpectedly or the message misreported its own length");return A.g.g=e,A.g.j=t,g}function _(A){return A.g.o()}function $(A){var g,I=A.g.i(),t=(A=A.g).g;if(A.g+=I,A=A.h,k)(g=R)||(g=R=new TextDecoder("utf-8",{fatal:!1})),g=g.decode(A.subarray(t,t+I));else{I=t+I;for(var C,e,B,i=[],Q=null;t<I;)128>(C=A[t++])?i.push(C):224>C?t>=I?i.push(65533):(e=A[t++],194>C||128!=(192&e)?(t--,i.push(65533)):i.push((31&C)<<6|63&e)):240>C?t>=I-1?i.push(65533):128!=(192&(e=A[t++]))||224===C&&160>e||237===C&&160<=e||128!=(192&(g=A[t++]))?(t--,i.push(65533)):i.push((15&C)<<12|(63&e)<<6|63&g):244>=C?t>=I-2?i.push(65533):128!=(192&(e=A[t++]))||0!=e-144+(C<<28)>>30||128!=(192&(g=A[t++]))||128!=(192&(B=A[t++]))?(t--,i.push(65533)):(C=(7&C)<<18|(63&e)<<12|(63&g)<<6|63&B,C-=65536,i.push(55296+(C>>10&1023),56320+(1023&C))):i.push(65533),8192<=i.length&&(Q=F(Q,i),i.length=0);g=F(Q,i)}return g}function AA(A,g,I){var t=A.g.i();for(t=A.g.g+t;A.g.g<t;)I.push(g.call(A.g))}function gA(A,g){2==A.h?AA(A,T.prototype.o,g):g.push(_(A))}function IA(){this.h=[],this.i=0,this.g=new O}function tA(A,g){0!==g.length&&(A.h.push(g),A.i+=g.length)}function CA(A){var g=A.i+A.g.length();if(0===g)return new Uint8Array(0);g=new Uint8Array(g);for(var I=A.h,t=I.length,C=0,e=0;e<t;e++){var B=I[e];0!==B.length&&(g.set(B,C),C+=B.length)}return 0!==(t=(I=A.g).h)&&(g.set(I.g.subarray(0,t),C),I.h=0),A.h=[g],g}function eA(A,g,I){if(null!=I){Z(A.g,8*g+5),A=A.g;var t=I;0===(t=(I=0>t?1:0)?-t:t)?0<1/t?q=0:(0,q=2147483648):isNaN(t)?(0,q=2147483647):34028234663852886e22<t?(0,q=(I<<31|2139095040)>>>0):11754943508222875e-54>t?(t=Math.round(t/Math.pow(2,-149)),0,q=(I<<31|t)>>>0):(g=Math.floor(Math.log(t)/Math.LN2),t*=Math.pow(2,-g),16777216<=(t=Math.round(8388608*t))&&++g,0,q=(I<<31|g+127<<23|8388607&t)>>>0),I=q,A.push(I>>>0&255),A.push(I>>>8&255),A.push(I>>>16&255),A.push(I>>>24&255)}}O.prototype.push=function(A){if(!(this.h+1<this.g.length)){var g=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(g)}this.g[this.h++]=A},O.prototype.length=function(){return this.h},O.prototype.end=function(){var A=this.g,g=this.h;return this.h=0,H(A,0,g)},P.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};var BA="function"==typeof Uint8Array;function iA(A,g,I){if(null!=A)return"object"==typeof A?BA&&A instanceof Uint8Array?I(A):QA(A,g,I):g(A)}function QA(A,g,I){if(Array.isArray(A)){for(var t=Array(A.length),C=0;C<A.length;C++)t[C]=iA(A[C],g,I);return Array.isArray(A)&&A.W&&sA(t),t}for(C in t={},A)t[C]=iA(A[C],g,I);return t}function oA(A){return"number"==typeof A?isFinite(A)?A:String(A):A}var EA,nA={W:{value:!0,configurable:!0}};function sA(A){return Array.isArray(A)&&!Object.isFrozen(A)&&Object.defineProperties(A,nA),A}function aA(A,g,I){var t=EA;if(EA=null,A||(A=t),t=this.constructor.ca,A||(A=t?[t]:[]),this.j=t?0:-1,this.m=this.g=null,this.h=A,A=(t=this.h.length)-1,!t||(null===(t=this.h[A])||"object"!=typeof t||Array.isArray(t)||BA&&t instanceof Uint8Array)?void 0!==g&&-1<g?(this.l=Math.max(g,A+1-this.j),this.i=null):this.l=Number.MAX_VALUE:(this.l=A-this.j,this.i=t),I)for(g=0;g<I.length;g++)(A=I[g])<this.l?(A+=this.j,(t=this.h[A])?sA(t):this.h[A]=rA):(hA(this),(t=this.i[A])?sA(t):this.i[A]=rA)}var rA=Object.freeze(sA([]));function hA(A){var g=A.l+A.j;A.h[g]||(A.i=A.h[g]={})}function cA(A,g,I){return-1===g?null:void 0!==I&&I||g>=A.l?A.i?A.i[g]:void 0:A.h[g+A.j]}function lA(A,g){var I=void 0!==I&&I,t=cA(A,g,I);return null==t&&(t=rA),t===rA&&dA(A,g,t=sA([]),I),t}function DA(A){var g=lA(A,3);if(A.m||(A.m={}),!A.m[3]){for(var I=0;I<g.length;I++)g[I]=+g[I];A.m[3]=!0}return g}function uA(A,g,I){return null==(A=cA(A,g))?I:A}function wA(A,g,I){return null==(A=null==(A=cA(A,g))?A:+A)?void 0===I?0:I:A}function dA(A,g,I,t){void 0!==t&&t||g>=A.l?(hA(A),A.i[g]=I):A.h[g+A.j]=I}function pA(A,g,I){if(-1===I)return null;if(A.g||(A.g={}),!A.g[I]){var t=cA(A,I,!1);t&&(A.g[I]=new g(t))}return A.g[I]}function yA(A,g){A.g||(A.g={});var I=A.g[1];if(!I){var t=lA(A,1);I=[];for(var C=0;C<t.length;C++)I[C]=new g(t[C]);A.g[1]=I}return I}function GA(A,g,I){var t=void 0!==t&&t;A.g||(A.g={});var C=I?NA(I,!1):I;A.g[g]=I,dA(A,g,C,t)}function fA(A,g,I,t){var C=yA(A,I);g=g||new I,A=lA(A,1),null!=t?(C.splice(t,0,g),A.splice(t,0,NA(g,!1))):(C.push(g),A.push(NA(g,!1)))}function NA(A,g){if(A.g)for(var I in A.g){var t=A.g[I];if(Array.isArray(t))for(var C=0;C<t.length;C++)t[C]&&NA(t[C],g);else t&&NA(t,g)}return A.h}function FA(A,g){if(A=A.o){tA(g,g.g.end());for(var I=0;I<A.length;I++)tA(g,A[I])}}function RA(A,g){if(4==g.h)return!1;var I=g.m;return j(g),g.N||(g=H(g.g.h,I,g.g.g),(I=A.o)?I.push(g):A.o=[g]),!0}function mA(A){aA.call(this,A,-1,SA)}function kA(A,g){for(;X(g);)switch(g.i){case 8:var I=g.g.i();dA(A,1,I);break;case 16:dA(A,2,I=g.g.i());break;case 29:case 26:gA(g,A.getPackedDataList());break;case 32:dA(A,4,I=V(g.g));break;default:if(!RA(A,g))return A}return A}aA.prototype.toJSON=function(){return QA(NA(this,!1),oA,J)},aA.prototype.toString=function(){return NA(this,!1).toString()},r(mA,aA),mA.prototype.getRows=function(){return cA(this,1)},mA.prototype.getCols=function(){return cA(this,2)},mA.prototype.getPackedDataList=function(){return DA(this)},mA.prototype.getLayout=function(){return uA(this,4,0)};var SA=[3];function MA(A,g){var I=void 0;return new(I||(I=Promise))((function(t,C){function e(A){try{i(g.next(A))}catch(A){C(A)}}function B(A){try{i(g.throw(A))}catch(A){C(A)}}function i(A){A.done?t(A.value):new I((function(g){g(A.value)})).then(e,B)}i((g=g.apply(A,void 0)).next())}))}function UA(A){aA.call(this,A)}function KA(A,g){for(;X(g);)switch(g.i){case 8:var I=g.g.i();dA(A,1,I);break;case 21:dA(A,2,I=_(g));break;case 26:dA(A,3,I=$(g));break;case 34:dA(A,4,I=$(g));break;default:if(!RA(A,g))return A}return A}function JA(A){aA.call(this,A,-1,YA)}r(UA,aA),r(JA,aA),JA.prototype.addClassification=function(A,g){return fA(this,A,UA,g),this};var YA=[1];function LA(A){aA.call(this,A)}function xA(A,g){for(;X(g);)switch(g.i){case 13:var I=_(g);dA(A,1,I);break;case 21:dA(A,2,I=_(g));break;case 29:dA(A,3,I=_(g));break;case 37:dA(A,4,I=_(g));break;case 45:dA(A,5,I=_(g));break;default:if(!RA(A,g))return A}return A}function bA(A){aA.call(this,A,-1,qA)}function HA(A){A:{var g=new bA;for(A=new P(A);X(A);)if(10===A.i){fA(g,z(A,new LA,xA),LA,void 0)}else if(!RA(g,A))break A}return g}r(LA,aA),r(bA,aA);var qA=[1];function TA(A){aA.call(this,A)}function vA(A){aA.call(this,A,-1,WA)}function VA(A,g){for(;X(g);)switch(g.i){case 8:var I=V(g.g);dA(A,1,I);break;case 16:dA(A,2,I=V(g.g));break;case 29:case 26:gA(g,A.getVertexBufferList());break;case 32:case 34:I=g;var t=A.getIndexBufferList();2==I.h?AA(I,T.prototype.i,t):t.push(I.g.i());break;default:if(!RA(A,g))return A}return A}r(TA,aA),r(vA,aA),vA.prototype.getVertexType=function(){return uA(this,1,0)},vA.prototype.getPrimitiveType=function(){return uA(this,2,0)},vA.prototype.getVertexBufferList=function(){return DA(this)},vA.prototype.getIndexBufferList=function(){return lA(this,4)};var WA=[3,4];function OA(A){aA.call(this,A)}function ZA(A,g,I){if(I=A.createShader(0===I?A.VERTEX_SHADER:A.FRAGMENT_SHADER),A.shaderSource(I,g),A.compileShader(I),!A.getShaderParameter(I,A.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+A.getShaderInfoLog(I));return I}function PA(A){return yA(A,UA).map((function(A){return{index:uA(A,1,0),Y:wA(A,2),label:null!=cA(A,3)?uA(A,3,""):void 0,displayName:null!=cA(A,4)?uA(A,4,""):void 0}}))}function XA(A){return{x:wA(A,1),y:wA(A,2),z:wA(A,3),visibility:null!=cA(A,4)?wA(A,4):void 0}}function jA(A,g){this.h=A,this.g=g,this.l=0}function zA(A,g,I){return function(A,g){var I=A.g;if(void 0===A.m){var t=ZA(I,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),C=ZA(I,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),e=I.createProgram();if(I.attachShader(e,t),I.attachShader(e,C),I.linkProgram(e),!I.getProgramParameter(e,I.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+I.getProgramInfoLog(e));t=A.m=e,I.useProgram(t),C=I.getUniformLocation(t,"sampler0"),A.j={I:I.getAttribLocation(t,"aVertex"),H:I.getAttribLocation(t,"aTex"),da:C},A.s=I.createBuffer(),I.bindBuffer(I.ARRAY_BUFFER,A.s),I.enableVertexAttribArray(A.j.I),I.vertexAttribPointer(A.j.I,2,I.FLOAT,!1,0,0),I.bufferData(I.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),I.STATIC_DRAW),I.bindBuffer(I.ARRAY_BUFFER,null),A.o=I.createBuffer(),I.bindBuffer(I.ARRAY_BUFFER,A.o),I.enableVertexAttribArray(A.j.H),I.vertexAttribPointer(A.j.H,2,I.FLOAT,!1,0,0),I.bufferData(I.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),I.STATIC_DRAW),I.bindBuffer(I.ARRAY_BUFFER,null),I.uniform1i(C,0)}t=A.j,I.useProgram(A.m),I.canvas.width=g.width,I.canvas.height=g.height,I.viewport(0,0,g.width,g.height),I.activeTexture(I.TEXTURE0),A.h.bindTexture2d(g.glName),I.enableVertexAttribArray(t.I),I.bindBuffer(I.ARRAY_BUFFER,A.s),I.vertexAttribPointer(t.I,2,I.FLOAT,!1,0,0),I.enableVertexAttribArray(t.H),I.bindBuffer(I.ARRAY_BUFFER,A.o),I.vertexAttribPointer(t.H,2,I.FLOAT,!1,0,0),I.bindFramebuffer(I.DRAW_FRAMEBUFFER?I.DRAW_FRAMEBUFFER:I.FRAMEBUFFER,null),I.clearColor(0,0,0,0),I.clear(I.COLOR_BUFFER_BIT),I.colorMask(!0,!0,!0,!0),I.drawArrays(I.TRIANGLE_FAN,0,4),I.disableVertexAttribArray(t.I),I.disableVertexAttribArray(t.H),I.bindBuffer(I.ARRAY_BUFFER,null),A.h.bindTexture2d(0)}(A,g),"function"==typeof A.g.canvas.transferToImageBitmap?Promise.resolve(A.g.canvas.transferToImageBitmap()):I?Promise.resolve(A.g.canvas):"function"==typeof createImageBitmap?createImageBitmap(A.g.canvas):(void 0===A.i&&(A.i=document.createElement("canvas")),new Promise((function(g){A.i.height=A.g.canvas.height,A.i.width=A.g.canvas.width,A.i.getContext("2d",{}).drawImage(A.g.canvas,0,0,A.g.canvas.width,A.g.canvas.height),g(A.i)})))}function _A(A){this.g=A}r(OA,aA),OA.prototype.getMesh=function(){return pA(this,vA,1)},OA.prototype.getPoseTransformMatrix=function(){return pA(this,mA,2)};var $A=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Ag(A,g){return g+A}function gg(A,g){window[A]=g}function Ig(A){if(this.g=A,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=A&&A.locateFile||Ag,"object"==typeof window)var g=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");g=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.S=g,A.options)for(var I=(g=i(Object.keys(A.options))).next();!I.done;I=g.next()){I=I.value;var t=A.options[I].default;void 0!==t&&(this.j[I]="function"==typeof t?t():t)}}function tg(A){return MA(A,(function A(){var g,I,t,C,e,B,i,o,E,n,s,a=this;return y(A,(function(A){switch(A.g){case 1:return g=a,a.R?(I=function(A,g){return void 0===A.g.files?[]:"function"==typeof A.g.files?A.g.files(g):A.g.files}(a,a.j),D(A,function(){return MA(this,(function A(){return y(A,(function(A){switch(A.g){case 1:return A.m=2,D(A,WebAssembly.instantiate($A),4);case 4:A.g=3,A.m=0;break;case 2:return A.m=0,A.j=null,A.return(!1);case 3:return A.return(!0)}}))}))}(),2)):A.return();case 2:if(t=A.h,"object"==typeof window)return gg("createMediapipeSolutionsWasm",{locateFile:a.locateFile}),gg("createMediapipeSolutionsPackedAssets",{locateFile:a.locateFile}),B=I.filter((function(A){return void 0!==A.data})),i=I.filter((function(A){return void 0===A.data})),o=Promise.all(B.map((function(A){var I=Cg(g,A.url);if(void 0!==A.path){var t=A.path;I=I.then((function(A){return g.overrideFile(t,A),Promise.resolve(A)}))}return I}))),E=Promise.all(i.map((function(A){return void 0===A.simd||A.simd&&t||!A.simd&&!t?function(A){var g=document.createElement("script");return g.setAttribute("src",A),g.setAttribute("crossorigin","anonymous"),new Promise((function(A){g.addEventListener("load",(function(){A()}),!1),g.addEventListener("error",(function(){A()}),!1),document.body.appendChild(g)}))}(g.locateFile(A.url,g.S)):Promise.resolve()}))).then((function(){return MA(g,(function A(){var g,I,t=this;return y(A,(function(A){if(1==A.g)return g=window.createMediapipeSolutionsWasm,I=window.createMediapipeSolutionsPackedAssets,D(A,g(I),2);t.h=A.h,A.g=0}))}))})),n=MA(g,(function A(){var g=this;return y(A,(function(A){return g.g.graph&&g.g.graph.url?A=D(A,Cg(g,g.g.graph.url),0):(A.g=0,A=void 0),A}))})),D(A,Promise.all([E,o,n]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return C=I.filter((function(A){return void 0===A.simd||A.simd&&t||!A.simd&&!t})).map((function(A){return g.locateFile(A.url,g.S)})),importScripts.apply(null,Q(C)),D(A,createMediapipeSolutionsWasm(Module),6);case 6:a.h=A.h,a.l=new OffscreenCanvas(1,1),a.h.canvas=a.l,e=a.h.GL.createContext(a.l,{antialias:!1,alpha:!1,ba:"undefined"!=typeof WebGL2RenderingContext?2:1}),a.h.GL.makeContextCurrent(e),A.g=4;break;case 7:if(a.l=document.createElement("canvas"),!(s=a.l.getContext("webgl2",{}))&&!(s=a.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),A.return();a.D=s,a.h.canvas=a.l,a.h.createContext(a.l,!0,!0,{});case 4:a.i=new a.h.SolutionWasm,a.R=!1,A.g=0}}))}))}function Cg(A,g){return MA(A,(function A(){var I,t,C=this;return y(A,(function(A){return g in C.F?A.return(C.F[g]):(I=C.locateFile(g,""),t=fetch(I).then((function(A){return A.arrayBuffer()})),C.F[g]=t,A.return(t))}))}))}function eg(A,g,I){return MA(A,(function A(){var t,C,e,B,Q,o,E,n,s,a,r,h,c,l,u=this;return y(A,(function(A){switch(A.g){case 1:if(!I)return A.return(g);for(t={},C=0,e=i(Object.keys(I)),B=e.next();!B.done;B=e.next())Q=B.value,"string"!=typeof(o=I[Q])&&"texture"===o.type&&void 0!==g[o.stream]&&++C;1<C&&(u.G=!1),E=i(Object.keys(I)),B=E.next();case 2:if(B.done){A.g=4;break}if(n=B.value,"string"==typeof(s=I[n]))return c=t,l=n,D(A,function(A,g,I){return MA(A,(function A(){var t,C=this;return y(A,(function(A){return"number"==typeof I||I instanceof Uint8Array||I instanceof C.h.Uint8BlobList?A.return(I):I instanceof C.h.Texture2dDataOut?((t=C.s[g])||(t=new jA(C.h,C.D),C.s[g]=t),A.return(zA(t,I,C.G))):A.return(void 0)}))}))}(u,n,g[s]),14);if(a=g[s.stream],"detection_list"===s.type){if(a){for(var w=a.getRectList(),d=a.getLandmarksList(),p=a.getClassificationsList(),G=[],f=0;f<w.size();++f){var N=w.get(f);A:{var F=new TA;for(N=new P(N);X(N);)switch(N.i){case 13:var R=_(N);dA(F,1,R);break;case 21:dA(F,2,R=_(N));break;case 29:dA(F,3,R=_(N));break;case 37:dA(F,4,R=_(N));break;case 45:dA(F,5,R=_(N));break;case 48:dA(F,6,R=V(N.g));break;default:if(!RA(F,N))break A}}F={Z:wA(F,1),$:wA(F,2),height:wA(F,3),width:wA(F,4),rotation:wA(F,5,0),X:uA(F,6,0)},N=yA(HA(d.get(f)),LA).map(XA);var m=p.get(f);A:for(R=new JA,m=new P(m);X(m);)if(10===m.i)R.addClassification(z(m,new UA,KA));else if(!RA(R,m))break A;F={T:F,O:N,M:PA(R)},G.push(F)}w=G}else w=[];t[n]=w,A.g=7;break}if("proto_list"===s.type){if(a){for(w=Array(a.size()),d=0;d<a.size();d++)w[d]=a.get(d);a.delete()}else w=[];t[n]=w,A.g=7;break}if(void 0===a){A.g=3;break}if("float_list"===s.type){t[n]=a,A.g=7;break}if("proto"===s.type){t[n]=a,A.g=7;break}if("texture"!==s.type)throw Error("Unknown output config type: '"+s.type+"'");return(r=u.s[n])||(r=new jA(u.h,u.D),u.s[n]=r),D(A,zA(r,a,u.G),13);case 13:h=A.h,t[n]=h;case 7:s.transform&&t[n]&&(t[n]=s.transform(t[n])),A.g=3;break;case 14:c[l]=A.h;case 3:B=E.next(),A.g=2;break;case 4:return A.return(t)}}))}))}function Bg(A,g){for(var I=g.name||"$",t=[].concat(Q(g.wants)),C=new A.h.StringList,e=i(g.wants),B=e.next();!B.done;B=e.next())C.push_back(B.value);e=A.h.PacketListener.implement({onResults:function(C){for(var e={},B=0;B<g.wants.length;++B)e[t[B]]=C.get(B);var i=A.listeners[I];i&&(A.C=eg(A,e,g.outs).then((function(I){I=i(I);for(var C=0;C<g.wants.length;++C){var B=e[t[C]];"object"==typeof B&&B.hasOwnProperty&&B.hasOwnProperty("delete")&&B.delete()}I&&(A.C=I)})))}}),A.i.attachMultiListener(C,e),C.delete()}function ig(A){A=function(A){A:{var g=new OA;for(A=new P(A);X(A);)switch(A.i){case 10:var I=z(A,new vA,VA);GA(g,1,I);break;case 18:GA(g,2,I=z(A,new mA,kA));break;default:if(!RA(g,A))break A}}return g}(A);var g=A.getMesh();if(!g)return A;var I=new Float32Array(g.getVertexBufferList());g.getVertexBufferList=function(){return I};var t=new Uint32Array(g.getIndexBufferList());return g.getIndexBufferList=function(){return t},A}(A=Ig.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},A.reset=function(){return MA(this,(function A(){var g=this;return y(A,(function(A){g.i&&(g.i.reset(),g.m={},g.s={}),A.g=0}))}))},A.setOptions=function(A,g){var I=this;if(g=g||this.g.options){for(var t=[],C=[],e={},B=i(Object.keys(A)),Q=B.next();!Q.done;e={K:e.K,L:e.L},Q=B.next()){var o=Q.value;o in this.j&&this.j[o]===A[o]||(this.j[o]=A[o],void 0!==(Q=g[o])&&(Q.onChange&&(e.K=Q.onChange,e.L=A[o],t.push(function(A){return function(){return MA(I,(function g(){var I=this;return y(g,(function(g){if(1==g.g)return D(g,A.K(A.L),2);!0===g.h&&(I.o=!0),g.g=0}))}))}}(e))),Q.graphOptionXref&&(o={valueNumber:1===Q.type?A[o]:0,valueBoolean:0===Q.type&&A[o],valueString:2===Q.type?A[o]:""},Q=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),Q.graphOptionXref),o),C.push(Q))))}0===t.length&&0===C.length||(this.o=!0,this.A=(void 0===this.A?[]:this.A).concat(C),this.u=(void 0===this.u?[]:this.u).concat(t))}},A.initialize=function(){return MA(this,(function A(){var g=this;return y(A,(function(A){return 1==A.g?D(A,tg(g),2):3!=A.g?D(A,MA(g,(function A(){var g,I,t,C,e,B,Q,o,E=this;return y(A,(function(A){if(1==A.g)return E.g.graph&&E.g.graph.url&&E.P===E.g.graph.url?A.return():(E.o=!0,E.g.graph&&E.g.graph.url?(E.P=E.g.graph.url,D(A,Cg(E,E.g.graph.url),3)):void(A.g=2));for(2!=A.g&&(g=A.h,E.i.loadGraph(g)),I=i(Object.keys(E.B)),t=I.next();!t.done;t=I.next())C=t.value,E.i.overrideFile(C,E.B[C]);if(E.B={},E.g.listeners)for(e=i(E.g.listeners),B=e.next();!B.done;B=e.next())Q=B.value,Bg(E,Q);o=E.j,E.j={},E.setOptions(o),A.g=0}))})),3):D(A,function(A){return MA(A,(function A(){var g,I,t,C,e,B,Q=this;return y(A,(function(A){switch(A.g){case 1:if(!Q.o)return A.return();if(!Q.u){A.g=2;break}g=i(Q.u),I=g.next();case 3:if(I.done){A.g=5;break}return D(A,(0,I.value)(),4);case 4:I=g.next(),A.g=3;break;case 5:Q.u=void 0;case 2:if(Q.A){for(t=new Q.h.GraphOptionChangeRequestList,C=i(Q.A),e=C.next();!e.done;e=C.next())B=e.value,t.push_back(B);Q.i.changeOptions(t),t.delete(),Q.A=void 0}Q.o=!1,A.g=0}}))}))}(g),0)}))}))},A.overrideFile=function(A,g){this.i?this.i.overrideFile(A,g):this.B[A]=g},A.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},A.send=function(A,g){return MA(this,(function I(){var t,C,e,B,Q,o,E,n,s,a=this;return y(I,(function(I){switch(I.g){case 1:return a.g.inputs?(t=1e3*(null==g?performance.now():g),D(I,a.C,2)):I.return();case 2:return D(I,a.initialize(),3);case 3:for(C=new a.h.PacketDataList,e=i(Object.keys(A)),B=e.next();!B.done;B=e.next())if(Q=B.value,o=a.g.inputs[Q]){A:{var r=a,h=A[Q];switch(o.type){case"video":var c=r.m[o.stream];if(c||(c=new jA(r.h,r.D),r.m[o.stream]=c),0===(r=c).l&&(r.l=r.h.createTexture()),"undefined"!=typeof HTMLVideoElement&&h instanceof HTMLVideoElement){var l=h.videoWidth;c=h.videoHeight}else"undefined"!=typeof HTMLImageElement&&h instanceof HTMLImageElement?(l=h.naturalWidth,c=h.naturalHeight):(l=h.width,c=h.height);c={glName:r.l,width:l,height:c},(l=r.g).canvas.width=c.width,l.canvas.height=c.height,l.activeTexture(l.TEXTURE0),r.h.bindTexture2d(r.l),l.texImage2D(l.TEXTURE_2D,0,l.RGBA,l.RGBA,l.UNSIGNED_BYTE,h),r.h.bindTexture2d(0),r=c;break A;case"detections":for((c=r.m[o.stream])||(c=new _A(r.h),r.m[o.stream]=c),(r=c).data||(r.data=new r.g.DetectionListData),r.data.reset(h.length),c=0;c<h.length;++c){l=h[c];var u=r.data,w=u.setBoundingBox,d=c,p=l.T,y=new TA;dA(y,1,p.Z),dA(y,2,p.$),dA(y,3,p.height),dA(y,4,p.width),dA(y,5,p.rotation),dA(y,6,p.X);var G=p=new IA;eA(G,1,cA(y,1)),eA(G,2,cA(y,2)),eA(G,3,cA(y,3)),eA(G,4,cA(y,4)),eA(G,5,cA(y,5));var f=cA(y,6);if(null!=f&&null!=f){Z(G.g,48);var N=G.g,F=f;f=0>F;var R=(F=Math.abs(F))>>>0;for(F=Math.floor((F-R)/4294967296),F>>>=0,f&&(F=~F>>>0,4294967295<(R=1+(~R>>>0))&&(R=0,4294967295<++F&&(F=0))),f=q=R,R=F;0<R||127<f;)N.push(127&f|128),f=(f>>>7|R<<25)>>>0,R>>>=7;N.push(f)}if(FA(y,G),p=CA(p),w.call(u,d,p),l.O)for(u=0;u<l.O.length;++u)G=!!(y=l.O[u]).visibility,d=(w=r.data).addNormalizedLandmark,p=c,y=Object.assign(Object.assign({},y),{visibility:G?y.visibility:0}),dA(G=new LA,1,y.x),dA(G,2,y.y),dA(G,3,y.z),y.visibility&&dA(G,4,y.visibility),eA(N=y=new IA,1,cA(G,1)),eA(N,2,cA(G,2)),eA(N,3,cA(G,3)),eA(N,4,cA(G,4)),eA(N,5,cA(G,5)),FA(G,N),y=CA(y),d.call(w,p,y);if(l.M)for(u=0;u<l.M.length;++u){if(d=(w=r.data).addClassification,p=c,y=l.M[u],dA(G=new UA,2,y.Y),y.index&&dA(G,1,y.index),y.label&&dA(G,3,y.label),y.displayName&&dA(G,4,y.displayName),N=y=new IA,null!=(R=cA(G,1))&&null!=R)if(Z(N.g,8),f=N.g,0<=R)Z(f,R);else{for(F=0;9>F;F++)f.push(127&R|128),R>>=7;f.push(1)}eA(N,2,cA(G,2)),null!=(f=cA(G,3))&&(f=M(f),Z(N.g,26),Z(N.g,f.length),tA(N,N.g.end()),tA(N,f)),null!=(f=cA(G,4))&&(f=M(f),Z(N.g,34),Z(N.g,f.length),tA(N,N.g.end()),tA(N,f)),FA(G,N),y=CA(y),d.call(w,p,y)}}r=r.data;break A;default:r={}}}switch(E=r,n=o.stream,o.type){case"video":C.pushTexture2d(Object.assign(Object.assign({},E),{stream:n,timestamp:t}));break;case"detections":(s=E).stream=n,s.timestamp=t,C.pushDetectionList(s);break;default:throw Error("Unknown input config type: '"+o.type+"'")}}return a.i.send(C),D(I,a.C,4);case 4:C.delete(),I.g=0}}))}))},A.onResults=function(A,g){this.listeners[g||"$"]=A},N("Solution",Ig),N("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});var Qg={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(A){return A.map(ig)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(A){return A.map((function(A){return yA(HA(A),LA).map(XA)}))}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},og=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Eg=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],ng=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],sg=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],ag=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],rg=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],hg=[].concat(Q(og),Q(Eg),Q(ng),Q(sg),Q(ag),Q(rg));function cg(A){A=A||{},A=Object.assign(Object.assign({},Qg),A),this.g=new Ig(A)}(A=cg.prototype).close=function(){return this.g.close(),Promise.resolve()},A.onResults=function(A){this.g.onResults(A)},A.initialize=function(){return MA(this,(function A(){var g=this;return y(A,(function(A){return D(A,g.g.initialize(),0)}))}))},A.reset=function(){this.g.reset()},A.send=function(A){return MA(this,(function g(){var I=this;return y(g,(function(g){return D(g,I.g.send(A),0)}))}))},A.setOptions=function(A){this.g.setOptions(A)},N("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),N("FaceMesh",cg),N("FACEMESH_LIPS",og),N("FACEMESH_LEFT_EYE",Eg),N("FACEMESH_LEFT_EYEBROW",ng),N("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),N("FACEMESH_RIGHT_EYE",sg),N("FACEMESH_RIGHT_EYEBROW",ag),N("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),N("FACEMESH_FACE_OVAL",rg),N("FACEMESH_CONTOURS",hg),N("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),N("matrixDataToMatrix",(function(A){for(var g=A.getCols(),I=A.getRows(),t=A.getPackedDataList(),C=[],e=0;e<I;e++)C.push(Array(g));for(e=0;e<I;e++)for(var B=0;B<g;B++){var i=1===A.getLayout()?e*g+B:B*I+e;C[e][B]=t[i]}return C})),N("VERSION","0.4.1633559619")}).call(this)},113:function(A){A.exports=function(A){var g={};function I(t){if(g[t])return g[t].exports;var C=g[t]={i:t,l:!1,exports:{}};return A[t].call(C.exports,C,C.exports,I),C.l=!0,C.exports}return I.m=A,I.c=g,I.d=function(A,g,t){I.o(A,g)||Object.defineProperty(A,g,{enumerable:!0,get:t})},I.r=function(A){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},I.t=function(A,g){if(1&g&&(A=I(A)),8&g)return A;if(4&g&&"object"==typeof A&&A&&A.__esModule)return A;var t=Object.create(null);if(I.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:A}),2&g&&"string"!=typeof A)for(var C in A)I.d(t,C,function(g){return A[g]}.bind(null,C));return t},I.n=function(A){var g=A&&A.__esModule?function(){return A.default}:function(){return A};return I.d(g,"a",g),g},I.o=function(A,g){return Object.prototype.hasOwnProperty.call(A,g)},I.p="",I(I.s=0)}([function(A,g,I){"use strict";I.r(g),I.d(g,"encode",(function(){return R})),I.d(g,"decode",(function(){return v})),I.d(g,"decodeAsync",(function(){return z})),I.d(g,"decodeArrayStream",(function(){return _})),I.d(g,"decodeStream",(function(){return $})),I.d(g,"Decoder",(function(){return q})),I.d(g,"Encoder",(function(){return N})),I.d(g,"ExtensionCodec",(function(){return y})),I.d(g,"ExtData",(function(){return a})),I.d(g,"EXT_TIMESTAMP",(function(){return c})),I.d(g,"encodeDateToTimeSpec",(function(){return D})),I.d(g,"encodeTimeSpecToTimestamp",(function(){return l})),I.d(g,"decodeTimestampToTimeSpec",(function(){return w})),I.d(g,"encodeTimestampExtension",(function(){return u})),I.d(g,"decodeTimestampExtension",(function(){return d}));var t=function(A,g){var I="function"==typeof Symbol&&A[Symbol.iterator];if(!I)return A;var t,C,e=I.call(A),B=[];try{for(;(void 0===g||g-- >0)&&!(t=e.next()).done;)B.push(t.value)}catch(A){C={error:A}}finally{try{t&&!t.done&&(I=e.return)&&I.call(e)}finally{if(C)throw C.error}}return B},C=function(){for(var A=[],g=0;g<arguments.length;g++)A=A.concat(t(arguments[g]));return A},e="undefined"!=typeof process&&"undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function B(A){for(var g=A.length,I=0,t=0;t<g;){var C=A.charCodeAt(t++);if(0!=(4294967168&C))if(0==(4294965248&C))I+=2;else{if(C>=55296&&C<=56319&&t<g){var e=A.charCodeAt(t);56320==(64512&e)&&(++t,C=((1023&C)<<10)+(1023&e)+65536)}I+=0==(4294901760&C)?3:4}else I++}return I}var i=e?new TextEncoder:void 0,Q="undefined"!=typeof process?200:0,o=(null==i?void 0:i.encodeInto)?function(A,g,I){i.encodeInto(A,g.subarray(I))}:function(A,g,I){g.set(i.encode(A),I)};function E(A,g,I){for(var t=g,e=t+I,B=[],i="";t<e;){var Q=A[t++];if(0==(128&Q))B.push(Q);else if(192==(224&Q)){var o=63&A[t++];B.push((31&Q)<<6|o)}else if(224==(240&Q)){o=63&A[t++];var E=63&A[t++];B.push((31&Q)<<12|o<<6|E)}else if(240==(248&Q)){var n=(7&Q)<<18|(o=63&A[t++])<<12|(E=63&A[t++])<<6|63&A[t++];n>65535&&(n-=65536,B.push(n>>>10&1023|55296),n=56320|1023&n),B.push(n)}else B.push(Q);B.length>=4096&&(i+=String.fromCharCode.apply(String,C(B)),B.length=0)}return B.length>0&&(i+=String.fromCharCode.apply(String,C(B))),i}var n=e?new TextDecoder:null,s="undefined"!=typeof process?200:0,a=function(A,g){this.type=A,this.data=g};function r(A,g,I){var t=Math.floor(I/4294967296),C=I;A.setUint32(g,t),A.setUint32(g+4,C)}function h(A,g){return 4294967296*A.getInt32(g)+A.getUint32(g+4)}var c=-1;function l(A){var g,I=A.sec,t=A.nsec;if(I>=0&&t>=0&&I<=17179869183){if(0===t&&I<=4294967295){var C=new Uint8Array(4);return(g=new DataView(C.buffer)).setUint32(0,I),C}var e=I/4294967296,B=4294967295&I;return C=new Uint8Array(8),(g=new DataView(C.buffer)).setUint32(0,t<<2|3&e),g.setUint32(4,B),C}return C=new Uint8Array(12),(g=new DataView(C.buffer)).setUint32(0,t),r(g,4,I),C}function D(A){var g=A.getTime(),I=Math.floor(g/1e3),t=1e6*(g-1e3*I),C=Math.floor(t/1e9);return{sec:I+C,nsec:t-1e9*C}}function u(A){return A instanceof Date?l(D(A)):null}function w(A){var g=new DataView(A.buffer,A.byteOffset,A.byteLength);switch(A.byteLength){case 4:return{sec:g.getUint32(0),nsec:0};case 8:var I=g.getUint32(0);return{sec:4294967296*(3&I)+g.getUint32(4),nsec:I>>>2};case 12:return{sec:h(g,4),nsec:g.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+A.length)}}function d(A){var g=w(A);return new Date(1e3*g.sec+g.nsec/1e6)}var p={type:c,encode:u,decode:d},y=function(){function A(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(p)}return A.prototype.register=function(A){var g=A.type,I=A.encode,t=A.decode;if(g>=0)this.encoders[g]=I,this.decoders[g]=t;else{var C=1+g;this.builtInEncoders[C]=I,this.builtInDecoders[C]=t}},A.prototype.tryToEncode=function(A,g){for(var I=0;I<this.builtInEncoders.length;I++)if(null!=(t=this.builtInEncoders[I])&&null!=(C=t(A,g)))return new a(-1-I,C);for(I=0;I<this.encoders.length;I++){var t,C;if(null!=(t=this.encoders[I])&&null!=(C=t(A,g)))return new a(I,C)}return A instanceof a?A:null},A.prototype.decode=function(A,g,I){var t=g<0?this.builtInDecoders[-1-g]:this.decoders[g];return t?t(A,g,I):new a(g,A)},A.defaultCodec=new A,A}();function G(A){return A instanceof Uint8Array?A:ArrayBuffer.isView(A)?new Uint8Array(A.buffer,A.byteOffset,A.byteLength):A instanceof ArrayBuffer?new Uint8Array(A):Uint8Array.from(A)}var f=function(A){var g="function"==typeof Symbol&&Symbol.iterator,I=g&&A[g],t=0;if(I)return I.call(A);if(A&&"number"==typeof A.length)return{next:function(){return A&&t>=A.length&&(A=void 0),{value:A&&A[t++],done:!A}}};throw new TypeError(g?"Object is not iterable.":"Symbol.iterator is not defined.")},N=function(){function A(A,g,I,t,C,e,B){void 0===A&&(A=y.defaultCodec),void 0===I&&(I=100),void 0===t&&(t=2048),void 0===C&&(C=!1),void 0===e&&(e=!1),void 0===B&&(B=!1),this.extensionCodec=A,this.context=g,this.maxDepth=I,this.initialBufferSize=t,this.sortKeys=C,this.forceFloat32=e,this.ignoreUndefined=B,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return A.prototype.encode=function(A,g){if(g>this.maxDepth)throw new Error("Too deep objects in depth "+g);null==A?this.encodeNil():"boolean"==typeof A?this.encodeBoolean(A):"number"==typeof A?this.encodeNumber(A):"string"==typeof A?this.encodeString(A):this.encodeObject(A,g)},A.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},A.prototype.ensureBufferSizeToWrite=function(A){var g=this.pos+A;this.view.byteLength<g&&this.resizeBuffer(2*g)},A.prototype.resizeBuffer=function(A){var g=new ArrayBuffer(A),I=new Uint8Array(g),t=new DataView(g);I.set(this.bytes),this.view=t,this.bytes=I},A.prototype.encodeNil=function(){this.writeU8(192)},A.prototype.encodeBoolean=function(A){!1===A?this.writeU8(194):this.writeU8(195)},A.prototype.encodeNumber=function(A){Number.isSafeInteger(A)?A>=0?A<128?this.writeU8(A):A<256?(this.writeU8(204),this.writeU8(A)):A<65536?(this.writeU8(205),this.writeU16(A)):A<4294967296?(this.writeU8(206),this.writeU32(A)):(this.writeU8(207),this.writeU64(A)):A>=-32?this.writeU8(224|A+32):A>=-128?(this.writeU8(208),this.writeI8(A)):A>=-32768?(this.writeU8(209),this.writeI16(A)):A>=-2147483648?(this.writeU8(210),this.writeI32(A)):(this.writeU8(211),this.writeI64(A)):this.forceFloat32?(this.writeU8(202),this.writeF32(A)):(this.writeU8(203),this.writeF64(A))},A.prototype.writeStringHeader=function(A){if(A<32)this.writeU8(160+A);else if(A<256)this.writeU8(217),this.writeU8(A);else if(A<65536)this.writeU8(218),this.writeU16(A);else{if(!(A<4294967296))throw new Error("Too long string: "+A+" bytes in UTF-8");this.writeU8(219),this.writeU32(A)}},A.prototype.encodeString=function(A){var g=A.length;if(e&&g>Q){var I=B(A);this.ensureBufferSizeToWrite(5+I),this.writeStringHeader(I),o(A,this.bytes,this.pos),this.pos+=I}else I=B(A),this.ensureBufferSizeToWrite(5+I),this.writeStringHeader(I),function(A,g,I){for(var t=A.length,C=I,e=0;e<t;){var B=A.charCodeAt(e++);if(0!=(4294967168&B)){if(0==(4294965248&B))g[C++]=B>>6&31|192;else{if(B>=55296&&B<=56319&&e<t){var i=A.charCodeAt(e);56320==(64512&i)&&(++e,B=((1023&B)<<10)+(1023&i)+65536)}0==(4294901760&B)?(g[C++]=B>>12&15|224,g[C++]=B>>6&63|128):(g[C++]=B>>18&7|240,g[C++]=B>>12&63|128,g[C++]=B>>6&63|128)}g[C++]=63&B|128}else g[C++]=B}}(A,this.bytes,this.pos),this.pos+=I},A.prototype.encodeObject=function(A,g){var I=this.extensionCodec.tryToEncode(A,this.context);if(null!=I)this.encodeExtension(I);else if(Array.isArray(A))this.encodeArray(A,g);else if(ArrayBuffer.isView(A))this.encodeBinary(A);else{if("object"!=typeof A)throw new Error("Unrecognized object: "+Object.prototype.toString.apply(A));this.encodeMap(A,g)}},A.prototype.encodeBinary=function(A){var g=A.byteLength;if(g<256)this.writeU8(196),this.writeU8(g);else if(g<65536)this.writeU8(197),this.writeU16(g);else{if(!(g<4294967296))throw new Error("Too large binary: "+g);this.writeU8(198),this.writeU32(g)}var I=G(A);this.writeU8a(I)},A.prototype.encodeArray=function(A,g){var I,t,C=A.length;if(C<16)this.writeU8(144+C);else if(C<65536)this.writeU8(220),this.writeU16(C);else{if(!(C<4294967296))throw new Error("Too large array: "+C);this.writeU8(221),this.writeU32(C)}try{for(var e=f(A),B=e.next();!B.done;B=e.next()){var i=B.value;this.encode(i,g+1)}}catch(A){I={error:A}}finally{try{B&&!B.done&&(t=e.return)&&t.call(e)}finally{if(I)throw I.error}}},A.prototype.countWithoutUndefined=function(A,g){var I,t,C=0;try{for(var e=f(g),B=e.next();!B.done;B=e.next())void 0!==A[B.value]&&C++}catch(A){I={error:A}}finally{try{B&&!B.done&&(t=e.return)&&t.call(e)}finally{if(I)throw I.error}}return C},A.prototype.encodeMap=function(A,g){var I,t,C=Object.keys(A);this.sortKeys&&C.sort();var e=this.ignoreUndefined?this.countWithoutUndefined(A,C):C.length;if(e<16)this.writeU8(128+e);else if(e<65536)this.writeU8(222),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too large map object: "+e);this.writeU8(223),this.writeU32(e)}try{for(var B=f(C),i=B.next();!i.done;i=B.next()){var Q=i.value,o=A[Q];this.ignoreUndefined&&void 0===o||(this.encodeString(Q),this.encode(o,g+1))}}catch(A){I={error:A}}finally{try{i&&!i.done&&(t=B.return)&&t.call(B)}finally{if(I)throw I.error}}},A.prototype.encodeExtension=function(A){var g=A.data.length;if(1===g)this.writeU8(212);else if(2===g)this.writeU8(213);else if(4===g)this.writeU8(214);else if(8===g)this.writeU8(215);else if(16===g)this.writeU8(216);else if(g<256)this.writeU8(199),this.writeU8(g);else if(g<65536)this.writeU8(200),this.writeU16(g);else{if(!(g<4294967296))throw new Error("Too large extension object: "+g);this.writeU8(201),this.writeU32(g)}this.writeI8(A.type),this.writeU8a(A.data)},A.prototype.writeU8=function(A){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,A),this.pos++},A.prototype.writeU8a=function(A){var g=A.length;this.ensureBufferSizeToWrite(g),this.bytes.set(A,this.pos),this.pos+=g},A.prototype.writeI8=function(A){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,A),this.pos++},A.prototype.writeU16=function(A){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,A),this.pos+=2},A.prototype.writeI16=function(A){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,A),this.pos+=2},A.prototype.writeU32=function(A){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,A),this.pos+=4},A.prototype.writeI32=function(A){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,A),this.pos+=4},A.prototype.writeF32=function(A){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,A),this.pos+=4},A.prototype.writeF64=function(A){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,A),this.pos+=8},A.prototype.writeU64=function(A){this.ensureBufferSizeToWrite(8),function(A,g,I){var t=I/4294967296,C=I;A.setUint32(g,t),A.setUint32(g+4,C)}(this.view,this.pos,A),this.pos+=8},A.prototype.writeI64=function(A){this.ensureBufferSizeToWrite(8),r(this.view,this.pos,A),this.pos+=8},A}(),F={};function R(A,g){void 0===g&&(g=F);var I=new N(g.extensionCodec,g.context,g.maxDepth,g.initialBufferSize,g.sortKeys,g.forceFloat32,g.ignoreUndefined);return I.encode(A,1),I.getUint8Array()}function m(A){return(A<0?"-":"")+"0x"+Math.abs(A).toString(16).padStart(2,"0")}var k=function(){function A(A,g){void 0===A&&(A=16),void 0===g&&(g=16),this.maxKeyLength=A,this.maxLengthPerKey=g,this.caches=[];for(var I=0;I<this.maxKeyLength;I++)this.caches.push([])}return A.prototype.canBeCached=function(A){return A>0&&A<=this.maxKeyLength},A.prototype.get=function(A,g,I){var t=this.caches[I-1],C=t.length;A:for(var e=0;e<C;e++){for(var B=t[e],i=B.bytes,Q=0;Q<I;Q++)if(i[Q]!==A[g+Q])continue A;return B.value}return null},A.prototype.store=function(A,g){var I=this.caches[A.length-1],t={bytes:A,value:g};I.length>=this.maxLengthPerKey?I[Math.random()*I.length|0]=t:I.push(t)},A.prototype.decode=function(A,g,I){var t=this.get(A,g,I);if(null!=t)return t;var C=E(A,g,I),e=Uint8Array.prototype.slice.call(A,g,g+I);return this.store(e,C),C},A}(),S=function(A,g,I,t){return new(I||(I=Promise))((function(C,e){function B(A){try{Q(t.next(A))}catch(A){e(A)}}function i(A){try{Q(t.throw(A))}catch(A){e(A)}}function Q(A){var g;A.done?C(A.value):(g=A.value,g instanceof I?g:new I((function(A){A(g)}))).then(B,i)}Q((t=t.apply(A,g||[])).next())}))},M=function(A,g){var I,t,C,e,B={label:0,sent:function(){if(1&C[0])throw C[1];return C[1]},trys:[],ops:[]};return e={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(e[Symbol.iterator]=function(){return this}),e;function i(e){return function(i){return function(e){if(I)throw new TypeError("Generator is already executing.");for(;B;)try{if(I=1,t&&(C=2&e[0]?t.return:e[0]?t.throw||((C=t.return)&&C.call(t),0):t.next)&&!(C=C.call(t,e[1])).done)return C;switch(t=0,C&&(e=[2&e[0],C.value]),e[0]){case 0:case 1:C=e;break;case 4:return B.label++,{value:e[1],done:!1};case 5:B.label++,t=e[1],e=[0];continue;case 7:e=B.ops.pop(),B.trys.pop();continue;default:if(!((C=(C=B.trys).length>0&&C[C.length-1])||6!==e[0]&&2!==e[0])){B=0;continue}if(3===e[0]&&(!C||e[1]>C[0]&&e[1]<C[3])){B.label=e[1];break}if(6===e[0]&&B.label<C[1]){B.label=C[1],C=e;break}if(C&&B.label<C[2]){B.label=C[2],B.ops.push(e);break}C[2]&&B.ops.pop(),B.trys.pop();continue}e=g.call(A,B)}catch(A){e=[6,A],t=0}finally{I=C=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}([e,i])}}},U=function(A){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var g,I=A[Symbol.asyncIterator];return I?I.call(A):(A="function"==typeof __values?__values(A):A[Symbol.iterator](),g={},t("next"),t("throw"),t("return"),g[Symbol.asyncIterator]=function(){return this},g);function t(I){g[I]=A[I]&&function(g){return new Promise((function(t,C){!function(A,g,I,t){Promise.resolve(t).then((function(g){A({value:g,done:I})}),g)}(t,C,(g=A[I](g)).done,g.value)}))}}},K=function(A){return this instanceof K?(this.v=A,this):new K(A)},J=function(A,g,I){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,C=I.apply(A,g||[]),e=[];return t={},B("next"),B("throw"),B("return"),t[Symbol.asyncIterator]=function(){return this},t;function B(A){C[A]&&(t[A]=function(g){return new Promise((function(I,t){e.push([A,g,I,t])>1||i(A,g)}))})}function i(A,g){try{(I=C[A](g)).value instanceof K?Promise.resolve(I.value.v).then(Q,o):E(e[0][2],I)}catch(A){E(e[0][3],A)}var I}function Q(A){i("next",A)}function o(A){i("throw",A)}function E(A,g){A(g),e.shift(),e.length&&i(e[0][0],e[0][1])}},Y=new DataView(new ArrayBuffer(0)),L=new Uint8Array(Y.buffer),x=function(){try{Y.getInt8(0)}catch(A){return A.constructor}throw new Error("never reached")}(),b=new x("Insufficient data"),H=new k,q=function(){function A(A,g,I,t,C,e,B,i){void 0===A&&(A=y.defaultCodec),void 0===I&&(I=4294967295),void 0===t&&(t=4294967295),void 0===C&&(C=4294967295),void 0===e&&(e=4294967295),void 0===B&&(B=4294967295),void 0===i&&(i=H),this.extensionCodec=A,this.context=g,this.maxStrLength=I,this.maxBinLength=t,this.maxArrayLength=C,this.maxMapLength=e,this.maxExtLength=B,this.cachedKeyDecoder=i,this.totalPos=0,this.pos=0,this.view=Y,this.bytes=L,this.headByte=-1,this.stack=[]}return A.prototype.setBuffer=function(A){this.bytes=G(A),this.view=function(A){if(A instanceof ArrayBuffer)return new DataView(A);var g=G(A);return new DataView(g.buffer,g.byteOffset,g.byteLength)}(this.bytes),this.pos=0},A.prototype.appendBuffer=function(A){if(-1!==this.headByte||this.hasRemaining()){var g=this.bytes.subarray(this.pos),I=G(A),t=new Uint8Array(g.length+I.length);t.set(g),t.set(I,g.length),this.setBuffer(t)}else this.setBuffer(A)},A.prototype.hasRemaining=function(A){return void 0===A&&(A=1),this.view.byteLength-this.pos>=A},A.prototype.createNoExtraBytesError=function(A){var g=this.view,I=this.pos;return new RangeError("Extra "+(g.byteLength-I)+" byte(s) found at buffer["+A+"]")},A.prototype.decodeSingleSync=function(){var A=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return A},A.prototype.decodeSingleAsync=function(A){var g,I,t,C;return S(this,void 0,void 0,(function(){var e,B,i,Q,o,E,n,s;return M(this,(function(a){switch(a.label){case 0:e=!1,a.label=1;case 1:a.trys.push([1,6,7,12]),g=U(A),a.label=2;case 2:return[4,g.next()];case 3:if((I=a.sent()).done)return[3,5];if(i=I.value,e)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(i);try{B=this.decodeSync(),e=!0}catch(A){if(!(A instanceof x))throw A}this.totalPos+=this.pos,a.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return Q=a.sent(),t={error:Q},[3,12];case 7:return a.trys.push([7,,10,11]),I&&!I.done&&(C=g.return)?[4,C.call(g)]:[3,9];case 8:a.sent(),a.label=9;case 9:return[3,11];case 10:if(t)throw t.error;return[7];case 11:return[7];case 12:if(e){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,B]}throw E=(o=this).headByte,n=o.pos,s=o.totalPos,new RangeError("Insufficient data in parcing "+m(E)+" at "+s+" ("+n+" in the current buffer)")}}))}))},A.prototype.decodeArrayStream=function(A){return this.decodeMultiAsync(A,!0)},A.prototype.decodeStream=function(A){return this.decodeMultiAsync(A,!1)},A.prototype.decodeMultiAsync=function(A,g){return J(this,arguments,(function(){var I,t,C,e,B,i,Q,o,E;return M(this,(function(n){switch(n.label){case 0:I=g,t=-1,n.label=1;case 1:n.trys.push([1,13,14,19]),C=U(A),n.label=2;case 2:return[4,K(C.next())];case 3:if((e=n.sent()).done)return[3,12];if(B=e.value,g&&0===t)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(B),I&&(t=this.readArraySize(),I=!1,this.complete()),n.label=4;case 4:n.trys.push([4,9,,10]),n.label=5;case 5:return[4,K(this.decodeSync())];case 6:return[4,n.sent()];case 7:return n.sent(),0==--t?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((i=n.sent())instanceof x))throw i;return[3,10];case 10:this.totalPos+=this.pos,n.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return Q=n.sent(),o={error:Q},[3,19];case 14:return n.trys.push([14,,17,18]),e&&!e.done&&(E=C.return)?[4,K(E.call(C))]:[3,16];case 15:n.sent(),n.label=16;case 16:return[3,18];case 17:if(o)throw o.error;return[7];case 18:return[7];case 19:return[2]}}))}))},A.prototype.decodeSync=function(){A:for(;;){var A=this.readHeadByte(),g=void 0;if(A>=224)g=A-256;else if(A<192)if(A<128)g=A;else if(A<144){if(0!=(t=A-128)){this.pushMapState(t),this.complete();continue A}g={}}else if(A<160){if(0!=(t=A-144)){this.pushArrayState(t),this.complete();continue A}g=[]}else{var I=A-160;g=this.decodeUtf8String(I,0)}else if(192===A)g=null;else if(194===A)g=!1;else if(195===A)g=!0;else if(202===A)g=this.readF32();else if(203===A)g=this.readF64();else if(204===A)g=this.readU8();else if(205===A)g=this.readU16();else if(206===A)g=this.readU32();else if(207===A)g=this.readU64();else if(208===A)g=this.readI8();else if(209===A)g=this.readI16();else if(210===A)g=this.readI32();else if(211===A)g=this.readI64();else if(217===A)I=this.lookU8(),g=this.decodeUtf8String(I,1);else if(218===A)I=this.lookU16(),g=this.decodeUtf8String(I,2);else if(219===A)I=this.lookU32(),g=this.decodeUtf8String(I,4);else if(220===A){if(0!==(t=this.readU16())){this.pushArrayState(t),this.complete();continue A}g=[]}else if(221===A){if(0!==(t=this.readU32())){this.pushArrayState(t),this.complete();continue A}g=[]}else if(222===A){if(0!==(t=this.readU16())){this.pushMapState(t),this.complete();continue A}g={}}else if(223===A){if(0!==(t=this.readU32())){this.pushMapState(t),this.complete();continue A}g={}}else if(196===A){var t=this.lookU8();g=this.decodeBinary(t,1)}else if(197===A)t=this.lookU16(),g=this.decodeBinary(t,2);else if(198===A)t=this.lookU32(),g=this.decodeBinary(t,4);else if(212===A)g=this.decodeExtension(1,0);else if(213===A)g=this.decodeExtension(2,0);else if(214===A)g=this.decodeExtension(4,0);else if(215===A)g=this.decodeExtension(8,0);else if(216===A)g=this.decodeExtension(16,0);else if(199===A)t=this.lookU8(),g=this.decodeExtension(t,1);else if(200===A)t=this.lookU16(),g=this.decodeExtension(t,2);else{if(201!==A)throw new Error("Unrecognized type byte: "+m(A));t=this.lookU32(),g=this.decodeExtension(t,4)}this.complete();for(var C=this.stack;C.length>0;){var e=C[C.length-1];if(0===e.type){if(e.array[e.position]=g,e.position++,e.position!==e.size)continue A;C.pop(),g=e.array}else{if(1===e.type){if(B=void 0,"string"!=(B=typeof g)&&"number"!==B)throw new Error("The type of key must be string or number but "+typeof g);e.key=g,e.type=2;continue A}if(e.map[e.key]=g,e.readCount++,e.readCount!==e.size){e.key=null,e.type=1;continue A}C.pop(),g=e.map}}return g}var B},A.prototype.readHeadByte=function(){return-1===this.headByte&&(this.headByte=this.readU8()),this.headByte},A.prototype.complete=function(){this.headByte=-1},A.prototype.readArraySize=function(){var A=this.readHeadByte();switch(A){case 220:return this.readU16();case 221:return this.readU32();default:if(A<160)return A-144;throw new Error("Unrecognized array type byte: "+m(A))}},A.prototype.pushMapState=function(A){if(A>this.maxMapLength)throw new Error("Max length exceeded: map length ("+A+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:A,key:null,readCount:0,map:{}})},A.prototype.pushArrayState=function(A){if(A>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+A+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:A,array:new Array(A),position:0})},A.prototype.decodeUtf8String=function(A,g){var I;if(A>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+A+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+g+A)throw b;var t,C=this.pos+g;return t=this.stateIsMapKey()&&(null===(I=this.cachedKeyDecoder)||void 0===I?void 0:I.canBeCached(A))?this.cachedKeyDecoder.decode(this.bytes,C,A):e&&A>s?function(A,g,I){var t=A.subarray(g,g+I);return n.decode(t)}(this.bytes,C,A):E(this.bytes,C,A),this.pos+=g+A,t},A.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},A.prototype.decodeBinary=function(A,g){if(A>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+A+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(A+g))throw b;var I=this.pos+g,t=this.bytes.subarray(I,I+A);return this.pos+=g+A,t},A.prototype.decodeExtension=function(A,g){if(A>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+A+") > maxExtLength ("+this.maxExtLength+")");var I=this.view.getInt8(this.pos+g),t=this.decodeBinary(A,g+1);return this.extensionCodec.decode(t,I,this.context)},A.prototype.lookU8=function(){return this.view.getUint8(this.pos)},A.prototype.lookU16=function(){return this.view.getUint16(this.pos)},A.prototype.lookU32=function(){return this.view.getUint32(this.pos)},A.prototype.readU8=function(){var A=this.view.getUint8(this.pos);return this.pos++,A},A.prototype.readI8=function(){var A=this.view.getInt8(this.pos);return this.pos++,A},A.prototype.readU16=function(){var A=this.view.getUint16(this.pos);return this.pos+=2,A},A.prototype.readI16=function(){var A=this.view.getInt16(this.pos);return this.pos+=2,A},A.prototype.readU32=function(){var A=this.view.getUint32(this.pos);return this.pos+=4,A},A.prototype.readI32=function(){var A=this.view.getInt32(this.pos);return this.pos+=4,A},A.prototype.readU64=function(){var A,g,I=(A=this.view,g=this.pos,4294967296*A.getUint32(g)+A.getUint32(g+4));return this.pos+=8,I},A.prototype.readI64=function(){var A=h(this.view,this.pos);return this.pos+=8,A},A.prototype.readF32=function(){var A=this.view.getFloat32(this.pos);return this.pos+=4,A},A.prototype.readF64=function(){var A=this.view.getFloat64(this.pos);return this.pos+=8,A},A}(),T={};function v(A,g){void 0===g&&(g=T);var I=new q(g.extensionCodec,g.context,g.maxStrLength,g.maxBinLength,g.maxArrayLength,g.maxMapLength,g.maxExtLength);return I.setBuffer(A),I.decodeSingleSync()}var V=function(A,g){var I,t,C,e,B={label:0,sent:function(){if(1&C[0])throw C[1];return C[1]},trys:[],ops:[]};return e={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(e[Symbol.iterator]=function(){return this}),e;function i(e){return function(i){return function(e){if(I)throw new TypeError("Generator is already executing.");for(;B;)try{if(I=1,t&&(C=2&e[0]?t.return:e[0]?t.throw||((C=t.return)&&C.call(t),0):t.next)&&!(C=C.call(t,e[1])).done)return C;switch(t=0,C&&(e=[2&e[0],C.value]),e[0]){case 0:case 1:C=e;break;case 4:return B.label++,{value:e[1],done:!1};case 5:B.label++,t=e[1],e=[0];continue;case 7:e=B.ops.pop(),B.trys.pop();continue;default:if(!((C=(C=B.trys).length>0&&C[C.length-1])||6!==e[0]&&2!==e[0])){B=0;continue}if(3===e[0]&&(!C||e[1]>C[0]&&e[1]<C[3])){B.label=e[1];break}if(6===e[0]&&B.label<C[1]){B.label=C[1],C=e;break}if(C&&B.label<C[2]){B.label=C[2],B.ops.push(e);break}C[2]&&B.ops.pop(),B.trys.pop();continue}e=g.call(A,B)}catch(A){e=[6,A],t=0}finally{I=C=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}([e,i])}}},W=function(A){return this instanceof W?(this.v=A,this):new W(A)},O=function(A,g,I){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,C=I.apply(A,g||[]),e=[];return t={},B("next"),B("throw"),B("return"),t[Symbol.asyncIterator]=function(){return this},t;function B(A){C[A]&&(t[A]=function(g){return new Promise((function(I,t){e.push([A,g,I,t])>1||i(A,g)}))})}function i(A,g){try{(I=C[A](g)).value instanceof W?Promise.resolve(I.value.v).then(Q,o):E(e[0][2],I)}catch(A){E(e[0][3],A)}var I}function Q(A){i("next",A)}function o(A){i("throw",A)}function E(A,g){A(g),e.shift(),e.length&&i(e[0][0],e[0][1])}};function Z(A){if(null==A)throw new Error("Assertion Failure: value must not be null nor undefined")}function P(A){return null!=A[Symbol.asyncIterator]?A:function(A){return O(this,arguments,(function(){var g,I,t,C;return V(this,(function(e){switch(e.label){case 0:g=A.getReader(),e.label=1;case 1:e.trys.push([1,,9,10]),e.label=2;case 2:return[4,W(g.read())];case 3:return I=e.sent(),t=I.done,C=I.value,t?[4,W(void 0)]:[3,5];case 4:return[2,e.sent()];case 5:return Z(C),[4,W(C)];case 6:return[4,e.sent()];case 7:return e.sent(),[3,2];case 8:return[3,10];case 9:return g.releaseLock(),[7];case 10:return[2]}}))}))}(A)}var X=function(A,g,I,t){return new(I||(I=Promise))((function(C,e){function B(A){try{Q(t.next(A))}catch(A){e(A)}}function i(A){try{Q(t.throw(A))}catch(A){e(A)}}function Q(A){var g;A.done?C(A.value):(g=A.value,g instanceof I?g:new I((function(A){A(g)}))).then(B,i)}Q((t=t.apply(A,g||[])).next())}))},j=function(A,g){var I,t,C,e,B={label:0,sent:function(){if(1&C[0])throw C[1];return C[1]},trys:[],ops:[]};return e={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(e[Symbol.iterator]=function(){return this}),e;function i(e){return function(i){return function(e){if(I)throw new TypeError("Generator is already executing.");for(;B;)try{if(I=1,t&&(C=2&e[0]?t.return:e[0]?t.throw||((C=t.return)&&C.call(t),0):t.next)&&!(C=C.call(t,e[1])).done)return C;switch(t=0,C&&(e=[2&e[0],C.value]),e[0]){case 0:case 1:C=e;break;case 4:return B.label++,{value:e[1],done:!1};case 5:B.label++,t=e[1],e=[0];continue;case 7:e=B.ops.pop(),B.trys.pop();continue;default:if(!((C=(C=B.trys).length>0&&C[C.length-1])||6!==e[0]&&2!==e[0])){B=0;continue}if(3===e[0]&&(!C||e[1]>C[0]&&e[1]<C[3])){B.label=e[1];break}if(6===e[0]&&B.label<C[1]){B.label=C[1],C=e;break}if(C&&B.label<C[2]){B.label=C[2],B.ops.push(e);break}C[2]&&B.ops.pop(),B.trys.pop();continue}e=g.call(A,B)}catch(A){e=[6,A],t=0}finally{I=C=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}([e,i])}}};function z(A,g){return void 0===g&&(g=T),X(this,void 0,void 0,(function(){var I;return j(this,(function(t){return I=P(A),[2,new q(g.extensionCodec,g.context,g.maxStrLength,g.maxBinLength,g.maxArrayLength,g.maxMapLength,g.maxExtLength).decodeSingleAsync(I)]}))}))}function _(A,g){void 0===g&&(g=T);var I=P(A);return new q(g.extensionCodec,g.context,g.maxStrLength,g.maxBinLength,g.maxArrayLength,g.maxMapLength,g.maxExtLength).decodeArrayStream(I)}function $(A,g){void 0===g&&(g=T);var I=P(A);return new q(g.extensionCodec,g.context,g.maxStrLength,g.maxBinLength,g.maxArrayLength,g.maxMapLength,g.maxExtLength).decodeStream(I)}}])},512:(A,g,I)=>{"use strict";I.r(g),I.d(g,{Abs:()=>_A,Acos:()=>$A,Acosh:()=>Ag,AdadeltaOptimizer:()=>zQ,AdagradOptimizer:()=>$Q,AdamOptimizer:()=>Io,AdamaxOptimizer:()=>eo,Add:()=>gg,AddN:()=>Ig,All:()=>tg,Any:()=>Cg,ArgMax:()=>eg,ArgMin:()=>Bg,Asin:()=>ig,Asinh:()=>Qg,Atan:()=>og,Atan2:()=>ng,Atanh:()=>Eg,AvgPool:()=>sg,AvgPool3D:()=>rg,AvgPool3DGrad:()=>hg,AvgPoolGrad:()=>ag,BatchMatMul:()=>cg,BatchToSpaceND:()=>lg,Bincount:()=>Dg,BroadcastArgs:()=>wg,BroadcastTo:()=>ug,Callback:()=>MG,CallbackList:()=>Gu,Cast:()=>dg,Ceil:()=>pg,ClipByValue:()=>yg,Complex:()=>Gg,ComplexAbs:()=>fg,Concat:()=>Ng,Conv2D:()=>Fg,Conv2DBackpropFilter:()=>Rg,Conv2DBackpropInput:()=>mg,Conv3D:()=>kg,Conv3DBackpropFilterV2:()=>Sg,Conv3DBackpropInputV2:()=>Mg,Cos:()=>Ug,Cosh:()=>Kg,CropAndResize:()=>Lg,Cumprod:()=>Jg,Cumsum:()=>Yg,CustomCallback:()=>Fu,DataStorage:()=>Z,DenseBincount:()=>xg,DepthToSpace:()=>bg,DepthwiseConv2dNative:()=>Hg,DepthwiseConv2dNativeBackpropFilter:()=>qg,DepthwiseConv2dNativeBackpropInput:()=>Tg,Diag:()=>vg,Dilation2D:()=>Vg,Dilation2DBackpropFilter:()=>Og,Dilation2DBackpropInput:()=>Wg,ENV:()=>XA,EarlyStopping:()=>JG,Einsum:()=>Pg,Elu:()=>Xg,EluGrad:()=>jg,Environment:()=>WA,Equal:()=>_g,Erf:()=>zg,Exp:()=>$g,ExpandDims:()=>AI,Expm1:()=>gI,FFT:()=>II,Fill:()=>tI,FlipLeftRight:()=>CI,Floor:()=>eI,FloorDiv:()=>BI,FromPixels:()=>eC,FusedBatchNorm:()=>iI,FusedConv2D:()=>QC,FusedDepthwiseConv2D:()=>oC,GatherNd:()=>oI,GatherV2:()=>QI,GraphModel:()=>gN,Greater:()=>EI,GreaterEqual:()=>nI,History:()=>Nu,IFFT:()=>aI,Identity:()=>sI,Imag:()=>rI,InputSpec:()=>mD,IsFinite:()=>hI,IsInf:()=>cI,IsNan:()=>lI,KernelBackend:()=>P,LRN:()=>kI,LRNGrad:()=>SI,LayerVariable:()=>ND,LayersModel:()=>Uw,LeakyRelu:()=>DI,Less:()=>uI,LessEqual:()=>wI,LinSpace:()=>dI,Log:()=>pI,Log1p:()=>yI,LogSoftmax:()=>RI,LogicalAnd:()=>GI,LogicalNot:()=>fI,LogicalOr:()=>NI,LogicalXor:()=>FI,LowerBound:()=>mI,Max:()=>MI,MaxPool:()=>KI,MaxPool3D:()=>YI,MaxPool3DGrad:()=>LI,MaxPoolGrad:()=>JI,MaxPoolWithArgmax:()=>xI,Maximum:()=>UI,Mean:()=>bI,Min:()=>HI,Minimum:()=>qI,MirrorPad:()=>TI,Mod:()=>vI,MomentumOptimizer:()=>io,Multinomial:()=>VI,Multiply:()=>WI,Neg:()=>OI,NonMaxSuppressionV3:()=>PI,NonMaxSuppressionV4:()=>XI,NonMaxSuppressionV5:()=>jI,NotEqual:()=>ZI,OP_SCOPE_SUFFIX:()=>Ye,OneHot:()=>_I,OnesLike:()=>zI,Optimizer:()=>jQ,OptimizerConstructors:()=>oo,Pack:()=>$I,PadV2:()=>At,Pool:()=>gt,Pow:()=>It,Prelu:()=>tt,Prod:()=>Ct,RMSPropOptimizer:()=>Qo,RNN:()=>Td,RaggedGather:()=>et,RaggedTensorToTensor:()=>Bt,Range:()=>it,Rank:()=>ie,Real:()=>Qt,RealDiv:()=>Zg,Reciprocal:()=>ot,Reduction:()=>Wa,Relu:()=>Et,Relu6:()=>ct,Reshape:()=>nt,ResizeBilinear:()=>rt,ResizeBilinearGrad:()=>ht,ResizeNearestNeighbor:()=>st,ResizeNearestNeighborGrad:()=>at,Reverse:()=>lt,RotateWithOffset:()=>BC,Round:()=>Dt,Rsqrt:()=>ut,SGDOptimizer:()=>Bo,ScatterNd:()=>wt,SearchSorted:()=>dt,Select:()=>pt,Selu:()=>yt,Sequential:()=>Lw,Sigmoid:()=>Rt,Sign:()=>Ft,Sin:()=>ft,Sinh:()=>Nt,Slice:()=>Gt,Softmax:()=>Kt,Softplus:()=>mt,SpaceToBatchND:()=>Mt,SparseFillEmptyRows:()=>Jt,SparseReshape:()=>Yt,SparseSegmentMean:()=>Lt,SparseSegmentSum:()=>xt,SparseToDense:()=>bt,SplitV:()=>Ut,Sqrt:()=>kt,Square:()=>qt,SquaredDifference:()=>Ht,Step:()=>CC,StridedSlice:()=>Tt,StringNGrams:()=>vt,StringSplit:()=>Vt,StringToHashBucketFast:()=>Wt,Sub:()=>Ot,Sum:()=>St,SymbolicTensor:()=>kD,Tan:()=>Zt,Tanh:()=>Pt,Tensor:()=>Ce,TensorBuffer:()=>Ae,Tile:()=>Xt,TopK:()=>jt,Transform:()=>zt,Transpose:()=>_t,Unique:()=>$t,Unpack:()=>AC,UnsortedSegmentSum:()=>gC,UpperBound:()=>IC,Variable:()=>Be,ZerosLike:()=>tC,_FusedMatMul:()=>iC,abs:()=>to,acos:()=>Eo,acosh:()=>no,add:()=>JQ,addN:()=>so,all:()=>ao,any:()=>ro,argMax:()=>ho,argMin:()=>co,asin:()=>lo,asinh:()=>Do,atan:()=>uo,atan2:()=>wo,atanh:()=>po,avgPool:()=>xo,avgPool3d:()=>bo,backend:()=>Si,backend_util:()=>l,basicLSTMCell:()=>Vo,batchNorm:()=>Oo,batchNorm2d:()=>Zo,batchNorm3d:()=>Po,batchNorm4d:()=>Xo,batchToSpaceND:()=>Wo,bincount:()=>jo,booleanMaskAsync:()=>Ps,broadcastArgs:()=>zo,broadcastTo:()=>_o,broadcast_util:()=>Q,browser:()=>o,buffer:()=>HB,callbacks:()=>YG,cast:()=>qB,ceil:()=>$o,clipByValue:()=>AE,clone:()=>TB,complex:()=>xe,concat:()=>Ho,concat1d:()=>gE,concat2d:()=>IE,concat3d:()=>tE,concat4d:()=>CE,constraints:()=>u,conv1d:()=>BE,conv2d:()=>eE,conv2dTranspose:()=>QE,conv3d:()=>oE,conv3dTranspose:()=>nE,copyRegisteredKernels:()=>dC,cos:()=>sE,cosh:()=>aE,cosineWindow:()=>ga,cumprod:()=>rE,cumsum:()=>hE,customGrad:()=>ZQ,data:()=>W,denseBincount:()=>cE,deprecationWarn:()=>hi,depthToSpace:()=>lE,depthwiseConv2d:()=>DE,deregisterOp:()=>TG,device_util:()=>e,diag:()=>uE,dilation2d:()=>wE,disableDeprecationWarnings:()=>ri,dispose:()=>di,disposeVariables:()=>ci,div:()=>LQ,divNoNan:()=>yE,dot:()=>GE,dropout:()=>$s,einsum:()=>fE,elu:()=>NE,enableDebugMode:()=>ai,enableProdMode:()=>si,enclosingPowerOfTwo:()=>Aa,engine:()=>li,env:()=>ZA,equal:()=>dE,erf:()=>FE,euclideanNorm:()=>qE,exp:()=>TE,expandDims:()=>vE,expm1:()=>VE,eye:()=>OE,fft:()=>ys,fill:()=>_Q,findBackend:()=>Ri,findBackendFactory:()=>mi,floor:()=>ZE,floorDiv:()=>YQ,fused:()=>h,gather:()=>PE,gatherND:()=>_s,gather_util:()=>E,getBackend:()=>Ni,getGradient:()=>hC,getKernel:()=>rC,getKernelsForBackend:()=>cC,grad:()=>TQ,grads:()=>vQ,greater:()=>XE,greaterEqual:()=>jE,ifft:()=>Gs,imag:()=>Ui,image:()=>Er,inTopKAsync:()=>Ia,initializers:()=>w,input:()=>qw,io:()=>B,irfft:()=>fs,isFinite:()=>zE,isInf:()=>_E,isNaN:()=>$E,keep:()=>pi,kernel_impls:()=>D,layers:()=>d,leakyRelu:()=>An,less:()=>gn,lessEqual:()=>In,linalg:()=>nr,linspace:()=>tn,loadGraphModel:()=>IN,loadGraphModelSync:()=>tN,loadLayersModel:()=>Hw,localResponseNormalization:()=>Cn,log:()=>en,log1p:()=>Bn,logSigmoid:()=>on,logSoftmax:()=>En,logSumExp:()=>nn,logicalAnd:()=>sn,logicalNot:()=>an,logicalOr:()=>rn,logicalXor:()=>hn,losses:()=>sr,lowerBound:()=>Dn,matMul:()=>Ei,math:()=>i,max:()=>YE,maxPool:()=>un,maxPool3d:()=>wn,maxPoolWithArgmax:()=>dn,maximum:()=>Co,mean:()=>pn,memory:()=>Di,meshgrid:()=>fn,metrics:()=>p,min:()=>LE,minimum:()=>Nn,mirrorPad:()=>Fn,mod:()=>Rn,model:()=>xw,models:()=>y,moments:()=>mn,movingAverage:()=>Xs,mul:()=>xQ,multiRNNCell:()=>kn,multinomial:()=>Sn,neg:()=>Ki,nextFrame:()=>lr,norm:()=>HE,notEqual:()=>Mn,oneHot:()=>ni,ones:()=>Gn,onesLike:()=>Un,op:()=>Le,outerProduct:()=>Kn,pad:()=>Jn,pad1d:()=>Yn,pad2d:()=>Ln,pad3d:()=>xn,pad4d:()=>bn,pool:()=>qn,pow:()=>Ao,prelu:()=>Tn,print:()=>vB,prod:()=>vn,profile:()=>ui,raggedGather:()=>Vn,raggedTensorToTensor:()=>Wn,rand:()=>On,randomGamma:()=>zn,randomNormal:()=>_n,randomStandardNormal:()=>$n,randomUniform:()=>As,range:()=>gs,ready:()=>fi,real:()=>Ji,reciprocal:()=>Is,registerBackend:()=>ki,registerCallbackConstructor:()=>Tw,registerGradient:()=>DC,registerKernel:()=>lC,registerOp:()=>HG,regularizers:()=>G,relu:()=>ts,relu6:()=>Cs,removeBackend:()=>Fi,reshape:()=>Lo,reverse:()=>es,reverse1d:()=>Bs,reverse2d:()=>is,reverse3d:()=>Qs,reverse4d:()=>os,rfft:()=>Fs,round:()=>Es,rsqrt:()=>ns,scalar:()=>XQ,scatterND:()=>js,scatter_util:()=>n,searchSorted:()=>ln,selu:()=>ss,separableConv2d:()=>as,sequential:()=>bw,serialization:()=>a,setBackend:()=>Gi,setPlatform:()=>Mi,setdiff1dAsync:()=>rs,sigmoid:()=>qo,sign:()=>hs,signal:()=>or,sin:()=>cs,sinh:()=>ls,slice:()=>To,slice1d:()=>Ds,slice2d:()=>us,slice3d:()=>ws,slice4d:()=>ds,slice_util:()=>s,softmax:()=>ps,softplus:()=>Qn,spaceToBatchND:()=>Hn,sparse:()=>ar,sparseToDense:()=>zs,spectral:()=>Qr,split:()=>Ns,sqrt:()=>bQ,square:()=>HQ,squaredDifference:()=>Rs,squeeze:()=>ms,stack:()=>ks,step:()=>Ss,stridedSlice:()=>Ms,string:()=>rr,sub:()=>go,sum:()=>xE,sumOutType:()=>re,tan:()=>Us,tanh:()=>vo,tensor:()=>He,tensor1d:()=>Ks,tensor2d:()=>Js,tensor3d:()=>qi,tensor4d:()=>Ys,tensor5d:()=>Ls,tensor6d:()=>xs,tensor_util:()=>C,test_util:()=>r,tidy:()=>wi,tile:()=>WE,time:()=>yi,topk:()=>bs,train:()=>hr,transpose:()=>Yi,truncatedNormal:()=>Hs,unique:()=>qs,unregisterGradient:()=>wC,unregisterKernel:()=>uC,unsortedSegmentSum:()=>Ts,unstack:()=>vs,upcastType:()=>ae,upperBound:()=>Vs,util:()=>t,valueAndGrad:()=>VQ,valueAndGrads:()=>WQ,variable:()=>Ws,variableGrads:()=>OQ,version:()=>hv,version_converter:()=>CN,version_core:()=>KQ,version_layers:()=>sw,where:()=>pE,whereAsync:()=>Zs,zeros:()=>yn,zerosLike:()=>qQ});var t={};I.r(t),I.d(t,{arraysEqual:()=>EA,assert:()=>CA,assertNonNegativeIntegerDimensions:()=>HA,assertNonNull:()=>BA,assertShapesMatch:()=>eA,bytesFromStringArray:()=>FA,bytesPerElement:()=>NA,checkConversionForErrors:()=>pA,clamp:()=>_,computeStrides:()=>KA,createScalarValue:()=>LC,createShuffledIndices:()=>rA,decodeString:()=>TC,distSquared:()=>tA,encodeString:()=>qC,fetch:()=>HC,fingerPrint64:()=>YC,flatten:()=>iA,getArrayFromDType:()=>dA,getTypedArrayFromDType:()=>wA,hasEncodingLoss:()=>GA,hexToLong:()=>fC,indexToLoc:()=>TA,inferDtype:()=>SA,inferFromImplicitShape:()=>lA,isBoolean:()=>mA,isFunction:()=>MA,isInt:()=>nA,isNumber:()=>kA,isPromise:()=>vA,isScalarShape:()=>oA,isString:()=>RA,isTypedArray:()=>fA,isValidDtype:()=>yA,locToIndex:()=>qA,makeOnesTypedArray:()=>LA,makeZerosNestedTypedArray:()=>bA,makeZerosTypedArray:()=>xA,nearestDivisor:()=>UA,nearestLargerEven:()=>$,now:()=>bC,parseAxisParam:()=>DA,randUniform:()=>IA,repeatedTry:()=>cA,rightPad:()=>hA,shuffle:()=>j,shuffleCombo:()=>z,sizeFromShape:()=>QA,sizeToSquarishShape:()=>aA,squeezeShape:()=>uA,sum:()=>gA,swap:()=>AA,tanh:()=>sA,toNestedArray:()=>YA,toTypedArray:()=>xC});var C={};I.r(C),I.d(C,{assertTypesMatch:()=>ce,getTensorsInContainer:()=>De,isTensorInList:()=>le,makeTypesMatch:()=>he});var e={};I.r(e),I.d(e,{isBrowser:()=>me,isMobile:()=>Re,mockIsMobile:()=>Fe});var B={};I.r(B),I.d(B,{browserFiles:()=>ZB,browserHTTPRequest:()=>Ii,concatenateArrayBuffers:()=>Pe,copyModel:()=>KB,decodeWeights:()=>Ve,encodeWeights:()=>ve,fromMemory:()=>Bi,fromMemorySync:()=>ii,getLoadHandlers:()=>BB,getModelArtifactsForJSON:()=>_e,getModelArtifactsForJSONSync:()=>ze,getModelArtifactsInfoForJSON:()=>$e,getSaveHandlers:()=>eB,getWeightSpecs:()=>AB,http:()=>gi,isHTTPScheme:()=>$B,listModels:()=>MB,loadWeights:()=>jB,moveModel:()=>JB,registerLoadRouter:()=>CB,registerSaveRouter:()=>tB,removeModel:()=>UB,weightsLoaderFactory:()=>zB,withSaveHandler:()=>Qi,withSaveHandlerSync:()=>oi});var i={};I.r(i),I.d(i,{confusionMatrix:()=>Li});var Q={};I.r(Q),I.d(Q,{assertAndGetBroadcastShape:()=>Hi,getBroadcastDims:()=>xi,getReductionAxes:()=>bi});var o={};I.r(o),I.d(o,{fromPixels:()=>Zi,fromPixelsAsync:()=>Wi,toPixels:()=>Oi});var E={};I.r(E),I.d(E,{prepareAndValidate:()=>Pi});var n={};I.r(n),I.d(n,{calculateShapes:()=>zi,validateInput:()=>ji,validateUpdateShape:()=>Xi});var s={};I.r(s),I.d(s,{assertParamsValid:()=>AQ,computeFlatOffset:()=>aQ,computeOutShape:()=>IQ,getNormalizedAxes:()=>BQ,isSliceContinous:()=>sQ,maskToAxes:()=>gQ,parseSliceParams:()=>rQ,sliceInfo:()=>hQ,startForAxis:()=>EQ,startIndicesWithElidedDims:()=>iQ,stopForAxis:()=>nQ,stopIndicesWithElidedDims:()=>QQ,stridesForAxis:()=>oQ,stridesWithElidedDims:()=>tQ});var a={};I.r(a),I.d(a,{Serializable:()=>lQ,SerializationMap:()=>DQ,registerClass:()=>uQ});var r={};I.r(r),I.d(r,{TEST_EPSILON_FLOAT16:()=>dQ,createVideoElement:()=>MQ,encodeStrings:()=>SQ,expectArrayBuffersEqual:()=>kQ,expectArraysClose:()=>pQ,expectArraysEqual:()=>NQ,expectNumbersClose:()=>FQ,expectPromiseToFail:()=>fQ,expectValuesInRange:()=>mQ,play:()=>UQ,testEpsilon:()=>yQ});var h={};I.r(h),I.d(h,{conv2d:()=>Qa,depthwiseConv2d:()=>na,matMul:()=>sa});var c={};I.r(c),I.d(c,{collectGatherOpShapeInfo:()=>wh,computeOutShape:()=>uh,segOpComputeOptimalWindowSize:()=>Dh});var l={};I.r(l),I.d(l,{ERF_A1:()=>Yr,ERF_A2:()=>Lr,ERF_A3:()=>xr,ERF_A4:()=>br,ERF_A5:()=>Hr,ERF_P:()=>Jr,PARALLELIZE_THRESHOLD:()=>fr,RowPartitionType:()=>wr,SELU_SCALE:()=>Kr,SELU_SCALEALPHA:()=>Ur,applyActivation:()=>Ba,assertAndGetBroadcastShape:()=>Hi,assertAxesAreInnerMostDims:()=>ME,assertParamsConsistent:()=>Dr,assignToTypedArray:()=>Or,axesAreInnerMostDims:()=>RE,calculateShapes:()=>zi,checkEinsumDimSizes:()=>gh,checkPadOnDimRoundingMode:()=>Yo,combineLocations:()=>mE,combineRaggedTensorToTensorShapes:()=>dr,complexWithEvenIndex:()=>vr,complexWithOddIndex:()=>Vr,computeConv2DInfo:()=>No,computeConv3DInfo:()=>Fo,computeDefaultPad:()=>Ro,computeDilation2DInfo:()=>yo,computeOptimalWindowSize:()=>Nr,computeOutAndReduceShapes:()=>kE,computeOutShape:()=>ur,computePool2DInfo:()=>Go,computePool3DInfo:()=>fo,convertConv2DDataFormat:()=>Jo,decodeEinsumEquation:()=>$r,eitherStridesOrDilationsAreOne:()=>Ko,expandShapeToKeepDim:()=>SE,exponent:()=>Pr,exponents:()=>Zr,fromStringArrayToUint8:()=>ph,fromUint8ToStringArray:()=>dh,getAxesPermutation:()=>UE,getBroadcastDims:()=>xi,getComplexWithIndex:()=>Wr,getEinsumComputePath:()=>Ih,getEinsumPermutation:()=>Ah,getFusedBiasGradient:()=>ea,getFusedDyActivation:()=>Ca,getImageCenter:()=>Fr,getInnerMostAxes:()=>JE,getPermuted:()=>mr,getRaggedRank:()=>yr,getReductionAxes:()=>bi,getReshaped:()=>Rr,getReshapedPermuted:()=>kr,getRowPartitionTypesHelper:()=>pr,getSliceBeginCoords:()=>Sr,getSliceSize:()=>Mr,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Bh,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ih,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Qh,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>nh,getSparseReshapeInputOutputMismatchErrorMessage:()=>ah,getSparseReshapeInputOutputMultipleErrorMessage:()=>sh,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>oh,getSparseReshapeNegativeOutputDimErrorMessage:()=>Eh,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>lh,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>rh,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>hh,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ch,getUndoAxesPermutation:()=>KE,isIdentityPermutation:()=>th,log:()=>nC,mergeRealAndImagArrays:()=>qr,prepareAndValidate:()=>Pi,prepareSplitSize:()=>eh,segment_util:()=>c,shouldFuse:()=>ia,slice_util:()=>s,splitRealAndImagArrays:()=>Tr,tupleValuesAreOne:()=>Uo,upcastType:()=>ae,validateDefaultValueShape:()=>Gr,validateInput:()=>ji,validateUpdateShape:()=>Xi,warn:()=>EC});var D={};I.r(D),I.d(D,{nonMaxSuppressionV3Impl:()=>fa,nonMaxSuppressionV4Impl:()=>Na,nonMaxSuppressionV5Impl:()=>Fa,whereImpl:()=>Os});var u={};I.r(u),I.d(u,{maxNorm:()=>gu,minMaxNorm:()=>Cu,nonNeg:()=>tu,unitNorm:()=>Iu});var w={};I.r(w),I.d(w,{constant:()=>iu,glorotNormal:()=>ru,glorotUniform:()=>au,heNormal:()=>hu,heUniform:()=>cu,identity:()=>nu,leCunNormal:()=>lu,leCunUniform:()=>Du,ones:()=>Bu,orthogonal:()=>uu,randomNormal:()=>ou,randomUniform:()=>Qu,truncatedNormal:()=>Eu,varianceScaling:()=>su,zeros:()=>eu});var d={};I.r(d),I.d(d,{Layer:()=>KD,RNN:()=>Td,RNNCell:()=>vd,activation:()=>sy,add:()=>dy,alphaDropout:()=>nG,average:()=>py,averagePooling1d:()=>Sy,averagePooling2d:()=>Ky,averagePooling3d:()=>Ly,avgPool1d:()=>My,avgPool2d:()=>Jy,avgPool3d:()=>xy,avgPooling1d:()=>Uy,avgPooling2d:()=>Yy,avgPooling3d:()=>by,batchNormalization:()=>Ry,bidirectional:()=>tG,concatenate:()=>yy,conv1d:()=>ty,conv2d:()=>Cy,conv2dTranspose:()=>ey,conv3d:()=>By,conv3dTranspose:()=>iy,convLstm2d:()=>$y,convLstm2dCell:()=>AG,cropping2D:()=>oy,dense:()=>ay,depthwiseConv2d:()=>ny,dot:()=>Fy,dropout:()=>ry,elu:()=>zp,embedding:()=>wy,flatten:()=>cy,gaussianDropout:()=>EG,gaussianNoise:()=>oG,globalAveragePooling1d:()=>Hy,globalAveragePooling2d:()=>qy,globalMaxPool1d:()=>eG,globalMaxPool2d:()=>BG,globalMaxPooling1d:()=>Ty,globalMaxPooling2d:()=>vy,gru:()=>Zy,gruCell:()=>Py,input:()=>qw,inputLayer:()=>jp,layerNormalization:()=>my,leakyReLU:()=>$p,lstm:()=>Xy,lstmCell:()=>jy,masking:()=>sG,maxPool1d:()=>iG,maxPool2d:()=>QG,maxPooling1d:()=>Vy,maxPooling2d:()=>Wy,maxPooling3d:()=>Oy,maximum:()=>Gy,minimum:()=>fy,multiply:()=>Ny,permute:()=>uy,prelu:()=>Ay,reLU:()=>_p,repeatVector:()=>ly,rescaling:()=>aG,reshape:()=>Dy,rnn:()=>gG,separableConv2d:()=>Qy,simpleRNN:()=>zy,simpleRNNCell:()=>_y,softmax:()=>gy,spatialDropout1d:()=>hy,stackedRNNCells:()=>IG,thresholdedReLU:()=>Iy,timeDistributed:()=>CG,upSampling2d:()=>Ey,zeroPadding2d:()=>ky});var p={};I.r(p),I.d(p,{MAPE:()=>GG,MSE:()=>FG,binaryAccuracy:()=>rG,binaryCrossentropy:()=>hG,categoricalAccuracy:()=>lG,categoricalCrossentropy:()=>DG,cosineProximity:()=>dG,mape:()=>fG,meanAbsoluteError:()=>pG,meanAbsolutePercentageError:()=>yG,meanSquaredError:()=>NG,mse:()=>RG,precision:()=>uG,recall:()=>wG,sparseCategoricalAccuracy:()=>cG});var y={};I.r(y),I.d(y,{modelFromJSON:()=>Jw});var G={};I.r(G),I.d(G,{l1:()=>kG,l1l2:()=>mG,l2:()=>SG});var f={};I.r(f),I.d(f,{json:()=>jG});var N={};I.r(N),I.d(N,{json:()=>zG});var F={};I.r(F),I.d(F,{json:()=>_G});var R={};I.r(R),I.d(R,{json:()=>$G});var m={};I.r(m),I.d(m,{json:()=>Af});var k={};I.r(k),I.d(k,{json:()=>gf});var S={};I.r(S),I.d(S,{json:()=>If});var M={};I.r(M),I.d(M,{json:()=>tf});var U={};I.r(U),I.d(U,{json:()=>Cf});var K={};I.r(K),I.d(K,{json:()=>ef});var J={};I.r(J),I.d(J,{json:()=>Bf});var Y={};I.r(Y),I.d(Y,{json:()=>Qf});var L={};I.r(L),I.d(L,{json:()=>of});var x={};I.r(x),I.d(x,{json:()=>Ef});var b={};I.r(b),I.d(b,{json:()=>nf});var H={};I.r(H),I.d(H,{json:()=>sf});var q={};I.r(q),I.d(q,{json:()=>af});var T={};I.r(T),I.d(T,{json:()=>rf});var v={};I.r(v),I.d(v,{json:()=>hf});var V={};I.r(V),I.d(V,{OP_SCOPE_SUFFIX:()=>Ye,abs:()=>to,acos:()=>Eo,acosh:()=>no,add:()=>JQ,addN:()=>so,all:()=>ao,any:()=>ro,argMax:()=>ho,argMin:()=>co,asin:()=>lo,asinh:()=>Do,atan:()=>uo,atan2:()=>wo,atanh:()=>po,avgPool:()=>xo,avgPool3d:()=>bo,basicLSTMCell:()=>Vo,batchNorm:()=>Oo,batchNorm2d:()=>Zo,batchNorm3d:()=>Po,batchNorm4d:()=>Xo,batchToSpaceND:()=>Wo,bincount:()=>jo,booleanMaskAsync:()=>Ps,broadcastArgs:()=>zo,broadcastTo:()=>_o,buffer:()=>HB,cast:()=>qB,ceil:()=>$o,clipByValue:()=>AE,clone:()=>TB,complex:()=>xe,concat:()=>Ho,concat1d:()=>gE,concat2d:()=>IE,concat3d:()=>tE,concat4d:()=>CE,conv1d:()=>BE,conv2d:()=>eE,conv2dTranspose:()=>QE,conv3d:()=>oE,conv3dTranspose:()=>nE,cos:()=>sE,cosh:()=>aE,cosineWindow:()=>ga,cumprod:()=>rE,cumsum:()=>hE,denseBincount:()=>cE,depthToSpace:()=>lE,depthwiseConv2d:()=>DE,diag:()=>uE,dilation2d:()=>wE,div:()=>LQ,divNoNan:()=>yE,dot:()=>GE,dropout:()=>$s,einsum:()=>fE,elu:()=>NE,enclosingPowerOfTwo:()=>Aa,equal:()=>dE,erf:()=>FE,euclideanNorm:()=>qE,exp:()=>TE,expandDims:()=>vE,expm1:()=>VE,eye:()=>OE,fft:()=>ys,fill:()=>_Q,floor:()=>ZE,floorDiv:()=>YQ,fused:()=>h,gather:()=>PE,gatherND:()=>_s,greater:()=>XE,greaterEqual:()=>jE,ifft:()=>Gs,imag:()=>Ui,image:()=>Er,inTopKAsync:()=>Ia,irfft:()=>fs,isFinite:()=>zE,isInf:()=>_E,isNaN:()=>$E,leakyRelu:()=>An,less:()=>gn,lessEqual:()=>In,linalg:()=>nr,linspace:()=>tn,localResponseNormalization:()=>Cn,log:()=>en,log1p:()=>Bn,logSigmoid:()=>on,logSoftmax:()=>En,logSumExp:()=>nn,logicalAnd:()=>sn,logicalNot:()=>an,logicalOr:()=>rn,logicalXor:()=>hn,losses:()=>sr,lowerBound:()=>Dn,matMul:()=>Ei,max:()=>YE,maxPool:()=>un,maxPool3d:()=>wn,maxPoolWithArgmax:()=>dn,maximum:()=>Co,mean:()=>pn,meshgrid:()=>fn,min:()=>LE,minimum:()=>Nn,mirrorPad:()=>Fn,mod:()=>Rn,moments:()=>mn,movingAverage:()=>Xs,mul:()=>xQ,multiRNNCell:()=>kn,multinomial:()=>Sn,neg:()=>Ki,norm:()=>HE,notEqual:()=>Mn,oneHot:()=>ni,ones:()=>Gn,onesLike:()=>Un,op:()=>Le,outerProduct:()=>Kn,pad:()=>Jn,pad1d:()=>Yn,pad2d:()=>Ln,pad3d:()=>xn,pad4d:()=>bn,pool:()=>qn,pow:()=>Ao,prelu:()=>Tn,print:()=>vB,prod:()=>vn,raggedGather:()=>Vn,raggedTensorToTensor:()=>Wn,rand:()=>On,randomGamma:()=>zn,randomNormal:()=>_n,randomStandardNormal:()=>$n,randomUniform:()=>As,range:()=>gs,real:()=>Ji,reciprocal:()=>Is,relu:()=>ts,relu6:()=>Cs,reshape:()=>Lo,reverse:()=>es,reverse1d:()=>Bs,reverse2d:()=>is,reverse3d:()=>Qs,reverse4d:()=>os,rfft:()=>Fs,round:()=>Es,rsqrt:()=>ns,scalar:()=>XQ,scatterND:()=>js,searchSorted:()=>ln,selu:()=>ss,separableConv2d:()=>as,setdiff1dAsync:()=>rs,sigmoid:()=>qo,sign:()=>hs,signal:()=>or,sin:()=>cs,sinh:()=>ls,slice:()=>To,slice1d:()=>Ds,slice2d:()=>us,slice3d:()=>ws,slice4d:()=>ds,softmax:()=>ps,softplus:()=>Qn,spaceToBatchND:()=>Hn,sparse:()=>ar,sparseToDense:()=>zs,spectral:()=>Qr,split:()=>Ns,sqrt:()=>bQ,square:()=>HQ,squaredDifference:()=>Rs,squeeze:()=>ms,stack:()=>ks,step:()=>Ss,stridedSlice:()=>Ms,string:()=>rr,sub:()=>go,sum:()=>xE,tan:()=>Us,tanh:()=>vo,tensor:()=>He,tensor1d:()=>Ks,tensor2d:()=>Js,tensor3d:()=>qi,tensor4d:()=>Ys,tensor5d:()=>Ls,tensor6d:()=>xs,tile:()=>WE,topk:()=>bs,transpose:()=>Yi,truncatedNormal:()=>Hs,unique:()=>qs,unsortedSegmentSum:()=>Ts,unstack:()=>vs,upperBound:()=>Vs,variable:()=>Ws,where:()=>pE,whereAsync:()=>Zs,zeros:()=>yn,zerosLike:()=>qQ});var W={};I.r(W),I.d(W,{CSVDataset:()=>PN,Dataset:()=>YN,FileDataSource:()=>iF,TextLineDataset:()=>qN,URLDataSource:()=>QF,array:()=>xN,csv:()=>oF,func:()=>EF,generator:()=>nF,microphone:()=>aF,version_data:()=>rF,webcam:()=>sF,zip:()=>bN});var O={};I.r(O),I.d(O,{addImpl:()=>XF,bincountImpl:()=>qR,bincountReduceImpl:()=>TR,castImpl:()=>VF,ceilImpl:()=>WR,concatImpl:()=>zR,equalImpl:()=>Km,expImpl:()=>Wm,expm1Impl:()=>jm,floorImpl:()=>ak,gatherNdImpl:()=>dk,gatherV2Impl:()=>yk,greaterEqualImpl:()=>Rk,greaterImpl:()=>fk,lessEqualImpl:()=>qk,lessImpl:()=>xk,linSpaceImpl:()=>Vk,logImpl:()=>Ok,maxImpl:()=>iS,maximumImpl:()=>ES,minimumImpl:()=>wS,multiplyImpl:()=>Nm,negImpl:()=>kS,notEqualImpl:()=>xS,prodImpl:()=>zS,raggedGatherImpl:()=>IM,raggedTensorToTensorImpl:()=>QM,rangeImpl:()=>EM,rsqrtImpl:()=>pM,scatterImpl:()=>fM,sigmoidImpl:()=>JF,simpleAbsImpl:()=>CR,sliceImpl:()=>LR,sparseFillEmptyRowsImpl:()=>WM,sparseReshapeImpl:()=>ZM,sparseSegmentReductionImpl:()=>XM,sqrtImpl:()=>AU,stridedSliceImpl:()=>oU,stringNGramsImpl:()=>sU,stringSplitImpl:()=>hU,stringToHashBucketFastImpl:()=>lU,subImpl:()=>Ik,tileImpl:()=>pU,topKImpl:()=>NU,transposeImpl:()=>nR,uniqueImpl:()=>UU});class Z{constructor(A,g){this.backend=A,this.dataMover=g,this.data=new WeakMap,this.dataIdsCount=0}get(A){return this.data.has(A)||this.dataMover.moveData(this.backend,A),this.data.get(A)}set(A,g){this.dataIdsCount++,this.data.set(A,g)}has(A){return this.data.has(A)}delete(A){return this.dataIdsCount--,this.data.delete(A)}numDataIds(){return this.dataIdsCount}}class P{refCount(A){return X("refCount")}incRef(A){return X("incRef")}timerAvailable(){return!0}time(A){return X("time")}read(A){return X("read")}readSync(A){return X("readSync")}readToGPU(A,g){return X("readToGPU")}numDataIds(){return X("numDataIds")}disposeData(A,g){return X("disposeData")}write(A,g,I){return X("write")}move(A,g,I,t,C){return X("move")}memory(){return X("memory")}floatPrecision(){return X("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return X("dispose")}}function X(A){throw new Error(`'${A}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function j(A){let g=A.length,I=0;for(;g>0;)I=Math.random()*g|0,g--,AA(A,g,I)}function z(A,g){if(A.length!==g.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${A.length}Second array length was ${g.length}`);let I=A.length,t=0;for(;I>0;)t=Math.random()*I|0,I--,AA(A,I,t),AA(g,I,t)}function _(A,g,I){return Math.max(A,Math.min(g,I))}function $(A){return A%2==0?A:A+1}function AA(A,g,I){const t=A[g];A[g]=A[I],A[I]=t}function gA(A){let g=0;for(let I=0;I<A.length;I++)g+=A[I];return g}function IA(A,g){const I=Math.random();return g*I+(1-I)*A}function tA(A,g){let I=0;for(let t=0;t<A.length;t++){const C=Number(A[t])-Number(g[t]);I+=C*C}return I}function CA(A,g){if(!A)throw new Error("string"==typeof g?g:g())}function eA(A,g,I=""){CA(EA(A,g),(()=>I+` Shapes ${A} and ${g} must match`))}function BA(A){CA(null!=A,(()=>"The input to the tensor constructor must be a non-null value."))}function iA(A,g=[],I=!1){if(null==g&&(g=[]),Array.isArray(A)||fA(A)&&!I)for(let t=0;t<A.length;++t)iA(A[t],g,I);else g.push(A);return g}function QA(A){if(0===A.length)return 1;let g=A[0];for(let I=1;I<A.length;I++)g*=A[I];return g}function oA(A){return 0===A.length}function EA(A,g){if(A===g)return!0;if(null==A||null==g)return!1;if(A.length!==g.length)return!1;for(let I=0;I<A.length;I++)if(A[I]!==g[I])return!1;return!0}function nA(A){return A%1==0}function sA(A){if(null!=Math.tanh)return Math.tanh(A);if(A===1/0)return 1;if(A===-1/0)return-1;{const g=Math.exp(2*A);return(g-1)/(g+1)}}function aA(A){const g=Math.ceil(Math.sqrt(A));return[g,Math.ceil(A/g)]}function rA(A){const g=new Uint32Array(A);for(let I=0;I<A;++I)g[I]=I;return j(g),g}function hA(A,g){return g<=A.length?A:A+" ".repeat(g-A.length)}function cA(A,g=(A=>0),I,t=setTimeout){return new Promise(((C,e)=>{let B=0;const i=()=>{if(A())return void C();B++;const Q=g(B);null!=I&&B>=I?e():t(i,Q)};i()}))}function lA(A,g){let I=1,t=-1;for(let g=0;g<A.length;++g)if(A[g]>=0)I*=A[g];else if(-1===A[g]){if(-1!==t)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${t} and dim ${g}`);t=g}else if(A[g]<0)throw Error(`Shapes can not be < 0. Found ${A[g]} at dim ${g}`);if(-1===t){if(g>0&&g!==I)throw Error(`Size(${g}) must match the product of shape ${A}`);return A}if(0===I)throw Error(`Cannot infer the missing size in [${A}] when there are 0 elements`);if(g%I!=0)throw Error(`The implicit shape can't be a fractional number. Got ${g} / ${I}`);const C=A.slice();return C[t]=g/I,C}function DA(A,g){const I=g.length;return CA((A=null==A?g.map(((A,g)=>g)):[].concat(A)).every((A=>A>=-I&&A<I)),(()=>`All values in axis param must be in range [-${I}, ${I}) but got axis ${A}`)),CA(A.every((A=>nA(A))),(()=>`All values in axis param must be integers but got axis ${A}`)),A.map((A=>A<0?I+A:A))}function uA(A,g){const I=[],t=[],C=null!=g&&Array.isArray(g)&&0===g.length,e=null==g||C?null:DA(g,A).sort();let B=0;for(let g=0;g<A.length;++g){if(null!=e){if(e[B]===g&&1!==A[g])throw new Error(`Can't squeeze axis ${g} since its dim '${A[g]}' is not 1`);(null==e[B]||e[B]>g)&&1===A[g]&&(I.push(A[g]),t.push(g)),e[B]<=g&&B++}1!==A[g]&&(I.push(A[g]),t.push(g))}return{newShape:I,keptDims:t}}function wA(A,g){let I=null;if(null==A||"float32"===A)I=new Float32Array(g);else if("int32"===A)I=new Int32Array(g);else{if("bool"!==A)throw new Error(`Unknown data type ${A}`);I=new Uint8Array(g)}return I}function dA(A,g){let I=null;if(null==A||"float32"===A)I=new Float32Array(g);else if("int32"===A)I=new Int32Array(g);else if("bool"===A)I=new Uint8Array(g);else{if("string"!==A)throw new Error(`Unknown data type ${A}`);I=new Array(g)}return I}function pA(A,g){for(let I=0;I<A.length;I++){const t=A[I];if(isNaN(t)||!isFinite(t))throw Error(`A tensor of type ${g} being uploaded contains ${t}.`)}}function yA(A){return"bool"===A||"complex64"===A||"float32"===A||"int32"===A||"string"===A}function GA(A,g){return"complex64"!==g&&(("float32"!==g||"complex64"===A)&&(("int32"!==g||"float32"===A||"complex64"===A)&&("bool"!==g||"bool"!==A)))}function fA(A){return A instanceof Float32Array||A instanceof Int32Array||A instanceof Uint8Array||A instanceof Uint8ClampedArray}function NA(A){if("float32"===A||"int32"===A)return 4;if("complex64"===A)return 8;if("bool"===A)return 1;throw new Error(`Unknown dtype ${A}`)}function FA(A){if(null==A)return 0;let g=0;return A.forEach((A=>g+=A.length)),g}function RA(A){return"string"==typeof A||A instanceof String}function mA(A){return"boolean"==typeof A}function kA(A){return"number"==typeof A}function SA(A){return Array.isArray(A)?SA(A[0]):A instanceof Float32Array?"float32":A instanceof Int32Array||A instanceof Uint8Array||A instanceof Uint8ClampedArray?"int32":kA(A)?"float32":RA(A)?"string":mA(A)?"bool":"float32"}function MA(A){return!!(A&&A.constructor&&A.call&&A.apply)}function UA(A,g){for(let I=g;I<A;++I)if(A%I==0)return I;return A}function KA(A){const g=A.length;if(g<2)return[];const I=new Array(g-1);I[g-2]=A[g-1];for(let t=g-3;t>=0;--t)I[t]=I[t+1]*A[t+1];return I}function JA(A,g,I,t=!1){const C=new Array;if(1===g.length){const e=g[0]*(t?2:1);for(let g=0;g<e;g++)C[g]=I[A+g]}else{const e=g[0],B=g.slice(1),i=B.reduce(((A,g)=>A*g))*(t?2:1);for(let g=0;g<e;g++)C[g]=JA(A+g*i,B,I,t)}return C}function YA(A,g,I=!1){if(0===A.length)return g[0];const t=A.reduce(((A,g)=>A*g))*(I?2:1);if(0===t)return[];if(t!==g.length)throw new Error(`[${A}] does not match the input size ${g.length}${I?" for a complex tensor":""}.`);return JA(0,A,g,I)}function LA(A,g){const I=xA(A,g);for(let A=0;A<I.length;A++)I[A]=1;return I}function xA(A,g){if(null==g||"float32"===g||"complex64"===g)return new Float32Array(A);if("int32"===g)return new Int32Array(A);if("bool"===g)return new Uint8Array(A);throw new Error(`Unknown data type ${g}`)}function bA(A,g){const I=A.reduce(((A,g)=>A*g),1);if(null==g||"float32"===g)return YA(A,new Float32Array(I));if("int32"===g)return YA(A,new Int32Array(I));if("bool"===g)return YA(A,new Uint8Array(I));throw new Error(`Unknown data type ${g}`)}function HA(A){A.forEach((g=>{CA(Number.isInteger(g)&&g>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${A}].`))}))}function qA(A,g,I){if(0===g)return 0;if(1===g)return A[0];let t=A[A.length-1];for(let g=0;g<A.length-1;++g)t+=I[g]*A[g];return t}function TA(A,g,I){if(0===g)return[];if(1===g)return[A];const t=new Array(g);for(let g=0;g<t.length-1;++g)t[g]=Math.floor(A/I[g]),A-=t[g]*I[g];return t[t.length-1]=A,t}function vA(A){return A&&A.then&&"function"==typeof A.then}const VA="tfjsflags";class WA{constructor(A){this.global=A,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=OA,this.populateURLFlags()}setPlatform(A,g){null!=this.platform&&(ZA().getBool("IS_TEST")||ZA().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${A}.`)),this.platformName=A,this.platform=g}registerFlag(A,g,I){if(this.flagRegistry[A]={evaluationFn:g,setHook:I},null!=this.urlFlags[A]){const g=this.urlFlags[A];ZA().getBool("IS_TEST")||ZA().getBool("PROD")||console.warn(`Setting feature override from URL ${A}: ${g}.`),this.set(A,g)}}async getAsync(A){return A in this.flags||(this.flags[A]=await this.evaluateFlag(A)),this.flags[A]}get(A){if(A in this.flags)return this.flags[A];const g=this.evaluateFlag(A);if(vA(g))throw new Error(`Flag ${A} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[A]=g,this.flags[A]}getNumber(A){return this.get(A)}getBool(A){return this.get(A)}getFlags(){return this.flags}get features(){return this.flags}set(A,g){if(null==this.flagRegistry[A])throw new Error(`Cannot set flag ${A} as it has not been registered.`);this.flags[A]=g,null!=this.flagRegistry[A].setHook&&this.flagRegistry[A].setHook(g)}evaluateFlag(A){if(null==this.flagRegistry[A])throw new Error(`Cannot evaluate flag '${A}': no evaluation function found.`);return this.flagRegistry[A].evaluationFn()}setFlags(A){this.flags=Object.assign({},A)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const A=this.getQueryParams(this.global.location.search);if(VA in A){A[VA].split(",").forEach((A=>{const[g,I]=A.split(":");this.urlFlags[g]=function(A,g){if("true"===(g=g.toLowerCase())||"false"===g)return"true"===g;if(""+ +g===g)return+g;throw new Error(`Could not parse value flag value ${g} for flag ${A}.`)}(g,I)}))}}}function OA(A){const g={};return A.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((A,...I)=>(function(A,g,I){A[decodeURIComponent(g)]=decodeURIComponent(I||"")}(g,I[0],I[1]),I.join("=")))),g}function ZA(){return XA}let PA,XA=null;function jA(){if(null==PA){let A;if("undefined"!=typeof window)A=window;else if(void 0!==I.g)A=I.g;else if("undefined"!=typeof process)A=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");A=self}PA=A}return PA}function zA(A,g){const I=function(){const A=jA();return null==A._tfGlobals&&(A._tfGlobals=new Map),A._tfGlobals}();if(I.has(A))return I.get(A);{const t=g();return I.set(A,t),I.get(A)}}const _A="Abs",$A="Acos",Ag="Acosh",gg="Add",Ig="AddN",tg="All",Cg="Any",eg="ArgMax",Bg="ArgMin",ig="Asin",Qg="Asinh",og="Atan",Eg="Atanh",ng="Atan2",sg="AvgPool",ag="AvgPoolGrad",rg="AvgPool3D",hg="AvgPool3DGrad",cg="BatchMatMul",lg="BatchToSpaceND",Dg="Bincount",ug="BroadcastTo",wg="BroadcastArgs",dg="Cast",pg="Ceil",yg="ClipByValue",Gg="Complex",fg="ComplexAbs",Ng="Concat",Fg="Conv2D",Rg="Conv2DBackpropFilter",mg="Conv2DBackpropInput",kg="Conv3D",Sg="Conv3DBackpropFilterV2",Mg="Conv3DBackpropInputV2",Ug="Cos",Kg="Cosh",Jg="Cumprod",Yg="Cumsum",Lg="CropAndResize",xg="DenseBincount",bg="DepthToSpace",Hg="DepthwiseConv2dNative",qg="DepthwiseConv2dNativeBackpropFilter",Tg="DepthwiseConv2dNativeBackpropInput",vg="Diag",Vg="Dilation2D",Wg="Dilation2DBackpropInput",Og="Dilation2DBackpropFilter",Zg="RealDiv",Pg="Einsum",Xg="Elu",jg="EluGrad",zg="Erf",_g="Equal",$g="Exp",AI="ExpandDims",gI="Expm1",II="FFT",tI="Fill",CI="FlipLeftRight",eI="Floor",BI="FloorDiv",iI="FusedBatchNorm",QI="GatherV2",oI="GatherNd",EI="Greater",nI="GreaterEqual",sI="Identity",aI="IFFT",rI="Imag",hI="IsFinite",cI="IsInf",lI="IsNan",DI="LeakyRelu",uI="Less",wI="LessEqual",dI="LinSpace",pI="Log",yI="Log1p",GI="LogicalAnd",fI="LogicalNot",NI="LogicalOr",FI="LogicalXor",RI="LogSoftmax",mI="LowerBound",kI="LRN",SI="LRNGrad",MI="Max",UI="Maximum",KI="MaxPool",JI="MaxPoolGrad",YI="MaxPool3D",LI="MaxPool3DGrad",xI="MaxPoolWithArgmax",bI="Mean",HI="Min",qI="Minimum",TI="MirrorPad",vI="Mod",VI="Multinomial",WI="Multiply",OI="Neg",ZI="NotEqual",PI="NonMaxSuppressionV3",XI="NonMaxSuppressionV4",jI="NonMaxSuppressionV5",zI="OnesLike",_I="OneHot",$I="Pack",At="PadV2",gt="Pool",It="Pow",tt="Prelu",Ct="Prod",et="RaggedGather",Bt="RaggedTensorToTensor",it="Range",Qt="Real",ot="Reciprocal",Et="Relu",nt="Reshape",st="ResizeNearestNeighbor",at="ResizeNearestNeighborGrad",rt="ResizeBilinear",ht="ResizeBilinearGrad",ct="Relu6",lt="Reverse",Dt="Round",ut="Rsqrt",wt="ScatterNd",dt="SearchSorted",pt="Select",yt="Selu",Gt="Slice",ft="Sin",Nt="Sinh",Ft="Sign",Rt="Sigmoid",mt="Softplus",kt="Sqrt",St="Sum",Mt="SpaceToBatchND",Ut="SplitV",Kt="Softmax",Jt="SparseFillEmptyRows",Yt="SparseReshape",Lt="SparseSegmentMean",xt="SparseSegmentSum",bt="SparseToDense",Ht="SquaredDifference",qt="Square",Tt="StridedSlice",vt="StringNGrams",Vt="StringSplit",Wt="StringToHashBucketFast",Ot="Sub",Zt="Tan",Pt="Tanh",Xt="Tile",jt="TopK",zt="Transform",_t="Transpose",$t="Unique",AC="Unpack",gC="UnsortedSegmentSum",IC="UpperBound",tC="ZerosLike",CC="Step",eC="FromPixels",BC="RotateWithOffset",iC="_FusedMatMul",QC="FusedConv2D",oC="FusedDepthwiseConv2D";function EC(...A){ZA().getBool("IS_TEST")||ZA().getBool("PROD")||console.warn(...A)}function nC(...A){ZA().getBool("IS_TEST")||ZA().getBool("PROD")||console.log(...A)}const sC=zA("kernelRegistry",(()=>new Map)),aC=zA("gradRegistry",(()=>new Map));function rC(A,g){const I=pC(A,g);return sC.get(I)}function hC(A){return aC.get(A)}function cC(A){const g=sC.entries(),I=[];for(;;){const{done:t,value:C}=g.next();if(t)break;const[e,B]=C,[i]=e.split("_");i===A&&I.push(B)}return I}function lC(A){const{kernelName:g,backendName:I}=A,t=pC(g,I);sC.has(t)&&EC(`The kernel '${g}' for backend '${I}' is already registered`),sC.set(t,A)}function DC(A){const{kernelName:g}=A;aC.has(g)&&ZA().getBool("DEBUG")&&EC(`Overriding the gradient for '${g}'`),aC.set(g,A)}function uC(A,g){const I=pC(A,g);if(!sC.has(I))throw new Error(`The kernel '${A}' for backend '${g}' is not registered`);sC.delete(I)}function wC(A){if(!aC.has(A))throw new Error(`The gradient '${A}' for backend is not registered`);aC.delete(A)}function dC(A,g){cC(A).forEach((A=>{lC(Object.assign({},A,{backendName:g}))}))}function pC(A,g){return`${g}_${A}`}var yC=I(720);const GC=I.n(yC)()||yC;function fC(A){return GC.fromString(A,!0,16)}const NC=fC("c3a5c85c97cb3127"),FC=fC("b492b66fbe98f273"),RC=fC("9ae16a3b2f90404f");function mC(A){return A.xor(A.shru(47))}function kC(A,g,I){const t=A.slice(g,g+I);return GC.fromBytes(Array.from(t),!0,!0)}function SC(A,g){return kC(A,g,8)}function MC(A,g){return kC(A,g,4)}function UC(A,g){return 0===g?A:A.shru(g).or(A.shl(64-g))}function KC(A,g,I=fC("9ddfea08eb382d69")){let t=A.xor(g).mul(I);t=t.xor(t.shru(47));let C=g.xor(t).mul(I);return C=C.xor(C.shru(47)),C=C.mul(I),C}function JC(A,g,I,t){return function(A,g,I,t,C,e){C=C.add(A),e=UC(e.add(C).add(t),21);const B=C;return C=(C=C.add(g)).add(I),e=e.add(UC(C,44)),[C.add(t),e.add(B)]}(SC(A,g),SC(A,g+8),SC(A,g+16),SC(A,g+24),I,t)}function YC(A,g=A.length){const I=GC.fromNumber(81,!0);if(g<=32)return g<=16?function(A,g=A.length){if(g>=8){const I=RC.add(2*g),t=SC(A,0).add(RC),C=SC(A,g-8);return KC(UC(C,37).mul(I).add(t),UC(t,25).add(C).mul(I),I)}if(g>=4){const I=RC.add(2*g);return KC(MC(A,0).shl(3).add(g),MC(A,g-4),I)}if(g>0){const I=A[0]+(A[g>>1]<<8),t=g+(A[g-1]<<2);return mC(RC.mul(I).xor(NC.mul(t))).mul(RC)}return RC}(A,g):function(A,g=A.length){const I=RC.add(2*g),t=SC(A,0).mul(FC),C=SC(A,8),e=SC(A,g-8).mul(I),B=SC(A,g-16).mul(RC);return KC(UC(t.add(C),43).add(UC(e,30)).add(B),t.add(UC(C.add(RC),18)).add(e),I)}(A,g);if(g<=64)return function(A,g=A.length){const I=RC.add(2*g),t=SC(A,0).mul(RC),C=SC(A,8),e=SC(A,g-8).mul(I),B=SC(A,g-16).mul(RC),i=UC(t.add(C),43).add(UC(e,30)).add(B),Q=KC(i,t.add(UC(C.add(RC),18)).add(e),I),o=SC(A,16).mul(I),E=SC(A,24),n=i.add(SC(A,g-32)).mul(I),s=Q.add(SC(A,g-24)).mul(I);return KC(UC(o.add(E),43).add(UC(n,30)).add(s),o.add(UC(E.add(t),18)).add(n),I)}(A,g);let t=I,C=I.mul(FC).add(113),e=mC(C.mul(RC).add(113)).mul(RC),B=[GC.UZERO,GC.UZERO],i=[GC.UZERO,GC.UZERO];t=t.mul(RC).add(SC(A,0));let Q=0;const o=64*(g-1>>6),E=o+(g-1&63)-63;do{t=UC(t.add(C).add(B[0]).add(SC(A,Q+8)),37).mul(FC),C=UC(C.add(B[1]).add(SC(A,Q+48)),42).mul(FC),t=t.xor(i[1]),C=C.add(B[0]).add(SC(A,Q+40)),e=UC(e.add(i[0]),33).mul(FC),B=JC(A,Q,B[1].mul(FC),t.add(i[0])),i=JC(A,Q+32,e.add(i[1]),C.add(SC(A,Q+16))),[e,t]=[t,e],Q+=64}while(Q!==o);const n=FC.add(e.and(255).shl(1));return Q=E,i[0]=i[0].add(g-1&63),B[0]=B[0].add(i[0]),i[0]=i[0].add(B[0]),t=UC(t.add(C).add(B[0]).add(SC(A,Q+8)),37).mul(n),C=UC(C.add(B[1]).add(SC(A,Q+48)),42).mul(n),t=t.xor(i[1].mul(9)),C=C.add(B[0].mul(9).add(SC(A,Q+40))),e=UC(e.add(i[0]),33).mul(n),B=JC(A,Q,B[1].mul(n),t.add(i[0])),i=JC(A,Q+32,e.add(i[1]),C.add(SC(A,Q+16))),[e,t]=[t,e],KC(KC(B[0],i[0],n).add(mC(C).mul(NC)).add(e),KC(B[1],i[1],n).add(t),n)}function LC(A,g){return"string"===g?qC(A):xC([A],g)}function xC(A,g){if("string"===g)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(A)&&(A=iA(A)),ZA().getBool("DEBUG")&&pA(A,g),function(A,g){return A instanceof Float32Array&&"float32"===g||A instanceof Int32Array&&"int32"===g||A instanceof Uint8Array&&"bool"===g}(A,g))return A;if(null==g||"float32"===g||"complex64"===g)return new Float32Array(A);if("int32"===g)return new Int32Array(A);if("bool"===g){const g=new Uint8Array(A.length);for(let I=0;I<g.length;++I)0!==Math.round(A[I])&&(g[I]=1);return g}throw new Error(`Unknown data type ${g}`)}function bC(){return ZA().platform.now()}function HC(A,g){return ZA().platform.fetch(A,g)}function qC(A,g="utf-8"){return g=g||"utf-8",ZA().platform.encode(A,g)}function TC(A,g="utf-8"){return g=g||"utf-8",ZA().platform.decode(A,g)}class vC{constructor(A,g){this.backendTimer=A,this.logger=g,null==g&&(this.logger=new WC)}profileKernel(A,g,I){let t;const C=()=>{t=I()};let e;const B=bC();if(this.backendTimer.timerAvailable())e=this.backendTimer.time(C);else{C();for(const A of t)A.dataSync();e=Promise.resolve({kernelMs:bC()-B})}if(ZA().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let g=0;g<t.length;g++){const I=t[g];I.data().then((g=>{VC(g,I.dtype,A)}))}return{kernelName:A,outputs:t,inputs:g,timeMs:e.then((A=>A.kernelMs)),extraInfo:e.then((A=>null!=A.getExtraProfileInfo?A.getExtraProfileInfo():""))}}logKernelProfile(A){const{kernelName:g,outputs:I,timeMs:t,inputs:C,extraInfo:e}=A;I.forEach((A=>{Promise.all([A.data(),t,e]).then((I=>{this.logger.logKernelProfile(g,A,I[0],I[1],C,I[2])}))}))}}function VC(A,g,I){if("float32"!==g)return!1;for(let g=0;g<A.length;g++){const t=A[g];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${I}'`),!0}return!1}class WC{logKernelProfile(A,g,I,t,C,e){const B="number"==typeof t?hA(`${t}ms`,9):t.error,i=hA(A,25),Q=g.rank,o=g.size,E=hA(g.shape.toString(),14);let n="";for(const A in C){const I=C[A];if(null!=I){const t=I.shape||g.shape,C=t.length;n+=`${A}: ${C}D ${C>0?t:""} `}}console.log(`%c${i}\t%c${B}\t%c${Q}D ${E}\t%c${o}\t%c${n}\t%c${e}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const OC=20,ZC=3,PC=7;function XC(A,g,I,t){const C=KA(g),e=function(A,g,I,t){const C=QA(g),e=t[t.length-1],B=new Array(e).fill(0),i=g.length,Q="complex64"===I?$C(A):A;if(i>1)for(let A=0;A<C/e;A++){const g=A*e;for(let A=0;A<e;A++)B[A]=Math.max(B[A],jC(Q[g+A],0,I).length)}return B}(A,g,I,C),B=g.length,i=_C(A,g,I,C,e),Q=["Tensor"];return t&&(Q.push(`  dtype: ${I}`),Q.push(`  rank: ${B}`),Q.push(`  shape: [${g}]`),Q.push("  values:")),Q.push(i.map((A=>"    "+A)).join("\n")),Q.join("\n")}function jC(A,g,I){let t;return t=Array.isArray(A)?`${parseFloat(A[0].toFixed(PC))} + ${parseFloat(A[1].toFixed(PC))}j`:RA(A)?`'${A}'`:"bool"===I?zC(A):parseFloat(A.toFixed(PC)).toString(),hA(t,g)}function zC(A){return 0===A?"false":"true"}function _C(A,g,I,t,C,e=!0){const B="complex64"===I?2:1,i=g[0],Q=g.length;if(0===Q){if("complex64"===I){return[jC($C(A)[0],0,I)]}return"bool"===I?[zC(A[0])]:[A[0].toString()]}if(1===Q){if(i>OC){const g=ZC*B;let t=Array.from(A.slice(0,g)),e=Array.from(A.slice((i-ZC)*B,i*B));return"complex64"===I&&(t=$C(t),e=$C(e)),["["+t.map(((A,g)=>jC(A,C[g],I))).join(", ")+", ..., "+e.map(((A,g)=>jC(A,C[i-ZC+g],I))).join(", ")+"]"]}return["["+("complex64"===I?$C(A):Array.from(A)).map(((A,g)=>jC(A,C[g],I))).join(", ")+"]"]}const o=g.slice(1),E=t.slice(1),n=t[0]*B,s=[];if(i>OC){for(let g=0;g<ZC;g++){const t=g*n,e=t+n;s.push(..._C(A.slice(t,e),o,I,E,C,!1))}s.push("...");for(let g=i-ZC;g<i;g++){const t=g*n,e=t+n;s.push(..._C(A.slice(t,e),o,I,E,C,g===i-1))}}else for(let g=0;g<i;g++){const t=g*n,e=t+n;s.push(..._C(A.slice(t,e),o,I,E,C,g===i-1))}const a=2===Q?",":"";s[0]="["+s[0]+a;for(let A=1;A<s.length-1;A++)s[A]=" "+s[A]+a;let r=",\n";for(let A=2;A<Q;A++)r+="\n";return s[s.length-1]=" "+s[s.length-1]+"]"+(e?"":r),s}function $C(A){const g=[];for(let I=0;I<A.length;I+=2)g.push([A[I],A[I+1]]);return g}class Ae{constructor(A,g,I){if(this.dtype=g,this.shape=A.slice(),this.size=QA(A),null!=I){const A=I.length;CA(A===this.size,(()=>`Length of values '${A}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===g)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=I||dA(g,this.size),this.strides=KA(A)}set(A,...g){0===g.length&&(g=[0]),CA(g.length===this.rank,(()=>`The number of provided coordinates (${g.length}) must match the rank (${this.rank})`));const I=this.locToIndex(g);this.values[I]=A}get(...A){0===A.length&&(A=[0]);let g=0;for(const I of A){if(I<0||I>=this.shape[g]){const g=`Requested out of range element at ${A}.   Buffer shape=${this.shape}`;throw new Error(g)}g++}let I=A[A.length-1];for(let g=0;g<A.length-1;++g)I+=this.strides[g]*A[g];return this.values[I]}locToIndex(A){if(0===this.rank)return 0;if(1===this.rank)return A[0];let g=A[A.length-1];for(let I=0;I<A.length-1;++I)g+=this.strides[I]*A[I];return g}indexToLoc(A){if(0===this.rank)return[];if(1===this.rank)return[A];const g=new Array(this.shape.length);for(let I=0;I<g.length-1;++I)g[I]=Math.floor(A/this.strides[I]),A-=g[I]*this.strides[I];return g[g.length-1]=A,g}get rank(){return this.shape.length}toTensor(){return ge().makeTensor(this.values,this.shape,this.dtype)}}let ge=null,Ie=null,te=null;class Ce{constructor(A,g,I,t){this.kept=!1,this.isDisposedInternal=!1,this.shape=A.slice(),this.dtype=g||"float32",this.size=QA(A),this.strides=KA(A),this.dataId=I,this.id=t,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const A=await this.data();return Ie.buffer(this.shape,this.dtype,A)}bufferSync(){return Ie.buffer(this.shape,this.dtype,this.dataSync())}async array(){const A=await this.data();return YA(this.shape,A,"complex64"===this.dtype)}arraySync(){return YA(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const A=ge().read(this.dataId);if("string"===this.dtype){const g=await A;try{return g.map((A=>TC(A)))}catch(A){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return A}dataToGPU(A){return this.throwIfDisposed(),ge().readToGPU(this.dataId,A)}dataSync(){this.throwIfDisposed();const A=ge().readSync(this.dataId);if("string"===this.dtype)try{return A.map((A=>TC(A)))}catch(A){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return A}async bytes(){this.throwIfDisposed();const A=await ge().read(this.dataId);return"string"===this.dtype?A:new Uint8Array(A.buffer)}dispose(){this.isDisposed||(ge().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(A=!1){return Ie.print(this,A)}clone(){return this.throwIfDisposed(),Ie.clone(this)}toString(A=!1){return XC(this.dataSync(),this.shape,this.dtype,A)}cast(A){return this.throwIfDisposed(),Ie.cast(this,A)}variable(A=!0,g,I){return this.throwIfDisposed(),ge().makeVariable(this,A,g,I)}}function ee(){return zA("Tensor",(()=>Ce))}Object.defineProperty(Ce,Symbol.hasInstance,{value:A=>!!A&&null!=A.data&&null!=A.dataSync&&null!=A.throwIfDisposed}),ee();class Be extends Ce{constructor(A,g,I,t){super(A.shape,A.dtype,A.dataId,t),this.trainable=g,this.name=I}assign(A){if(A.dtype!==this.dtype)throw new Error(`dtype of the new value (${A.dtype}) and previous value (${this.dtype}) must match`);if(!EA(A.shape,this.shape))throw new Error(`shape of the new value (${A.shape}) and previous value (${this.shape}) must match`);ge().disposeTensor(this),this.dataId=A.dataId,ge().incRef(this,null)}dispose(){ge().disposeVariable(this),this.isDisposedInternal=!0}}var ie,Qe,oe,Ee,ne;Object.defineProperty(Be,Symbol.hasInstance,{value:A=>A instanceof Ce&&null!=A.assign&&A.assign instanceof Function}),function(A){A.R0="R0",A.R1="R1",A.R2="R2",A.R3="R3",A.R4="R4",A.R5="R5",A.R6="R6"}(ie||(ie={})),function(A){A.float32="float32",A.int32="int32",A.bool="int32",A.complex64="complex64"}(Qe||(Qe={})),function(A){A.float32="float32",A.int32="int32",A.bool="bool",A.complex64="complex64"}(oe||(oe={})),function(A){A.float32="float32",A.int32="float32",A.bool="float32",A.complex64="complex64"}(Ee||(Ee={})),function(A){A.float32="complex64",A.int32="complex64",A.bool="complex64",A.complex64="complex64"}(ne||(ne={}));const se={float32:Ee,int32:Qe,bool:oe,complex64:ne};function ae(A,g){if("string"===A||"string"===g){if("string"===A&&"string"===g)return"string";throw new Error(`Can not upcast ${A} with ${g}`)}return se[A][g]}function re(A){return ae(A,"int32")}function he(A,g){if(A.dtype===g.dtype)return[A,g];const I=ae(A.dtype,g.dtype);return[A.cast(I),g.cast(I)]}function ce(A,g){CA(A.dtype===g.dtype,(()=>`The dtypes of the first(${A.dtype}) and second(${g.dtype}) input must match`))}function le(A,g){return g.some((g=>g.id===A.id))}function De(A){const g=[];return ue(A,g,new Set),g}function ue(A,g,I){if(null==A)return;if(A instanceof Ce)return void g.push(A);if(t=A,!Array.isArray(t)&&"object"!=typeof t)return;var t;const C=A;for(const A in C){const t=C[A];I.has(t)||(I.add(t),ue(t,g,I))}}function we(A){return null!=A.kernelName}class de{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((A=>A.name))))}}}dispose(){for(const A in this.registeredVariables)this.registeredVariables[A].dispose()}}class pe{constructor(A){this.ENV=A,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new de}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const A=this.getSortedBackends();for(let g=0;g<A.length;g++){const I=A[g];if(await this.initializeBackend(I).success)return void await this.setBackend(I)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:A,asyncInit:g}=this.initializeBackendsAndReturnBest();if(g)throw new Error(`The highest priority backend '${A}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(A)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(A){if(!(A in this.registry)){if(!(A in this.registryFactory))return null;{const{asyncInit:g}=this.initializeBackend(A);if(g)return null}}return this.registry[A]}findBackendFactory(A){return A in this.registryFactory?this.registryFactory[A].factory:null}registerBackend(A,g,I=1){return A in this.registryFactory?(EC(`${A} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[A]={factory:g,priority:I},!0)}async setBackend(A){if(null==this.registryFactory[A])throw new Error(`Backend name '${A}' not found in registry`);if(this.backendName=A,null==this.registry[A]){this.backendInstance=null;const{success:g,asyncInit:I}=this.initializeBackend(A);if(!(I?await g:g))return!1}return this.backendInstance=this.registry[A],this.setupRegisteredKernels(),this.profiler=new vC(this.backendInstance),!0}setupRegisteredKernels(){cC(this.backendName).forEach((A=>{null!=A.setupFunc&&A.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(A){cC(A).forEach((g=>{null!=g.disposeFunc&&g.disposeFunc(this.registry[A])}))}initializeBackend(A){const g=this.registryFactory[A];if(null==g)throw new Error(`Cannot initialize backend ${A}, no registration found.`);try{const I=g.factory();if(!I||I instanceof P||"function"!=typeof I.then)return this.registry[A]=I,{success:!0,asyncInit:!1};{const g=++this.pendingBackendInitId,t=I.then((I=>!(g<this.pendingBackendInitId)&&(this.registry[A]=I,this.pendingBackendInit=null,!0))).catch((I=>(g<this.pendingBackendInitId||(this.pendingBackendInit=null,EC(`Initialization of backend ${A} failed`),EC(I.stack||I.message)),!1)));return this.pendingBackendInit=t,{success:t,asyncInit:!0}}}catch(g){return EC(`Initialization of backend ${A} failed`),EC(g.stack||g.message),{success:!1,asyncInit:!1}}}removeBackend(A){if(!(A in this.registryFactory))throw new Error(`${A} backend not found in registry`);this.backendName===A&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,A in this.registry&&(this.disposeRegisteredKernels(A),this.registry[A].dispose(),delete this.registry[A]),delete this.registryFactory[A],this.backendName===A&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((A,g)=>this.registryFactory[g].priority-this.registryFactory[A].priority))}initializeBackendsAndReturnBest(){const A=this.getSortedBackends();for(let g=0;g<A.length;g++){const I=A[g],{success:t,asyncInit:C}=this.initializeBackend(I);if(C||t)return{name:I,asyncInit:C}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(A,g){const I=this.state.tensorInfo.get(g),t=I.backend,C=this.readSync(g),e=t.refCount(g);t.disposeData(g,!0),I.backend=A,A.move(g,C,I.shape,I.dtype,e),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(A,g){let I,t=null;if(null==g){if("function"!=typeof A)throw new Error("Please provide a function to tidy()");g=A}else{if("string"!=typeof A&&!(A instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof g)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");t=A}return this.scopedRun((()=>this.startScope(t)),(()=>this.endScope(I)),(()=>(I=g(),I instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),I)))}scopedRun(A,g,I){A();try{const A=I();return g(),A}catch(A){throw g(),A}}nextTensorId(){return pe.nextTensorId++}nextVariableId(){return pe.nextVariableId++}clone(A){const g=Ge.runKernel(sI,{x:A}),I={x:A};return this.addTapeNode(this.state.activeScope.name,I,[g],(A=>({x:()=>{const g={x:A},I={dtype:"float32"};return Ge.runKernel(dg,g,I)}})),[],{}),g}runKernel(A,g,I){null==this.backendName&&this.backend;if(!(null!=rC(A,this.backendName)))throw new Error(`Kernel '${A}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:A,inputs:g,attrs:I})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(A,g,I){const t=this.backend.numDataIds();let C=0;I.forEach((A=>{C+="complex64"===A.dtype?3:1}));const e=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],B=t-g-C-e;if(B>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${B} data ids) after running '${A}'`)}runKernelFunc(A){let g,I=[];const t=this.isTapeOn(),C=this.state.numBytes,e=this.state.numTensors;let B,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const Q=we(A)?A.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(we(A)){const{kernelName:g,inputs:C,attrs:e}=A;null==this.backendName&&this.backend;const Q=rC(g,this.backendName);CA(null!=Q,(()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`)),B=()=>{const A=this.backend.numDataIds();i=Q.kernelFunc({inputs:C,attrs:e,backend:this.backend});const B=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,A,B);const o=B.map((A=>null!=A.rank?A:this.makeTensorFromTensorInfo(A)));if(t){const A=this.getTensorsForGradient(g,C,o);I=this.saveTensorsForBackwardMode(A)}return o}}else{const{forwardFunc:g}=A,C=A=>{t&&(I=A.map((A=>this.keep(this.clone(A)))))};B=()=>{const A=this.backend.numDataIds();i=this.tidy((()=>g(this.backend,C)));const I=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Q,A,I),I}}const{inputs:o,attrs:E}=A,n=we(A)?null:A.backwardsFunc;let s;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(s=this.profiler.profileKernel(Q,o,(()=>B())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(s),g=s.outputs):g=B()})),t&&this.addTapeNode(Q,o,g,n,I,E),this.state.profiling&&this.state.activeProfile.kernels.push({name:Q,bytesAdded:this.state.numBytes-C,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-e,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(o).map((A=>null!=o[A]?o[A].shape:null)),outputShapes:g.map((A=>A.shape)),kernelTimeMs:s.timeMs,extraInfo:s.extraInfo}),Array.isArray(i)?g:g[0]}saveTensorsForBackwardMode(A){const g=A.map((A=>this.keep(this.clone(A))));return g}getTensorsForGradient(A,g,I){const t=hC(A);if(null!=t){const A=t.inputsToSave||[],C=t.outputsToSave||[];let e;t.saveAllInputs?(CA(Array.isArray(g),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(g).map((A=>g[A]))):e=A.map((A=>g[A]));const B=I.filter(((A,g)=>C[g]));return e.concat(B)}return[]}makeTensor(A,g,I,t){if(null==A)throw new Error("Values passed to engine.makeTensor() are null");I=I||"float32",t=t||this.backend;let C=A;"string"===I&&RA(A[0])&&(C=A.map((A=>qC(A))));const e=t.write(C,g,I),B=new Ce(g,I,e,this.nextTensorId());if(this.trackTensor(B,t),"string"===I){const A=this.state.tensorInfo.get(e),g=FA(C);this.state.numBytes+=g-A.bytes,A.bytes=g}return B}makeTensorFromDataId(A,g,I,t){const C={dataId:A,shape:g,dtype:I=I||"float32"};return this.makeTensorFromTensorInfo(C,t)}makeTensorFromTensorInfo(A,g){const{dataId:I,shape:t,dtype:C}=A,e=new Ce(t,C,I,this.nextTensorId());return this.trackTensor(e,g),e}makeVariable(A,g=!0,I,t){I=I||this.nextVariableId().toString(),null!=t&&t!==A.dtype&&(A=A.cast(t));const C=new Be(A,g,I,this.nextTensorId());if(null!=this.state.registeredVariables[C.name])throw new Error(`Variable with name ${C.name} was already registered`);return this.state.registeredVariables[C.name]=C,this.incRef(C,this.backend),C}trackTensor(A,g){this.state.numTensors++,"string"===A.dtype&&this.state.numStringTensors++;let I=0;"complex64"!==A.dtype&&"string"!==A.dtype&&(I=A.size*NA(A.dtype)),this.state.numBytes+=I,this.state.tensorInfo.has(A.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(A.dataId,{backend:g||this.backend,dtype:A.dtype,shape:A.shape,bytes:I})),A instanceof Be||this.track(A)}incRef(A,g){this.trackTensor(A,g),this.backend.incRef(A.dataId)}removeDataId(A,g){this.state.tensorInfo.has(A)&&this.state.tensorInfo.get(A).backend===g&&(this.state.tensorInfo.delete(A),this.state.numDataBuffers--)}disposeTensor(A){if(!this.state.tensorInfo.has(A.dataId))return;const g=this.state.tensorInfo.get(A.dataId);if(this.state.numTensors--,"string"===A.dtype&&(this.state.numStringTensors--,this.state.numBytes-=g.bytes),"complex64"!==A.dtype&&"string"!==A.dtype){const g=A.size*NA(A.dtype);this.state.numBytes-=g}g.backend.disposeData(A.dataId)&&this.removeDataId(A.dataId,g.backend)}disposeVariables(){for(const A in this.state.registeredVariables){const g=this.state.registeredVariables[A];this.disposeVariable(g)}}disposeVariable(A){this.disposeTensor(A),null!=this.state.registeredVariables[A.name]&&delete this.state.registeredVariables[A.name]}memory(){const A=this.backend.memory();return A.numTensors=this.state.numTensors,A.numDataBuffers=this.state.numDataBuffers,A.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(A.unreliable=!0,null==A.reasons&&(A.reasons=[]),A.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),A}async profile(A){this.state.profiling=!0;const g=this.state.numBytes,I=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await A(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((A=>A.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-g,this.state.activeProfile.newTensors=this.state.numTensors-I;for(const A of this.state.activeProfile.kernels)A.kernelTimeMs=await A.kernelTimeMs,A.extraInfo=await A.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(A,g,I,t,C,e){const B={id:this.state.nextTapeNodeId++,kernelName:A,inputs:g,outputs:I,saved:C},i=hC(A);null!=i&&(t=i.gradFunc),null!=t&&(B.gradient=A=>(A=A.map(((A,g)=>{if(null==A){const A=I[g],t=xA(A.size,A.dtype);return this.makeTensor(t,A.shape,A.dtype)}return A})),t(A.length>1?A:A[0],C,e))),this.state.activeTape.push(B)}keep(A){return A.kept=!0,A}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(A){const g={track:[],name:"unnamed scope",id:this.state.nextScopeId++};A&&(g.name=A),this.state.scopeStack.push(g),this.state.activeScope=g}endScope(A){const g=De(A),I=new Set(g.map((A=>A.id)));for(let A=0;A<this.state.activeScope.track.length;A++){const g=this.state.activeScope.track[A];g.kept||I.has(g.id)||g.dispose()}const t=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],g.forEach((A=>{A.kept||A.scopeId!==t.id||this.track(A)}))}gradients(A,g,I,t=!1){if(CA(g.length>0,(()=>"gradients() received an empty list of xs.")),null!=I&&"float32"!==I.dtype)throw new Error(`dy must have 'float32' dtype, but has '${I.dtype}'`);const C=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",A)));CA(C instanceof Ce,(()=>"The result y returned by f() must be a tensor."));const e=function(A,g,I){const t={},C={};for(let A=0;A<g.length;A++)t[g[A].id]=!0;for(let I=0;I<A.length;I++){const e=A[I],B=e.inputs;for(const A in B){const I=B[A];let i=!1;for(let A=0;A<g.length;A++)if(t[I.id]){e.outputs.forEach((A=>t[A.id]=!0)),i=!0,C[e.id]=!0;break}if(i)break}}const e={};e[I.id]=!0;const B={};for(let g=A.length-1;g>=0;g--){const I=A[g],t=I.inputs;for(let A=0;A<I.outputs.length;A++)if(e[I.outputs[A].id]){for(const A in t)e[t[A].id]=!0,B[I.id]=!0;break}}const i=[];for(let g=0;g<A.length;g++){const I=A[g];if(C[I.id]&&B[I.id]){const A={};for(const g in I.inputs){const C=I.inputs[g];t[C.id]&&(A[g]=C)}const g=Object.assign({},I);g.inputs=A,g.outputs=I.outputs,i.push(g)}}return i}(this.state.activeTape,g,C);if(!t&&0===e.length&&g.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const A={};A[C.id]=null==I?function(A){const g=LA(QA(A),"float32");return Ge.makeTensor(g,A,"float32")}(C.shape):I,function(A,g,I,t){for(let C=g.length-1;C>=0;C--){const e=g[C],B=[];if(e.outputs.forEach((g=>{const I=A[g.id];null!=I?B.push(I):B.push(null)})),null==e.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${e.kernelName}.`);const i=e.gradient(B);for(const g in e.inputs){if(!(g in i))throw new Error(`Cannot backprop through input ${g}. Available gradients found: ${Object.keys(i)}.`);const C=I((()=>i[g]()));if("float32"!==C.dtype)throw new Error(`Error in gradient for op ${e.kernelName}. The gradient of input ${g} must have 'float32' dtype, but has '${C.dtype}'`);const B=e.inputs[g];if(!EA(C.shape,B.shape))throw new Error(`Error in gradient for op ${e.kernelName}. The gradient of input '${g}' has shape '${C.shape}', which does not match the shape of the input '${B.shape}'`);if(null==A[B.id])A[B.id]=C;else{const g=A[B.id];A[B.id]=t(g,C),g.dispose()}}}}(A,e,(A=>this.tidy(A)),fe);const t=g.map((g=>A[g.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((A=>{for(const g of A.saved)g.dispose()})),this.state.activeTape=null),{value:C,grads:t}}))}customGrad(A){return CA(MA(A),(()=>"The f passed in customGrad(f) must be a function.")),(...g)=>{let I;CA(g.every((A=>A instanceof Ce)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const t={};g.forEach(((A,g)=>{t[g]=A}));return this.runKernelFunc({forwardFunc:(t,C)=>(I=A(...g,C),CA(I.value instanceof Ce,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),CA(MA(I.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),I.value),backwardsFunc:(A,t)=>{const C=I.gradFunc(A,t),e=Array.isArray(C)?C:[C];CA(e.length===g.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),CA(e.every((A=>A instanceof Ce)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const B={};return e.forEach(((A,g)=>{B[g]=()=>A})),B},inputs:t})}}readSync(A){return this.state.tensorInfo.get(A).backend.readSync(A)}read(A){return this.state.tensorInfo.get(A).backend.read(A)}readToGPU(A,g){return this.state.tensorInfo.get(A).backend.readToGPU(A,g)}async time(A){const g=bC(),I=await this.backend.time(A);return I.wallMs=bC()-g,I}track(A){return null!=this.state.activeScope&&(A.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(A)),A}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new de;for(const A in this.registry)this.disposeRegisteredKernels(A),this.registry[A].dispose(),delete this.registry[A];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function ye(){const A=jA();if(null==A._tfengine){const g=new WA(A);A._tfengine=new pe(g)}var g;return g=A._tfengine.ENV,XA=g,ge=()=>A._tfengine,A._tfengine}pe.nextTensorId=0,pe.nextVariableId=0;const Ge=ye();function fe(A,g){const I={a:A,b:g};return Ge.runKernel(gg,I)}let Ne;function Fe(A){Ne=A}function Re(A){if(void 0!==Ne)return Ne;if(A||"undefined"!=typeof navigator&&null!=navigator){if(A||(A=navigator),"ReactNative"===A.product)return!0;const g=A.userAgent||A.vendor||("undefined"!=typeof window?window.opera:"");if(!g){const g=A;return g.userAgentData&&g.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(g)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(g.substr(0,4))}return!1}function me(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ke=ZA();function Se(A,g){let I=A;if(fA(A))return"string"===g?[]:[A.length];if(!Array.isArray(A))return[];const t=[];for(;Array.isArray(I)||fA(I)&&"string"!==g;)t.push(I.length),I=I[0];return Array.isArray(A)&&ZA().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Me(A,t,[]),t}function Me(A,g,I){if(I=I||[],!Array.isArray(A)&&!fA(A))return void CA(0===g.length,(()=>`Element arr[${I.join("][")}] is a primitive, but should be an array/TypedArray of ${g[0]} elements`));CA(g.length>0,(()=>`Element arr[${I.join("][")}] should be a primitive, but is an array of ${A.length} elements`)),CA(A.length===g[0],(()=>`Element arr[${I.join("][")}] should have ${g[0]} elements, but has ${A.length} elements`));const t=g.slice(1);for(let g=0;g<A.length;++g)Me(A[g],t,I.concat(g))}function Ue(A,g,I,t){if("string_or_numeric"!==A){if(null==A)throw new Error("Expected dtype cannot be null.");if("numeric"!==A&&A!==g||"numeric"===A&&"string"===g)throw new Error(`Argument '${I}' passed to '${t}' must be ${A} tensor, but got ${g} tensor`)}}function Ke(A,g,I,t="numeric"){if(A instanceof Ce)return Ue(t,A.dtype,g,I),A;let C=SA(A);if("string"!==C&&["bool","int32","float32"].indexOf(t)>=0&&(C=t),Ue(t,C,g,I),null==A||!fA(A)&&!Array.isArray(A)&&"number"!=typeof A&&"boolean"!=typeof A&&"string"!=typeof A){const t=null==A?"null":A.constructor.name;throw new Error(`Argument '${g}' passed to '${I}' must be a Tensor or TensorLike, but got '${t}'`)}const e=Se(A,C);fA(A)||Array.isArray(A)||(A=[A]);const B="string"!==C?xC(A,C):iA(A,[],!0);return Ge.makeTensor(B,e,C)}function Je(A,g,I,t="numeric"){if(!Array.isArray(A))throw new Error(`Argument ${g} passed to ${I} must be a \`Tensor[]\` or \`TensorLike[]\``);return A.map(((A,C)=>Ke(A,`${g}[${C}]`,I,t)))}ke.registerFlag("DEBUG",(()=>!1),(A=>{A&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ke.registerFlag("IS_BROWSER",(()=>me())),ke.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),ke.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ke.registerFlag("PROD",(()=>!1)),ke.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ke.getBool("DEBUG"))),ke.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ke.registerFlag("IS_TEST",(()=>!1)),ke.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),ke.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),ke.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),ke.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),ke.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const Ye="__op";function Le(A){const g=Object.keys(A);if(1!==g.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${g.length} keys.`);let I=g[0];const t=A[I];I.endsWith("_")&&(I=I.substring(0,I.length-1)),I+=Ye;const C=(...A)=>{Ge.startScope(I);try{const g=t(...A);return vA(g)&&console.error("Cannot return a Promise inside of tidy."),Ge.endScope(g),g}catch(A){throw Ge.endScope(null),A}};return Object.defineProperty(C,"name",{value:I,configurable:!0}),C}const xe=Le({complex_:function(A,g){const I=Ke(A,"real","complex"),t=Ke(g,"imag","complex");eA(I.shape,t.shape,`real and imag shapes, ${I.shape} and ${t.shape}, must match in call to tf.complex().`);const C={real:I,imag:t};return Ge.runKernel(Gg,C)}});function be(A,g,I,t){if(null==t&&(t=SA(A)),"complex64"===t)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!fA(A)&&!Array.isArray(A)&&"number"!=typeof A&&"boolean"!=typeof A&&"string"!=typeof A)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=g){HA(g);const A=QA(g),t=QA(I);CA(A===t,(()=>`Based on the provided shape, [${g}], the tensor should have ${A} values but has ${t}`));for(let A=0;A<I.length;++A){const t=I[A],C=A!==I.length-1||t!==QA(g.slice(A));CA(I[A]===g[A]||!C,(()=>`Error creating a new Tensor. Inferred shape (${I}) does not match the provided shape (${g}). `))}}return fA(A)||Array.isArray(A)||(A=[A]),g=g||I,A="string"!==t?xC(A,t):iA(A,[],!0),Ge.makeTensor(A,g,t)}function He(A,g,I){return be(A,g,Se(A,I),I)}const qe={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Te=4;async function ve(A,g){const I=[],t=[],C=Array.isArray(A)?A.map((A=>A.name)):Object.keys(A);for(let e=0;e<C.length;++e){const B=C[e],i=Array.isArray(A)?A[e].tensor:A[B];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error(`Unsupported dtype in weight '${B}': ${i.dtype}`);const Q={name:B,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const A=new Promise((async A=>{const g=await i.bytes(),I=g.reduce(((A,g)=>A+g.length),0)+Te*g.length,t=new Uint8Array(I);let C=0;for(let A=0;A<g.length;A++){const I=g[A],e=new Uint8Array(new Uint32Array([I.length]).buffer);t.set(e,C),C+=Te,t.set(I,C),C+=I.length}A(t)}));t.push(A)}else t.push(i.data());null!=g&&(Q.group=g),I.push(Q)}return{data:We(await Promise.all(t)),specs:I}}function Ve(A,g){const I={};let t,C=0;for(const e of g){const g=e.name,B=e.dtype,i=e.shape,Q=QA(i);let o;if("quantization"in e){const I=e.quantization;if("uint8"===I.dtype||"uint16"===I.dtype){if(!("min"in I)||!("scale"in I))throw new Error(`Weight ${e.name} with quantization ${I.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==I.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${I.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==B)throw new Error(`Weight ${e.name} is quantized with ${I.dtype} which only supports weights of type float32 not ${B}.`)}const i=qe[I.dtype],E=A.slice(C,C+Q*i),n="uint8"===I.dtype?new Uint8Array(E):new Uint16Array(E);if("float32"===B)if("uint8"===I.dtype||"uint16"===I.dtype){o=new Float32Array(n.length);for(let A=0;A<n.length;A++){const g=n[A];o[A]=g*I.scale+I.min}}else{if("float16"!==I.dtype)throw new Error(`Unsupported quantization type ${I.dtype} for weight type float32.`);void 0===t&&(t=gB()),o=t(n)}else{if("int32"!==B)throw new Error(`Unsupported dtype in weight '${g}': ${B}`);if("uint8"!==I.dtype&&"uint16"!==I.dtype)throw new Error(`Unsupported quantization type ${I.dtype} for weight type int32.`);o=new Int32Array(n.length);for(let A=0;A<n.length;A++){const g=n[A];o[A]=Math.round(g*I.scale+I.min)}}C+=Q*i}else if("string"===B){const g=QA(e.shape);o=[];for(let I=0;I<g;I++){const g=new Uint32Array(A.slice(C,C+Te))[0];C+=Te;const I=new Uint8Array(A.slice(C,C+g));o.push(I),C+=g}}else{const t=qe[B],e=A.slice(C,C+Q*t);if("float32"===B)o=new Float32Array(e);else if("int32"===B)o=new Int32Array(e);else if("bool"===B)o=new Uint8Array(e);else{if("complex64"!==B)throw new Error(`Unsupported dtype in weight '${g}': ${B}`);{o=new Float32Array(e);const A=new Float32Array(o.length/2),t=new Float32Array(o.length/2);for(let g=0;g<A.length;g++)A[g]=o[2*g],t[g]=o[2*g+1];const C=He(A,i,"float32"),B=He(t,i,"float32");I[g]=xe(C,B),C.dispose(),B.dispose()}}C+=Q*t}"complex64"!==B&&(I[g]=He(o,i,B))}return I}function We(A){if(null===A)throw new Error(`Invalid input value: ${JSON.stringify(A)}`);let g=0;const I=[];A.forEach((A=>{if(g+=A.byteLength,I.push(A.byteLength===A.buffer.byteLength?A:new A.constructor(A)),!(A instanceof Float32Array||A instanceof Int32Array||A instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${A.constructor.name}`)}));const t=new Uint8Array(g);let C=0;return I.forEach((A=>{t.set(new Uint8Array(A.buffer),C),C+=A.byteLength})),t.buffer}const Oe="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Ze(A){return Oe?Buffer.byteLength(A):new Blob([A]).size}function Pe(A){if(1===A.length)return A[0];let g=0;A.forEach((A=>{g+=A.byteLength}));const I=new Uint8Array(g);let t=0;return A.forEach((A=>{I.set(new Uint8Array(A),t),t+=A.byteLength})),I.buffer}function Xe(A){for(A=A.trim();A.endsWith("/");)A=A.slice(0,A.length-1);const g=A.split("/");return g[g.length-1]}function je(A,g){const I={modelTopology:A.modelTopology,format:A.format,generatedBy:A.generatedBy,convertedBy:A.convertedBy,weightsManifest:g};return null!=A.signature&&(I.signature=A.signature),null!=A.userDefinedMetadata&&(I.userDefinedMetadata=A.userDefinedMetadata),null!=A.modelInitializer&&(I.modelInitializer=A.modelInitializer),null!=A.trainingConfig&&(I.trainingConfig=A.trainingConfig),I}function ze(A,g,I){const t={modelTopology:A.modelTopology,format:A.format,generatedBy:A.generatedBy,convertedBy:A.convertedBy};if(null!=A.trainingConfig&&(t.trainingConfig=A.trainingConfig),null!=A.weightsManifest){if(!g)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!I)throw new Error("modelJSON has weightsManifest but weightData is null");t.weightSpecs=g,t.weightData=I}return null!=A.signature&&(t.signature=A.signature),null!=A.userDefinedMetadata&&(t.userDefinedMetadata=A.userDefinedMetadata),null!=A.modelInitializer&&(t.modelInitializer=A.modelInitializer),t}async function _e(A,g){let I,t;return null!=A.weightsManifest&&([I,t]=await g(A.weightsManifest)),ze(A,I,t)}function $e(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==A.modelTopology?0:Ze(JSON.stringify(A.modelTopology)),weightSpecsBytes:null==A.weightSpecs?0:Ze(JSON.stringify(A.weightSpecs)),weightDataBytes:null==A.weightData?0:A.weightData.byteLength}}function AB(A){const g=[];for(const I of A)g.push(...I.weights);return g}function gB(){const A=function(){const A=A=>{let g=A<<13,I=0;for(;0==(8388608&g);)I-=8388608,g<<=1;return g&=-8388609,I+=947912704,g|I},g=new Uint32Array(2048);g[0]=0;for(let I=1;I<1024;I++)g[I]=A(I);for(let A=1024;A<2048;A++)g[A]=939524096+(A-1024<<13);return g}(),g=function(){const A=new Uint32Array(64);A[0]=0,A[31]=1199570944,A[32]=2147483648,A[63]=3347054592;for(let g=1;g<31;g++)A[g]=g<<23;for(let g=33;g<63;g++)A[g]=2147483648+(g-32<<23);return A}(),I=function(){const A=new Uint32Array(64);for(let g=0;g<64;g++)A[g]=1024;return A[0]=A[32]=0,A}();return t=>{const C=new ArrayBuffer(4*t.length),e=new Uint32Array(C);for(let C=0;C<t.length;C++){const B=t[C],i=A[I[B>>10]+(1023&B)]+g[B>>10];e[C]=i}return new Float32Array(C)}}class IB{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==IB.instance&&(IB.instance=new IB),IB.instance}static registerSaveRouter(A){IB.getInstance().saveRouters.push(A)}static registerLoadRouter(A){IB.getInstance().loadRouters.push(A)}static getSaveHandlers(A){return IB.getHandlers(A,"save")}static getLoadHandlers(A,g){return IB.getHandlers(A,"load",g)}static getHandlers(A,g,I){const t=[];return("load"===g?IB.getInstance().loadRouters:IB.getInstance().saveRouters).forEach((g=>{const C=g(A,I);null!==C&&t.push(C)})),t}}const tB=A=>IB.registerSaveRouter(A),CB=A=>IB.registerLoadRouter(A),eB=A=>IB.getSaveHandlers(A),BB=(A,g)=>IB.getLoadHandlers(A,g),iB="tensorflowjs",QB="models_store",oB="model_info_store";function EB(){if(!ZA().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const A="undefined"==typeof window?self:window,g=A.indexedDB||A.mozIndexedDB||A.webkitIndexedDB||A.msIndexedDB||A.shimIndexedDB;if(null==g)throw new Error("The current browser does not appear to support IndexedDB.");return g}function nB(A){const g=A.result;g.createObjectStore(QB,{keyPath:"modelPath"}),g.createObjectStore(oB,{keyPath:"modelPath"})}class sB{constructor(A){if(this.indexedDB=EB(),null==A||!A)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=A}async save(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,A)}async load(){return this.databaseAction(this.modelPath)}databaseAction(A,g){return new Promise(((A,I)=>{const t=this.indexedDB.open(iB,1);t.onupgradeneeded=()=>nB(t),t.onsuccess=()=>{const C=t.result;if(null==g){const g=C.transaction(QB,"readonly"),t=g.objectStore(QB).get(this.modelPath);t.onsuccess=()=>{if(null==t.result)return C.close(),I(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));A(t.result.modelArtifacts)},t.onerror=A=>(C.close(),I(t.error)),g.oncomplete=()=>C.close()}else{const t=$e(g),e=C.transaction(oB,"readwrite");let B=e.objectStore(oB);const i=B.put({modelPath:this.modelPath,modelArtifactsInfo:t});let Q;i.onsuccess=()=>{Q=C.transaction(QB,"readwrite");const i=Q.objectStore(QB).put({modelPath:this.modelPath,modelArtifacts:g,modelArtifactsInfo:t});i.onsuccess=()=>A({modelArtifactsInfo:t}),i.onerror=A=>{B=e.objectStore(oB);const g=B.delete(this.modelPath);g.onsuccess=()=>(C.close(),I(i.error)),g.onerror=A=>(C.close(),I(i.error))}},i.onerror=A=>(C.close(),I(i.error)),e.oncomplete=()=>{null==Q?C.close():Q.oncomplete=()=>C.close()}}},t.onerror=A=>I(t.error)}))}}sB.URL_SCHEME="indexeddb://";const aB=A=>{return ZA().getBool("IS_BROWSER")&&!Array.isArray(A)&&A.startsWith(sB.URL_SCHEME)?(g=A.slice(sB.URL_SCHEME.length),new sB(g)):null;var g};IB.registerSaveRouter(aB),IB.registerLoadRouter(aB);class rB{constructor(){this.indexedDB=EB()}async listModels(){return new Promise(((A,g)=>{const I=this.indexedDB.open(iB,1);I.onupgradeneeded=()=>nB(I),I.onsuccess=()=>{const t=I.result,C=t.transaction(oB,"readonly"),e=C.objectStore(oB).getAll();e.onsuccess=()=>{const g={};for(const A of e.result)g[A.modelPath]=A.modelArtifactsInfo;A(g)},e.onerror=A=>(t.close(),g(e.error)),C.oncomplete=()=>t.close()},I.onerror=A=>g(I.error)}))}async removeModel(A){var g;return A=(g=A).startsWith(sB.URL_SCHEME)?g.slice(sB.URL_SCHEME.length):g,new Promise(((g,I)=>{const t=this.indexedDB.open(iB,1);t.onupgradeneeded=()=>nB(t),t.onsuccess=()=>{const C=t.result,e=C.transaction(oB,"readwrite"),B=e.objectStore(oB),i=B.get(A);let Q;i.onsuccess=()=>{if(null==i.result)return C.close(),I(new Error(`Cannot find model with path '${A}' in IndexedDB.`));{const t=B.delete(A),e=()=>{Q=C.transaction(QB,"readwrite");const t=Q.objectStore(QB).delete(A);t.onsuccess=()=>g(i.result.modelArtifactsInfo),t.onerror=A=>I(i.error)};t.onsuccess=e,t.onerror=A=>(e(),C.close(),I(i.error))}},i.onerror=A=>(C.close(),I(i.error)),e.oncomplete=()=>{null==Q?C.close():Q.oncomplete=()=>C.close()}},t.onerror=A=>I(t.error)}))}}const hB="/",cB="tensorflowjs_models",lB="info",DB="model_topology",uB="weight_specs",wB="weight_data",dB="model_metadata";function pB(A){return{info:[cB,A,lB].join(hB),topology:[cB,A,DB].join(hB),weightSpecs:[cB,A,uB].join(hB),weightData:[cB,A,wB].join(hB),modelMetadata:[cB,A,dB].join(hB)}}function yB(A){for(const g of Object.values(A))window.localStorage.removeItem(g)}function GB(A){const g=A.split(hB);if(g.length<3)throw new Error(`Invalid key format: ${A}`);return g.slice(1,g.length-1).join(hB)}class fB{constructor(A){if(!ZA().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==A||!A)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=A,this.keys=pB(this.modelPath)}async save(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const g=JSON.stringify(A.modelTopology),I=JSON.stringify(A.weightSpecs),t=$e(A);try{this.LS.setItem(this.keys.info,JSON.stringify(t)),this.LS.setItem(this.keys.topology,g),this.LS.setItem(this.keys.weightSpecs,I),this.LS.setItem(this.keys.weightData,function(A){if(Oe)return Buffer.from(A).toString("base64");const g=new Uint8Array(A);let I="";for(let A=0,t=g.length;A<t;A++)I+=String.fromCharCode(g[A]);return btoa(I)}(A.weightData));const C={format:A.format,generatedBy:A.generatedBy,convertedBy:A.convertedBy,signature:null!=A.signature?A.signature:void 0,userDefinedMetadata:null!=A.userDefinedMetadata?A.userDefinedMetadata:void 0,modelInitializer:null!=A.modelInitializer?A.modelInitializer:void 0,trainingConfig:null!=A.trainingConfig?A.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(C)),{modelArtifactsInfo:t}}catch(A){throw yB(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${t.modelTopologyBytes}, weightSpecsBytes=${t.weightSpecsBytes}, weightDataBytes=${t.weightDataBytes}.`)}}}async load(){const A=JSON.parse(this.LS.getItem(this.keys.info));if(null==A)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==A.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const g={},I=JSON.parse(this.LS.getItem(this.keys.topology));if(null==I)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);g.modelTopology=I;const t=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==t)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);g.weightSpecs=t;const C=this.LS.getItem(this.keys.modelMetadata);if(null!=C){const A=JSON.parse(C);g.format=A.format,g.generatedBy=A.generatedBy,g.convertedBy=A.convertedBy,null!=A.signature&&(g.signature=A.signature),null!=A.userDefinedMetadata&&(g.userDefinedMetadata=A.userDefinedMetadata),null!=A.modelInitializer&&(g.modelInitializer=A.modelInitializer),null!=A.trainingConfig&&(g.trainingConfig=A.trainingConfig)}const e=this.LS.getItem(this.keys.weightData);if(null==e)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return g.weightData=function(A){if(Oe){const g=Buffer.from(A,"base64");return g.buffer.slice(g.byteOffset,g.byteOffset+g.byteLength)}const g=atob(A),I=new Uint8Array(g.length);for(let A=0;A<g.length;++A)I.set([g.charCodeAt(A)],A);return I.buffer}(e),g}}fB.URL_SCHEME="localstorage://";const NB=A=>{return ZA().getBool("IS_BROWSER")&&!Array.isArray(A)&&A.startsWith(fB.URL_SCHEME)?(g=A.slice(fB.URL_SCHEME.length),new fB(g)):null;var g};IB.registerSaveRouter(NB),IB.registerLoadRouter(NB);class FB{constructor(){CA(ZA().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),CA("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const A={},g=cB+hB,I=hB+lB;for(let t=0;t<this.LS.length;++t){const C=this.LS.key(t);if(C.startsWith(g)&&C.endsWith(I)){A[GB(C)]=JSON.parse(this.LS.getItem(C))}}return A}async removeModel(A){var g;const I=pB(A=(g=A).startsWith(fB.URL_SCHEME)?g.slice(fB.URL_SCHEME.length):g);if(null==this.LS.getItem(I.info))throw new Error(`Cannot find model at path '${A}'`);const t=JSON.parse(this.LS.getItem(I.info));return yB(I),t}}const RB="://";class mB{constructor(){this.managers={}}static getInstance(){return null==mB.instance&&(mB.instance=new mB),mB.instance}static registerManager(A,g){CA(null!=A,(()=>"scheme must not be undefined or null.")),A.endsWith(RB)&&(A=A.slice(0,A.indexOf(RB))),CA(A.length>0,(()=>"scheme must not be an empty string."));const I=mB.getInstance();CA(null==I.managers[A],(()=>`A model store manager is already registered for scheme '${A}'.`)),I.managers[A]=g}static getManager(A){const g=mB.getInstance().managers[A];if(null==g)throw new Error(`Cannot find model manager for scheme '${A}'`);return g}static getSchemes(){return Object.keys(mB.getInstance().managers)}}function kB(A){if(-1===A.indexOf(RB))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${mB.getSchemes().join(",")}`);return{scheme:A.split(RB)[0],path:A.split(RB)[1]}}async function SB(A,g,I=!1){CA(A!==g,(()=>`Old path and new path are the same: '${A}'`));const t=IB.getLoadHandlers(A);CA(t.length>0,(()=>`Copying failed because no load handler is found for source URL ${A}.`)),CA(t.length<2,(()=>`Copying failed because more than one (${t.length}) load handlers for source URL ${A}.`));const C=t[0],e=IB.getSaveHandlers(g);CA(e.length>0,(()=>`Copying failed because no save handler is found for destination URL ${g}.`)),CA(e.length<2,(()=>`Copying failed because more than one (${t.length}) save handlers for destination URL ${g}.`));const B=e[0],i=kB(A).scheme,Q=kB(A).path,o=i===kB(A).scheme,E=await C.load();I&&o&&await mB.getManager(i).removeModel(Q);const n=await B.save(E);return I&&!o&&await mB.getManager(i).removeModel(Q),n.modelArtifactsInfo}async function MB(){const A=mB.getSchemes(),g={};for(const I of A){const A=await mB.getManager(I).listModels();for(const t in A){g[I+RB+t]=A[t]}}return g}async function UB(A){const g=kB(A);return mB.getManager(g.scheme).removeModel(g.path)}async function KB(A,g){return SB(A,g,!1)}async function JB(A,g){return SB(A,g,!0)}class YB{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(A,g){return fetch(A,g)}now(){return performance.now()}encode(A,g){if("utf-8"!==g&&"utf8"!==g)throw new Error(`Browser's encoder only supports utf-8, but got ${g}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(A)}decode(A,g){return new TextDecoder(g).decode(A)}setTimeoutCustom(A,g){window&&ZA().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(A),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),g),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(A=>{if(A.source===window&&A.data.name===this.messageName){A.stopPropagation();(0,this.functionRefs[A.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(A,g)}}if(ZA().get("IS_BROWSER")){ZA().setPlatform("browser",new YB);try{mB.registerManager(fB.URL_SCHEME,new FB)}catch(A){}try{mB.registerManager(sB.URL_SCHEME,new rB)}catch(A){}}const LB=()=>I(410);let xB;class bB{constructor(){this.util=I(628),this.textEncoder=new this.util.TextEncoder}fetch(A,g){return null!=ZA().global.fetch?ZA().global.fetch(A,g):(null==xB&&(xB=LB()),xB(A,g))}now(){const A=process.hrtime();return 1e3*A[0]+A[1]/1e6}encode(A,g){if("utf-8"!==g&&"utf8"!==g)throw new Error(`Node built-in encoder only supports utf-8, but got ${g}`);return this.textEncoder.encode(A)}decode(A,g){return 0===A.length?"":new this.util.TextDecoder(g).decode(A)}}function HB(A,g="float32",I){return g=g||"float32",HA(A),new Ae(A,g,I)}ZA().get("IS_NODE")&&!ZA().get("IS_BROWSER")&&ZA().setPlatform("node",new bB);const qB=Le({cast_:function(A,g){const I=Ke(A,"x","cast");if(!yA(g))throw new Error(`Failed to cast to unknown dtype ${g}`);if("string"===g&&"string"!==I.dtype||"string"!==g&&"string"===I.dtype)throw new Error("Only strings can be casted to strings");const t={x:I},C={dtype:g};return Ge.runKernel(dg,t,C)}});const TB=Le({clone_:function(A){const g={x:Ke(A,"x","clone","string_or_numeric")};return Ge.runKernel(sI,g)}});function vB(A,g=!1){console.log(A.toString(g))}ye();Ie={buffer:HB,cast:qB,clone:TB,print:vB};function VB(A){return new Promise((A=>setTimeout(A))).then(A)}class WB{constructor(A){if(!ZA().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");A.startsWith(WB.URL_SCHEME)&&(A=A.slice(WB.URL_SCHEME.length)),null!=A&&0!==A.length||(A="model"),this.modelJsonFileName=A+".json",this.weightDataFileName=A+".weights.bin"}async save(A){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const g=window.URL.createObjectURL(new Blob([A.weightData],{type:"application/octet-stream"}));if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const I=je(A,[{paths:["./"+this.weightDataFileName],weights:A.weightSpecs}]),t=window.URL.createObjectURL(new Blob([JSON.stringify(I)],{type:"application/json"})),C=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(C.download=this.modelJsonFileName,C.href=t,await VB((()=>C.dispatchEvent(new MouseEvent("click")))),null!=A.weightData){const A=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;A.download=this.weightDataFileName,A.href=g,await VB((()=>A.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:$e(A)}}}}WB.URL_SCHEME="downloads://";class OB{constructor(A){if(null==A||A.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${A}`);this.jsonFile=A[0],this.weightsFiles=A.slice(1)}async load(){return new Promise(((A,g)=>{const I=new FileReader;I.onload=I=>{const t=JSON.parse(I.target.result),C=t.modelTopology;if(null==C)return void g(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==t.weightsManifest)return void g(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void A({modelTopology:C});const e=_e(t,(A=>this.loadWeights(A)));A(e)},I.onerror=A=>g(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),I.readAsText(this.jsonFile)}))}loadWeights(A){const g=[],I=[];for(const t of A)g.push(...t.weights),I.push(...t.paths);const t=this.checkManifestAndWeightFiles(A),C=I.map((A=>this.loadWeightsFile(A,t[A])));return Promise.all(C).then((A=>[g,Pe(A)]))}loadWeightsFile(A,g){return new Promise(((I,t)=>{const C=new FileReader;C.onload=A=>{const g=A.target.result;I(g)},C.onerror=g=>t(`Failed to weights data from file of path '${A}'.`),C.readAsArrayBuffer(g)}))}checkManifestAndWeightFiles(A){const g=[],I=this.weightsFiles.map((A=>Xe(A.name))),t={};for(const C of A)C.paths.forEach((A=>{const C=Xe(A);if(-1!==g.indexOf(C))throw new Error(`Duplicate file basename found in weights manifest: '${C}'`);if(g.push(C),-1===I.indexOf(C))throw new Error(`Weight file with basename '${C}' is not provided.`);t[A]=this.weightsFiles[I.indexOf(C)]}));if(g.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${g.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return t}}function ZB(A){return new OB(A)}function PB(A,g,I,t){!function(A){CA(null!=A&&Array.isArray(A)&&A.length>0,(()=>"promises must be a none empty array"))}(A),function(A,g){CA(A>=0&&A<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${A}`)),CA(g>=0&&g<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${g}`)),CA(g>=A,(()=>`startFraction must be no more than endFraction, but got startFraction ${A} and endFraction ${g}`))}(I=null==I?0:I,t=null==t?1:t);let C=0;return Promise.all(A.map((e=>(e.then((e=>{const B=I+ ++C/A.length*(t-I);return g(B),e})),e))))}async function XB(A,g){null==g&&(g={});const I=null==g.fetchFunc?ZA().platform.fetch:g.fetchFunc,t=A.map((A=>I(A,g.requestInit,{isBinary:!0}))),C=(null==g.onProgress?await Promise.all(t):await PB(t,g.onProgress,0,.5)).map((A=>A.arrayBuffer()));return null==g.onProgress?await Promise.all(C):await PB(C,g.onProgress,.5,1)}async function jB(A,g="",I,t){return zB((A=>XB(A,{requestInit:t})))(A,g,I)}function zB(A){return async(g,I="",t)=>{const C=g.map((()=>!1)),e={},B=null!=t?t.map((()=>!1)):[],i=[];if(g.forEach(((A,g)=>{let I=0;A.weights.forEach((A=>{const Q="quantization"in A?A.quantization.dtype:A.dtype,o=qe[Q]*QA(A.shape),E=()=>{C[g]=!0,null==e[g]&&(e[g]=[]),e[g].push({manifestEntry:A,groupOffset:I,sizeBytes:o})};null!=t?t.forEach(((g,I)=>{g===A.name&&(E(),B[I]=!0)})):E(),i.push(A.name),I+=o}))})),!B.every((A=>A))){const A=t.filter(((A,g)=>!B[g]));throw new Error(`Could not find weights in manifest with names: ${A.join(", ")}. \nManifest JSON has weights with names: ${i.join(", ")}.`)}const Q=C.reduce(((A,g,I)=>(g&&A.push(I),A)),[]),o=[];Q.forEach((A=>{g[A].paths.forEach((A=>{const g=I+(I.endsWith("/")?"":"/")+A;o.push(g)}))}));const E=await A(o),n={};let s=0;return Q.forEach((A=>{const I=g[A].paths.length;let t=0;for(let A=0;A<I;A++)t+=E[s+A].byteLength;const C=new ArrayBuffer(t),B=new Uint8Array(C);let i=0;for(let A=0;A<I;A++){const g=new Uint8Array(E[s+A]);B.set(g,i),i+=g.byteLength}e[A].forEach((A=>{const g=Ve(C.slice(A.groupOffset,A.groupOffset+A.sizeBytes),[A.manifestEntry]);for(const A in g)n[A]=g[A]})),s+=I})),n}}IB.registerSaveRouter((A=>ZA().getBool("IS_BROWSER")&&!Array.isArray(A)&&A.startsWith(WB.URL_SCHEME)?function(A="model"){return new WB(A)}(A.slice(WB.URL_SCHEME.length)):null));class _B{constructor(A,g){if(this.DEFAULT_METHOD="POST",null==g&&(g={}),this.weightPathPrefix=g.weightPathPrefix,this.onProgress=g.onProgress,this.weightUrlConverter=g.weightUrlConverter,null!=g.fetchFunc?(CA("function"==typeof g.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=g.fetchFunc):this.fetch=ZA().platform.fetch,CA(null!=A&&A.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(A)&&CA(2===A.length,(()=>`URL paths for http must have a length of 2, (actual length is ${A.length}).`)),this.path=A,null!=g.requestInit&&null!=g.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=g.requestInit||{}}async save(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const g=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);g.body=new FormData;const I=je(A,[{paths:["./model.weights.bin"],weights:A.weightSpecs}]);g.body.append("model.json",new Blob([JSON.stringify(I)],{type:"application/json"}),"model.json"),null!=A.weightData&&g.body.append("model.weights.bin",new Blob([A.weightData],{type:"application/octet-stream"}),"model.weights.bin");const t=await this.fetch(this.path,g);if(t.ok)return{modelArtifactsInfo:$e(A),responses:[t]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${t.status}.`)}async load(){const A=await this.fetch(this.path,this.requestInit);if(!A.ok)throw new Error(`Request to ${this.path} failed with status code ${A.status}. Please verify this URL points to the model JSON of the model to load.`);let g;try{g=await A.json()}catch(A){let g=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?g+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":g+=" Please make sure the server is serving valid JSON for this request.",new Error(g)}const I=g.modelTopology,t=g.weightsManifest;if(null==I&&null==t)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return _e(g,(A=>this.loadWeights(A)))}async loadWeights(A){const g=Array.isArray(this.path)?this.path[1]:this.path,[I,t]=function(A){const g=A.lastIndexOf("/"),I=A.lastIndexOf("?"),t=A.substring(0,g),C=I>g?A.substring(I):"";return[t+"/",C]}(g),C=this.weightPathPrefix||I,e=AB(A),B=[],i=[];for(const g of A)for(const A of g.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(A)):B.push(C+A+t);this.weightUrlConverter&&B.push(...await Promise.all(i));return[e,Pe(await XB(B,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function $B(A){return null!=A.match(_B.URL_SCHEME_REGEX)}_B.URL_SCHEME_REGEX=/^https?:\/\//;const Ai=(A,g)=>{if("undefined"==typeof fetch&&(null==g||null==g.fetchFunc))return null;{let I=!0;if(I=Array.isArray(A)?A.every((A=>$B(A))):$B(A),I)return gi(A,g)}return null};function gi(A,g){return new _B(A,g)}function Ii(A,g){return gi(A,g)}IB.registerSaveRouter(Ai),IB.registerLoadRouter(Ai);class ti{constructor(A){this.modelArtifacts=A}load(){return this.modelArtifacts}}class Ci{constructor(A){this.saveHandler=A}save(A){return this.saveHandler(A)}}class ei{constructor(A){A.load&&(this.load=()=>Promise.resolve(A.load())),A.save&&(this.save=g=>Promise.resolve(A.save(g)))}}function Bi(A,g,I,t){return new ei(ii(...arguments))}function ii(A,g,I,t){if(1===arguments.length){return null!=A.modelTopology||null!=A.weightSpecs?new ti(A):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ti({modelTopology:A}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ti({modelTopology:A,weightSpecs:g,weightData:I,trainingConfig:t})}function Qi(A){return new Ci(A)}function oi(A){return new Ci(A)}const Ei=Le({matMul_:function(A,g,I=!1,t=!1){let C=Ke(A,"a","matMul"),e=Ke(g,"b","matMul");[C,e]=he(C,e);const B={a:C,b:e},i={transposeA:I,transposeB:t};return Ge.runKernel(cg,B,i)}});const ni=Le({oneHot_:function(A,g,I=1,t=0,C="int32"){if(g<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${g}`);const e={indices:Ke(A,"indices","oneHot","int32")},B={dtype:C,depth:g,onValue:I,offValue:t};return Ge.runKernel(_I,e,B)}});function si(){ZA().set("PROD",!0)}function ai(){ZA().set("DEBUG",!0)}function ri(){ZA().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function hi(A){ZA().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(A+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function ci(){Ge.disposeVariables()}function li(){return Ge}function Di(){return Ge.memory()}function ui(A){return Ge.profile(A)}function wi(A,g){return Ge.tidy(A,g)}function di(A){De(A).forEach((A=>A.dispose()))}function pi(A){return Ge.keep(A)}function yi(A){return Ge.time(A)}function Gi(A){return Ge.setBackend(A)}function fi(){return Ge.ready()}function Ni(){return Ge.backendName}function Fi(A){Ge.removeBackend(A)}function Ri(A){return Ge.findBackend(A)}function mi(A){return Ge.findBackendFactory(A)}function ki(A,g,I=1){return Ge.registerBackend(A,g,I)}function Si(){return Ge.backend}function Mi(A,g){ZA().setPlatform(A,g)}te=hi;const Ui=Le({imag_:function(A){const g={input:Ke(A,"input","imag")};return Ge.runKernel(rI,g)}});const Ki=Le({neg_:function(A){const g={x:Ke(A,"x","neg")};return Ge.runKernel(OI,g)}});const Ji=Le({real_:function(A){const g={input:Ke(A,"input","real")};return Ge.runKernel(Qt,g)}});const Yi=Le({transpose_:function(A,g,I){const t=Ke(A,"x","transpose");if(null==g&&(g=t.shape.map(((A,g)=>g)).reverse()),CA(t.rank===g.length,(()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${g}.`)),g.forEach((A=>{CA(A>=0&&A<t.rank,(()=>"All entries in 'perm' must be between 0 and "+(t.rank-1)+` but got ${g}`))})),t.rank<=1)return t.clone();const C={x:t},e={perm:g};return"complex64"===t.dtype?wi((()=>{let A=Ji(t),g=Ui(t);return A=Ge.runKernel(_t,{x:A},e),g=Ge.runKernel(_t,{x:g},e),I&&(g=Ki(g)),xe(A,g)})):Ge.runKernel(_t,C,e)}});const Li=Le({confusionMatrix_:function(A,g,I){const t=Ke(A,"labels","confusionMatrix"),C=Ke(g,"predictions","confusionMatrix");CA(null==I||I>0&&Number.isInteger(I),(()=>`If provided, numClasses must be a positive integer, but got ${I}`)),CA(1===t.rank,(()=>`Expected the rank of labels to be 1, but got ${t.rank}`)),CA(1===C.rank,(()=>`Expected the rank of predictions to be 1, but got ${C.rank}`)),CA(t.shape[0]===C.shape[0],(()=>`Mismatch in the number of examples: ${t.shape[0]} vs. ${C.shape[0]}. Labels and predictions should have the same number of elements.`)),CA(I>0&&Number.isInteger(I),(()=>`numClasses is required to be a positive integer, but got ${I}`));const e=ni(qB(t,"int32"),I),B=ni(qB(C,"int32"),I),i=Yi(e),Q=Ei(i,B);return qB(Q,"int32")}});function xi(A,g){const I=A.length,t=[];for(let C=0;C<I;C++){const e=I-1-C,B=A[e]||1;(g[g.length-1-C]||1)>1&&1===B&&t.unshift(e)}return t}function bi(A,g){const I=[];for(let t=0;t<g.length;t++){const C=A[A.length-t-1],e=g.length-t-1,B=g[e];(null==C||1===C&&B>1)&&I.unshift(e)}return I}function Hi(A,g){const I=[],t=Math.max(A.length,g.length);for(let C=0;C<t;C++){let t=A[A.length-C-1];null==t&&(t=1);let e=g[g.length-C-1];if(null==e&&(e=1),1===t)I.unshift(e);else if(1===e)I.unshift(t);else{if(t!==e){throw Error(`Operands could not be broadcast together with shapes ${A} and ${g}.`)}I.unshift(t)}}return I}function qi(A,g,I){if(BA(A),null!=g&&3!==g.length)throw new Error("tensor3d() requires shape to have three numbers");const t=Se(A,I);if(3!==t.length&&1!==t.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===t.length&&null==g)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return be(A,g,t,I)}let Ti;function vi(A,g=3){if(g>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==A)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let I=!1,t=!1,C=!1,e=!1,B=!1,i=!1;if(A.data instanceof Uint8Array)I=!0;else if("undefined"!=typeof ImageData&&A instanceof ImageData)t=!0;else if("undefined"!=typeof HTMLVideoElement&&A instanceof HTMLVideoElement)C=!0;else if("undefined"!=typeof HTMLImageElement&&A instanceof HTMLImageElement)e=!0;else if(null!=A.getContext)B=!0;else{if(!("undefined"!=typeof ImageBitmap&&A instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${A.constructor.name}`);i=!0}if(null!=rC(eC,Ge.backendName)){const I={pixels:A},t={numChannels:g};return Ge.runKernel(eC,I,t)}const[Q,o]=C?[A.videoWidth,A.videoHeight]:[A.width,A.height];let E,n;if(B)E=A.getContext("2d").getImageData(0,0,Q,o).data;else if(t||I)E=A.data;else if(e||C||i){if(null==Ti)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ti=new OffscreenCanvas(1,1).getContext("2d")}else Ti=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ti.canvas.width=Q,Ti.canvas.height=o,Ti.drawImage(A,0,0,Q,o),E=Ti.getImageData(0,0,Q,o).data}if(4===g)n=new Int32Array(E);else{const A=Q*o;n=new Int32Array(A*g);for(let I=0;I<A;I++)for(let A=0;A<g;++A)n[I*g+A]=E[4*I+A]}return qi(n,[o,Q,g],"int32")}function Vi(A){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(A instanceof ImageBitmap)&&function(A){return null!=A&&0!==A.width&&0!==A.height}(A)&&!function(A){return null!=A&&A.data instanceof Uint8Array}(A)}async function Wi(A,g=3){let I=null;if(ZA().getBool("WRAP_TO_IMAGEBITMAP")&&Vi(A)){let g;try{g=await createImageBitmap(A,{premultiplyAlpha:"none"})}catch(A){g=null}I=null!=g&&g.width===A.width&&g.height===A.height?g:A}else I=A;return vi(I,g)}async function Oi(A,g){let I=Ke(A,"img","toPixels");if(!(A instanceof Ce)){const A=I;I=qB(A,"int32"),A.dispose()}if(2!==I.rank&&3!==I.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${I.rank}.`);const[t,C]=I.shape.slice(0,2),e=2===I.rank?1:I.shape[2];if(e>4||2===e)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if("float32"!==I.dtype&&"int32"!==I.dtype)throw new Error(`Unsupported type for toPixels: ${I.dtype}. Please use float32 or int32 tensors.`);const B=await I.data(),i="float32"===I.dtype?255:1,Q=new Uint8ClampedArray(C*t*4);for(let A=0;A<t*C;++A){const g=[0,0,0,255];for(let t=0;t<e;t++){const C=B[A*e+t];if("float32"===I.dtype){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if("int32"===I.dtype&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);1===e?(g[0]=C*i,g[1]=C*i,g[2]=C*i):g[t]=C*i}const t=4*A;Q[t+0]=Math.round(g[0]),Q[t+1]=Math.round(g[1]),Q[t+2]=Math.round(g[2]),Q[t+3]=Math.round(g[3])}if(null!=g){g.width=C,g.height=t;const A=g.getContext("2d"),I=new ImageData(Q,C,t);A.putImageData(I,0,0)}return I!==A&&I.dispose(),Q}const Zi=Le({fromPixels_:vi});function Pi(A,g){const I=A.shape.length,t=g.shape.length;if(I<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${I}.`);if(t<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${t}.`);if("int32"!==g.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${g.dtype}.`);if(g.shape[t-1]>I)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${g.shape[t-1]} vs. ${I}`);if(0===QA(A.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${A.shape}.`);const C=g.shape,e=C[C.length-1];let B=1;for(let A=0;A<C.length-1;++A)B*=C[A];const i=A.shape,Q=C.slice();Q.pop();let o=1;for(let A=e;A<I;++A)o*=i[A],Q.push(i[A]);const E=[...KA(A.shape).map((A=>A/o)),1].slice(0,e);return[Q,B,o,E]}function Xi(A,g,I){const t=g.rank>1?g.shape[g.rank-1]:1,C=g.rank>1?g.rank-1:1,e=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${I.shape}, indices.shape: ${g.shape}, shape: ${A}, sliceDim: ${t}, and batchDim: ${C}.`;if(I.rank<C)throw new Error(e+` update.rank < ${C}. `);if(A.length<t+(I.rank-C))throw new Error(e+` Output shape length < ${t+(I.rank-C)}`);if(I.rank!==C+A.length-t)throw new Error(e+" update.rank != "+(C+A.length-t));for(let A=0;A<C;++A)if(I.shape[A]!==g.shape[A])throw new Error(e+` updates.shape[${A}] (${I.shape[A]}) != indices.shape[${A}] (${g.shape[A]}).`);for(let g=0;g<I.rank-C;++g)if(I.shape[g+C]!==A[g+t])throw new Error(e+` updates.shape[${g+C}] (${I.shape[g+C]}) != shape[${g+C}] (${A[g+C]})`)}function ji(A,g,I){if(g.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${g.rank}.`);if(A.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${A.rank}.`);if("int32"!==g.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${g.dtype}`);if(I.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${I}`);if(0===I.length){if(0===g.size)throw new Error(`Indices specified for empty output. indices shape: ${g.shape}`);if(0===A.size)throw new Error(`Updates specified for empty output. updates shape: ${A.shape}`)}Xi(I,g,A)}function zi(A,g,I){const t=g.shape.length,C=t>1?g.shape[t-1]:1,e=I.length;let B=1;for(let A=C;A<e;++A)B*=I[A];const i=C<1?1:C;return{sliceRank:C,numUpdates:QA(g.shape)/i,sliceSize:B,strides:[...KA(I.slice(0,C)),1],outputSize:QA(I)}}const _i=-2,$i=-1;function AQ(A,g,I){const t=A.shape.length;CA(t===g.length,(()=>`Error in slice${t}D: Length of begin ${g} must match the rank of the array (${t}).`)),CA(t===I.length,(()=>`Error in slice${t}D: Length of size ${I} must match the rank of the array (${t}).`));for(let C=0;C<t;++C)CA(g[C]+I[C]<=A.shape[C],(()=>`Error in slice${t}D: begin[${C}] + size[${C}] (${g[C]+I[C]}) would overflow input.shape[${C}] (${A.shape[C]})`))}function gQ(A){const g=[];let I=0;for(;A>0;)1&A&&g.push(I),A/=2,I++;return g}function IQ(A,g,I){const t=[];for(let C=0;C<A.length;C++)t[C]=Math.ceil((g[C]-A[C])/I[C]);return t}function tQ(A,g,I,t){const C=[...A];for(let A=C.length;A<t.length;A++)C.push(1);for(let A=0;A<I;A++)0===A?C[g]=1:(C.splice(g,0,1),C.pop());return C}function CQ(A,g,I){return I<=A?I:I-(g-1)}function eQ(A,g){const I=[];for(let t=0;t<A;t++)I.push(g+t);return I}function BQ(A,g,I,t,C,e,B,i,Q){const o=A.length;let E=new Array(o),n=new Array(o),s=new Array(o);if(g.length&&I>0){const Q=g[0],o=I+1;E=iQ(B,Q,o,t,A),n=QQ(i,Q,o,C,A),s=tQ(e,Q,o,A)}else for(let g=0;g<o;g++)E[g]=EQ(B,t,e,A,g,Q),n[g]=nQ(i,C,e,A,g,Q),s[g]=oQ(e,g,Q);return{begin:E,end:n,strides:s}}function iQ(A,g,I,t,C){const e=[...C],B=eQ(I,g);for(let C=0;C<e.length;C++)if(B.indexOf(C)>-1)e[C]=0;else{const B=CQ(g,I,C);let i=t[B];A&1<<B&&(i=0),e[C]=i}return e}function QQ(A,g,I,t,C){const e=[...C],B=eQ(I,g);for(let C=0;C<e.length;C++)if(B.indexOf(C)>-1)e[C]=Number.MAX_SAFE_INTEGER;else{const B=CQ(g,I,C);let i=t[B];A&1<<B&&(i=Number.MAX_SAFE_INTEGER),e[C]=i}for(let A=0;A<e.length;A++){const g=C[A];e[A]<0&&(e[A]+=g),e[A]=_(0,e[A],C[A])}return e}function oQ(A,g,I){let t=A[g];return(I&1<<g||null==t)&&(t=1),t}function EQ(A,g,I,t,C,e){let B=g[C];const i=I[C]||1;(A&1<<C||e&1<<C||null==B)&&(B=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const Q=t[C];return B<0&&(B+=Q),B=_(0,B,Q-1),B}function nQ(A,g,I,t,C,e){let B=g[C];const i=I[C]||1;(A&1<<C||e&1<<C||null==B)&&(B=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const Q=t[C];return B<0&&(B+=Q),B=i>0?_(0,B,Q):_(-1,B,Q-1),B}function sQ(A,g,I){let t=I.length;for(let A=0;A<I.length;A++)if(I[A]>1){t=A;break}for(let C=t+1;C<I.length;C++)if(g[C]>0||I[C]!==A[C])return!1;return!0}function aQ(A,g){let I=A.length>0?A[A.length-1]:1;for(let t=0;t<A.length-1;t++)I+=A[t]*g[t];return I}function rQ(A,g,I){let t;const C=A.shape.length;let e;return t="number"==typeof g?[g,...new Array(C-1).fill(0)]:g.length<C?g.concat(new Array(C-g.length).fill(0)):g.slice(),t.forEach((A=>{CA(-1!==A,(()=>"slice() does not support negative begin indexing."))})),e=null==I?new Array(C).fill(-1):"number"==typeof I?[I,...new Array(C-1).fill(-1)]:I.length<C?I.concat(new Array(C-I.length).fill(-1)):I,e=e.map(((g,I)=>g>=0?g:(CA(-1===g,(()=>`Negative size values should be exactly -1 but got ${g} for the slice() size at index ${I}.`)),A.shape[I]-t[I]))),[t,e]}function hQ(A,g,I,t,C,e,B,i,Q){let o;if(null==t?(o=new Array(g.length),o.fill(1)):o=t,null!=B&&0!=(B&B-1))throw new Error("Multiple ellipses in slice is not allowed.");let E=!1;const n={dims:o.length,numAddAxisAfterEllipsis:0,begin:g.slice(),end:I.slice(),strides:o.slice(),beginMask:C,endMask:e,ellipsisMask:B,newAxisMask:i,shrinkAxisMask:Q};for(let A=0;A<n.dims;A++)E&&0!=(1<<A&i)&&n.numAddAxisAfterEllipsis++,1<<A&B&&(E=!0);E||(n.ellipsisMask|=1<<n.dims,n.dims++);const s={dims:A.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(A,g){g.beginMask=0,g.endMask=0,g.shrinkAxisMask=0;let I=0;g.beginValid=null!=A.begin,g.endValid=null!=A.end,g.begin=new Array(g.dims),g.end=new Array(g.dims),g.strides=new Array(g.dims),g.finalShapeGatherIndices=[],g.finalShapeGatherIndicesSparse=[],g.inputShapeGatherIndicesSparse=new Array(g.dims);for(let t=0;t<A.dims;t++)if(1<<t&A.ellipsisMask){const C=Math.min(g.dims-(A.dims-t)+1+A.numAddAxisAfterEllipsis,g.dims);for(;I<C;I++)g.begin[I]=0,g.end[I]=0,g.strides[I]=1,g.beginMask|=1<<I,g.endMask|=1<<I,g.finalShapeGatherIndices.push(I),g.finalShapeGatherIndicesSparse.push(-1),g.inputShapeGatherIndicesSparse[I]=t}else if(1<<t&A.newAxisMask)g.finalShapeGatherIndices.push(_i),g.finalShapeGatherIndicesSparse.push(-1);else{if(I===g.begin.length)throw Error(`Index out of range using input dim ${I}; input has only ${g.dims} dims, ${g.begin.length}.`);null!=A.begin&&(g.begin[I]=A.begin[t]),null!=A.end&&(g.end[I]=A.end[t]),g.strides[I]=A.strides[t],A.beginMask&1<<t&&(g.beginMask|=1<<I),A.endMask&1<<t&&(g.endMask|=1<<I),A.shrinkAxisMask&1<<t?(g.finalShapeGatherIndices.push($i),g.finalShapeGatherIndicesSparse.push(-1),g.shrinkAxisMask|=1<<I):(g.finalShapeGatherIndices.push(I),g.finalShapeGatherIndicesSparse.push(t)),g.inputShapeGatherIndicesSparse[I]=t,I++}}(n,s);let a=!0,r=!0,h=!0;const c=[],l=[];for(let g=0;g<A.length;++g){if(0===s.strides[g])throw Error(`strides[${g}] must be non-zero`);const I=!!(s.shrinkAxisMask&1<<g),t=A[g];if(-1===t){c.push(I?1:-1);continue}const C=[s.beginMask&1<<g,s.endMask&1<<g],e=[s.strides[g]>0?0:-1,s.strides[g]>0?t:t-1];if(I&&s.strides[g]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&1===s.strides[g];const B=!!(s.beginMask&1<<g&&s.endMask&1<<g);if(s.beginValid&&s.endValid){if(I){const A=s.begin[g]<0?t+s.begin[g]:s.begin[g];if(s.begin[g]=A,s.end[g]=s.begin[g]+1,A<0||A>=t)throw Error(`slice index ${s.begin[g]} of dimension ${g} out of bounds.`)}else s.begin[g]=cQ(s.begin[g],0,s.strides[g],t,C,e),s.end[g]=cQ(s.end[g],1,s.strides[g],t,C,e);const A=1===s.strides[g]&&0===s.begin[g]&&s.end[g]===t;a=a&&A,r=r&&(0===g&&1===s.strides[g]||A)}else a=a&&1===s.strides[g]&&B,r=r&&(0===g&&1===s.strides[g]||B);let i,Q=!1;if(s.beginValid&&s.endValid?(i=s.end[g]-s.begin[g],Q=!0):I?(i=1,Q=!0):B&&t>=0&&(i=s.strides[g]<0?-t:t,Q=!0),Q){let A;A=0===i||i<0!=s.strides[g]<0?0:Math.trunc(i/s.strides[g])+(i%s.strides[g]!=0?1:0),c.push(A)}else c.push(-1)}for(let A=0;A<s.finalShapeGatherIndices.length;++A){const g=s.finalShapeGatherIndices[A];g>=0?l.push(c[g]):g===_i&&l.push(1)}return{finalShapeSparse:l.filter(((A,g)=>s.finalShapeGatherIndices[g]!==_i)),finalShape:l,isIdentity:a,sliceDim0:r,isSimpleSlice:h,begin:s.begin,end:s.end,strides:s.strides}}function cQ(A,g,I,t,C,e){if(C[g])return I>0?e[g]:e[g+1&1];{const g=A<0?t+A:A;return g<e[0]?e[0]:g>e[1]?e[1]:g}}class lQ{getClassName(){return this.constructor.className}static fromConfig(A,g){return new A(g)}}class DQ{constructor(){this.classNameMap={}}static getMap(){return null==DQ.instance&&(DQ.instance=new DQ),DQ.instance}static register(A){DQ.getMap().classNameMap[A.className]=[A,A.fromConfig]}}function uQ(A){CA(null!=A.className,(()=>"Class being registered does not have the static className property defined.")),CA("string"==typeof A.className,(()=>"className is required to be a string, but got type "+typeof A.className)),CA(A.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),DQ.register(A)}const wQ=.001,dQ=.1;function pQ(A,g,I){return null==I&&(I=yQ()),GQ(A,g,((A,g)=>RQ(A,g,I)))}function yQ(){return 32===Ge.backend.floatPrecision()?wQ:dQ}function GQ(A,g,I){let t=!0;if((fA(A)||fA(g))&&(t=!1),fA(A)&&fA(g)&&(t=!0),t){const I=A.constructor.name,t=g.constructor.name;if(I!==t)throw new Error(`Arrays are of different type. Actual: ${I}. Expected: ${t}`)}if(Array.isArray(A)&&Array.isArray(g)){const I=Se(A),t=Se(g);if(!EA(I,t))throw new Error(`Arrays have different shapes. Actual: [${I}]. Expected: [${t}]`)}const C=fA(A)?A:iA(A),e=fA(g)?g:iA(g);if(C.length!==e.length)throw new Error(`Arrays have different lengths actual: ${C.length} vs expected: ${e.length}.\nActual:   ${C}.\nExpected: ${e}.`);for(let A=0;A<e.length;++A){const g=C[A],t=e[A];if(!I(g,t))throw new Error(`Arrays differ: actual[${A}] = ${g}, expected[${A}] = ${t}.\nActual:   ${C}.\nExpected: ${e}.`)}"undefined"!=typeof expect&&expect().nothing()}function fQ(A,g){A().then((()=>g.fail()),(()=>g())),"undefined"!=typeof expect&&expect().nothing()}function NQ(A,g){const I="string"==typeof g||"number"==typeof g||"boolean"==typeof g?[g]:g;return RA(A)||RA(A[0])||RA(g)||RA(g[0])?GQ(A,I,((A,g)=>A==g)):GQ(A,g,((A,g)=>RQ(A,g,0)))}function FQ(A,g,I){if(null==I&&(I=yQ()),!RQ(A,g,I))throw new Error(`Numbers differ: actual === ${A}, expected === ${g}`);"undefined"!=typeof expect&&expect().nothing()}function RQ(A,g,I){return!isFinite(A)&&!isFinite(g)||!(isNaN(A)||isNaN(g)||Math.abs(A-g)>I)}function mQ(A,g,I){for(let t=0;t<A.length;t++)if(A[t]<g||A[t]>I)throw new Error(`Value out of range:${A[t]} low: ${g}, high: ${I}`)}function kQ(A,g){const I=new Float32Array(A),t=new Float32Array(g);if(I.length!==t.length)throw new Error(`Expected ArrayBuffer to be of length ${t.length}, but it was ${I.length}`);for(let A=0;A<t.length;A++)if(I[A]!==t[A])throw new Error(`Expected ArrayBuffer value at ${A} to be ${t[A]} but got ${I[A]} instead`)}function SQ(A){for(let g=0;g<A.length;g++){const I=A[g];Array.isArray(I)?SQ(I):A[g]=qC(I)}return A}function MQ(A){const g=document.createElement("video");return"playsInline"in g&&(g.playsInline=!0),g.muted=!0,g.loop=!0,g.style.position="fixed",g.style.left="0px",g.style.top="0px",g.preload="auto",g.appendChild(A),new Promise((A=>{g.addEventListener("loadeddata",(I=>A(g))),g.load()}))}async function UQ(A){await A.play(),"requestVideoFrameCallback"in A&&await new Promise((g=>{A.requestVideoFrameCallback(g)}))}const KQ="3.21.0";const JQ=Le({add_:function(A,g){let I=Ke(A,"a","add"),t=Ke(g,"b","add");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(gg,C)}});const YQ=Le({floorDiv_:function(A,g){let I=Ke(A,"a","floorDiv"),t=Ke(g,"b","floorDiv");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(BI,C)}});const LQ=Le({div_:function(A,g){let I=Ke(A,"a","div"),t=Ke(g,"b","div");if([I,t]=he(I,t),"int32"===I.dtype&&"int32"===t.dtype)return YQ(I,t);const C={a:I,b:t};return Ge.runKernel(Zg,C,{})}});const xQ=Le({mul_:function(A,g){let I=Ke(A,"a","mul"),t=Ke(g,"b","mul");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(WI,C)}});const bQ=Le({sqrt_:function(A){const g={x:Ke(A,"x","sqrt","float32")};return Ge.runKernel(kt,g)}});const HQ=Le({square_:function(A){const g=Ke(A,"x","square");return Ge.runKernel("Square",{x:g},{})}});const qQ=Le({zerosLike_:function(A){const g={x:Ke(A,"x","zerosLike")};return Ge.runKernel(tC,g)}});function TQ(A){return CA(MA(A),(()=>"The f passed in grad(f) must be a function")),(g,I)=>{const t=Ke(g,"x","tf.grad","string_or_numeric"),C=null!=I?Ke(I,"dy","tf.grad"):null;return Ge.tidy((()=>{const{value:g,grads:I}=Ge.gradients((()=>A(t)),[t],C);return null!=C&&eA(g.shape,C.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),PQ(I),I[0]}))}}function vQ(A){return CA(MA(A),(()=>"The f passed in grads(f) must be a function")),(g,I)=>{CA(Array.isArray(g),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const t=Je(g,"args","tf.grads","string_or_numeric"),C=null!=I?Ke(I,"dy","tf.grads"):null;return Ge.tidy((()=>{const{value:g,grads:I}=Ge.gradients((()=>A(...t)),t,C);return null!=C&&eA(g.shape,C.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),PQ(I),I}))}}function VQ(A){return CA(MA(A),(()=>"The f passed in valueAndGrad(f) must be a function")),(g,I)=>{CA(g instanceof Ce,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),CA(null==I||I instanceof Ce,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:t,value:C}=Ge.gradients((()=>A(g)),[g],I);return PQ(t),{grad:t[0],value:C}}}function WQ(A){return CA(MA(A),(()=>"The f passed in valueAndGrads(f) must be a function")),(g,I)=>{CA(Array.isArray(g)&&g.every((A=>A instanceof Ce)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),CA(null==I||I instanceof Ce,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const t=Ge.gradients((()=>A(...g)),g,I);return null!=I&&eA(t.value.shape,I.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),PQ(t.grads),t}}function OQ(A,g){CA(MA(A),(()=>"The f passed in variableGrads(f) must be a function")),CA(null==g||Array.isArray(g)&&g.every((A=>A instanceof Be)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const I=null!=g;if(!I){g=[];for(const A in Ge.registeredVariables)g.push(Ge.registeredVariables[A])}const t=I?g.filter((A=>!A.trainable)):null,C=g.length;g=g.filter((A=>A.trainable)),CA(g.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${C} variables is trainable.`));const{value:e,grads:B}=Ge.gradients(A,g,null,!0);CA(B.some((A=>null!=A)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),CA(0===e.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${e.rank} tensor`));const i={};return g.forEach(((A,g)=>{null!=B[g]&&(i[A.name]=B[g])})),null!=t&&t.forEach((A=>i[A.name]=null)),{value:e,grads:i}}function ZQ(A){return Ge.customGrad(A)}function PQ(A){if(A.filter((A=>null==A)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function XQ(A,g){if((fA(A)&&"string"!==g||Array.isArray(A))&&"complex64"!==g)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===g&&fA(A)&&!(A instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return be(A,[],[],g)}class jQ extends lQ{minimize(A,g=!1,I){const{value:t,grads:C}=this.computeGradients(A,I);if(null!=I){const A=I.map((A=>({name:A.name,tensor:C[A.name]})));this.applyGradients(A)}else this.applyGradients(C);return di(C),g?t:(t.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(A,g){return OQ(A,g)}dispose(){null!=this.iterations_&&di(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:XQ(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(A){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(A){return this.iterations_=(await A[0].tensor.data())[0],A.slice(1)}}Object.defineProperty(jQ,Symbol.hasInstance,{value:A=>null!=A.minimize&&null!=A.computeGradients&&null!=A.applyGradients});class zQ extends jQ{constructor(A,g,I=null){super(),this.learningRate=A,this.rho=g,this.epsilon=I,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==I&&(this.epsilon=Ge.backend.epsilon())}applyGradients(A){(Array.isArray(A)?A.map((A=>A.name)):Object.keys(A)).forEach(((g,I)=>{const t=Ge.registeredVariables[g];null==this.accumulatedGrads[I]&&(this.accumulatedGrads[I]={originalName:`${g}/accum_grad`,variable:wi((()=>qQ(t).variable(false)))}),null==this.accumulatedUpdates[I]&&(this.accumulatedUpdates[I]={originalName:`${g}/accum_var`,variable:wi((()=>qQ(t).variable(false)))});const C=Array.isArray(A)?A[I].tensor:A[g];if(null==C)return;const e=this.accumulatedGrads[I].variable,B=this.accumulatedUpdates[I].variable;wi((()=>{const A=JQ(xQ(e,this.rho),xQ(HQ(C),1-this.rho)),g=xQ(LQ(bQ(JQ(B,this.epsilon)),bQ(JQ(e,this.epsilon))),C),I=JQ(xQ(B,this.rho),xQ(HQ(g),1-this.rho));e.assign(A),B.assign(I);const i=JQ(xQ(g,-this.learningRate),t);t.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(di(this.accumulatedGrads.map((A=>A.variable))),di(this.accumulatedUpdates.map((A=>A.variable))))}async getWeights(){const A=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(A.map((A=>({name:A.originalName,tensor:A.variable}))))}async setWeights(A){const g=(A=await this.extractIterations(A)).length/2;this.accumulatedGrads=A.slice(0,g).map((A=>({originalName:A.name,variable:A.tensor.variable(false)}))),this.accumulatedUpdates=A.slice(g,2*g).map((A=>({originalName:A.name,variable:A.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(A,g){return new A(g.learningRate,g.rho,g.epsilon)}}function _Q(A,g,I){const t={shape:A,value:g,dtype:I};return Ge.runKernel(tI,{},t)}zQ.className="Adadelta",uQ(zQ);class $Q extends jQ{constructor(A,g=.1){super(),this.learningRate=A,this.initialAccumulatorValue=g,this.accumulatedGrads=[]}applyGradients(A){(Array.isArray(A)?A.map((A=>A.name)):Object.keys(A)).forEach(((g,I)=>{const t=Ge.registeredVariables[g];if(null==this.accumulatedGrads[I]){const A=!1;this.accumulatedGrads[I]={originalName:`${g}/accumulator`,variable:wi((()=>_Q(t.shape,this.initialAccumulatorValue).variable(A)))}}const C=Array.isArray(A)?A[I].tensor:A[g];if(null==C)return;const e=this.accumulatedGrads[I].variable;wi((()=>{const A=JQ(e,HQ(C));e.assign(A);const g=JQ(xQ(LQ(C,bQ(JQ(A,Ge.backend.epsilon()))),-this.learningRate),t);t.assign(g)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&di(this.accumulatedGrads.map((A=>A.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((A=>({name:A.originalName,tensor:A.variable}))))}async setWeights(A){A=await this.extractIterations(A);this.accumulatedGrads=A.map((A=>({originalName:A.name,variable:A.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(A,g){return new A(g.learningRate,g.initialAccumulatorValue)}}$Q.className="Adagrad",uQ($Q);const Ao=Le({pow_:function(A,g){let I=Ke(A,"base","pow"),t=Ke(g,"exp","pow");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(It,C)}});const go=Le({sub_:function(A,g){let I=Ke(A,"a","sub"),t=Ke(g,"b","sub");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(Ot,C)}});class Io extends jQ{constructor(A,g,I,t=null){super(),this.learningRate=A,this.beta1=g,this.beta2=I,this.epsilon=t,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],wi((()=>{this.accBeta1=XQ(g).variable(),this.accBeta2=XQ(I).variable()})),null==t&&(this.epsilon=Ge.backend.epsilon())}applyGradients(A){const g=Array.isArray(A)?A.map((A=>A.name)):Object.keys(A);wi((()=>{const I=go(1,this.accBeta1),t=go(1,this.accBeta2);g.forEach(((g,C)=>{const e=Ge.registeredVariables[g];null==this.accumulatedFirstMoment[C]&&(this.accumulatedFirstMoment[C]={originalName:`${g}/m`,variable:wi((()=>qQ(e).variable(false)))}),null==this.accumulatedSecondMoment[C]&&(this.accumulatedSecondMoment[C]={originalName:`${g}/v`,variable:wi((()=>qQ(e).variable(false)))});const B=Array.isArray(A)?A[C].tensor:A[g];if(null==B)return;const i=this.accumulatedFirstMoment[C].variable,Q=this.accumulatedSecondMoment[C].variable,o=JQ(xQ(i,this.beta1),xQ(B,1-this.beta1)),E=JQ(xQ(Q,this.beta2),xQ(HQ(B),1-this.beta2)),n=LQ(o,I),s=LQ(E,t);i.assign(o),Q.assign(E);const a=JQ(xQ(LQ(n,JQ(bQ(s),this.epsilon)),-this.learningRate),e);e.assign(a)})),this.accBeta1.assign(xQ(this.accBeta1,this.beta1)),this.accBeta2.assign(xQ(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&di(this.accumulatedFirstMoment.map((A=>A.variable))),null!=this.accumulatedSecondMoment&&di(this.accumulatedSecondMoment.map((A=>A.variable)))}async getWeights(){const A=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(A.map((A=>({name:A.originalName,tensor:A.variable}))))}async setWeights(A){A=await this.extractIterations(A),wi((()=>{this.accBeta1.assign(Ao(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ao(this.beta2,this.iterations_+1))}));const g=A.length/2;this.accumulatedFirstMoment=A.slice(0,g).map((A=>({originalName:A.name,variable:A.tensor.variable(false)}))),this.accumulatedSecondMoment=A.slice(g,2*g).map((A=>({originalName:A.name,variable:A.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(A,g){return new A(g.learningRate,g.beta1,g.beta2,g.epsilon)}}Io.className="Adam",uQ(Io);const to=Le({abs_:function(A){const g=Ke(A,"x","abs");if("complex64"===g.dtype){const A={x:g};return Ge.runKernel(fg,A)}{const A={x:g};return Ge.runKernel(_A,A)}}});const Co=Le({maximum_:function(A,g){let I=Ke(A,"a","maximum"),t=Ke(g,"b","maximum");[I,t]=he(I,t),"bool"===I.dtype&&(I=qB(I,"int32"),t=qB(t,"int32")),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(UI,C)}});class eo extends jQ{constructor(A,g,I,t=null,C=0){super(),this.learningRate=A,this.beta1=g,this.beta2=I,this.epsilon=t,this.decay=C,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],wi((()=>{this.iteration=XQ(0).variable(),this.accBeta1=XQ(g).variable()})),null==t&&(this.epsilon=Ge.backend.epsilon())}applyGradients(A){const g=Array.isArray(A)?A.map((A=>A.name)):Object.keys(A);wi((()=>{const I=go(1,this.accBeta1),t=LQ(-this.learningRate,JQ(xQ(this.iteration,this.decay),1));g.forEach(((g,C)=>{const e=Ge.registeredVariables[g];null==this.accumulatedFirstMoment[C]&&(this.accumulatedFirstMoment[C]={originalName:`${g}/m`,variable:qQ(e).variable(false)}),null==this.accumulatedWeightedInfNorm[C]&&(this.accumulatedWeightedInfNorm[C]={originalName:`${g}/v`,variable:qQ(e).variable(false)});const B=Array.isArray(A)?A[C].tensor:A[g];if(null==B)return;const i=this.accumulatedFirstMoment[C].variable,Q=this.accumulatedWeightedInfNorm[C].variable,o=JQ(xQ(i,this.beta1),xQ(B,1-this.beta1)),E=xQ(Q,this.beta2),n=to(B),s=Co(E,n);i.assign(o),Q.assign(s);const a=JQ(xQ(LQ(t,I),LQ(o,JQ(s,this.epsilon))),e);e.assign(a)})),this.iteration.assign(JQ(this.iteration,1)),this.accBeta1.assign(xQ(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&di(this.accumulatedFirstMoment.map((A=>A.variable))),null!=this.accumulatedWeightedInfNorm&&di(this.accumulatedWeightedInfNorm.map((A=>A.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(A){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(A,g){return new A(g.learningRate,g.beta1,g.beta2,g.epsilon,g.decay)}}eo.className="Adamax",uQ(eo);class Bo extends jQ{constructor(A){super(),this.learningRate=A,this.setLearningRate(A)}applyGradients(A){(Array.isArray(A)?A.map((A=>A.name)):Object.keys(A)).forEach(((g,I)=>{const t=Array.isArray(A)?A[I].tensor:A[g];if(null==t)return;const C=Ge.registeredVariables[g];wi((()=>{const A=JQ(xQ(this.c,t),C);C.assign(A)}))})),this.incrementIterations()}setLearningRate(A){this.learningRate=A,null!=this.c&&this.c.dispose(),this.c=pi(XQ(-A))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(A){if(0!==(A=await this.extractIterations(A)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(A,g){return new A(g.learningRate)}}Bo.className="SGD",uQ(Bo);class io extends Bo{constructor(A,g,I=!1){super(A),this.learningRate=A,this.momentum=g,this.useNesterov=I,this.accumulations=[],this.m=XQ(this.momentum)}applyGradients(A){(Array.isArray(A)?A.map((A=>A.name)):Object.keys(A)).forEach(((g,I)=>{const t=Ge.registeredVariables[g];if(null==this.accumulations[I]){const A=!1;this.accumulations[I]={originalName:`${g}/momentum`,variable:wi((()=>qQ(t).variable(A)))}}const C=this.accumulations[I].variable,e=Array.isArray(A)?A[I].tensor:A[g];null!=e&&wi((()=>{let A;const g=JQ(xQ(this.m,C),e);A=this.useNesterov?JQ(xQ(this.c,JQ(e,xQ(g,this.m))),t):JQ(xQ(this.c,g),t),C.assign(g),t.assign(A)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&di(this.accumulations.map((A=>A.variable)))}setMomentum(A){this.momentum=A}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((A=>({name:A.originalName,tensor:A.variable}))))}async setWeights(A){A=await this.extractIterations(A);this.accumulations=A.map((A=>({originalName:A.name,variable:A.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(A,g){return new A(g.learningRate,g.momentum,g.useNesterov)}}io.className="Momentum",uQ(io);class Qo extends jQ{constructor(A,g=.9,I=0,t=null,C=!1){if(super(),this.learningRate=A,this.decay=g,this.momentum=I,this.epsilon=t,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=C,null==t&&(this.epsilon=Ge.backend.epsilon()),null==A)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(A){(Array.isArray(A)?A.map((A=>A.name)):Object.keys(A)).forEach(((g,I)=>{const t=Ge.registeredVariables[g],C=!1;null==this.accumulatedMeanSquares[I]&&(this.accumulatedMeanSquares[I]={originalName:`${g}/rms`,variable:wi((()=>qQ(t).variable(C)))}),null==this.accumulatedMoments[I]&&(this.accumulatedMoments[I]={originalName:`${g}/momentum`,variable:wi((()=>qQ(t).variable(C)))}),null==this.accumulatedMeanGrads[I]&&this.centered&&(this.accumulatedMeanGrads[I]={originalName:`${g}/mg`,variable:wi((()=>qQ(t).variable(C)))});const e=Array.isArray(A)?A[I].tensor:A[g];if(null==e)return;const B=this.accumulatedMeanSquares[I].variable,i=this.accumulatedMoments[I].variable;wi((()=>{const A=JQ(xQ(B,this.decay),xQ(HQ(e),1-this.decay));if(this.centered){const g=this.accumulatedMeanGrads[I].variable,C=JQ(xQ(g,this.decay),xQ(e,1-this.decay)),Q=LQ(xQ(e,this.learningRate),bQ(go(A,JQ(HQ(C),this.epsilon)))),o=JQ(xQ(i,this.momentum),Q);B.assign(A),g.assign(C),i.assign(o);const E=go(t,o);t.assign(E)}else{const A=JQ(xQ(B,this.decay),xQ(HQ(e),1-this.decay)),g=JQ(xQ(i,this.momentum),LQ(xQ(e,this.learningRate),bQ(JQ(A,this.epsilon))));B.assign(A),i.assign(g);const I=go(t,g);t.assign(I)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&di(this.accumulatedMeanSquares.map((A=>A.variable))),null!=this.accumulatedMeanGrads&&this.centered&&di(this.accumulatedMeanGrads.map((A=>A.variable))),null!=this.accumulatedMoments&&di(this.accumulatedMoments.map((A=>A.variable)))}async getWeights(){const A=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&A.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(A.map((A=>({name:A.originalName,tensor:A.variable}))))}async setWeights(A){A=await this.extractIterations(A);const g=this.centered?A.length/3:A.length/2,I=!1;this.accumulatedMeanSquares=A.slice(0,g).map((A=>({originalName:A.name,variable:A.tensor.variable(I)}))),this.accumulatedMoments=A.slice(g,2*g).map((A=>({originalName:A.name,variable:A.tensor.variable(I)}))),this.centered&&(this.accumulatedMeanGrads=A.slice(2*g,3*g).map((A=>({originalName:A.name,variable:A.tensor.variable(I)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(A,g){return new A(g.learningRate,g.decay,g.momentum,g.epsilon,g.centered)}}Qo.className="RMSProp",uQ(Qo);class oo{static sgd(A){return new Bo(A)}static momentum(A,g,I=!1){return new io(A,g,I)}static rmsprop(A,g=.9,I=0,t=null,C=!1){return new Qo(A,g,I,t,C)}static adam(A=.001,g=.9,I=.999,t=null){return new Io(A,g,I,t)}static adadelta(A=.001,g=.95,I=null){return new zQ(A,g,I)}static adamax(A=.002,g=.9,I=.999,t=null,C=0){return new eo(A,g,I,t,C)}static adagrad(A,g=.1){return new $Q(A,g)}}const Eo=Le({acos_:function(A){const g={x:Ke(A,"x","acos")};return Ge.runKernel($A,g)}});const no=Le({acosh_:function(A){const g={x:Ke(A,"x","acosh")};return Ge.runKernel(Ag,g)}});const so=Le({addN_:function(A){CA(Array.isArray(A),(()=>"The argument passed to tf.addN() must be a list of tensors")),CA(A.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${A.length}`));const g=A.map(((A,g)=>Ke(A,`tensors${g}`,"addN"))),I=g[0];g.forEach((A=>{if(A.dtype!==I.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),g.forEach((A=>{if(!EA(A.shape,I.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const t=g;return Ge.runKernel(Ig,t)}});const ao=Le({all_:function(A,g=null,I=!1){const t={x:Ke(A,"x","all","bool")},C={axis:g,keepDims:I};return Ge.runKernel(tg,t,C)}});const ro=Le({any_:function(A,g=null,I=!1){const t={x:Ke(A,"x","any","bool")},C={axis:g,keepDims:I};return Ge.runKernel(Cg,t,C)}});const ho=Le({argMax_:function(A,g=0){const I={x:Ke(A,"x","argMax")},t={axis:g};return Ge.runKernel(eg,I,t)}});const co=Le({argMin_:function(A,g=0){const I={x:Ke(A,"x","argMin")},t={axis:g};return Ge.runKernel(Bg,I,t)}});const lo=Le({asin_:function(A){const g={x:Ke(A,"x","asin")};return Ge.runKernel(ig,g)}});const Do=Le({asinh_:function(A){const g={x:Ke(A,"x","asinh")};return Ge.runKernel(Qg,g)}});const uo=Le({atan_:function(A){const g={x:Ke(A,"x","atan")};return Ge.runKernel(og,g)}});const wo=Le({atan2_:function(A,g){let I=Ke(A,"a","atan2"),t=Ke(g,"b","atan2");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(ng,C)}});const po=Le({atanh_:function(A){const g={x:Ke(A,"x","atanh")};return Ge.runKernel(Eg,g)}});function yo(A,g,I,t,C="NHWC",e){return No(A,[...g,A[3]],I,e,t,null,null,Jo(C))}function Go(A,g,I,t,C,e,B="channelsLast"){const[i,Q]=mo(g);let o;if("channelsLast"===B)o=[i,Q,A[3],A[3]];else{if("channelsFirst"!==B)throw new Error(`Unknown dataFormat ${B}`);o=[i,Q,A[1],A[1]]}return No(A,o,I,t,C,e,!1,B)}function fo(A,g,I,t,C,e,B="NDHWC"){const[i,Q,o]=ko(g);let E,n;if("NDHWC"===B)n="channelsLast",E=[i,Q,o,A[4],A[4]];else{if("NCDHW"!==B)throw new Error(`Unknown dataFormat ${B}`);n="channelsFirst",E=[i,Q,o,A[1],A[1]]}return Fo(A,E,I,t,C,!1,n,e)}function No(A,g,I,t,C,e,B=!1,i="channelsLast"){let[Q,o,E,n]=[-1,-1,-1,-1];if("channelsLast"===i)[Q,o,E,n]=A;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[Q,n,o,E]=A}const[s,a,,r]=g,[h,c]=mo(I),[l,D]=mo(t),u=So(s,l),w=So(a,D),{padInfo:d,outHeight:p,outWidth:y}=function(A,g,I,t,C,e,B,i,Q){let o,E,n;if("number"==typeof A){o={top:A,bottom:A,left:A,right:A,type:0===A?"VALID":"NUMBER"};const C=function(A,g,I,t,C){null==t&&(t=Ro(A,g,I));const e=A[0],B=A[1],i=Mo((e-g+2*t)/I+1,C),Q=Mo((B-g+2*t)/I+1,C);return[i,Q]}([g,I],e,t,A,i);E=C[0],n=C[1]}else if("same"===A){E=Math.ceil(g/t),n=Math.ceil(I/C);const A=Math.max(0,(E-1)*t+e-g),i=Math.max(0,(n-1)*C+B-I),Q=Math.floor(A/2),s=A-Q,a=Math.floor(i/2);o={top:Q,bottom:s,left:a,right:i-a,type:"SAME"}}else if("valid"===A)o={top:0,bottom:0,left:0,right:0,type:"VALID"},E=Math.ceil((g-e+1)/t),n=Math.ceil((I-B+1)/C);else{if("object"!=typeof A)throw Error(`Unknown padding parameter: ${A}`);{const s="channelsLast"===Q?A[1][0]:A[2][0],a="channelsLast"===Q?A[1][1]:A[2][1],r="channelsLast"===Q?A[2][0]:A[3][0],h="channelsLast"===Q?A[2][1]:A[3][1];o={top:s,bottom:a,left:r,right:h,type:0===s&&0===a&&0===r&&0===h?"VALID":"EXPLICIT"},E=Mo((g-e+s+a)/t+1,i),n=Mo((I-B+r+h)/C+1,i)}}return{padInfo:o,outHeight:E,outWidth:n}}(C,o,E,h,c,u,w,e,i),G=B?r*n:r;let f;return"channelsFirst"===i?f=[Q,G,p,y]:"channelsLast"===i&&(f=[Q,p,y,G]),{batchSize:Q,dataFormat:i,inHeight:o,inWidth:E,inChannels:n,outHeight:p,outWidth:y,outChannels:G,padInfo:d,strideHeight:h,strideWidth:c,filterHeight:s,filterWidth:a,effectiveFilterHeight:u,effectiveFilterWidth:w,dilationHeight:l,dilationWidth:D,inShape:A,outShape:f,filterShape:g}}function Fo(A,g,I,t,C,e=!1,B="channelsLast",i){let[Q,o,E,n,s]=[-1,-1,-1,-1,-1];if("channelsLast"===B)[Q,o,E,n,s]=A;else{if("channelsFirst"!==B)throw new Error(`Unknown dataFormat ${B}`);[Q,s,o,E,n]=A}const[a,r,h,,c]=g,[l,D,u]=ko(I),[w,d,p]=ko(t),y=So(a,w),G=So(r,d),f=So(h,p),{padInfo:N,outDepth:F,outHeight:R,outWidth:m}=function(A,g,I,t,C,e,B,i,Q,o,E){let n,s,a,r;if("number"==typeof A){n={top:A,bottom:A,left:A,right:A,front:A,back:A,type:0===A?"VALID":"NUMBER"};const e=function(A,g,I,t,C,e){null==C&&(C=Ro(A,g,t));const B=A[0],i=A[1],Q=A[2],o=Mo((B-g+2*C)/t+1,e),E=Mo((i-g+2*C)/t+1,e),n=Mo((Q-g+2*C)/t+1,e);return[o,E,n,I]}([g,I,t,1],i,1,C,A,E);s=e[0],a=e[1],r=e[2]}else if("same"===A){s=Math.ceil(g/C),a=Math.ceil(I/e),r=Math.ceil(t/B);const A=(s-1)*C+i-g,E=(a-1)*e+Q-I,h=(r-1)*B+o-t,c=Math.floor(A/2),l=A-c,D=Math.floor(E/2),u=E-D,w=Math.floor(h/2);n={top:D,bottom:u,left:w,right:h-w,front:c,back:l,type:"SAME"}}else{if("valid"!==A)throw Error(`Unknown padding parameter: ${A}`);n={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},s=Math.ceil((g-i+1)/C),a=Math.ceil((I-Q+1)/e),r=Math.ceil((t-o+1)/B)}return{padInfo:n,outDepth:s,outHeight:a,outWidth:r}}(C,o,E,n,l,D,u,y,G,f,i),k=e?c*s:c;let S;return"channelsFirst"===B?S=[Q,k,F,R,m]:"channelsLast"===B&&(S=[Q,F,R,m,k]),{batchSize:Q,dataFormat:B,inDepth:o,inHeight:E,inWidth:n,inChannels:s,outDepth:F,outHeight:R,outWidth:m,outChannels:k,padInfo:N,strideDepth:l,strideHeight:D,strideWidth:u,filterDepth:a,filterHeight:r,filterWidth:h,effectiveFilterDepth:y,effectiveFilterHeight:G,effectiveFilterWidth:f,dilationDepth:w,dilationHeight:d,dilationWidth:p,inShape:A,outShape:S,filterShape:g}}function Ro(A,g,I,t=1){const C=So(g,t);return Math.floor((A[0]*(I-1)-I+C)/2)}function mo(A){return"number"==typeof A?[A,A,A]:2===A.length?[A[0],A[1],1]:A}function ko(A){return"number"==typeof A?[A,A,A]:A}function So(A,g){return g<=1?A:A+(A-1)*(g-1)}function Mo(A,g){if(!g)return Math.trunc(A);switch(g){case"round":return Math.round(A);case"ceil":return Math.ceil(A);case"floor":return Math.floor(A);default:throw new Error(`Unknown roundingMode ${g}`)}}function Uo(A){const[g,I,t]=mo(A);return 1===g&&1===I&&1===t}function Ko(A,g){return Uo(A)||Uo(g)}function Jo(A){if("NHWC"===A)return"channelsLast";if("NCHW"===A)return"channelsFirst";throw new Error(`Unknown dataFormat ${A}`)}function Yo(A,g,I){if(null!=I){if("string"==typeof g)throw Error(`Error in ${A}: pad must be an integer when using dimRoundingMode ${I} but got pad ${g}.`);if("number"==typeof g)CA(nA(g),(()=>`Error in ${A}: pad must be an integer when using dimRoundingMode ${I} but got pad ${g}.`));else{if("object"!=typeof g)throw Error(`Error in ${A}: Unknown padding parameter: ${g}`);g.forEach((g=>{g.forEach((g=>{CA(nA(g),(()=>`Error in ${A}: pad must be an integer when using dimRoundingMode ${I} but got pad ${g}.`))}))}))}}}const Lo=Le({reshape_:function(A,g){const I={x:Ke(A,"x","reshape","string_or_numeric")},t={shape:g};return Ge.runKernel(nt,I,t)}});const xo=Le({avgPool_:function(A,g,I,t,C){const e=Ke(A,"x","avgPool","float32");CA(Ko(I,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${I} and dilations '1'`));let B=e,i=!1;3===e.rank&&(i=!0,B=Lo(e,[1,e.shape[0],e.shape[1],e.shape[2]])),CA(4===B.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${B.rank}.`)),Yo("avgPool",t,C);const Q={x:B},o={filterSize:g,strides:I,pad:t,dimRoundingMode:C};let E=Ge.runKernel(sg,Q,o);return E=qB(E,e.dtype),i?Lo(E,[E.shape[1],E.shape[2],E.shape[3]]):E}});const bo=Le({avgPool3d_:function(A,g,I,t,C,e="NDHWC"){const B=Ke(A,"x","avgPool3d","float32");let i=B,Q=!1;4===B.rank&&(Q=!0,i=Lo(B,[1,B.shape[0],B.shape[1],B.shape[2],B.shape[3]])),CA(5===i.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`)),CA("NDHWC"===e,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${e}`)),Yo("avgPool3d",t,C);const o={x:i},E={filterSize:g,strides:I,pad:t,dimRoundingMode:C,dataFormat:e};let n=Ge.runKernel(rg,o,E);return n=qB(n,i.dtype),Q?Lo(n,[n.shape[1],n.shape[2],n.shape[3],n.shape[4]]):n}});const Ho=Le({concat_:function(A,g=0){CA(A.length>=1,(()=>"Pass at least one tensor to concat"));const I=Je(A,"tensors","concat","string_or_numeric");if("complex64"===I[0].dtype&&I.forEach((A=>{if("complex64"!==A.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${A.dtype}. `)})),1===I.length)return TB(I[0]);const t=I,C={axis:g};return Ge.runKernel(Ng,t,C)}});const qo=Le({sigmoid_:function(A){const g={x:Ke(A,"x","sigmoid","float32")};return Ge.runKernel(Rt,g)}});const To=Le({slice_:function(A,g,I){const t=Ke(A,"x","slice","string_or_numeric");if(0===t.rank)throw new Error("Slicing scalar is not possible");const C={x:t},e={begin:g,size:I};return Ge.runKernel(Gt,C,e)}});const vo=Le({tanh_:function(A){const g={x:Ke(A,"x","tanh","float32")};return Ge.runKernel(Pt,g)}});const Vo=Le({basicLSTMCell_:function(A,g,I,t,C,e){const B=Ke(A,"forgetBias","basicLSTMCell"),i=Ke(g,"lstmKernel","basicLSTMCell"),Q=Ke(I,"lstmBias","basicLSTMCell"),o=Ke(t,"data","basicLSTMCell"),E=Ke(C,"c","basicLSTMCell"),n=Ke(e,"h","basicLSTMCell"),s=Ho([o,n],1),a=Ei(s,i),r=JQ(a,Q),h=r.shape[0],c=r.shape[1]/4,l=[h,c],D=To(r,[0,0],l),u=To(r,[0,c],l),w=To(r,[0,2*c],l),d=To(r,[0,3*c],l),p=JQ(xQ(qo(D),vo(u)),xQ(E,qo(JQ(B,w))));return[p,xQ(vo(p),qo(d))]}});const Wo=Le({batchToSpaceND_:function(A,g,I){const t=Ke(A,"x","batchToSpaceND"),C=g.reduce(((A,g)=>A*g));CA(t.rank>=1+g.length,(()=>`input rank is ${t.rank} but should be > than blockShape.length ${g.length}`)),CA(I.length===g.length,(()=>`crops.length is ${I.length} but should be equal to blockShape.length  ${g.length}`)),CA(t.shape[0]%C==0,(()=>`input tensor batch is ${t.shape[0]} but is not divisible by the product of the elements of blockShape ${g.join(" * ")} === ${C}`));const e={x:t},B={blockShape:g,crops:I};return Ge.runKernel(lg,e,B)}});const Oo=Le({batchNorm_:function(A,g,I,t,C,e){null==e&&(e=.001);const B=Ke(A,"x","batchNorm"),i=Ke(g,"mean","batchNorm"),Q=Ke(I,"variance","batchNorm");let o,E;null!=C&&(o=Ke(C,"scale","batchNorm")),null!=t&&(E=Ke(t,"offset","batchNorm")),CA(i.rank===Q.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),CA(null==E||i.rank===E.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),CA(null==o||i.rank===o.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const n={x:function(A){let g;return g=0===A.rank||1===A.rank?Lo(A,[1,1,1,A.size]):2===A.rank?Lo(A,[1,1,A.shape[0],A.shape[1]]):3===A.rank?Lo(A,[1,A.shape[0],A.shape[1],A.shape[2]]):A,g}(B),scale:o,offset:E,mean:i,variance:Q},s={varianceEpsilon:e},a=Ge.runKernel(iI,n,s);return Lo(a,B.shape)}});const Zo=Le({batchNorm2d_:function(A,g,I,t,C,e){const B=Ke(A,"x","batchNorm"),i=Ke(g,"mean","batchNorm"),Q=Ke(I,"variance","batchNorm");let o,E;return null!=C&&(o=Ke(C,"scale","batchNorm")),null!=t&&(E=Ke(t,"offset","batchNorm")),CA(2===B.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${B.rank}.`)),CA(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`)),CA(2===Q.rank||1===Q.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${Q.rank}.`)),null!=o&&CA(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${o.rank}.`)),null!=E&&CA(2===E.rank||1===E.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${E.rank}.`)),Oo(B,i,Q,E,o,e)}});const Po=Le({batchNorm3d_:function(A,g,I,t,C,e){const B=Ke(A,"x","batchNorm"),i=Ke(g,"mean","batchNorm"),Q=Ke(I,"variance","batchNorm");let o,E;return null!=C&&(o=Ke(C,"scale","batchNorm")),null!=t&&(E=Ke(t,"offset","batchNorm")),CA(3===B.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${B.rank}.`)),CA(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`)),CA(3===Q.rank||1===Q.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${Q.rank}.`)),null!=o&&CA(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${o.rank}.`)),null!=E&&CA(3===E.rank||1===E.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${E.rank}.`)),Oo(B,i,Q,E,o,e)}});const Xo=Le({batchNorm4d_:function(A,g,I,t,C,e){const B=Ke(A,"x","batchNorm"),i=Ke(g,"mean","batchNorm"),Q=Ke(I,"variance","batchNorm");let o,E;return null!=C&&(o=Ke(C,"scale","batchNorm")),null!=t&&(E=Ke(t,"offset","batchNorm")),CA(4===B.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${B.rank}.`)),CA(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`)),CA(4===Q.rank||1===Q.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${Q.rank}.`)),null!=o&&CA(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${o.rank}.`)),null!=E&&CA(4===E.rank||1===E.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${E.rank}.`)),Oo(B,i,Q,E,o,e)}});const jo=Le({bincount_:function(A,g,I){const t=Ke(A,"x","bincount"),C=Ke(g,"weights","bincount");CA("int32"===t.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${t.dtype}`)),CA(I>=0,(()=>`size must be non-negative, but got ${I}.`)),CA(C.size===t.size||0===C.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${t.shape}, weights shape: ${C.shape}.`));const e={x:t,weights:C},B={size:I};return Ge.runKernel(Dg,e,B)}});const zo=Le({broadcastArgs_:function(A,g){const I=Ke(A,"s0","broadcastArgs","int32"),t=Ke(g,"s1","broadcastArgs","int32");if(1!==I.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${I.rank}`);if(1!==t.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${t.rank}`);const C={s0:I,s1:t};return Ge.runKernel(wg,C)}});const _o=Le({broadcastTo_:function(A,g){let I=Ke(A,"broadcastTo","x");const t=I.shape;if(g.some((A=>!(A>0)||A%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${g}].`);if(g.length<I.rank)throw new Error(`broadcastTo(): shape.length=${g.length} < input.rank=${I.rank}.`);if(g.length>I.rank){const A=I.shape.slice();for(;A.length<g.length;)A.unshift(1);I=Lo(I,A)}const C=I.shape,e=Array.from(g);for(let A=g.length-1;A>=0;A--)if(C[A]===g[A])e[A]=1;else if(1!==I.shape[A])throw new Error(`broadcastTo(): [${t}] cannot be broadcast to [${g}].`);if(0===e.map(((A,g)=>A>1?g:-1)).filter((A=>A>=0)).length)return TB(I);const B={x:I},i={reps:e};return Ge.runKernel(Xt,B,i)}});const $o=Le({ceil_:function(A){const g={x:Ke(A,"x","ceil","float32")};return Ge.runKernel(pg,g)}});const AE=Le({clipByValue_:function(A,g,I){const t=Ke(A,"x","clipByValue");if(CA(g<=I,(()=>`Error in clip: min (${g}) must be less than or equal to max (${I}).`)),g===I)return _Q(t.shape,g,t.dtype);const C={x:t},e={clipValueMin:g,clipValueMax:I};return Ge.runKernel(yg,C,e)}});const gE=Le({concat1d_:function(A){return Ho(A,0)}});const IE=Le({concat2d_:function(A,g){return Ho(A,g)}});const tE=Le({concat3d_:function(A,g){return Ho(A,g)}});const CE=Le({concat4d_:function(A,g){return Ho(A,g)}});const eE=Le({conv2d_:function(A,g,I,t,C="NHWC",e=[1,1],B){const i=Ke(A,"x","conv2d","float32"),Q=Ke(g,"filter","conv2d","float32");let o=i,E=!1;3===i.rank&&(E=!0,o=Lo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),CA(4===o.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${o.rank}.`)),CA(4===Q.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${Q.rank}.`)),Yo("conv2d",t,B);const n="NHWC"===C?o.shape[3]:o.shape[1];CA(n===Q.shape[2],(()=>`Error in conv2d: depth of input (${n}) must match input depth for filter ${Q.shape[2]}.`)),CA(Ko(I,e),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${I} and dilations '${e}'`));const s={x:o,filter:Q},a={strides:I,pad:t,dataFormat:C,dilations:e,dimRoundingMode:B},r=Ge.runKernel(Fg,s,a);return E?Lo(r,[r.shape[1],r.shape[2],r.shape[3]]):r}});const BE=Le({conv1d_:function(A,g,I,t,C="NWC",e=1,B){const i=Ke(A,"x","conv1d"),Q=Ke(g,"filter","conv1d");let o=i,E=!1;2===i.rank&&(E=!0,o=Lo(i,[1,i.shape[0],i.shape[1]])),CA(3===o.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${o.rank}.`)),CA(3===Q.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${Q.rank}.`)),Yo("conv1d",t,B),CA(o.shape[2]===Q.shape[1],(()=>`Error in conv1d: depth of input (${o.shape[2]}) must match input depth for filter ${Q.shape[1]}.`)),CA(Ko(I,e),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${I} and dilation '${e}'`)),CA("NWC"===C,(()=>`Error in conv1d: got dataFormat of ${C} but only NWC is currently supported.`));const n=Lo(Q,[1,Q.shape[0],Q.shape[1],Q.shape[2]]),s=Lo(o,[o.shape[0],1,o.shape[1],o.shape[2]]),a=eE(s,n,[1,I],t,"NHWC",[1,e],B);return Lo(a,E?[a.shape[2],a.shape[3]]:[a.shape[0],a.shape[2],a.shape[3]])}});const iE=Le({conv2DBackpropInput_:function(A,g,I,t,C,e="NHWC",B){CA(A.length===g.rank,(()=>`Length of inShape (${A.length}) and rank of dy (${g.rank}) must match`));let i=A,Q=g,o=!1;3===g.rank&&(o=!0,Q=Lo(g,[1,g.shape[0],g.shape[1],g.shape[2]]),i=[1,A[0],A[1],A[2]]),CA(4===i.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`)),CA(4===Q.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${Q.rank}`)),CA(4===I.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${I.rank}`));const E="NHWC"===e?i[3]:i[1],n="NHWC"===e?Q.shape[3]:Q.shape[1];CA(E===I.shape[2],(()=>`Error in conv2dDerInput: depth of input (${E}) must match input depth for filter ${I.shape[2]}.`)),CA(n===I.shape[3],(()=>`Error in conv2dDerInput: depth of output (${n}) must match output depth for filter ${I.shape[3]}.`)),Yo("conv2dDerInput",C,B);const s={dy:Q,filter:I},a={strides:t,pad:C,dataFormat:e,dimRoundingMode:B,inputShape:i},r=Ge.runKernel(mg,s,a);return o?Lo(r,[r.shape[1],r.shape[2],r.shape[3]]):r}});const QE=Le({conv2dTranspose_:function(A,g,I,t,C,e){const B=Ke(A,"x","conv2dTranspose"),i=Ke(g,"filter","conv2dTranspose");return iE(I,B,i,t,C,"NHWC",e)}});const oE=Le({conv3d_:function(A,g,I,t,C="NDHWC",e=[1,1,1]){const B=Ke(A,"x","conv3d"),i=Ke(g,"filter","conv3d");let Q=B,o=!1;4===B.rank&&(o=!0,Q=Lo(B,[1,B.shape[0],B.shape[1],B.shape[2],B.shape[3]])),CA(5===Q.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${Q.rank}.`)),CA(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),CA(Q.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${Q.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),CA(Ko(I,e),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${I} and dilations '${e}'`)),CA("NDHWC"===C,(()=>`Error in conv3d: got dataFormat of ${C} but only NDHWC is currently supported.`));const E={x:Q,filter:i},n={strides:I,pad:t,dataFormat:C,dilations:e},s=Ge.runKernel(kg,E,n);return o?Lo(s,[s.shape[1],s.shape[2],s.shape[3],s.shape[4]]):s}});const EE=Le({conv3DBackpropInput_:function(A,g,I,t,C){CA(A.length===g.rank,(()=>`Length of inShape (${A.length}) and rank of dy (${g.rank}) must match`));let e=A,B=g,i=!1;4===g.rank&&(i=!0,B=Lo(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]]),e=[1,A[0],A[1],A[2],A[3]]);const Q=e[4],o=B.shape[4];CA(5===e.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${e.length}.`)),CA(5===B.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${B.rank}`)),CA(5===I.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${I.rank}`)),CA(Q===I.shape[3],(()=>`Error in conv3dDerInput: depth of input (${Q}) must match input depth for filter ${I.shape[3]}.`)),CA(o===I.shape[4],(()=>`Error in conv3dDerInput: depth of output (${o}) must match output depth for filter ${I.shape[4]}.`));const E={dy:B,filter:I},n={pad:C,strides:t,inputShape:e},s=Ge.runKernel(Mg,E,n);return i?Lo(s,[s.shape[1],s.shape[2],s.shape[3],s.shape[4]]):s}});const nE=Le({conv3dTranspose_:function(A,g,I,t,C){const e=Ke(A,"x","conv3dTranspose"),B=Ke(g,"filter","conv3dTranspose");return EE(I,e,B,t,C)}});const sE=Le({cos_:function(A){const g={x:Ke(A,"x","cos","float32")};return Ge.runKernel(Ug,g)}});const aE=Le({cosh_:function(A){const g={x:Ke(A,"x","cosh","float32")};return Ge.runKernel(Kg,g)}});const rE=Le({cumprod_:function(A,g=0,I=!1,t=!1){const C={x:Ke(A,"x","cumprod")},e={axis:g,exclusive:I,reverse:t};return Ge.runKernel(Jg,C,e)}});const hE=Le({cumsum_:function(A,g=0,I=!1,t=!1){const C={x:Ke(A,"x","cumsum")},e={axis:g,exclusive:I,reverse:t};return Ge.runKernel(Yg,C,e)}});const cE=Le({denseBincount_:function(A,g,I,t=!1){const C=Ke(A,"x","denseBincount"),e=Ke(g,"weights","denseBincount");CA("int32"===C.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${C.dtype}`)),CA(C.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${C.rank}.`)),CA(I>=0,(()=>`size must be non-negative, but got ${I}.`)),CA(e.size===C.size||0===e.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${C.shape}, weights shape: ${e.shape}.`));const B={x:C,weights:e},i={size:I,binaryOutput:t};return Ge.runKernel(xg,B,i)}});const lE=Le({depthToSpace_:function(A,g,I="NHWC"){const t=Ke(A,"x","depthToSpace","float32"),C="NHWC"===I?t.shape[1]:t.shape[2],e="NHWC"===I?t.shape[2]:t.shape[3],B="NHWC"===I?t.shape[3]:t.shape[1];CA(g>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${g}`)),CA(C*g>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${C} and ${g}  for depthToSpace with input shape\n    ${t.shape}`)),CA(e*g>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${e} and ${g} for depthToSpace with input shape\n        ${t.shape}`)),CA(B%(g*g)==0,(()=>`Dimension size must be evenly divisible by ${g*g} but is ${B} for depthToSpace with input shape ${t.shape}`));const i={x:t},Q={blockSize:g,dataFormat:I};return Ge.runKernel(bg,i,Q)}});const DE=Le({depthwiseConv2d_:function(A,g,I,t,C="NHWC",e=[1,1],B){const i=Ke(A,"x","depthwiseConv2d","float32"),Q=Ke(g,"filter","depthwiseConv2d","float32");let o=i,E=!1;3===i.rank&&(E=!0,o=Lo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),CA(4===o.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${o.rank}.`)),CA(4===Q.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${Q.rank}.`));const n="NHWC"===C?o.shape[3]:o.shape[1];CA(n===Q.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${n}) must match the inChannels dimension in filter ${Q.shape[2]}.`)),Yo("depthwiseConv2d",t,B);const s={x:o,filter:Q},a={strides:I,pad:t,dataFormat:C,dilations:e,dimRoundingMode:B},r=Ge.runKernel(Hg,s,a);return E?Lo(r,[r.shape[1],r.shape[2],r.shape[3]]):r}});const uE=Le({diag_:function(A){const g={x:Ke(A,"x","diag")};return Ge.runKernel(vg,g)}});const wE=Le({dilation2d_:function(A,g,I,t,C=[1,1],e="NHWC"){const B=Ke(A,"x","dilation2d"),i=Ke(g,"filter","dilation2d");CA(3===B.rank||4===B.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${B.rank}.`)),CA(3===i.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`)),CA("NHWC"===e,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${e}`));let Q=B,o=!1;3===B.rank&&(Q=Lo(B,[1,B.shape[0],B.shape[1],B.shape[2]]),o=!0);const E={x:Q,filter:i},n={strides:I,pad:t,dilations:C},s=Ge.runKernel(Vg,E,n);return o?Lo(s,[s.shape[1],s.shape[2],s.shape[3]]):s}});const dE=Le({equal_:function(A,g){let I=Ke(A,"a","equal","string_or_numeric"),t=Ke(g,"b","equal","string_or_numeric");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(_g,C)}});const pE=Le({where_:function(A,g,I){const t=Ke(g,"a","where"),C=Ke(I,"b","where"),e=Ke(A,"condition","where","bool"),B=Hi(Hi(e.shape,t.shape),C.shape),i={condition:_o(e,B),t:_o(t,B),e:_o(C,B)};return Ge.runKernel(pt,i)}});const yE=Le({divNoNan_:function(A,g){let I=Ke(A,"a","div"),t=Ke(g,"b","div");[I,t]=he(I,t);const C=LQ(I,t),e=qQ(C),B=dE(t,e);return pE(B,e,C)}});const GE=Le({dot_:function(A,g){const I=Ke(A,"t1","dot"),t=Ke(g,"t2","dot");CA(!(1!==I.rank&&2!==I.rank||1!==t.rank&&2!==t.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${I.rank} and ${t.rank}.`));const C=1===I.rank?I.size:I.shape[1],e=1===t.rank?t.size:t.shape[0];if(CA(C===e,(()=>`Error in dot: inner dimensions of inputs must match, but got ${C} and ${e}.`)),1===I.rank&&1===t.rank){const A=Lo(I,[1,-1]),g=Lo(t,[-1,1]),C=Ei(A,g);return Lo(C,[])}if(1===I.rank&&2===t.rank){const A=Lo(I,[1,-1]),g=Lo(t,[t.shape[0],t.shape[1]]),C=Ei(A,g);return Lo(C,[C.size])}if(2===I.rank&&1===t.rank){const A=Lo(t,[-1,1]),g=Ei(I,A);return Lo(g,[g.size])}{const A=Lo(t,[t.shape[0],t.shape[1]]);return Ei(I,A)}}});const fE=Le({einsum_:function(A,...g){const I=g.map(((A,g)=>Ke(A,`tensors${g}`,"einsum"))),t={equation:A};return Ge.runKernel(Pg,I,t)}});const NE=Le({elu_:function(A){const g={x:Ke(A,"x","elu","float32")};return Ge.runKernel(Xg,g)}});const FE=Le({erf_:function(A){let g=Ke(A,"x","erf");CA("int32"===g.dtype||"float32"===g.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===g.dtype&&(g=qB(g,"float32"));const I={x:g};return Ge.runKernel(zg,I)}});function RE(A,g){for(let I=0;I<A.length;++I)if(A[A.length-I-1]!==g-1-I)return!1;return!0}function mE(A,g,I){const t=A.length+g.length,C=[];let e=0,B=0;for(let i=0;i<t;i++)-1===I.indexOf(i)?C.push(A[e++]):C.push(g[B++]);return C}function kE(A,g){const I=[],t=A.length;for(let C=0;C<t;C++)-1===g.indexOf(C)&&I.push(A[C]);return[I,g.map((g=>A[g]))]}function SE(A,g){return mE(A,g.map((A=>1)),g)}function ME(A,g,I){CA(RE(g,I),(()=>`${A} supports only inner-most axes for now. Got axes ${g} and rank-${I} input.`))}function UE(A,g){if(RE(A,g))return null;const I=[];for(let t=0;t<g;++t)-1===A.indexOf(t)&&I.push(t);return A.forEach((A=>I.push(A))),I}function KE(A){return A.map(((A,g)=>[g,A])).sort(((A,g)=>A[1]-g[1])).map((A=>A[0]))}function JE(A,g){const I=[];for(let t=g-A;t<g;++t)I.push(t);return I}const YE=Le({max_:function(A,g=null,I=!1){const t={x:Ke(A,"x","max")},C={reductionIndices:g,keepDims:I};return Ge.runKernel(MI,t,C)}});const LE=Le({min_:function(A,g=null,I=!1){const t={x:Ke(A,"x","min")},C={axis:g,keepDims:I};return Ge.runKernel(HI,t,C)}});const xE=Le({sum_:function(A,g=null,I=!1){let t=Ke(A,"x","sum");"bool"===t.dtype&&(t=qB(t,"int32"));const C={x:t},e={axis:g,keepDims:I};return Ge.runKernel(St,C,e)}});function bE(A,g,I=null){if(0===A.rank)return to(A);if(1!==A.rank&&null===I)return bE(Lo(A,[-1]),g,I);if(1===A.rank||"number"==typeof I||Array.isArray(I)&&1===I.length){if(1===g)return xE(to(A),I);if(g===1/0)return YE(to(A),I);if(g===-1/0)return LE(to(A),I);if("euclidean"===g||2===g)return bQ(xE(Ao(to(A),XQ(2,"int32")),I));throw new Error(`Error in norm: invalid ord value: ${g}`)}if(Array.isArray(I)&&2===I.length){if(1===g)return YE(xE(to(A),I[0]),I[1]-1);if(g===1/0)return YE(xE(to(A),I[1]),I[0]);if(g===-1/0)return LE(xE(to(A),I[1]),I[0]);if("fro"===g||"euclidean"===g)return bQ(xE(HQ(A),I));throw new Error(`Error in norm: invalid ord value: ${g}`)}throw new Error(`Error in norm: invalid axis: ${I}`)}const HE=Le({norm_:function(A,g="euclidean",I=null,t=!1){const C=bE(A=Ke(A,"x","norm"),g,I);let e=C.shape;if(t){const g=DA(I,A.shape);e=SE(C.shape,g)}return Lo(C,e)}});const qE=Le({euclideanNorm_:function(A,g=null,I=!1){return HE(A,"euclidean",g,I)}});const TE=Le({exp_:function(A){const g={x:Ke(A,"x","exp")};return Ge.runKernel($g,g)}});const vE=Le({expandDims_:function(A,g=0){const I=Ke(A,"x","expandDims","string_or_numeric");CA(g<=I.rank,(()=>"Axis must be <= rank of the tensor"));const t={input:I},C={dim:g};return Ge.runKernel(AI,t,C)}});const VE=Le({expm1_:function(A){const g={x:Ke(A,"x","expm1")};return Ge.runKernel(gI,g)}});const WE=Le({tile_:function(A,g){const I=Ke(A,"x","tile","string_or_numeric");CA(I.rank===g.length,(()=>`Error in transpose: rank of input ${I.rank} must match length of reps ${g}.`));const t={x:I},C={reps:g};return Ge.runKernel(Xt,t,C)}});const OE=Le({eye_:function(A,g,I,t="float32"){null==g&&(g=A);const C=HB([A,g],t),e=A<=g?A:g;for(let A=0;A<e;++A)C.set(1,A,A);const B=Lo(C.toTensor(),[A,g]);if(null==I)return B;if(1===I.length)return WE(vE(B,0),[I[0],1,1]);if(2===I.length)return WE(vE(vE(B,0),0),[I[0],I[1],1,1]);if(3===I.length)return WE(vE(vE(vE(B,0),0),0),[I[0],I[1],I[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${I.length}D.`)}});const ZE=Le({floor_:function(A){const g={x:Ke(A,"x","floor","float32")};return Ge.runKernel(eI,g)}});const PE=Le({gather_:function(A,g,I=0,t=0){const C={x:Ke(A,"x","gather"),indices:Ke(g,"indices","gather","int32")},e={axis:I,batchDims:t};return Ge.runKernel(QI,C,e)}});const XE=Le({greater_:function(A,g){let I=Ke(A,"a","greater","string_or_numeric"),t=Ke(g,"b","greater","string_or_numeric");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(EI,C)}});const jE=Le({greaterEqual_:function(A,g){let I=Ke(A,"a","greaterEqual","string_or_numeric"),t=Ke(g,"b","greaterEqual","string_or_numeric");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(nI,C)}});const zE=Le({isFinite_:function(A){const g={x:Ke(A,"x","isFinite")};return Ge.runKernel(hI,g)}});const _E=Le({isInf_:function(A){const g={x:Ke(A,"x","isInf")};return Ge.runKernel(cI,g)}});const $E=Le({isNaN_:function(A){const g={x:Ke(A,"x","isNaN")};return Ge.runKernel(lI,g)}});const An=Le({leakyRelu_:function(A,g=.2){const I={x:Ke(A,"x","leakyRelu")},t={alpha:g};return Ge.runKernel(DI,I,t)}});const gn=Le({less_:function(A,g){let I=Ke(A,"a","less","string_or_numeric"),t=Ke(g,"b","less","string_or_numeric");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(uI,C)}});const In=Le({lessEqual_:function(A,g){let I=Ke(A,"a","lessEqual","string_or_numeric"),t=Ke(g,"b","lessEqual","string_or_numeric");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(wI,C)}});function tn(A,g,I){if(I<=0)throw new Error("The number of values should be positive.");const t={start:A,stop:g,num:I};return Ge.runKernel(dI,{},t)}const Cn=Le({localResponseNormalization_:function(A,g=5,I=1,t=1,C=.5){const e=Ke(A,"x","localResponseNormalization");CA(4===e.rank||3===e.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${e.rank}.`)),CA(nA(g),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${g}.`));let B=e,i=!1;3===e.rank&&(i=!0,B=Lo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const Q={x:B},o={depthRadius:g,bias:I,alpha:t,beta:C},E=Ge.runKernel(kI,Q,o);return i?Lo(E,[E.shape[1],E.shape[2],E.shape[3]]):E}});const en=Le({log_:function(A){const g={x:Ke(A,"x","log","float32")};return Ge.runKernel(pI,g)}});const Bn=Le({log1p_:function(A){const g={x:Ke(A,"x","log1p")};return Ge.runKernel(yI,g)}});const Qn=Le({softplus_:function(A){const g={x:Ke(A,"x","softplus")};return Ge.runKernel(mt,g)}});const on=Le({logSigmoid_:function(A){const g=Ke(A,"x","logSigmoid");return ZQ((A=>({value:Ki(Qn(Ki(A))),gradFunc:g=>xQ(g,qo(Ki(A)))})))(g)}});const En=Le({logSoftmax_:function(A,g=-1){const I=Ke(A,"logits","logSoftmax");if(-1===g&&(g=I.rank-1),g!==I.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${I.rank} and axis was ${g}`);const t=ZQ(((A,I)=>{const t=YE(A,g,!0),C=go(A,t),e=go(qB(C,"float32"),en(xE(TE(C),g,!0)));I([e]);return{value:e,gradFunc:(A,I)=>{const[t]=I,C=TE(t);return go(A,xQ(xE(A,g,!0),C))}}}));return t(I)}});const nn=Le({logSumExp_:function(A,g=null,I=!1){const t=Ke(A,"x","logSumExp"),C=DA(g,t.shape),e=YE(t,C,!0),B=go(t,e),i=TE(B),Q=xE(i,C),o=en(Q),E=JQ(Lo(e,o.shape),o);if(I){const A=SE(E.shape,C);return Lo(E,A)}return E}});const sn=Le({logicalAnd_:function(A,g){const I=Ke(A,"a","logicalAnd","bool"),t=Ke(g,"b","logicalAnd","bool");Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(GI,C)}});const an=Le({logicalNot_:function(A){const g={x:Ke(A,"x","logicalNot","bool")};return Ge.runKernel(fI,g)}});const rn=Le({logicalOr_:function(A,g){const I=Ke(A,"a","logicalOr","bool"),t=Ke(g,"b","logicalOr","bool");Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(NI,C)}});const hn=Le({logicalXor_:function(A,g){const I=Ke(A,"a","logicalXor","bool"),t=Ke(g,"b","logicalXor","bool");return Hi(I.shape,t.shape),sn(rn(A,g),an(sn(A,g)))}}),cn=2147483648;const ln=Le({searchSorted_:function(A,g,I="left"){const t=Ke(A,"sortedSequence","searchSorted"),C=Ke(g,"values","searchSorted"),e=t.shape[t.shape.length-1],B=C.shape[C.shape.length-1],i=Lo(t,[-1,e]),Q=Lo(C,[-1,B]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==Q.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(QA(Q.shape)>=cn)throw new Error("values tensor size must less than 2147483648");if(i.shape[1]>=cn)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${i.shape[1]}`);const o={sortedSequence:i,values:Q},E={side:I};return Ge.runKernel(dt,o,E)}});function Dn(A,g){return ln(A,g,"left")}const un=Le({maxPool_:function(A,g,I,t,C){const e=Ke(A,"x","maxPool");let B=e,i=!1;3===e.rank&&(i=!0,B=Lo(e,[1,e.shape[0],e.shape[1],e.shape[2]])),CA(4===B.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${B.rank}.`)),CA(Ko(I,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${I} and dilations '1'`)),Yo("maxPool",t,C);const Q={x:B},o={filterSize:g,strides:I,pad:t,dimRoundingMode:C},E=Ge.runKernel(KI,Q,o);return i?Lo(E,[E.shape[1],E.shape[2],E.shape[3]]):E}});const wn=Le({maxPool3d_:function(A,g=[1,1,1],I,t,C,e="NDHWC"){const B=Ke(A,"x","maxPool3d");let i=B,Q=!1;4===B.rank&&(Q=!0,i=Lo(B,[1,B.shape[0],B.shape[1],B.shape[2],B.shape[3]])),CA(5===i.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`)),CA("NDHWC"===e,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${e}`)),Yo("maxPool3d",t,C);const o={x:i},E={filterSize:g,strides:I,pad:t,dimRoundingMode:C,dataFormat:e},n=Ge.runKernel(YI,o,E);return Q?Lo(n,[n.shape[1],n.shape[2],n.shape[3],n.shape[4]]):n}});const dn=Le({maxPoolWithArgmax_:function(A,g,I,t,C=!1){const e={x:Ke(A,"x","maxPoolWithArgmax")},B={filterSize:g,strides:I,pad:t,includeBatchInIndex:C},i=Ge.runKernel(xI,e,B);return{result:i[0],indexes:i[1]}}});const pn=Le({mean_:function(A,g=null,I=!1){const t={x:Ke(A,"x","mean")},C={axis:g,keepDims:I};return Ge.runKernel(bI,t,C)}});function yn(A,g="float32"){if("complex64"===g){const g=yn(A,"float32"),I=yn(A,"float32");return xe(g,I)}const I=xA(QA(A),g);return Ge.makeTensor(I,A,g)}function Gn(A,g="float32"){if("complex64"===g){const g=Gn(A,"float32"),I=yn(A,"float32");return xe(g,I)}const I=LA(QA(A),g);return Ge.makeTensor(I,A,g)}function fn(A,g,{indexing:I="xy"}={}){if("xy"!==I&&"ij"!==I)throw new TypeError(`${I} is not a valid third argument to meshgrid`);if(void 0===A)return[];let t=Ke(A,"x","meshgrid",A instanceof Ce?A.dtype:"float32");if(void 0===g)return[t];let C=Ke(g,"y","meshgrid",g instanceof Ce?g.dtype:"float32");const e=QA(t.shape),B=QA(C.shape);return"xy"===I?(t=Lo(t,[1,-1]),C=Lo(C,[-1,1]),[Ei(Gn([B,1],t.dtype),t),Ei(C,Gn([1,e],C.dtype))]):(t=Lo(t,[-1,1]),C=Lo(C,[1,-1]),[Ei(t,Gn([1,B],t.dtype)),Ei(Gn([e,1],C.dtype),C)])}const Nn=Le({minimum_:function(A,g){let I=Ke(A,"a","minimum"),t=Ke(g,"b","minimum");[I,t]=he(I,t),"bool"===I.dtype&&(I=qB(I,"int32"),t=qB(t,"int32")),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(qI,C)}});const Fn=Le({mirrorPad_:function(A,g,I){CA("reflect"===I||"symmetric"===I,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${I}.`));const t=Ke(A,"x","mirrorPad");if(0===t.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");CA(g.length===t.rank,(()=>`Padding doesn't match input. Must be ${t.rank}. Got ${g.length}.`));const C="reflect"===I?1:0;for(let A=0;A<t.rank;A++)CA(2===g[A].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),CA(g[A][0]>=0&&g[A][0]<=t.shape[A]-C&&g[A][1]>=0&&g[A][1]<=t.shape[A]-C,(()=>`Padding in dimension ${A} cannot be greater than or equal to ${t.shape[A]-C} or less than 0 for input of shape ${t.shape}`));const e={paddings:g,mode:I},B={x:t};return Ge.runKernel(TI,B,e)}});const Rn=Le({mod_:function(A,g){let I=Ke(A,"a","mod"),t=Ke(g,"b","mod");[I,t]=he(I,t);const C={a:I,b:t};return Ge.runKernel(vI,C)}});const mn=Le({moments_:function(A,g=null,I=!1){const t=DA(g,(A=Ke(A,"x","moments")).shape),C=pn(A,t,I);let e=C.shape;I||(e=SE(C.shape,t));const B=HQ(go(qB(A,"float32"),Lo(C,e)));return{mean:C,variance:pn(B,t,I)}}});const kn=Le({multiRNNCell_:function(A,g,I,t){const C=Ke(g,"data","multiRNNCell"),e=Je(I,"c","multiRNNCell"),B=Je(t,"h","multiRNNCell");let i=C;const Q=[];for(let g=0;g<A.length;g++){const I=A[g](i,e[g],B[g]);Q.push(I[0]),Q.push(I[1]),i=I[1]}const o=[],E=[];for(let A=0;A<Q.length;A+=2)o.push(Q[A]),E.push(Q[A+1]);return[o,E]}});const Sn=Le({multinomial_:function(A,g,I,t=!1){const C=Ke(A,"logits","multinomial"),e=C.size,B=C.rank;if(e<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${e}.`);if(B>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${B}`);I=I||Math.random();const i={logits:1===B?Lo(C,[1,-1]):C},Q={numSamples:g,seed:I,normalized:t},o=Ge.runKernel(VI,i,Q);return 1===B?Lo(o,[o.size]):o}});const Mn=Le({notEqual_:function(A,g){let I=Ke(A,"a","notEqual","string_or_numeric"),t=Ke(g,"b","notEqual","string_or_numeric");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(ZI,C)}});const Un=Le({onesLike_:function(A){const g={x:Ke(A,"x","onesLike")};return Ge.runKernel(zI,g)}});const Kn=Le({outerProduct_:function(A,g){const I=Ke(A,"v1","outerProduct"),t=Ke(g,"v2","outerProduct");CA(1===I.rank&&1===t.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${I.rank} and ${t.rank}.`));const C=Lo(I,[-1,1]),e=Lo(t,[1,-1]);return Ei(C,e)}});const Jn=Le({pad_:function(A,g,I=0){const t=Ke(A,"x","pad");if(0===t.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const C={paddings:g,constantValue:I},e={x:t};return Ge.runKernel(At,e,C)}});const Yn=Le({pad1d_:function(A,g,I=0){return CA(2===g.length,(()=>"Invalid number of paddings. Must be length of 2.")),Jn(A,[g],I)}});const Ln=Le({pad2d_:function(A,g,I=0){return CA(2===g.length&&2===g[0].length&&2===g[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Jn(A,g,I)}});const xn=Le({pad3d_:function(A,g,I=0){return CA(3===g.length&&2===g[0].length&&2===g[1].length&&2===g[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Jn(A,g,I)}});const bn=Le({pad4d_:function(A,g,I=0){return CA(4===g.length&&2===g[0].length&&2===g[1].length&&2===g[2].length&&2===g[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Jn(A,g,I)}});const Hn=Le({spaceToBatchND_:function(A,g,I){const t=Ke(A,"x","spaceToBatchND");CA(t.rank>=1+g.length,(()=>`input rank ${t.rank} should be > than [blockShape] ${g.length}`)),CA(I.length===g.length,(()=>`paddings.shape[0] ${I.length} must be equal to [blockShape] ${g.length}`)),CA(t.shape.reduce(((A,t,C)=>C>0&&C<=g.length?A&&(t+I[C-1][0]+I[C-1][1])%g[C-1]==0:A),!0),(()=>`input spatial dimensions ${t.shape.slice(1)} with paddings ${I.toString()} must be divisible by blockShapes ${g.toString()}`));const C={x:t},e={blockShape:g,paddings:I};return Ge.runKernel(Mt,C,e)}});const qn=Le({pool_:function(A,g,I,t,C,e,B){null==C&&(C=[1,1]),null==e&&(e=1),0===t&&(t="valid");const i=Ke(A,"x","maxPool");let Q=i,o=!1;3===i.rank&&(o=!0,Q=Lo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),CA(Ko(e,C),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${e} and dilations '${C}'`));const E=Go(Q.shape,g,e,C,t),n=[E.dilationHeight,E.dilationWidth];let s;s="same"===t?function(A,g){const I=A.map(((A,I)=>A+(A-1)*(g[I]-1))),t=I.map((A=>A-1)),C=t.map((A=>Math.floor(A/2))),e=t.map(((A,g)=>A-C[g]));return t.map(((A,g)=>[C[g],e[g]]))}([E.filterHeight,E.filterWidth],n):[[0,0],[0,0]];const a=1===n[0]&&1===n[1],[r,h]=function(A,g,I){const t=I.map((A=>A[0])),C=I.map((A=>A[1])),e=A.concat(t,C),B=g.map(((A,g)=>(A-e[g]%A)%A)),i=C.map(((A,g)=>A+B[g])),Q=g.map(((A,g)=>[t[g],i[g]])),o=g.map(((A,g)=>[0,B[g]]));return[Q,o]}([E.inHeight,E.inWidth],n,s),c=a?t:"valid",l=a?Q:Hn(Q,n,r),D=("avg"===I?()=>xo(l,g,e,c,B):()=>un(l,g,e,c,B))(),u=a?D:Wo(D,n,h);return o?Lo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Tn=Le({prelu_:function(A,g){const I={x:Ke(A,"x","prelu"),alpha:Ke(g,"alpha","prelu")};return Ge.runKernel(tt,I)}});const vn=Le({prod_:function(A,g=null,I=!1){let t=Ke(A,"x","prod");"bool"===t.dtype&&(t=qB(t,"int32"));const C={x:t},e={axis:g,keepDims:I};return Ge.runKernel(Ct,C,e)}});const Vn=Le({raggedGather_:function(A,g,I,t){const C={paramsNestedSplits:A.map(((A,g)=>Ke(A,`tensors${g}`,"raggedGather","int32"))),paramsDenseValues:Ke(g,"paramsDenseValues","raggedGather"),indices:Ke(I,"indices","raggedGather","int32")},e={outputRaggedRank:t},B=Ge.runKernel(et,C,e);return{outputNestedSplits:B.slice(0,B.length-1),outputDenseValues:B[B.length-1]}}});const Wn=Le({raggedTensorToTensor_:function(A,g,I,t,C){const e=Ke(A,"shape","raggedTensorToTensor","int32"),B=Ke(g,"values","raggedTensorToTensor"),i={shape:e,values:B,defaultValue:Ke(I,"defaultValue","raggedTensorToTensor",B.dtype),rowPartitionTensors:t.map(((A,g)=>Ke(A,`tensors${g}`,"raggedTensorToTensor","int32")))},Q={rowPartitionTypes:C};return Ge.runKernel(Bt,i,Q)}});const On=Le({rand_:function(A,g,I){const t=QA(A);let C=null;if(null==I||"float32"===I)C=new Float32Array(t);else if("int32"===I)C=new Int32Array(t);else{if("bool"!==I)throw new Error(`Unknown data type ${I}`);C=new Uint8Array(t)}for(let A=0;A<t;A++)C[A]=g();return Ge.makeTensor(C,A,I)}});var Zn=I(377);class Pn{constructor(A,g,I,t,C){this.mean=A,this.stdDev=g,this.dtype=I,this.nextVal=NaN,this.truncated=t,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const e=C||Math.random();this.random=Zn.alea(e.toString())}nextValue(){if(!isNaN(this.nextVal)){const A=this.nextVal;return this.nextVal=NaN,A}let A,g,I=!1;for(;!I;){let t,C,e;do{t=2*this.random()-1,C=2*this.random()-1,e=t*t+C*C}while(e>=1||0===e);const B=Math.sqrt(-2*Math.log(e)/e);A=this.mean+this.stdDev*t*B,g=this.mean+this.stdDev*C*B,this.truncated&&!this.isValidTruncated(A)||(I=!0)}return this.truncated&&!this.isValidTruncated(g)||(this.nextVal=this.convertValue(g)),this.convertValue(A)}convertValue(A){return null==this.dtype||"float32"===this.dtype?A:Math.round(A)}isValidTruncated(A){return A<=this.upper&&A>=this.lower}}class Xn{constructor(A,g,I,t){this.alpha=A,this.beta=1/g,this.dtype=I;const C=t||Math.random();this.randu=Zn.alea(C.toString()),this.randn=new Pn(0,1,I,!1,this.randu()),this.d=A<1?A+2/3:A-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let A,g,I,t,C,e;for(;;){do{t=this.randn.nextValue(),e=1+this.c*t}while(e<=0);if(e*=e*e,A=t*t,g=1-.331*A*A,I=.5*A+this.d*(1-e+Math.log(e)),C=this.randu(),C<g||Math.log(C)<I)break}return e=1/this.beta*this.d*e,this.alpha<1&&(e*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(e)}convertValue(A){return"float32"===this.dtype?A:Math.round(A)}}class jn{constructor(A=0,g=1,I,t){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=A,this.range=g-A,this.dtype=I,null==t&&(t=Math.random()),"number"==typeof t&&(t=t.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${A} - ${g} <= 1 and dtype is not float`);this.random=Zn.alea(t)}convertValue(A){return this.canReturnFloat()?A:Math.round(A)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const zn=Le({randomGamma_:function(A,g,I=1,t="float32",C){if(null==I&&(I=1),null==t&&(t="float32"),"float32"!==t&&"int32"!==t)throw new Error(`Unsupported data type ${t}`);const e=new Xn(g,I,t,C),B=HB(A,t);for(let A=0;A<B.values.length;A++)B.values[A]=e.nextValue();return B.toTensor()}});const _n=Le({randomNormal_:function(A,g=0,I=1,t,C){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);const e=new Pn(g,I,t,!1,C),B=HB(A,t);for(let A=0;A<B.values.length;A++)B.values[A]=e.nextValue();return B.toTensor()}});const $n=Le({randomStandardNormal_:function(A,g,I){if(null!=g&&"bool"===g)throw new Error(`Unsupported data type ${g}`);return _n(A,0,1,g,I)}});const As=Le({randomUniform_:function(A,g=0,I=1,t="float32",C){const e=HB(A,t),B=new jn(g,I,null,C);for(let A=0;A<e.values.length;A++)e.values[A]=B.nextValue();return e.toTensor()}});function gs(A,g,I=1,t="float32"){if(0===I)throw new Error("Cannot have a step of zero");const C={start:A,stop:g,step:I,dtype:t};return Ge.runKernel(it,{},C)}const Is=Le({reciprocal_:function(A){const g={x:Ke(A,"x","reciprocal")};return Ge.runKernel(ot,g)}});const ts=Le({relu_:function(A){const g={x:Ke(A,"x","relu")};return Ge.runKernel(Et,g)}});const Cs=Le({relu6_:function(A){const g={x:Ke(A,"x","relu6")};return Ge.runKernel(ct,g)}});const es=Le({reverse_:function(A,g){const I={x:Ke(A,"x","reverse")},t={dims:g};return Ge.runKernel(lt,I,t)}});const Bs=Le({reverse1d_:function(A){const g=Ke(A,"x","reverse");return CA(1===g.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${g.rank}.`)),es(g,0)}});const is=Le({reverse2d_:function(A,g){const I=Ke(A,"x","reverse");return CA(2===I.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${I.rank}.`)),es(I,g)}});const Qs=Le({reverse3d_:function(A,g){const I=Ke(A,"x","reverse");return CA(3===I.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${I.rank}.`)),es(I,g)}});const os=Le({reverse4d_:function(A,g){const I=Ke(A,"x","reverse");return CA(4===I.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${I.rank}.`)),es(I,g)}});const Es=Le({round_:function(A){const g={x:Ke(A,"x","round")};return Ge.runKernel(Dt,g)}});const ns=Le({rsqrt_:function(A){const g={x:Ke(A,"x","rsqrt","float32")};return Ge.runKernel(ut,g)}});const ss=Le({selu_:function(A){const g={x:Ke(A,"x","selu")};return Ge.runKernel(yt,g)}});const as=Le({separableConv2d_:function(A,g,I,t,C,e=[1,1],B="NHWC"){const i=Ke(A,"x","separableConv2d"),Q=Ke(g,"depthwiseFilter","separableConv2d"),o=Ke(I,"pointwiseFilter","separableConv2d");let E=i,n=!1;if(3===i.rank&&(n=!0,E=Lo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===B)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");CA(4===E.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${E.rank}.`)),CA(4===Q.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${Q.rank}.`)),CA(4===o.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${Q.rank}.`)),CA(1===o.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${o.shape[0]}.`)),CA(1===o.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${o.shape[1]}.`));const s=Q.shape[2],a=Q.shape[3];CA(o.shape[2]===s*a,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${s*a}, but got ${o.shape[2]}.`));const r=DE(E,Q,t,C,B,e),h=eE(r,o,1,"valid",B);return n?Lo(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const rs=async function(A,g){const I=Ke(A,"x","setdiff1d"),t=Ke(g,"y","setdiff1d");CA(I.dtype===t.dtype,(()=>`x and y should have the same dtype, but got x (${I.dtype}) and y (${t.dtype}).`)),CA(1===I.rank,(()=>`x should be 1D tensor, but got x (${I.shape}).`)),CA(1===t.rank,(()=>`y should be 1D tensor, but got y (${t.shape}).`));const C=await I.data(),e=await t.data(),B=new Set(e);let i=0;for(let A=0;A<C.length;A++)B.has(C[A])||i++;const Q=new Ae([i],I.dtype),o=new Ae([i],"int32");for(let A=0,g=0;A<C.length;A++)B.has(C[A])||(Q.values[g]=C[A],o.values[g]=A,g++);return[Q.toTensor(),o.toTensor()]};const hs=Le({sign_:function(A){const g={x:Ke(A,"x","sign")};return Ge.runKernel(Ft,g)}});const cs=Le({sin_:function(A){const g={x:Ke(A,"x","sin","float32")};return Ge.runKernel(ft,g)}});const ls=Le({sinh_:function(A){const g={x:Ke(A,"x","sinh")};return Ge.runKernel(Nt,g)}});const Ds=Le({slice1d_:function(A,g,I){const t=Ke(A,"x","slice1d");return CA(1===t.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${t.rank} tensor`)),To(t,[g],[I])}});const us=Le({slice2d_:function(A,g,I){const t=Ke(A,"x","slice2d");return CA(2===t.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${t.rank} tensor`)),To(t,g,I)}});const ws=Le({slice3d_:function(A,g,I){const t=Ke(A,"x","slice3d");return CA(3===t.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${t.rank} tensor`)),To(t,g,I)}});const ds=Le({slice4d_:function(A,g,I){const t=Ke(A,"x","slice4d");return CA(4===t.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${t.rank} tensor`)),To(t,g,I)}});const ps=Le({softmax_:function(A,g=-1){const I=Ke(A,"logits","softmax","float32");if(-1===g&&(g=I.rank-1),g!==I.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${I.rank} and dim was ${g}`);const t={logits:I},C={dim:g};return Ge.runKernel(Kt,t,C)}});const ys=Le({fft_:function(A){CA("complex64"===A.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${A.dtype}.`));const g={input:A};return Ge.runKernel(II,g)}});const Gs=Le({ifft_:function(A){CA("complex64"===A.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${A.dtype}.`));const g={input:A};return Ge.runKernel(aI,g)}});const fs=Le({irfft_:function(A){const g=A.shape[A.shape.length-1],I=A.size/g;let t;if(g<=2){const C=Lo(A,[I,g]);t=Gs(C)}else{const C=[I,2*(g-1)],e=Lo(Ji(A),[I,g]),B=Lo(Ui(A),[I,g]),i=es(To(e,[0,1],[I,g-2]),1),Q=xQ(es(To(B,[0,1],[I,g-2]),1),XQ(-1)),o=Ho([e,i],1),E=Ho([B,Q],1),n=Lo(xe(o,E),[C[0],C[1]]);t=Gs(n)}if(t=Ji(t),3===A.rank&&0!==A.shape[0]){const g=t,I=A.shape[0];t=Lo(t,[I,t.shape[0]/I,t.shape[1]]),g.dispose()}return t}});const Ns=Le({split_:function(A,g,I=0){const t={x:Ke(A,"x","split")},C={numOrSizeSplits:g,axis:I};return Ge.runKernel(Ut,t,C)}});const Fs=Le({rfft_:function(A,g){CA("float32"===A.dtype,(()=>`The dtype for rfft() must be real value but got ${A.dtype}`));let I=A.shape[A.shape.length-1];const t=A.size/I;let C;if(null!=g&&g<I){const t=A.shape.map((A=>0)),e=A.shape.map((A=>A));e[A.shape.length-1]=g,C=To(A,t,e),I=g}else if(null!=g&&g>I){const t=A.shape.map((A=>A));t[A.shape.length-1]=g-I,C=Ho([A,yn(t)],A.shape.length-1),I=g}else C=A;const e=qQ(C),B=Lo(xe(C,e),[t,I]),i=ys(B),Q=Math.floor(I/2)+1,o=Ji(i),E=Ui(i),n=Ns(o,[Q,I-Q],o.shape.length-1),s=Ns(E,[Q,I-Q],E.shape.length-1),a=C.shape.slice();return a[C.shape.length-1]=Q,Lo(xe(n[0],s[0]),a)}});const Rs=Le({squaredDifference_:function(A,g){let I=Ke(A,"a","squaredDifference"),t=Ke(g,"b","squaredDifference");[I,t]=he(I,t),Hi(I.shape,t.shape);const C={a:I,b:t};return Ge.runKernel(Ht,C,{})}});const ms=Le({squeeze_:function(A,g){const I=Ke(A,"x","squeeze","string_or_numeric");return Lo(I,uA(I.shape,g).newShape)}});const ks=Le({stack_:function(A,g=0){const I=Je(A,"tensors","stack","string_or_numeric");CA(I.length>=1,(()=>"Pass at least one tensor to tf.stack")),I.length>0&&CA(g<=I[0].rank,(()=>"Axis must be <= rank of the tensor"));const t=I,C={axis:g};return Ge.runKernel($I,t,C)}});const Ss=Le({step_:function(A,g=0){const I={x:Ke(A,"x","step")},t={alpha:g};return Ge.runKernel(CC,I,t)}});const Ms=Le({stridedSlice_:function(A,g,I,t,C=0,e=0,B=0,i=0,Q=0){const o={x:Ke(A,"x","stridedSlice","string_or_numeric")},E={begin:g,end:I,strides:t,beginMask:C,endMask:e,ellipsisMask:B,newAxisMask:i,shrinkAxisMask:Q};return Ge.runKernel(Tt,o,E)}});const Us=Le({tan_:function(A){const g={x:Ke(A,"x","tan","float32")};return Ge.runKernel(Zt,g)}});function Ks(A,g){BA(A);const I=Se(A,g);if(1!==I.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return be(A,null,I,g)}function Js(A,g,I){if(BA(A),null!=g&&2!==g.length)throw new Error("tensor2d() requires shape to have two numbers");const t=Se(A,I);if(2!==t.length&&1!==t.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===t.length&&null==g)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return be(A,g,t,I)}function Ys(A,g,I){if(BA(A),null!=g&&4!==g.length)throw new Error("tensor4d() requires shape to have four numbers");const t=Se(A,I);if(4!==t.length&&1!==t.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===t.length&&null==g)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return be(A,g,t,I)}function Ls(A,g,I){if(BA(A),null!=g&&5!==g.length)throw new Error("tensor5d() requires shape to have five numbers");const t=Se(A,I);if(5!==t.length&&1!==t.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===t.length&&null==g)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return be(A,g,t,I)}function xs(A,g,I){if(BA(A),null!=g&&6!==g.length)throw new Error("tensor6d() requires shape to have six numbers");const t=Se(A,I);if(6!==t.length&&1!==t.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===t.length&&null==g)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return be(A,g=g||t,t,I)}const bs=Le({topk_:function(A,g=1,I=!0){const t=Ke(A,"x","topk");if(0===t.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const C=t.shape[t.shape.length-1];if(g<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${g}`);if(g>C)throw new Error(`'k' passed to topk() must be <= the last dimension (${C}) but got ${g}`);const e={x:t},B={k:g,sorted:I},[i,Q]=Ge.runKernel(jt,e,B);return{values:i,indices:Q}}});const Hs=Le({truncatedNormal_:function(A,g=0,I=1,t,C){if(null!=t&&"bool"===t)throw new Error("Unsupported data type $ { dtype }");const e=new Pn(g,I,t,!0,C),B=HB(A,t);for(let A=0;A<B.values.length;A++)B.values[A]=e.nextValue();return B.toTensor()}});const qs=Le({unique_:function(A,g=0){const I=Ke(A,"x","unique","string_or_numeric");CA(I.rank>0,(()=>"The input tensor must be at least 1D"));const t={x:I},C={axis:g},[e,B]=Ge.runKernel($t,t,C);return{values:e,indices:B}}});const Ts=Le({unsortedSegmentSum_:function(A,g,I){const t=Ke(A,"x","unsortedSegmentSum"),C=Ke(g,"segmentIds","unsortedSegmentSum","int32");CA(nA(I),(()=>"numSegments must be of dtype int"));const e={x:t,segmentIds:C},B={numSegments:I};return Ge.runKernel(gC,e,B)}});const vs=Le({unstack_:function(A,g=0){const I=Ke(A,"x","unstack","string_or_numeric");CA(g>=-I.shape.length&&g<I.shape.length,(()=>`Axis = ${g} is not in [-${I.shape.length}, ${I.shape.length})`));const t={value:I},C={axis:g};return Ge.runKernel(AC,t,C)}});function Vs(A,g){return ln(A,g,"right")}function Ws(A,g=!0,I,t){return Ge.makeVariable(A,g,I,t)}function Os(A,g){const I=[];for(let A=0;A<g.length;A++)g[A]&&I.push(A);const t=HB(A,"int32"),C=HB([I.length,A.length],"int32");for(let g=0;g<I.length;g++){const e=t.indexToLoc(I[g]),B=g*A.length;C.values.set(e,B)}return C.toTensor()}const Zs=async function(A){const g=Ke(A,"condition","whereAsync","bool"),I=await g.data(),t=Os(g.shape,I);return A!==g&&g.dispose(),t};const Ps=async function(A,g,I){const t=Ke(A,"tensor","boolMask"),C=Ke(g,"mask","boolMask","bool"),e=null==I?0:I,B=C.rank,i=t.shape;CA(B>0,(()=>"mask cannot be scalar")),eA(i.slice(e,e+B),C.shape,"mask's shape must match the first K dimensions of tensor's shape,");let Q=1;for(let A=e;A<e+B;A++)Q*=i[A];const o=i.slice(0,e).concat([Q],i.slice(e+B)),E=Lo(t,o),n=Lo(C,[-1]),s=await Zs(n),a=ms(s,[1]),r=PE(E,a,e);return A!==t&&t.dispose(),g!==C&&C.dispose(),a.dispose(),E.dispose(),n.dispose(),s.dispose(),r};const Xs=Le({movingAverage_:function(A,g,I,t,C=!0){const e=Ke(A,"v","movingAverage"),B=Ke(g,"x","movingAverage"),i=Ke(I,"decay","movingAverage");ce(e,B),CA(EA(e.shape,B.shape),(()=>"Shape mismatch in v and x"));const Q=XQ(1),o=go(Q,i);let E=xQ(go(B,e),o);if(C){CA(null!=t,(()=>"When using zeroDebias: true, step is required."));const A=Ke(t,"step","movingAverage");E=LQ(E,go(Q,Ao(i,A)))}return JQ(e,E)}});const js=Le({scatterND_:function(A,g,I){const t=Ke(A,"indices","scatterND","int32"),C=Ke(g,"updates","scatterND");ji(C,t,I);const e={indices:t,updates:C},B={shape:I};return Ge.runKernel(wt,e,B)}});const zs=Le({sparseToDense_:function(A,g,I,t=0){const C=Ke(A,"sparseIndices","sparseToDense","int32"),e=Ke(g,"sparseValues","sparseToDense","string_or_numeric"),B=Ke(t,"defaultValue","sparseToDense",e.dtype);!function(A,g,I,t){if("int32"!==A.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${A.dtype}.`);if(A.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${A.shape}.`);const C=A.rank>0?A.shape[0]:1,e=A.rank>1?A.shape[1]:1;if(I.length!==e)throw new Error(`outputShape has incorrect number of elements:, ${I.length}, should be: ${e}.`);const B=g.size;if(0!==g.rank&&(1!==g.rank||B!==C))throw new Error(`sparseValues has incorrect shape ${g.shape}, should be [] or [${C}]`);if(g.dtype!==t.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(C,e,I,B);const i={sparseIndices:C,sparseValues:e,defaultValue:B},Q={outputShape:I};return Ge.runKernel(bt,i,Q)}});const _s=Le({gatherND_:function(A,g){const I=Ke(g,"indices","gatherND","int32"),t={params:Ke(A,"x","gatherND","string_or_numeric"),indices:I};return Ge.runKernel(oI,t)}});const $s=Le({dropout_:function(A,g,I,t){const C=Ke(A,"x","dropout");if(CA("float32"===C.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${C.dtype} tensor instead.`)),CA(g>=0&&g<1,(()=>`rate must be a float in the range [0, 1), but got ${g}.`)),0===g)return A instanceof Ce?C.clone():C;const e=function(A,g){if(null==g)return A.shape.slice();if(EA(A.shape,g))return g;if(A.shape.length===g.length){const I=[];for(let t=0;t<A.shape.length;t++)null==g[t]&&null!=A.shape[t]?I.push(A.shape[t]):I.push(g[t]);return I}return g}(C,I),B=1-g,i=LQ(ZE(JQ(As(e,0,1,"float32",t),B)),B);return xQ(C,i)}});function Aa(A){return Math.floor(Math.pow(2,Math.ceil(Math.log(A)/Math.log(2))))}function ga(A,g,I){const t=1-A%2,C=new Float32Array(A);for(let e=0;e<A;++e){const B=2*Math.PI*e/(A+t-1);C[e]=g-I*Math.cos(B)}return Ks(C,"float32")}const Ia=async function(A,g,I=1){const t=Ke(A,"predictions","inTopK"),C=Ke(g,"targets","inTopK");CA(t.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${t.rank}`)),CA(t.rank-1===C.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${t.rank} and targets rank ${C.rank}`)),eA(t.shape.slice(0,t.shape.length-1),C.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const e=t.shape[t.shape.length-1];CA(I>0&&I<=e,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${e}), but got ${I}`));const B=await t.data(),i=await C.data(),[Q,o]=[B.length/e,e],E=wA("bool",Q);for(let A=0;A<Q;A++){const g=A*o,t=B.subarray(g,g+o),C=[];for(let A=0;A<t.length;A++)C.push({value:t[A],index:A});C.sort(((A,g)=>g.value-A.value)),E[A]=0;for(let g=0;g<I;g++)if(C[g].index===i[A]){E[A]=1;break}}return A!==t&&t.dispose(),g!==C&&C.dispose(),He(E,C.shape,"bool")};const ta=Le({conv2DBackpropFilter_:function(A,g,I,t,C,e="NHWC",B){let i=A;3===A.rank&&(i=Lo(A,[1,A.shape[0],A.shape[1],A.shape[2]]));let Q=g;3===Q.rank&&(Q=Lo(g,[1,g.shape[0],g.shape[1],g.shape[2]])),CA(4===i.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`)),CA(4===Q.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${Q.shape}.`)),CA(4===I.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${I}.`));const o="NHWC"===e?i.shape[3]:i.shape[1],E="NHWC"===e?Q.shape[3]:Q.shape[1];CA(o===I[2],(()=>`Error in conv2dDerFilter: depth of input ${o}) must match input depth in filter (${I[2]}.`)),CA(E===I[3],(()=>`Error in conv2dDerFilter: depth of dy (${E}) must match output depth for filter (${I[3]}).`)),Yo("conv2dDerFilter",C,B);const n={x:i,dy:Q},s={strides:t,pad:C,dataFormat:e,dimRoundingMode:B,filterShape:I};return Ge.runKernel(Rg,n,s)}});function Ca(A,g,I){if(null==I||"linear"===I)return A;if("relu"===I)return xQ(A,Ss(g));throw new Error(`Cannot compute gradient for fused activation ${I}.`)}function ea(A,g){let I=g;const t=bi(A.shape,g.shape);return t.length>0&&(I=xE(I,t)),Lo(I,A.shape)}function Ba(A,g,I,t){if("linear"===g)return A;if("relu"===g)return ts(A);if("elu"===g)return NE(A);if("relu6"===g)return Cs(A);if("prelu"===g)return Tn(A,I);if("leakyrelu"===g)return An(A,t);if("sigmoid"===g)return qo(A);throw new Error(`Unknown fused activation ${g}.`)}const ia=(A,g)=>!(A>0)||"linear"===g;const Qa=Le({fusedConv2d_:function({x:A,filter:g,strides:I,pad:t,dataFormat:C="NHWC",dilations:e=[1,1],dimRoundingMode:B,bias:i,activation:Q="linear",preluActivationWeights:o,leakyreluAlpha:E}){if(Q=Q||"linear",!1===ia(Ge.state.gradientDepth,Q)){CA("NHWC"===C,(()=>`Error in fused conv2d: got dataFormat of ${C} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let n=eE(A,g,I,t,C,e,B);return null!=i&&(n=JQ(n,i)),Ba(n,Q,o,E)}const n=Ke(A,"x","conv2d","float32"),s=Ke(g,"filter","conv2d","float32");let a=n,r=!1;3===n.rank&&(r=!0,a=Lo(n,[1,n.shape[0],n.shape[1],n.shape[2]])),CA(4===a.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${a.rank}.`)),CA(4===s.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${s.rank}.`)),Yo("fused conv2d",t,B);const h="NHWC"===C?a.shape[3]:a.shape[1];CA(s.shape[2]===h,(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${s.shape[2]}.`)),CA(Ko(I,e),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${I} and dilations '${e}'`));const c=No(a.shape,s.shape,I,e,t,B);let l,D;if(null!=i&&(l=Ke(i,"bias","fused conv2d"),[l]=he(l,n),"NHWC"===C?Hi(c.outShape,l.shape):(CA(l.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${l.shape.length}.`)),CA(0===l.shape.length||l.shape[0]===c.outChannels||1===l.shape[0],(()=>`Error in fused conv2d: bias shape (${l.shape}) is not compatible with the number of output channels (${c.outChannels})`)))),null!=o){const A=o.shape;if(CA(A.length<=1||3===A.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`)),1===A.length)CA(1===A[0]||A[0]===c.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${c.outChannels}).`));else if(3===A.length)try{Hi(A,c.outShape)}catch(g){const I=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${c.outShape}).`;throw Error(I)}D=Ke(o,"prelu weights","fused conv2d")}const u=(A,g)=>{CA("NHWC"===C,(()=>`Error in gradient of fused conv2D: got dataFormat of ${C} but only NHWC is currently supported.`));const[B,i,o,E]=g,n=Ca(A,o,Q);CA(Uo(e),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${e}'`));const s=[iE(i.shape,n,B,I,t),ta(i,n,B.shape,I,t)];if(null!=E){const A=ea(E,n);s.push(A)}return s},w={x:a,filter:s,bias:l,preluActivationWeights:D},d={strides:I,pad:t,dataFormat:C,dilations:e,dimRoundingMode:B,activation:Q,leakyreluAlpha:E};if(null==i){const A=ZQ(((A,g,I)=>{let t=Ge.runKernel(QC,w,d);return I([g,A,t]),r&&(t=Lo(t,[t.shape[1],t.shape[2],t.shape[3]])),{value:t,gradFunc:u}}));return A(a,s)}{const A=ZQ(((A,g,I,t)=>{let C=Ge.runKernel(QC,w,d);return t([g,A,C,I]),r&&(C=Lo(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:u}}));return A(a,s,l)}}});const oa=Le({depthwiseConv2dNativeBackpropFilter_:function(A,g,I,t,C,e=[1,1],B){let i=A;3===A.rank&&(i=Lo(A,[1,A.shape[0],A.shape[1],A.shape[2]]));let Q=g;3===Q.rank&&(Q=Lo(g,[1,g.shape[0],g.shape[1],g.shape[2]]));const o={x:i,dy:Q},E={strides:t,pad:C,dimRoundingMode:B,dilations:e,filterShape:I};return Ge.runKernel(qg,o,E)}});const Ea=Le({depthwiseConv2dNativeBackpropInput_:function(A,g,I,t,C,e=[1,1],B){let i=g,Q=!1;3===g.rank&&(Q=!0,i=Lo(g,[1,g.shape[0],g.shape[1],g.shape[2]]));const o={dy:i,filter:I},E={strides:t,pad:C,dimRoundingMode:B,dilations:e,inputShape:A},n=Ge.runKernel(Tg,o,E);return Q?Lo(n,[n.shape[1],n.shape[2],n.shape[3]]):n}});const na=Le({fusedDepthwiseConv2d_:function({x:A,filter:g,strides:I,pad:t,dataFormat:C="NHWC",dilations:e=[1,1],dimRoundingMode:B,bias:i,activation:Q="linear",preluActivationWeights:o,leakyreluAlpha:E}){if(!1===ia(Ge.state.gradientDepth,Q)){let n=DE(A,g,I,t,C,e,B);return null!=i&&(n=JQ(n,i)),Ba(n,Q,o,E)}const n=Ke(A,"x","depthwiseConv2d","float32"),s=Ke(g,"filter","depthwiseConv2d","float32");let a=n,r=!1;3===n.rank&&(r=!0,a=Lo(n,[1,n.shape[0],n.shape[1],n.shape[2]])),CA(4===a.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${a.rank}.`)),CA(4===s.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${s.rank}.`)),CA(a.shape[3]===s.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${a.shape[3]}) must match the inChannels dimension in filter ${s.shape[2]}.`)),null==e&&(e=[1,1]),CA(Ko(I,e),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${I} and dilations '${e}'`)),Yo("fused depthwiseConv2d",t,B);const h=No(a.shape,s.shape,I,e,t,B,!0);let c,l;null!=i&&(c=Ke(i,"bias","fused conv2d"),[c]=he(c,n),Hi(h.outShape,c.shape)),null!=o&&(l=Ke(o,"prelu weights","fused depthwiseConv2d"));const D=(A,g)=>{CA(Uo(e),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${e}'`));const[C,i,o,E]=g,n=Ca(A,o,Q),s=Ea(i.shape,n,C,I,t,e,B),a=oa(i,n,C.shape,I,t,e,B);if(null!=E){return[s,a,ea(c,n)]}return[s,a]},u={x:a,filter:s,bias:c,preluActivationWeights:l},w={strides:I,pad:t,dataFormat:C,dilations:e,dimRoundingMode:B,activation:Q,leakyreluAlpha:E};if(null==i){const A=ZQ(((A,g,I)=>{let t=Ge.runKernel(oC,u,w);return I([g,A,t]),r&&(t=Lo(t,[t.shape[1],t.shape[2],t.shape[3]])),{value:t,gradFunc:D}}));return A(a,s)}{const A=ZQ(((A,g,I,t)=>{let C=Ge.runKernel(oC,u,w);return t([g,A,C,I]),r&&(C=Lo(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:D}}));return A(a,s,c)}}});const sa=Le({fusedMatMul_:function({a:A,b:g,transposeA:I=!1,transposeB:t=!1,bias:C,activation:e="linear",preluActivationWeights:B,leakyreluAlpha:i=.2}){if(!1===ia(Ge.state.gradientDepth,e)){let Q=Ei(A,g,I,t);return null!=C&&(Q=JQ(Q,C)),Ba(Q,e,B,i)}let Q=Ke(A,"a","fused matMul"),o=Ke(g,"b","fused matMul");[Q,o]=he(Q,o);const E=I?Q.shape[Q.rank-2]:Q.shape[Q.rank-1],n=t?o.shape[o.rank-1]:o.shape[o.rank-2],s=I?Q.shape[Q.rank-1]:Q.shape[Q.rank-2],a=t?o.shape[o.rank-2]:o.shape[o.rank-1],r=Q.shape.slice(0,-2),h=o.shape.slice(0,-2),c=QA(r),l=QA(h);CA(E===n,(()=>`Error in fused matMul: inner shapes (${E}) and (${n}) of Tensors with shapes ${Q.shape} and ${o.shape} and transposeA=${I} and transposeB=${t} must match.`));const D=Hi(Q.shape.slice(0,-2),o.shape.slice(0,-2)).concat([s,a]),u=Lo(Q,I?[c,E,s]:[c,s,E]),w=Lo(o,t?[l,a,n]:[l,n,a]);let d,p;null!=C&&(d=Ke(C,"bias","fused matMul"),[d]=he(d,Q),Hi(D,d.shape)),null!=B&&(p=Ke(B,"prelu weights","fused matMul"));const y=(A,g)=>{const[B,i,Q,o]=g,E=Ca(Lo(A,Q.shape),Q,e);let n,s;if(I||t?!I&&t?(n=Ei(E,i,!1,!1),s=Ei(E,B,!0,!1)):I&&!t?(n=Ei(i,E,!1,!0),s=Ei(B,E,!1,!1)):(n=Ei(i,E,!0,!0),s=Ei(E,B,!0,!0)):(n=Ei(E,i,!1,!0),s=Ei(B,E,!0,!1)),null!=C){return[n,s,ea(o,E)]}return[n,s]},G={a:u,b:w,bias:d,preluActivationWeights:p},f={transposeA:I,transposeB:t,activation:e,leakyreluAlpha:i};if(null==C){const A=ZQ(((A,g,I)=>{const t=Ge.runKernel(iC,G,f);return I([A,g,t]),{value:Lo(t,D),gradFunc:y}}));return A(u,w)}{const A=ZQ(((A,g,I,t)=>{const C=Ge.runKernel(iC,G,f);return t([A,g,C,I]),{value:Lo(C,D),gradFunc:y}}));return A(u,w,d)}}});const aa=Le({hammingWindow_:function(A){return ga(A,.54,.46)}});const ra=Le({hannWindow_:function(A){return ga(A,.5,.5)}});const ha=Le({frame_:function(A,g,I,t=!1,C=0){let e=0;const B=[];for(;e+g<=A.size;)B.push(To(A,e,g)),e+=I;if(t)for(;e<A.size;){const t=e+g-A.size,i=Ho([To(A,e,g-t),_Q([t],C)]);B.push(i),e+=I}return 0===B.length?Js([],[0,g]):Lo(Ho(B),[B.length,g])}});const ca=Le({stft_:function(A,g,I,t,C=ra){null==t&&(t=Aa(g));const e=ha(A,g,I),B=xQ(e,C(g));return Fs(B,t)}});const la=Le({cropAndResize_:function(A,g,I,t,C="bilinear",e=0){const B=Ke(A,"image","cropAndResize"),i=Ke(g,"boxes","cropAndResize","float32"),Q=Ke(I,"boxInd","cropAndResize","int32"),o=i.shape[0];CA(4===B.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${B.rank}.`)),CA(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${o},4] but had shape ${i.shape}.`)),CA(1===Q.rank&&Q.shape[0]===o,(()=>`Error in cropAndResize: boxInd must be have size [${o}] but had shape ${i.shape}.`)),CA(2===t.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${t.length}.`)),CA(t[0]>=1&&t[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${t}`)),CA("bilinear"===C||"nearest"===C,(()=>`method must be bilinear or nearest, but was ${C}`));const E={image:B,boxes:i,boxInd:Q},n={method:C,extrapolationValue:e,cropSize:t};return Ge.runKernel(Lg,E,n)}});const Da=Le({flipLeftRight_:function(A){const g=Ke(A,"image","flipLeftRight","float32");CA(4===g.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${g.rank}.`));const I={image:g};return Ge.runKernel(CI,I,{})}});const ua=Le({grayscaleToRGB_:function(A){const g=Ke(A,"image","grayscaleToRGB"),I=g.rank-1,t=g.shape[I];CA(g.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${g.rank}.`)),CA(1===t,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${t}.`));const C=new Array(g.rank);return C.fill(1,0,I),C[I]=3,WE(g,C)}});const wa=Le({rotateWithOffset_:function(A,g,I=0,t=.5){const C=Ke(A,"image","rotateWithOffset","float32");CA(4===C.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${C.rank}.`));const e={image:C},B={radians:g,fillValue:I,center:t};return Ge.runKernel(BC,e,B)}});function da(A,g,I,t,C,e){null==t&&(t=.5),null==C&&(C=Number.NEGATIVE_INFINITY),null==e&&(e=0);const B=A.shape[0];return I=Math.min(I,B),CA(0<=t&&t<=1,(()=>`iouThreshold must be in [0, 1], but was '${t}'`)),CA(2===A.rank,(()=>`boxes must be a 2D tensor, but was of rank '${A.rank}'`)),CA(4===A.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${A.shape[1]}`)),CA(1===g.rank,(()=>"scores must be a 1D tensor")),CA(g.shape[0]===B,(()=>`scores has incompatible shape with boxes. Expected ${B}, but was ${g.shape[0]}`)),CA(0<=e&&e<=1,(()=>`softNmsSigma must be in [0, 1], but was '${e}'`)),{maxOutputSize:I,iouThreshold:t,scoreThreshold:C,softNmsSigma:e}}const pa=Le({nonMaxSuppression_:function(A,g,I,t=.5,C=Number.NEGATIVE_INFINITY){const e=Ke(A,"boxes","nonMaxSuppression","float32"),B=Ke(g,"scores","nonMaxSuppression","float32"),i=da(e,B,I,t,C),Q={maxOutputSize:I=i.maxOutputSize,iouThreshold:t=i.iouThreshold,scoreThreshold:C=i.scoreThreshold};return Ge.runKernel(PI,{boxes:e,scores:B},Q)}});function ya(A,g,I){const t=function(A,g,I){return function(A,g,I){let t=0,C=A.length,e=0,B=!1;for(;t<C;){e=t+(C-t>>>1);const i=I(g,A[e]);i>0?t=e+1:(C=e,B=!i)}return B?t:-t-1}(A,g,I||Ga)}(A,g,I),C=t<0?-(t+1):t;A.splice(C,0,g)}function Ga(A,g){return A>g?1:A<g?-1:0}function fa(A,g,I,t,C){return Ra(A,g,I,t,C,0)}function Na(A,g,I,t,C,e){return Ra(A,g,I,t,C,0,!1,e,!0)}function Fa(A,g,I,t,C,e){return Ra(A,g,I,t,C,e,!0)}function Ra(A,g,I,t,C,e,B=!1,i=!1,Q=!1){const o=[];for(let A=0;A<g.length;A++)g[A]>C&&o.push({score:g[A],boxIndex:A,suppressBeginIndex:0});o.sort(Sa);const E=e>0?-.5/e:0,n=[],s=[];for(;n.length<I&&o.length>0;){const g=o.pop(),{score:I,boxIndex:e,suppressBeginIndex:B}=g;if(I<C)break;let i=!1;for(let I=n.length-1;I>=B;--I){const B=ma(A,e,n[I]);if(B>=t){i=!0;break}if(g.score=g.score*ka(t,E,B),g.score<=C)break}g.suppressBeginIndex=n.length,i||(g.score===I?(n.push(e),s.push(g.score)):g.score>C&&ya(o,g,Sa))}const a=n.length,r=I-a;i&&r>0&&(n.push(...new Array(r).fill(0)),s.push(...new Array(r).fill(0)));const h={selectedIndices:n};return B&&(h.selectedScores=s),Q&&(h.validOutputs=a),h}function ma(A,g,I){const t=A.subarray(4*g,4*g+4),C=A.subarray(4*I,4*I+4),e=Math.min(t[0],t[2]),B=Math.min(t[1],t[3]),i=Math.max(t[0],t[2]),Q=Math.max(t[1],t[3]),o=Math.min(C[0],C[2]),E=Math.min(C[1],C[3]),n=Math.max(C[0],C[2]),s=Math.max(C[1],C[3]),a=(i-e)*(Q-B),r=(n-o)*(s-E);if(a<=0||r<=0)return 0;const h=Math.max(e,o),c=Math.max(B,E),l=Math.min(i,n),D=Math.min(Q,s),u=Math.max(l-h,0)*Math.max(D-c,0);return u/(a+r-u)}function ka(A,g,I){const t=Math.exp(g*I*I);return I<=A?t:0}function Sa(A,g){return A.score-g.score||A.score===g.score&&g.boxIndex-A.boxIndex}const Ma=async function(A,g,I,t=.5,C=Number.NEGATIVE_INFINITY){const e=Ke(A,"boxes","nonMaxSuppressionAsync"),B=Ke(g,"scores","nonMaxSuppressionAsync"),i=da(e,B,I,t,C);I=i.maxOutputSize,t=i.iouThreshold,C=i.scoreThreshold;const Q=await Promise.all([e.data(),B.data()]),o=Q[0],E=Q[1],{selectedIndices:n}=fa(o,E,I,t,C);return e!==A&&e.dispose(),B!==g&&B.dispose(),Ks(n,"int32")};const Ua=Le({nonMaxSuppressionWithScore_:function(A,g,I,t=.5,C=Number.NEGATIVE_INFINITY,e=0){const B=Ke(A,"boxes","nonMaxSuppression"),i=Ke(g,"scores","nonMaxSuppression"),Q=da(B,i,I,t,C,e),o={boxes:B,scores:i},E={maxOutputSize:I=Q.maxOutputSize,iouThreshold:t=Q.iouThreshold,scoreThreshold:C=Q.scoreThreshold,softNmsSigma:e=Q.softNmsSigma},n=Ge.runKernel(jI,o,E);return{selectedIndices:n[0],selectedScores:n[1]}}});const Ka=async function(A,g,I,t=.5,C=Number.NEGATIVE_INFINITY,e=0){const B=Ke(A,"boxes","nonMaxSuppressionAsync"),i=Ke(g,"scores","nonMaxSuppressionAsync"),Q=da(B,i,I,t,C,e);I=Q.maxOutputSize,t=Q.iouThreshold,C=Q.scoreThreshold,e=Q.softNmsSigma;const o=await Promise.all([B.data(),i.data()]),E=o[0],n=o[1],{selectedIndices:s,selectedScores:a}=Fa(E,n,I,t,C,e);return B!==A&&B.dispose(),i!==g&&i.dispose(),{selectedIndices:Ks(s,"int32"),selectedScores:Ks(a)}};const Ja=Le({nonMaxSuppressionPadded_:function(A,g,I,t=.5,C=Number.NEGATIVE_INFINITY,e=!1){const B=Ke(A,"boxes","nonMaxSuppression"),i=Ke(g,"scores","nonMaxSuppression"),Q=da(B,i,I,t,C,null),o={boxes:B,scores:i},E={maxOutputSize:Q.maxOutputSize,iouThreshold:Q.iouThreshold,scoreThreshold:Q.scoreThreshold,padToMaxOutputSize:e},n=Ge.runKernel(XI,o,E);return{selectedIndices:n[0],validOutputs:n[1]}}});const Ya=async function(A,g,I,t=.5,C=Number.NEGATIVE_INFINITY,e=!1){const B=Ke(A,"boxes","nonMaxSuppressionAsync"),i=Ke(g,"scores","nonMaxSuppressionAsync"),Q=da(B,i,I,t,C,null),o=Q.maxOutputSize,E=Q.iouThreshold,n=Q.scoreThreshold,[s,a]=await Promise.all([B.data(),i.data()]),{selectedIndices:r,validOutputs:h}=Na(s,a,o,E,n,e);return B!==A&&B.dispose(),i!==g&&i.dispose(),{selectedIndices:Ks(r,"int32"),validOutputs:XQ(h,"int32")}};const La=Le({resizeBilinear_:function(A,g,I=!1,t=!1){const C=Ke(A,"images","resizeBilinear");CA(3===C.rank||4===C.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${C.rank}.`)),CA(2===g.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${g}.`)),CA(!1===t||!1===I,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let e=C,B=!1;3===C.rank&&(B=!0,e=Lo(C,[1,C.shape[0],C.shape[1],C.shape[2]]));const[]=g,i={images:e},Q={alignCorners:I,halfPixelCenters:t,size:g},o=Ge.runKernel(rt,i,Q);return B?Lo(o,[o.shape[1],o.shape[2],o.shape[3]]):o}});const xa=Le({resizeNearestNeighbor_:function(A,g,I=!1,t=!1){const C=Ke(A,"images","resizeNearestNeighbor");CA(3===C.rank||4===C.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${C.rank}.`)),CA(2===g.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${g}.`)),CA("float32"===C.dtype||"int32"===C.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),CA(!1===t||!1===I,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let e=C,B=!1;3===C.rank&&(B=!0,e=Lo(C,[1,C.shape[0],C.shape[1],C.shape[2]]));const[]=g,i={images:e},Q={alignCorners:I,halfPixelCenters:t,size:g},o=Ge.runKernel(st,i,Q);return B?Lo(o,[o.shape[1],o.shape[2],o.shape[3]]):o}});const ba=Le({threshold_:function(A,g="binary",I=!1,t=.5){const C=Ke(A,"image","threshold"),e=C.shape[0]*C.shape[1];let B,i,Q,o,E=xQ(Ks([t]),255);if(CA(3===C.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${C.rank}.`)),CA(3===C.shape[2]||1===C.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${C.shape[2]}.`)),CA("int32"===C.dtype||"float32"===C.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${C.dtype}.`)),CA("otsu"===g||"binary"===g,(()=>`Method must be binary or otsu, but was ${g}`)),3===C.shape[2]){[B,i,Q]=Ns(C,[1,1,1],-1);const A=xQ(B,.2989),g=xQ(i,.587),I=xQ(Q,.114);o=JQ(JQ(A,g),I)}else o=A;if("otsu"===g){E=function(A,g){let I,t,C,e,B,i,Q=Ks([-1]),o=Ks([0]),E=Ks([0]);for(let n=0;n<A.size-1;n++){I=To(A,0,n+1),t=To(A,n+1),B=LQ(xE(I),g),i=LQ(xE(t),g);const s=xE(xQ(I,gs(0,I.size)));C=LQ(s,xE(I));const a=_Q(t.shape,I.size),r=JQ(gs(0,t.size),a),h=xQ(t,r);e=LQ(xE(h),xE(t));const c=go(C,e),l=go(C,e),D=xQ(B,i);E=xQ(xQ(D,c),l);const u=XE(E,o);o=pE(u,E,o),Q=pE(u,Ks([n]),Q)}return Q}(jo(qB(Es(o),"int32"),He([]),256),e)}const n=I?In(o,E):XE(o,E);return qB(xQ(n,255),"int32")}});const Ha=Le({transform_:function(A,g,I="nearest",t="constant",C=0,e){const B=Ke(A,"image","transform","float32"),i=Ke(g,"transforms","transform","float32");CA(4===B.rank,(()=>`Error in transform: image must be rank 4,but got rank ${B.rank}.`)),CA(2===i.rank&&(i.shape[0]===B.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),CA(null==e||2===e.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${e}.`));const Q={image:B,transforms:i},o={interpolation:I,fillMode:t,fillValue:C,outputShape:e};return Ge.runKernel(zt,Q,o)}});const qa=Le({bandPart_:function(A,g,I){CA(g%1==0,(()=>`bandPart(): numLower must be an integer, got ${g}.`)),CA(I%1==0,(()=>`bandPart(): numUpper must be an integer, got ${I}.`));const t=Ke(A,"a","bandPart");CA(t.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${t.rank}.`));const C=t.shape,[e,B]=t.shape.slice(-2);if(!(g<=e))throw new Error(`bandPart(): numLower (${g}) must not be greater than the number of rows (${e}).`);if(!(I<=B))throw new Error(`bandPart(): numUpper (${I}) must not be greater than the number of columns (${B}).`);g<0&&(g=e),I<0&&(I=B);const i=Lo(gs(0,e,1,"int32"),[-1,1]),Q=gs(0,B,1,"int32"),o=go(i,Q),E=sn(In(o,XQ(+g,"int32")),jE(o,XQ(-I,"int32"))),n=yn([e,B],t.dtype);return Lo(ks(vs(Lo(t,[-1,e,B])).map((A=>pE(E,A,n)))),C)}});const Ta=Le({gramSchmidt_:function(A){let g;if(Array.isArray(A)){g=!1,CA(null!=A&&A.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const I=A[0].shape[0];for(let g=1;g<A.length;++g)CA(A[g].shape[0]===I,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${A[g].shape[0]} vs. ${I})`))}else g=!0,A=Ns(A,A.shape[0],0).map((A=>ms(A,[0])));CA(A.length<=A[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${A.length}) exceeds number of dimensions (${A[0].shape[0]}).`));const I=[],t=A;for(let g=0;g<A.length;++g)I.push(Ge.tidy((()=>{let A=t[g];if(g>0)for(let t=0;t<g;++t){const g=xQ(xE(xQ(I[t],A)),I[t]);A=go(A,g)}return LQ(A,HE(A,"euclidean"))})));return g?ks(I,0):I}});function va(A,g=!1){return Ge.tidy((()=>{CA(2===A.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${A.shape.length}D Tensor.`));const I=A.shape[0],t=A.shape[1];let C=OE(I),e=TB(A);const B=Js([[1]],[1,1]);let i=TB(B);const Q=I>=t?t:I;for(let A=0;A<Q;++A){const g=e,Q=i,o=C;[i,e,C]=Ge.tidy((()=>{const g=To(e,[A,A],[I-A,1]),Q=HE(g),o=To(e,[A,A],[1,1]),E=pE(XE(o,0),Js([[-1]]),Js([[1]])),n=go(o,xQ(E,Q)),s=LQ(g,n);i=1===s.shape[0]?TB(B):Ho([B,To(s,[1,0],[s.shape[0]-1,s.shape[1]])],0);const a=Ki(LQ(Ei(E,n),Q)),r=To(e,[A,0],[I-A,t]),h=xQ(a,i),c=Yi(i);if(0===A)e=go(r,Ei(h,Ei(c,r)));else{const g=go(r,Ei(h,Ei(c,r)));e=Ho([To(e,[0,0],[A,t]),g],0)}const l=Yi(h),D=To(C,[0,A],[I,C.shape[1]-A]);if(0===A)C=go(D,Ei(Ei(D,i),l));else{const g=go(D,Ei(Ei(D,i),l));C=Ho([To(C,[0,0],[I,A]),g],1)}return[i,e,C]})),di([g,Q,o])}return!g&&I>t&&(C=To(C,[0,0],[I,t]),e=To(e,[0,0],[t,t])),[C,e]}))}const Va=Le({qr_:function(A,g=!1){if(CA(A.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${A.rank}`)),2===A.rank)return va(A,g);{const I=A.shape.slice(0,A.shape.length-2).reduce(((A,g)=>A*g)),t=vs(Lo(A,[I,A.shape[A.shape.length-2],A.shape[A.shape.length-1]]),0),C=[],e=[];t.forEach((A=>{const[I,t]=va(A,g);C.push(I),e.push(t)}));return[Lo(ks(C,0),A.shape),Lo(ks(e,0),A.shape)]}}});var Wa;!function(A){A[A.NONE=0]="NONE",A[A.MEAN=1]="MEAN",A[A.SUM=2]="SUM",A[A.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Wa||(Wa={}));const Oa=Le({computeWeightedLoss_:function(A,g,I=Wa.SUM_BY_NONZERO_WEIGHTS){const t=Ke(A,"losses","computeWeightedLoss");let C=null;null!=g&&(C=Ke(g,"weights","computeWeightedLoss"));const e=null==C?t:xQ(t,C);if(I===Wa.NONE)return e;if(I===Wa.SUM)return xE(e);if(I===Wa.MEAN){if(null==C)return pn(e);{const A=t.size/C.size,g=LQ(xE(e),xE(C));return A>1?LQ(g,XQ(A)):g}}if(I===Wa.SUM_BY_NONZERO_WEIGHTS){if(null==C)return LQ(xE(e),XQ(t.size));{const A=xQ(C,Gn(t.shape)),g=qB(xE(Mn(A,XQ(0))),"float32");return LQ(xE(e),g)}}throw Error(`Unknown reduction: ${I}`)}});const Za=Le({absoluteDifference_:function(A,g,I,t=Wa.SUM_BY_NONZERO_WEIGHTS){const C=Ke(A,"labels","absoluteDifference"),e=Ke(g,"predictions","absoluteDifference");let B=null;null!=I&&(B=Ke(I,"weights","absoluteDifference")),eA(C.shape,e.shape,"Error in absoluteDifference: ");const i=to(go(C,e));return Oa(i,B,t)}});const Pa=Le({cosineDistance_:function(A,g,I,t,C=Wa.SUM_BY_NONZERO_WEIGHTS){const e=Ke(A,"labels","cosineDistance"),B=Ke(g,"predictions","cosineDistance");let i=null;null!=t&&(i=Ke(t,"weights","cosineDistance")),eA(e.shape,B.shape,"Error in cosineDistance: ");const Q=XQ(1),o=go(Q,xE(xQ(e,B),I,!0));return Oa(o,i,C)}});const Xa=Le({hingeLoss_:function(A,g,I,t=Wa.SUM_BY_NONZERO_WEIGHTS){let C=Ke(A,"labels","hingeLoss");const e=Ke(g,"predictions","hingeLoss");let B=null;null!=I&&(B=Ke(I,"weights","hingeLoss")),eA(C.shape,e.shape,"Error in hingeLoss: ");const i=XQ(1);C=go(xQ(XQ(2),C),i);const Q=ts(go(i,xQ(C,e)));return Oa(Q,B,t)}});const ja=Le({huberLoss_:function(A,g,I,t=1,C=Wa.SUM_BY_NONZERO_WEIGHTS){const e=Ke(A,"labels","huberLoss"),B=Ke(g,"predictions","huberLoss");let i=null;null!=I&&(i=Ke(I,"weights","huberLoss")),eA(e.shape,B.shape,"Error in huberLoss: ");const Q=XQ(t),o=to(go(B,e)),E=Nn(o,Q),n=go(o,E),s=JQ(xQ(XQ(.5),HQ(E)),xQ(Q,n));return Oa(s,i,C)}});const za=Le({logLoss_:function(A,g,I,t=1e-7,C=Wa.SUM_BY_NONZERO_WEIGHTS){const e=Ke(A,"labels","logLoss"),B=Ke(g,"predictions","logLoss");let i=null;null!=I&&(i=Ke(I,"weights","logLoss")),eA(e.shape,B.shape,"Error in logLoss: ");const Q=XQ(1),o=XQ(t),E=Ki(xQ(e,en(JQ(B,o)))),n=xQ(go(Q,e),en(JQ(go(Q,B),o))),s=go(E,n);return Oa(s,i,C)}});const _a=Le({meanSquaredError_:function(A,g,I,t=Wa.SUM_BY_NONZERO_WEIGHTS){const C=Ke(A,"labels","meanSquaredError"),e=Ke(g,"predictions","meanSquaredError");let B=null;null!=I&&(B=Ke(I,"weights","meanSquaredError")),eA(C.shape,e.shape,"Error in meanSquaredError: ");const i=Rs(C,e);return Oa(i,B,t)}});const $a=Le({sigmoidCrossEntropy_:function(A,g,I,t=0,C=Wa.SUM_BY_NONZERO_WEIGHTS){let e=Ke(A,"multiClassLabels","sigmoidCrossEntropy");const B=Ke(g,"logits","sigmoidCrossEntropy");let i=null;if(null!=I&&(i=Ke(I,"weights","sigmoidCrossEntropy")),eA(e.shape,B.shape,"Error in sigmoidCrossEntropy: "),t>0){const A=XQ(t),g=XQ(1),I=XQ(.5);e=JQ(xQ(e,go(g,A)),xQ(I,A))}const Q=function(A,g){const I=Ke(A,"labels","sigmoidCrossEntropyWithLogits"),t=Ke(g,"logits","sigmoidCrossEntropyWithLogits");eA(I.shape,t.shape,"Error in sigmoidCrossEntropyWithLogits: ");const C=ts(t),e=xQ(t,I),B=Bn(TE(Ki(to(t))));return JQ(go(C,e),B)}(e,B);return Oa(Q,i,C)}});const Ar=Le({softmaxCrossEntropy_:function(A,g,I,t=0,C=Wa.SUM_BY_NONZERO_WEIGHTS){let e=Ke(A,"onehotLabels","softmaxCrossEntropy");const B=Ke(g,"logits","softmaxCrossEntropy");let i=null;if(null!=I&&(i=Ke(I,"weights","softmaxCrossEntropy")),eA(e.shape,B.shape,"Error in softmaxCrossEntropy: "),t>0){const A=XQ(t),g=XQ(1),I=XQ(e.shape[1]);e=JQ(xQ(e,go(g,A)),LQ(A,I))}const Q=function(A,g,I=-1){if(-1===I&&(I=g.rank-1),I!==g.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${g.rank} and dim was ${I}`);const t=ZQ(((A,g,t)=>{const C=nn(g,[I],!0),e=go(qB(g,"float32"),C);t([A,e]);const B=Ki(xQ(e,A));return{value:xE(B,[I]),gradFunc:(A,g)=>{const[t,C]=g,e=SE(A.shape,[I]);return[xQ(Lo(A,e),go(qB(t,"float32"),TE(C))),xQ(Lo(A,e),go(TE(C),qB(t,"float32")))]}}}));return t(A,g)}(e,B);return Oa(Q,i,C)}});const gr=Le({sparseFillEmptyRows_:function(A,g,I,t){const C=Ke(A,"indices","sparseFillEmptyRows","int32"),e=Ke(g,"values","sparseFillEmptyRows"),B=Ke(I,"denseShape","sparseFillEmptyRows","int32"),i=Ke(t,"defaultValue","sparseFillEmptyRows",e.dtype);if(2!==C.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${C.shape}`);if(1!==e.rank)throw new Error(`Values should be Tensor1D but received shape ${e.shape}`);if(1!==B.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${B.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const Q={indices:C,values:e,denseShape:B,defaultValue:i},o=Ge.runKernel(Jt,Q);return{outputIndices:o[0],outputValues:o[1],emptyRowIndicator:o[2],reverseIndexMap:o[3]}}});const Ir=Le({sparseReshape_:function(A,g,I){const t=Ke(A,"inputIndices","sparseReshape","int32"),C=Ke(g,"inputShape","sparseReshape","int32"),e=Ke(I,"newShape","sparseReshape","int32");if(2!==t.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${t.shape}`);if(1!==C.rank)throw new Error(`Input shape should be Tensor1D but received shape ${C.shape}`);if(1!==e.rank)throw new Error(`New shape should be Tensor1D but received shape ${e.shape}`);const B={inputIndices:t,inputShape:C,newShape:e},i=Ge.runKernel(Yt,B);return{outputIndices:i[0],outputShape:i[1]}}});const tr=Le({sparseSegmentMean_:function(A,g,I){const t=Ke(A,"data","sparseSegmentMean"),C=Ke(g,"indices","sparseSegmentMean","int32"),e=Ke(I,"segmentIds","sparseSegmentMean","int32");if(t.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==C.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${C.shape}`);if(1!==e.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${e.shape}`);const B={data:t,indices:C,segmentIds:e};return Ge.runKernel(Lt,B)}});const Cr=Le({sparseSegmentSum_:function(A,g,I){const t=Ke(A,"data","sparseSegmentSum"),C=Ke(g,"indices","sparseSegmentSum","int32"),e=Ke(I,"segmentIds","sparseSegmentSum","int32");if(t.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==C.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${C.shape}`);if(1!==e.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${e.shape}`);const B={data:t,indices:C,segmentIds:e};return Ge.runKernel(xt,B)}});const er=Le({stringNGrams_:function(A,g,I,t,C,e,B,i){const Q=Ke(A,"data","stringNGrams","string");if("string"!==Q.dtype)throw new Error("Data must be of datatype string");if(1!==Q.shape.length)throw new Error(`Data must be a vector, saw: ${Q.shape}`);const o=Ke(g,"dataSplits","stringNGrams");if("int32"!==o.dtype)throw new Error("Data splits must be of datatype int32");const E={separator:I,nGramWidths:t,leftPad:C,rightPad:e,padWidth:B,preserveShortSequences:i},n={data:Q,dataSplits:o},s=Ge.runKernel(vt,n,E);return{nGrams:s[0],nGramsSplits:s[1]}}});const Br=Le({stringSplit_:function(A,g,I=!0){const t=Ke(A,"input","stringSplit","string"),C=Ke(g,"delimiter","stringSplit","string");if(1!==t.rank)throw new Error(`Input should be Tensor1D but received shape ${t.shape}`);if(0!==C.rank)throw new Error(`Delimiter should be a scalar but received shape ${C.shape}`);const e={skipEmpty:I},B={input:t,delimiter:C},i=Ge.runKernel(Vt,B,e);return{indices:i[0],values:i[1],shape:i[2]}}});const ir=Le({stringToHashBucketFast_:function(A,g){const I=Ke(A,"input","stringToHashBucketFast","string"),t={numBuckets:g};if(g<=0)throw new Error("Number of buckets must be at least 1");const C={input:I};return Ge.runKernel(Wt,C,t)}}),Qr={fft:ys,ifft:Gs,rfft:Fs,irfft:fs},or={hammingWindow:aa,hannWindow:ra,frame:ha,stft:ca},Er={flipLeftRight:Da,grayscaleToRGB:ua,resizeNearestNeighbor:xa,resizeBilinear:La,rotateWithOffset:wa,cropAndResize:la,nonMaxSuppression:pa,nonMaxSuppressionAsync:Ma,nonMaxSuppressionWithScore:Ua,nonMaxSuppressionWithScoreAsync:Ka,nonMaxSuppressionPadded:Ja,nonMaxSuppressionPaddedAsync:Ya,threshold:ba,transform:Ha},nr={bandPart:qa,gramSchmidt:Ta,qr:Va},sr={absoluteDifference:Za,computeWeightedLoss:Oa,cosineDistance:Pa,hingeLoss:Xa,huberLoss:ja,logLoss:za,meanSquaredError:_a,sigmoidCrossEntropy:$a,softmaxCrossEntropy:Ar},ar={sparseFillEmptyRows:gr,sparseReshape:Ir,sparseSegmentMean:tr,sparseSegmentSum:Cr},rr={stringNGrams:er,stringSplit:Br,stringToHashBucketFast:ir},hr={sgd:oo.sgd,momentum:oo.momentum,adadelta:oo.adadelta,adagrad:oo.adagrad,rmsprop:oo.rmsprop,adamax:oo.adamax,adam:oo.adam},cr="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:A=>A();function lr(){return new Promise((A=>cr((()=>A()))))}function Dr(A,g){const I=A[0].length;A.forEach(((A,g)=>{CA(A.length===I,(()=>`Error in concat${I}D: rank of tensors[${g}] must be the same as the rank of the rest (${I})`))})),CA(g>=0&&g<I,(()=>`Error in concat${I}D: axis must be between 0 and ${I-1}.`));const t=A[0];A.forEach(((A,C)=>{for(let e=0;e<I;e++)CA(e===g||A[e]===t[e],(()=>`Error in concat${I}D: Shape of tensors[${C}] (${A}) does not match the shape of the rest (${t}) along the non-concatenated axis ${C}.`))}))}function ur(A,g){const I=A[0].slice();for(let t=1;t<A.length;t++)I[g]+=A[t][g];return I}var wr;function dr(A,g,I){let t=new Array;if(null==I&&null==g)return t;if(null==g)for(;t.length<A+I.length;)t.push(-1);else t=g.slice();if(null==I)return t;if(A+I.length!==t.length)throw new Error(`rt input.shape and shape=${g} are incompatible: rt input.rank = ${A+I.length}, but shape.rank = ${t.length}`);for(let C=1;C<I.length;++C){const e=I[C],B=t[t.length-I.length+C],i=t[B];if(e>=0)if(i>=0){if(i!==e)throw new Error(`rt input.shape and shape=${g} are incompatible: rt input.shape[${C+A}] = ${e} but shape[${C+A}] = ${i}`)}else t[B]=e}return t}function pr(A){const g={FIRST_DIM_SIZE:wr.FIRST_DIM_SIZE,VALUE_ROWIDS:wr.VALUE_ROWIDS,ROW_LENGTHS:wr.ROW_LENGTHS,ROW_SPLITS:wr.ROW_SPLITS,ROW_LIMITS:wr.ROW_LIMITS,ROW_STARTS:wr.ROW_STARTS},I=[];for(const t of A){if(!(t in g))break;I.push(g[t])}return I}function yr(A){return 0===A.length?0:A[0]===wr.FIRST_DIM_SIZE?A.length-1:A.length}function Gr(A,g){if(null==A||null==g)return;const I=A.length,t=g.length;if(I>=t)throw new Error(`defaultValue.shape=${A} and ragged tensor flatValues.shape=${g}, are incompatible: defaultValue.rank = ${I} must be less than ragged tensor input flatValues.rank = ${t})`);for(let C=0;C<Math.min(I,t-1);++C){const I=A[C],t=g[C+1];if(I>=0&&t>=0&&1!==I&&I!==t)throw new Error(`defaultValue.shape=${A}, and ragged tensor input flatValues.shape=${g} are incompatible: defaultValue.shape[${C-A.length}] = ${I} but ragged tensor input.flatValues.shape[${C-A.length}] = ${t}`)}}!function(A){A[A.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",A[A.VALUE_ROWIDS=1]="VALUE_ROWIDS",A[A.ROW_LENGTHS=2]="ROW_LENGTHS",A[A.ROW_SPLITS=3]="ROW_SPLITS",A[A.ROW_LIMITS=4]="ROW_LIMITS",A[A.ROW_STARTS=5]="ROW_STARTS"}(wr||(wr={}));const fr=30;function Nr(A){return A<=fr?A:UA(A,Math.floor(Math.sqrt(A)))}function Fr(A,g,I){return[I*("number"==typeof A?A:A[0]),g*("number"==typeof A?A:A[1])]}function Rr(A,g,I,t=!0){let C=[];if(t)C=C.concat(g.slice(0)),C.push(A[0]/I),C=C.concat(A.slice(1));else{C=C.concat(A[0]);const I=g.length;for(let t=0;t<I;++t)C=C.concat([A[t+1]/g[t],g[t]]);C=C.concat(A.slice(I+1))}return C}function mr(A,g,I=!0){const t=[];if(I){t.push(g);for(let I=g+1;I<A;++I)I<=2*g?(t.push(I),t.push(I-(g+1))):t.push(I)}else{const I=[],C=[];for(let t=1;t<A;++t)t>=2*g+1||t%2==1?C.push(t):I.push(t);t.push(...I),t.push(0),t.push(...C)}return t}function kr(A,g,I,t=!0){const C=[];t?C.push(A[0]/I):C.push(A[0]*I);for(let I=1;I<A.length;++I)I<=g.length?t?C.push(g[I-1]*A[I]):C.push(A[I]/g[I-1]):C.push(A[I]);return C}function Sr(A,g){const I=[0];for(let t=0;t<g;++t)I.push(A[t][0]);return I}function Mr(A,g,I){const t=A.slice(0,1);for(let C=0;C<I;++C)t.push(A[C+1]-g[C][0]-g[C][1]);return t}const Ur=1.7580993408473768,Kr=1.0507009873554805,Jr=.3275911,Yr=.254829592,Lr=-.284496736,xr=1.421413741,br=-1.453152027,Hr=1.061405429;function qr(A,g){if(A.length!==g.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${A.length}, imag: ${g.length}.`);const I=new Float32Array(2*A.length);for(let t=0;t<I.length;t+=2)I[t]=A[t/2],I[t+1]=g[t/2];return I}function Tr(A){const g=new Float32Array(A.length/2),I=new Float32Array(A.length/2);for(let t=0;t<A.length;t+=2)g[t/2]=A[t],I[t/2]=A[t+1];return{real:g,imag:I}}function vr(A){const g=Math.ceil(A.length/4),I=new Float32Array(g),t=new Float32Array(g);for(let g=0;g<A.length;g+=4)I[Math.floor(g/4)]=A[g],t[Math.floor(g/4)]=A[g+1];return{real:I,imag:t}}function Vr(A){const g=Math.floor(A.length/4),I=new Float32Array(g),t=new Float32Array(g);for(let g=2;g<A.length;g+=4)I[Math.floor(g/4)]=A[g],t[Math.floor(g/4)]=A[g+1];return{real:I,imag:t}}function Wr(A,g){return{real:A[2*g],imag:A[2*g+1]}}function Or(A,g,I,t){A[2*t]=g,A[2*t+1]=I}function Zr(A,g){const I=new Float32Array(A/2),t=new Float32Array(A/2);for(let C=0;C<Math.ceil(A/2);C++){const e=(g?2:-2)*Math.PI*(C/A);I[C]=Math.cos(e),t[C]=Math.sin(e)}return{real:I,imag:t}}function Pr(A,g,I){const t=(I?2:-2)*Math.PI*(A/g);return{real:Math.cos(t),imag:Math.sin(t)}}const Xr="->",jr=/->/g,zr=",",_r="...";function $r(A,g){const I=((A=A.replace(/\s/g,"")).length-A.replace(jr,"").length)/Xr.length;if(I<1)throw new Error("Equations without an arrow are not supported.");if(I>1)throw new Error(`Equation must contain exactly one arrow ("${Xr}").`);const[t,C]=A.split(Xr);CA(-1===t.indexOf(_r),(()=>`The ellipsis notation ("${_r}") is not supported yet.`));const e=t.split(zr),B=e.length;if(g!==B)throw new Error(`Expected ${B} input tensors, received ${g}`);if(B>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let A=0;A<C.length;++A){const g=C[A];if(!e.some((A=>-1!==A.indexOf(g))))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);-1===i.indexOf(g)&&i.push(g)}for(let A=0;A<t.length;++A){const g=t[A];-1===i.indexOf(g)&&g!==zr&&i.push(g)}const Q=new Array(e.length);for(let A=0;A<B;++A){if(new Set(e[A].split("")).size!==e[A].length)throw new Error(`Found duplicate axes in input component ${e[A]}. Support for duplicate axes in input is not implemented yet.`);Q[A]=[];for(let g=0;g<e[A].length;++g)Q[A].push(i.indexOf(e[A][g]))}const o=i.length,E=[];for(let A=C.length;A<o;++A)E.push(A);return{allDims:i,summedDims:E,idDims:Q}}function Ah(A,g){let I=new Array(A);I.fill(-1);for(let A=0;A<g.length;++A)I[g[A]]=A;const t=[];for(let g=0;g<A;++g)-1===I[g]&&t.push(g);return I=I.filter((A=>-1!==A)),{permutationIndices:I,expandDims:t}}function gh(A,g,I){const t=new Array(A);for(let A=0;A<I.length;++A){const C=I[A].shape;for(let I=0;I<g[A].length;++I)void 0===t[g[A][I]]?t[g[A][I]]=C[I]:CA(t[g[A][I]]===C[I],(()=>`Expected dimension ${t[g[A][I]]} at axis ${I} of input shaped ${JSON.stringify(C)}, but got dimension ${C[I]}`))}}function Ih(A,g){const I=A,t=[];let C=0;0===A.length&&I.push(-1),C=A.length+1;for(let A=0;A<C;++A)t.push([]);const e=[];for(let A=0;A<I.length;++A){const C=Ch(g,I[A]);for(const g of C)-1===e.indexOf(g)&&(t[A].push(g),e.push(g))}return{path:I,steps:t}}function th(A){return A.every(((A,g)=>A===g))}function Ch(A,g){const I=[];for(let t=0;t<A.length;++t)0!==A[t].length&&-1===A[t].indexOf(g)&&-1!==g||I.push(t);return I}function eh(A,g,I=0){let t=[];if("number"==typeof g)CA(A.shape[I]%g==0,(()=>"Number of splits must evenly divide the axis.")),t=new Array(g).fill(A.shape[I]/g);else{const C=g.reduce(((A,g)=>(-1===g&&(A+=1),A)),0);CA(C<=1,(()=>"There should be only one negative value in split array."));const e=g.indexOf(-1);if(-1!==e){const t=g.reduce(((A,g)=>g>0?A+g:A));g[e]=A.shape[I]-t}CA(A.shape[I]===g.reduce(((A,g)=>A+g)),(()=>"The sum of sizes must match the size of the axis dimension.")),t=g}return t}function Bh(A){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${A}`}function ih(A,g){return`indices(${A}, 0) is invalid: ${g} < 0`}function Qh(A,g,I){return`indices(${A}, 0) is invalid: ${g} >= ${I}`}function oh(A,g){return`only one output dimension may be -1, not both ${A} and ${g}`}function Eh(A,g){return`size ${A} must be non-negative, not ${g}`}function nh(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function sh(A,g){return`Input to reshape is a SparseTensor with ${QA(A)}\n  dense values, but the requested shape requires a multiple of ${QA(g)}. inputShape=${A} outputShape= ${g}`}function ah(A,g){return`Input to reshape is a tensor with ${QA(A)} dense values, but the requested shape has ${QA(g)}. inputShape=${A} outputShape=${g}`}function rh(){return"segment ids must be >= 0"}function hh(){return"segment ids are not increasing"}function ch(A,g){return`Segment id ${A} out of range [0, ${g}), possibly because segmentIds input is not sorted.`}function lh(A,g,I){return`Bad: indices[${A}] == ${g} out of range [0, ${I})`}function Dh(A,g){let I,t=!1;for(A<=fr?(I=A,t=!0):I=UA(A,Math.floor(Math.sqrt(A)));!t;)I>g||I===A?t=!0:I=UA(A,I+1);return I}function uh(A,g,I){const t=[],C=A.length;for(let e=0;e<C;e++)e!==g?t.push(A[e]):t.push(I);return t}function wh(A,g,I,t){const C=g.shape.length,e=A.shape.length;if(0!==t&&(t<-C||t>C))throw new Error(`Expect batchDims in the range of [-${C}, ${C}], but got ${t}`);if(t<0&&(t+=C),t>e)throw new Error(`batchDims (${t}) must be less than rank(x) (\n    ${e}).`);if(I<t)throw new Error(`batchDims (${t}) must be less than or equal to axis (${I}).`);for(let I=0;I<t;++I)if(A.shape[I]!==g.shape[I])throw new Error(`x.shape[${I}]: ${A.shape[I]} should be equal to indices.shape[${I}]: ${g.shape[I]}.`);const B=A.shape[I],i=[];let Q=1,o=1,E=1;for(let g=0;g<t;++g)i.push(A.shape[g]),Q*=A.shape[g];for(let g=t;g<I;g++)i.push(A.shape[g]),o*=A.shape[g];for(let A=t;A<C;A++)i.push(g.shape[A]);for(let g=I+1;g<e;g++)i.push(A.shape[g]),E*=A.shape[g];return{batchSize:Q,sliceSize:E,outerSize:o,dimSize:B,outputShape:i}}function dh(A){try{return A.map((A=>TC(A)))}catch(A){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${A}`)}}function ph(A){return A.map((A=>qC(A)))}const yh={kernelName:_A,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,Ss(qB(I,"float32"),-1))}}},Gh={kernelName:$A,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>{const g=HQ(qB(I,"float32")),t=bQ(go(XQ(1),g));return Ki(LQ(A,t))}}}},fh={kernelName:Ag,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>{const g=bQ(go(HQ(qB(I,"float32")),1));return LQ(A,g)}}}},Nh={kernelName:gg,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{let g=A;const t=bi(I.shape,C);return t.length>0&&(g=xE(g,t)),Lo(g,I.shape)},b:()=>{let g=A;const I=bi(t.shape,C);return I.length>0&&(g=xE(g,I)),Lo(g,t.shape)}}}},Fh={kernelName:Ig,saveAllInputs:!0,gradFunc:(A,g)=>{const I={};return g.forEach(((g,t)=>{I[t]=()=>A.clone()})),I}},Rh={kernelName:eg,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>qQ(I)}}},mh={kernelName:Bg,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>qQ(I)}}},kh={kernelName:ig,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,bQ(go(XQ(1),HQ(qB(I,"float32")))))}}},Sh={kernelName:Qg,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>{const g=bQ(JQ(XQ(1),HQ(qB(I,"float32"))));return LQ(A,g)}}}},Mh={kernelName:ng,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{const g=JQ(HQ(I),HQ(t));let e=xQ(A,LQ(t,g));const B=bi(I.shape,C);return B.length>0&&(e=xE(e,B)),Lo(e,I.shape)},b:()=>{const g=JQ(HQ(I),HQ(t));let e=Ki(xQ(A,LQ(I,g)));const B=bi(t.shape,C);return B.length>0&&(e=xE(e,B)),Lo(e,t.shape)}}}},Uh={kernelName:og,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,JQ(HQ(qB(I,"float32")),1))}}},Kh={kernelName:Eg,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,go(XQ(1),HQ(qB(I,"float32"))))}}};const Jh=Le({avgPool3dGrad_:function(A,g,I,t,C,e){const B=Ke(A,"dy","avgPool3dGrad"),i=Ke(g,"input","avgPool3dGrad");let Q=B,o=i,E=!1;4===i.rank&&(E=!0,Q=Lo(B,[1,B.shape[0],B.shape[1],B.shape[2],B.shape[3]]),o=Lo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),CA(5===Q.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${Q.rank}.`)),CA(5===o.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${o.rank}.`)),Yo("avgPool3dGrad",C,e);const n={dy:Q,input:o},s={filterSize:I,strides:t,pad:C,dimRoundingMode:e},a=Ge.runKernel(hg,n,s);return E?Lo(a,[a.shape[1],a.shape[2],a.shape[3],a.shape[4]]):a}}),Yh={kernelName:rg,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{filterSize:C,strides:e,pad:B,dimRoundingMode:i}=I;return{x:()=>Jh(A,t,C,e,B,i)}}};const Lh=Le({avgPoolGrad_:function(A,g,I,t,C){const e=Ke(A,"dy","avgPoolGrad"),B=Ke(g,"input","avgPoolGrad");CA(B.rank===e.rank,(()=>`Rank of input (${B.rank}) does not match rank of dy (${e.rank})`));let i=B,Q=e,o=!1;3===B.rank&&(o=!0,i=Lo(B,[1,B.shape[0],B.shape[1],B.shape[2]]),Q=Lo(e,[1,e.shape[0],e.shape[1],e.shape[2]])),CA(4===Q.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${Q.rank}.`)),CA(4===i.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`));const E={dy:Q,input:i},n={filterSize:I,strides:t,pad:C},s=Ge.runKernel(ag,E,n);return o?Lo(s,[s.shape[1],s.shape[2],s.shape[3]]):s}}),xh={kernelName:sg,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{filterSize:C,strides:e,pad:B}=I;return{x:()=>Lh(A,t,C,e,B)}}},bh={kernelName:cg,inputsToSave:["a","b"],gradFunc:(A,g,I)=>{const[t,C]=g,{transposeA:e,transposeB:B}=I;return e||B?!e&&B?{a:()=>Ei(A,C,!1,!1),b:()=>Ei(A,t,!0,!1)}:e&&!B?{a:()=>Ei(C,A,!1,!0),b:()=>Ei(t,A,!1,!1)}:{a:()=>Ei(C,A,!0,!0),b:()=>Ei(A,t,!0,!0)}:{a:()=>Ei(A,C,!1,!0),b:()=>Ei(t,A,!0,!1)}}},Hh={kernelName:lg,gradFunc:(A,g,I)=>{const{blockShape:t,crops:C}=I;return{x:()=>Hn(A,t,C)}}},qh={kernelName:ug,gradFunc:(A,g,I)=>{const t=I,C=t.inputShape,e=t.shape,B=Array.from(e);for(let A=C.length-1;A>=0;A--)if(C[A]===e[A])B[A]=1;else if(1!==C[A])throw new Error(`broadcastTo(): [${C}] cannot be broadcast to [${e}].`);const i=[];for(let A=0;A<B.length;A++)B[A]>1&&i.push(A);return{x:()=>xE(A,i,!0)}}},Th={kernelName:dg,gradFunc:A=>({x:()=>A.clone()})},vh={kernelName:pg,gradFunc:A=>({x:()=>qQ(A)})},Vh={kernelName:yg,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{clipValueMin:C,clipValueMax:e}=I;return{x:()=>pE(sn(jE(t,C),In(t,e)),A,qQ(A))}}},Wh={kernelName:fg,inputsToSave:["x"],gradFunc:yh.gradFunc},Oh={kernelName:Ng,saveAllInputs:!0,gradFunc:(A,g,I)=>{const t=g.map((A=>A.shape)),{axis:C}=I,e=DA(C,g[0].shape)[0],B=t.map((A=>A[e]));return Ns(A,B,e).map((A=>()=>A))}},Zh={kernelName:Fg,inputsToSave:["x","filter"],gradFunc:(A,g,I)=>{const[t,C]=g,{dilations:e,strides:B,pad:i,dataFormat:Q}=I;return CA(Uo(e),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${e}'`)),{x:()=>iE(t.shape,A,C,B,i,Q),filter:()=>ta(t,A,C.shape,B,i,Q)}}},Ph={kernelName:mg,inputsToSave:["dy","filter"],gradFunc:(A,g,I)=>{const[t,C]=g,{strides:e,pad:B,dataFormat:i,dimRoundingMode:Q}=I;return{dy:()=>eE(A,C,e,B,i,1,Q),filter:()=>ta(A,t,C.shape,e,B,i,Q)}}};const Xh=Le({conv3DBackpropFilter_:function(A,g,I,t,C){let e=A;4===A.rank&&(e=Lo(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]]));let B=g;4===B.rank&&(B=Lo(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),CA(5===e.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${e.shape}.`)),CA(5===B.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${B.shape}.`)),CA(5===I.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${I}.`)),CA(e.shape[4]===I[3],(()=>`Error in conv3dDerFilter: depth of input ${e.shape[4]}) must match input depth in filter (${I[3]}.`)),CA(B.shape[4]===I[4],(()=>`Error in conv3dDerFilter: depth of dy (${B.shape[4]}) must match output depth for filter (${I[4]}).`));const i={x:e,dy:B},Q={strides:t,pad:C,filterShape:I};return Ge.runKernel(Sg,i,Q)}}),jh={kernelName:kg,inputsToSave:["x","filter"],gradFunc:(A,g,I)=>{const{dilations:t,strides:C,pad:e}=I;CA(Uo(t),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${t}'`));const[B,i]=g;return{x:()=>EE(B.shape,A,i,C,e),filter:()=>Xh(B,A,i.shape,C,e)}}},zh={kernelName:Ug,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(Ki(cs(qB(I,"float32"))),A)}}},_h={kernelName:Kg,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(ls(qB(I,"float32")),A)}}},$h={kernelName:Yg,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{axis:C,exclusive:e,reverse:B}=I;return{x:()=>{const g=UE([C],t.rank);let I=hE(A,C,e,!B);return null!=g&&(I=Yi(I,g)),I}}}},Ac={kernelName:Hg,inputsToSave:["x","filter"],gradFunc:(A,g,I)=>{const{dilations:t,strides:C,pad:e,dimRoundingMode:B}=I,i=null==t?[1,1]:t;CA(Uo(i),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[Q,o]=g;return CA(4===Q.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${Q.rank}.`)),CA(4===o.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${o.rank}.`)),CA(Q.shape[3]===o.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${Q.shape[3]}) must match the inChannels dimension in filter ${o.shape[2]}.`)),CA(Ko(C,i),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${C} and dilations '${i}'.`)),Yo("depthwiseConv2d",e,B),{x:()=>Ea(Q.shape,A,o,C,e,i,B),filter:()=>oa(Q,A,o.shape,C,e,i,B)}}},gc={kernelName:Vg,inputsToSave:["x","filter"],gradFunc:(A,g,I)=>{const[t,C]=g,e={x:t,filter:C,dy:A},B={x:t,filter:C,dy:A};return{x:()=>Ge.runKernel(Wg,e,I),filter:()=>Ge.runKernel(Og,B,I)}}},Ic={kernelName:Xg,outputsToSave:[!0],gradFunc:(A,g)=>{const[I]=g,t={dy:A,y:I};return{x:()=>Ge.runKernel(jg,t)}}},tc={kernelName:zg,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g,t=xQ(TE(Ki(HQ(I))),2/Math.sqrt(Math.PI));return{x:()=>xQ(A,t)}}},Cc={kernelName:$g,outputsToSave:[!0],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,I)}}},ec={kernelName:AI,inputsToSave:["input"],gradFunc:(A,g)=>{const[I]=g;return{input:()=>Lo(A,I.shape)}}},Bc={kernelName:gI,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,TE(I))}}},ic={kernelName:eI,gradFunc:A=>({x:()=>qQ(A)})},Qc={kernelName:BI,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{const g=LQ(A,qB(t,"float32")),e=bi(I.shape,C);return e.length>0?Lo(xE(g,e),I.shape):g},b:()=>{let g=xQ(A,qB(I,"float32"));const e=bi(t.shape,C);e.length>0&&(g=Lo(xE(g,e),t.shape));const B=HQ(t);return Ki(LQ(g,qB(B,"float32")))}}}},oc={kernelName:iI,inputsToSave:["x","mean","variance","scale"],gradFunc:(A,g,I)=>{const{varianceEpsilon:t}=I,[C,e,B,i]=g,Q=null==i?XQ(1):i,o=bi(e.shape,C.shape),E=[];if(1===e.rank){for(let A=0;A<C.shape.length-1;++A)E.push(C.shape[A]);E.push(1)}const n=go(C,e),s=xQ(A,Q),a=ns(JQ(B,XQ(t))),r=xQ(xQ(xQ(a,a),a),XQ(-.5));return{x:()=>1===e.rank?Lo(xQ(xQ(A,WE(Lo(a,[1,1,1,e.shape[0]]),E)),Q),C.shape):Lo(xQ(xQ(A,a),Q),C.shape),mean:()=>{let A=xQ(xQ(a,XQ(-1)),s);return 1===e.rank&&(A=xE(A,o)),Lo(A,e.shape)},variance:()=>{let A=xQ(xQ(r,n),s);return 1===e.rank&&(A=xE(A,o)),Lo(A,e.shape)},scale:()=>{const g=xQ(n,a);let I=xQ(A,g);return 1===e.rank&&(I=xE(I,o)),Lo(I,e.shape)},offset:()=>{let g=A;return 1===e.rank&&(g=xE(g,o)),Lo(g,e.shape)}}}},Ec={kernelName:QI,inputsToSave:["x","indices"],gradFunc:(A,g,I)=>{const[t,C]=g,{axis:e}=I,B=DA(e,t.shape)[0];return{x:()=>{const g=t.shape,I=C.size,i=g.slice(0,B),Q=i.length,o=g.slice(e,g.length).slice(1),E=o.length,n=nc(0,Q),s=nc(Q+1,Q+1+E),a=sc([i,[I],o]),r=Lo(A,a),h=Lo(C,[I]),c=sc([[Q],n,s]),l=Yi(r,c);let D=Ts(l,h,t.shape[B]);const u=KE(c);return D=Yi(D,u),D},indices:()=>C}}};function nc(A,g){const I=[];for(let t=A;t<g;++t)I.push(t);return I}function sc(A){const g=[];for(let I=0;I<A.length;++I)for(let t=0;t<A[I].length;++t)g.push(A[I][t]);return g}const ac={kernelName:nI,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g;return{a:()=>qQ(I),b:()=>qQ(t)}}},rc={kernelName:sI,gradFunc:A=>({x:()=>qB(A,"float32")})},hc={kernelName:hI,gradFunc:A=>({x:()=>qQ(A)})},cc={kernelName:cI,gradFunc:A=>({x:()=>qQ(A)})},lc={kernelName:lI,gradFunc:A=>({x:()=>qQ(A)})},Dc={kernelName:DI,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{alpha:C}=I,e=XE(t,0);return{x:()=>pE(e,A,xQ(A,C))}}},uc={kernelName:yI,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,JQ(I,1))}}},wc={kernelName:pI,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,qB(I,"float32"))}}},dc={kernelName:RI,inputsToSave:[],outputsToSave:[!0],gradFunc:(A,g,I)=>{const[t]=g,{axis:C}=I;return{logits:()=>{const g=TE(t);return go(A,xQ(xE(A,C,!0),g))}}}};const pc=Le({localResponseNormalizationBackprop_:function(A,g,I,t=5,C=1,e=1,B=.5){const i={x:A,y:g,dy:I},Q={depthRadius:t,bias:C,alpha:e,beta:B};return Ge.runKernel(SI,i,Q)}}),yc={kernelName:kI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(A,g,I)=>{const[t,C]=g,{depthRadius:e,bias:B,alpha:i,beta:Q}=I;return{x:()=>pc(t,C,A,e,B,i,Q)}}};function Gc(A,g,I,t){return g.rank<I.rank&&(g=Lo(g,SE(g.shape,t))),A.rank<I.rank&&(A=Lo(A,SE(A.shape,t))),{x:()=>xQ(A,qB(dE(I,g),A.dtype))}}const fc={kernelName:MI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(A,g,I)=>{const t=I,{reductionIndices:C}=t,e=g[0],B=Gc(A,g[1],e,DA(C,e.shape));return{x:()=>B.x()}}},Nc={kernelName:UI,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g;return{a:()=>xQ(A,qB(jE(I,t),"float32")),b:()=>xQ(A,qB(gn(I,t),"float32"))}}};const Fc=Le({maxPool3dGrad_:function(A,g,I,t,C,e,B){const i=Ke(A,"dy","maxPool3dGrad"),Q=Ke(g,"input","maxPool3dGrad"),o=Ke(I,"output","maxPool3dGrad");let E=i,n=Q,s=o,a=!1;4===Q.rank&&(a=!0,E=Lo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),n=Lo(Q,[1,Q.shape[0],Q.shape[1],Q.shape[2],Q.shape[3]]),s=Lo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),CA(5===E.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${E.rank}.`)),CA(5===n.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${n.rank}.`)),CA(5===s.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${s.rank}.`)),Yo("maxPool3dGrad",e,B);const r={dy:E,input:n,output:s},h={filterSize:t,strides:C,pad:e,dimRoundingMode:B},c=Ge.runKernel(LI,r,h);return a?Lo(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),Rc={kernelName:YI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(A,g,I)=>{const[t,C]=g,{filterSize:e,strides:B,pad:i,dimRoundingMode:Q}=I;return{x:()=>Fc(A,t,C,e,B,i,Q)}}};const mc=Le({maxPoolGrad_:function(A,g,I,t,C,e,B){const i=Ke(A,"dy","maxPoolGrad"),Q=Ke(g,"input","maxPoolGrad"),o=Ke(I,"output","maxPoolGrad");CA(Q.rank===i.rank,(()=>`Rank of input (${Q.rank}) does not match rank of dy (${i.rank})`)),CA(4===i.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`)),CA(4===Q.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${Q.rank}.`)),Yo("maxPoolGrad",e,B);const E={dy:i,input:Q,output:o},n={filterSize:t,strides:C,pad:e,dimRoundingMode:B};return Ge.runKernel(JI,E,n)}}),kc={kernelName:KI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(A,g,I)=>{const[t,C]=g,{filterSize:e,strides:B,pad:i}=I;return{x:()=>mc(A,t,C,e,B,i)}}},Sc={kernelName:TI,inputsToSave:["x"],gradFunc:(A,g,I)=>{const t=g[0],{paddings:C}=I,e=C.map((A=>A[0]));return{x:()=>To(A,e,t.shape)}}},Mc={kernelName:At,inputsToSave:["x"],gradFunc:(A,g,I)=>{const t=g[0],{paddings:C}=I,e=C.map((A=>A[0]));return{x:()=>To(A,e,t.shape)}}},Uc={kernelName:It,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(A,g)=>{const[I,t,C]=g,e=I,B=t,i=Hi(e.shape,B.shape);return{a:()=>{const g=qB(B,"float32");let I=xQ(A,xQ(g,Ao(e,go(g,XQ(1)))));const t=bi(e.shape,i);return t.length>0&&(I=xE(I,t)),Lo(I,e.shape)},b:()=>{const g=XE(e,0),I=pE(g,en(e),qQ(e));let t=xQ(A,xQ(C,I));const Q=bi(B.shape,i);return Q.length>0&&(t=xE(t,Q)),Lo(t,B.shape)}}}};function Kc(A,g,I){const t=A.shape.length,C=t-I.length,e=UE(I,t);let B=A;null!=e&&(B=Yi(A,e));const i=B.shape.slice(),Q=i.splice(t-I.length,I.length).reduce(((A,g)=>A*g),1);i.push(Q);let o=function(A,g,I){const t=A.shape.slice();t[I]=1;const C=Lo(g,t),e=rE(A,I,!0,!1),B=rE(A,I,!0,!0),i=xQ(e,B);return xQ(C,i)}(B.reshape(i),g,C);if(o=o.reshape(B.shape),null!=e){const A=KE(e);o=Yi(o,A)}return o}const Jc={kernelName:yt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>{const g=XE(I,XQ(0)),t=XQ(Ur),C=XQ(Kr),e=xQ(A,C),B=xQ(xQ(A,t),TE(qB(I,"float32")));return pE(g,e,B)}}}},Yc={kernelName:Mt,gradFunc:(A,g,I)=>{const{blockShape:t,paddings:C}=I;return{x:()=>Wo(A,t,C)}}},Lc={kernelName:Ut,gradFunc:(A,g,I)=>{const{axis:t}=I;return{x:()=>Ho(A,t)}}};const xc=[yh,Gh,fh,Nh,Fh,Rh,mh,kh,Sh,Mh,Uh,Kh,Yh,xh,bh,Hh,qh,Th,vh,Vh,Wh,Oh,Ph,Zh,jh,zh,_h,$h,Ac,gc,{kernelName:Zg,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{const g=LQ(A,qB(t,"float32")),e=bi(I.shape,C);return e.length>0?Lo(xE(g,e),I.shape):g},b:()=>{let g=xQ(A,qB(I,"float32"));const e=bi(t.shape,C);e.length>0&&(g=Lo(xE(g,e),t.shape));const B=HQ(t);return Ki(LQ(g,qB(B,"float32")))}}}},Ic,tc,Cc,ec,Bc,Qc,ic,oc,Ec,ac,rc,hc,cc,lc,Dc,uc,wc,dc,yc,fc,fc,Nc,Rc,kc,{kernelName:bI,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{axis:C}=I,e=DA(C,t.shape),B=QA(kE(t.shape,e)[1]);return{x:()=>{const g=t.shape.slice();e.forEach((A=>{g[A]=1}));const I=Lo(A,g);return LQ(xQ(I,Gn(t.shape,"float32")),B)}}}},{kernelName:HI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(A,g,I)=>{const t=I,{axis:C}=t,[e,B]=g,i=Gc(A,B,e,DA(C,e.shape));return{x:()=>i.x()}}},{kernelName:qI,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g;return{a:()=>xQ(A,qB(In(I,t),"float32")),b:()=>xQ(A,qB(XE(I,t),"float32"))}}},Sc,{kernelName:vI,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{const g=bi(I.shape,C);return g.length>0?Lo(xE(A,g),I.shape):A},b:()=>{const g=xQ(A,Ki(ZE(LQ(I,t)))),e=bi(t.shape,C);return e.length>0?Lo(xE(g,e),t.shape):g}}}},{kernelName:WI,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{const g=xQ(A,qB(t,"float32")),e=bi(I.shape,C);return e.length>0?Lo(xE(g,e),I.shape):g},b:()=>{const g=xQ(A,qB(I,"float32")),e=bi(t.shape,C);return e.length>0?Lo(xE(g,e),t.shape):g}}}},{kernelName:OI,gradFunc:A=>({x:()=>Ki(A)})},{kernelName:_I,inputsToSave:["indices"],gradFunc:(A,g)=>{const I=g[0];return{indices:()=>yn(I.shape,"float32")}}},{kernelName:zI,gradFunc:A=>({x:()=>qQ(A)})},{kernelName:$I,saveAllInputs:!0,gradFunc:(A,g,I)=>{const{axis:t}=I;return vs(A,t).map((A=>()=>A))}},Mc,Mc,Uc,{kernelName:tt,inputsToSave:["x","alpha"],gradFunc:(A,g)=>{const[I,t]=g,C=XE(I,0);return{x:()=>pE(C,A,xQ(A,t)),alpha:()=>{let g=pE(C,qQ(A),xQ(A,I));const e=bi(t.shape,A.shape);return e.length>0&&(g=xE(g,e)),Lo(g,t.shape)}}}},{kernelName:Ct,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{axis:C}=I;let e=[];return e=null==C?t.shape.map(((A,g)=>g)):"number"==typeof C?[C]:C,{x:()=>Kc(t,A,e)}}},{kernelName:ot,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,Ki(HQ(I)))}}},{kernelName:ct,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g,t=xQ(In(I,6),Ss(I));return{x:()=>xQ(A,qB(t,"float32"))}}},{kernelName:Et,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,qB(Ss(I),"float32"))}}},{kernelName:nt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>Lo(A,I.shape)}}},{kernelName:rt,inputsToSave:["images"],gradFunc:(A,g,I)=>{const[t]=g,C={dy:A,images:t};return{images:()=>Ge.runKernel(ht,C,I)}}},{kernelName:st,inputsToSave:["images"],gradFunc:(A,g,I)=>{const[t]=g,C={dy:A,images:t};return{images:()=>Ge.runKernel(at,C,I)}}},{kernelName:lt,gradFunc:(A,g,I)=>{const{dims:t}=I,C=DA(t,A.shape);return{x:()=>es(A,C)}}},{kernelName:Dt,gradFunc:A=>({x:()=>qQ(A)})},{kernelName:ut,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>Ki(LQ(A,xQ(Ao(I,1.5),2)))}}},{kernelName:pt,inputsToSave:["condition"],gradFunc:(A,g)=>{const[I]=g;return{condition:()=>qB(qQ(I),"float32"),t:()=>xQ(A,qB(I,A.dtype)),e:()=>xQ(A,qB(an(I),A.dtype))}}},Jc,{kernelName:Rt,outputsToSave:[!0],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,xQ(I,go(XQ(1),I)))}}},{kernelName:Ft,gradFunc:A=>({x:()=>qQ(A)})},{kernelName:ft,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(sE(qB(I,"float32")),A)}}},{kernelName:Nt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(aE(qB(I,"float32")),A)}}},{kernelName:Gt,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{begin:C,size:e}=I,B=t.shape,[i,Q]=rQ(t,C,e),o=[];for(let g=0;g<A.rank;g++)o.push([i[g],B[g]-i[g]-Q[g]]);return{x:()=>Jn(A,o)}}},{kernelName:Kt,outputsToSave:[!0],gradFunc:(A,g,I)=>{const[t]=g,{dim:C}=I,e=xQ(A,t);return{logits:()=>go(e,xQ(xE(e,[C],true),t))}}},{kernelName:mt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,qo(I))}}},Yc,Yc,Lc,Lc,{kernelName:kt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,xQ(bQ(qB(I,"float32")),2))}}},{kernelName:Ht,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=XQ(2);return{a:()=>xQ(A,xQ(C,go(I,t))),b:()=>xQ(A,xQ(C,go(t,I)))}}},{kernelName:qt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(A,xQ(qB(I,"float32"),2))}}},{kernelName:CC,gradFunc:A=>({x:()=>qQ(A)})},{kernelName:Ot,inputsToSave:["a","b"],gradFunc:(A,g)=>{const[I,t]=g,C=Hi(I.shape,t.shape);return{a:()=>{let g=A;const t=bi(I.shape,C);return t.length>0&&(g=xE(g,t)),Lo(g,I.shape)},b:()=>{let g=A;const I=bi(t.shape,C);return I.length>0&&(g=xE(g,I)),Lo(Ki(g),t.shape)}}}},{kernelName:St,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,C=t.shape.slice(),{axis:e}=I;DA(e,t.shape).forEach((A=>{C[A]=1}));const B=Lo(A,C),i=xQ(B,Gn(t.shape,"float32"));return{x:()=>i}}},{kernelName:Zt,inputsToSave:["x"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>LQ(A,HQ(sE(I)))}}},{kernelName:Pt,outputsToSave:[!0],gradFunc:(A,g)=>{const[I]=g;return{x:()=>xQ(go(XQ(1),HQ(I)),A)}}},{kernelName:Xt,inputsToSave:["x"],gradFunc:(A,g,I)=>{const[t]=g,{reps:C}=I;return{x:()=>{let g=qQ(t);if(1===t.rank)for(let I=0;I<C[0];++I)g=JQ(g,To(A,[I*t.shape[0]],[t.shape[0]]));else if(2===t.rank)for(let I=0;I<C[0];++I)for(let e=0;e<C[1];++e)g=JQ(g,To(A,[I*t.shape[0],e*t.shape[1]],[t.shape[0],t.shape[1]]));else if(3===t.rank)for(let I=0;I<C[0];++I)for(let e=0;e<C[1];++e)for(let B=0;B<C[2];++B)g=JQ(g,To(A,[I*t.shape[0],e*t.shape[1],B*t.shape[2]],[t.shape[0],t.shape[1],t.shape[2]]));else{if(4!==t.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${t.rank} tensors yet.`);for(let I=0;I<C[0];++I)for(let e=0;e<C[1];++e)for(let B=0;B<C[2];++B)for(let i=0;i<C[3];++i)g=JQ(g,To(A,[I*t.shape[0],e*t.shape[1],B*t.shape[2],i*t.shape[3]],[t.shape[0],t.shape[1],t.shape[2],t.shape[3]]))}return g}}}},{kernelName:_t,gradFunc:(A,g,I)=>{const t=I,{perm:C}=t,e=KE(C);return{x:()=>Yi(A,e)}}},{kernelName:AC,gradFunc:(A,g,I)=>{const t=I,{axis:C}=t;return{value:()=>ks(A,C)}}},{kernelName:gC,inputsToSave:["segmentIds"],gradFunc:(A,g)=>{const[I]=g;return{x:()=>function(A,g){const I=Co(g,qQ(g)),t=PE(A,I);let C=jE(g,XQ(0,"int32"));const e=t.rank-C.rank;for(let A=0;A<e;++A)C=vE(C,A+1);C=sn(C,Gn(t.shape,"bool"));const B=qQ(t);return pE(C,t,B)}(A,I)}}},{kernelName:tC,gradFunc:A=>({x:()=>qQ(A)})}];for(const A of xc)DC(A);ee().prototype.abs=function(){return this.throwIfDisposed(),to(this)},ee().prototype.acos=function(){return this.throwIfDisposed(),Eo(this)},ee().prototype.acosh=function(){return this.throwIfDisposed(),no(this)},ee().prototype.add=function(A){return this.throwIfDisposed(),JQ(this,A)},ee().prototype.all=function(A,g){return this.throwIfDisposed(),ao(this,A,g)},ee().prototype.any=function(A,g){return this.throwIfDisposed(),ro(this,A,g)},ee().prototype.argMax=function(A){return this.throwIfDisposed(),ho(this,A)},ee().prototype.argMin=function(A){return this.throwIfDisposed(),co(this,A)},ee().prototype.asScalar=function(){return this.throwIfDisposed(),CA(1===this.size,(()=>"The array must have only 1 element.")),Lo(this,[])},ee().prototype.asType=function(A){return this.throwIfDisposed(),qB(this,A)},ee().prototype.as1D=function(){return this.throwIfDisposed(),Lo(this,[this.size])},ee().prototype.as2D=function(A,g){return this.throwIfDisposed(),Lo(this,[A,g])},ee().prototype.as3D=function(A,g,I){return this.throwIfDisposed(),Lo(this,[A,g,I])},ee().prototype.as4D=function(A,g,I,t){return this.throwIfDisposed(),Lo(this,[A,g,I,t])},ee().prototype.as5D=function(A,g,I,t,C){return this.throwIfDisposed(),Lo(this,[A,g,I,t,C])},ee().prototype.asin=function(){return this.throwIfDisposed(),lo(this)},ee().prototype.asinh=function(){return this.throwIfDisposed(),Do(this)},ee().prototype.atan=function(){return this.throwIfDisposed(),uo(this)},ee().prototype.atan2=function(A){return this.throwIfDisposed(),wo(this,A)},ee().prototype.atanh=function(){return this.throwIfDisposed(),po(this)},ee().prototype.avgPool=function(A,g,I,t){return this.throwIfDisposed(),xo(this,A,g,I,t)},ee().prototype.batchToSpaceND=function(A,g){return this.throwIfDisposed(),Wo(this,A,g)},ee().prototype.batchNorm=function(A,g,I,t,C){return this.throwIfDisposed(),Oo(this,A,g,I,t,C)},ee().prototype.broadcastTo=function(A){return this.throwIfDisposed(),_o(this,A)},ee().prototype.cast=function(A){return this.throwIfDisposed(),qB(this,A)},ee().prototype.ceil=function(){return this.throwIfDisposed(),$o(this)},ee().prototype.clipByValue=function(A,g){return this.throwIfDisposed(),AE(this,A,g)},ee().prototype.concat=function(A,g){return this.throwIfDisposed(),A instanceof Ce&&(A=[A]),Ho([this,...A],g)},ee().prototype.conv1d=function(A,g,I,t,C,e){return this.throwIfDisposed(),BE(this,A,g,I,t,C,e)},ee().prototype.conv2dTranspose=function(A,g,I,t,C){return this.throwIfDisposed(),QE(this,A,g,I,t,C)},ee().prototype.conv2d=function(A,g,I,t,C,e){return this.throwIfDisposed(),eE(this,A,g,I,t,C,e)},ee().prototype.cos=function(){return this.throwIfDisposed(),sE(this)},ee().prototype.cosh=function(){return this.throwIfDisposed(),aE(this)},ee().prototype.cumprod=function(A,g,I){return this.throwIfDisposed(),rE(this,A,g,I)},ee().prototype.cumsum=function(A,g,I){return this.throwIfDisposed(),hE(this,A,g,I)},ee().prototype.depthToSpace=function(A,g){return this.throwIfDisposed(),lE(this,A,g)},ee().prototype.depthwiseConv2d=function(A,g,I,t,C,e){return this.throwIfDisposed(),DE(this,A,g,I,t,C,e)},ee().prototype.dilation2d=function(A,g,I,t,C){return this.throwIfDisposed(),wE(this,A,g,I,t,C)},ee().prototype.divNoNan=function(A){return this.throwIfDisposed(),yE(this,A)},ee().prototype.div=function(A){return this.throwIfDisposed(),LQ(this,A)},ee().prototype.dot=function(A){return this.throwIfDisposed(),GE(this,A)},ee().prototype.elu=function(){return this.throwIfDisposed(),NE(this)},ee().prototype.equal=function(A){return this.throwIfDisposed(),dE(this,A)},ee().prototype.erf=function(){return this.throwIfDisposed(),FE(this)},ee().prototype.euclideanNorm=function(A,g){return this.throwIfDisposed(),qE(this,A,g)},ee().prototype.exp=function(){return this.throwIfDisposed(),TE(this)},ee().prototype.expandDims=function(A){return this.throwIfDisposed(),vE(this,A)},ee().prototype.expm1=function(){return this.throwIfDisposed(),VE(this)},ee().prototype.fft=function(){return this.throwIfDisposed(),ys(this)},ee().prototype.flatten=function(){return this.throwIfDisposed(),Lo(this,[this.size])},ee().prototype.floor=function(){return this.throwIfDisposed(),ZE(this)},ee().prototype.floorDiv=function(A){return this.throwIfDisposed(),YQ(this,A)},ee().prototype.gather=function(A,g){return this.throwIfDisposed(),PE(this,A,g)},ee().prototype.greaterEqual=function(A){return this.throwIfDisposed(),jE(this,A)},ee().prototype.greater=function(A){return this.throwIfDisposed(),XE(this,A)},ee().prototype.ifft=function(){return this.throwIfDisposed(),Gs(this)},ee().prototype.irfft=function(){return this.throwIfDisposed(),fs(this)},ee().prototype.isFinite=function(){return this.throwIfDisposed(),zE(this)},ee().prototype.isInf=function(){return this.throwIfDisposed(),_E(this)},ee().prototype.isNaN=function(){return this.throwIfDisposed(),$E(this)},ee().prototype.leakyRelu=function(A){return this.throwIfDisposed(),An(this,A)},ee().prototype.lessEqual=function(A){return this.throwIfDisposed(),In(this,A)},ee().prototype.less=function(A){return this.throwIfDisposed(),gn(this,A)},ee().prototype.localResponseNormalization=function(A,g,I,t){return this.throwIfDisposed(),Cn(this,A,g,I,t)},ee().prototype.logSigmoid=function(){return this.throwIfDisposed(),on(this)},ee().prototype.logSoftmax=function(A){return this.throwIfDisposed(),En(this,A)},ee().prototype.logSumExp=function(A,g){return this.throwIfDisposed(),nn(this,A,g)},ee().prototype.log=function(){return this.throwIfDisposed(),en(this)},ee().prototype.log1p=function(){return this.throwIfDisposed(),Bn(this)},ee().prototype.logicalAnd=function(A){return this.throwIfDisposed(),sn(this,A)},ee().prototype.logicalNot=function(){return this.throwIfDisposed(),an(this)},ee().prototype.logicalOr=function(A){return this.throwIfDisposed(),rn(this,A)},ee().prototype.logicalXor=function(A){return this.throwIfDisposed(),hn(this,A)},ee().prototype.matMul=function(A,g,I){return this.throwIfDisposed(),Ei(this,A,g,I)},ee().prototype.maxPool=function(A,g,I,t){return this.throwIfDisposed(),un(this,A,g,I,t)},ee().prototype.max=function(A,g){return this.throwIfDisposed(),YE(this,A,g)},ee().prototype.maximum=function(A){return this.throwIfDisposed(),Co(this,A)},ee().prototype.mean=function(A,g){return this.throwIfDisposed(),pn(this,A,g)},ee().prototype.min=function(A,g){return this.throwIfDisposed(),LE(this,A,g)},ee().prototype.minimum=function(A){return this.throwIfDisposed(),Nn(this,A)},ee().prototype.mirrorPad=function(A,g){return this.throwIfDisposed(),Fn(this,A,g)},ee().prototype.mod=function(A){return this.throwIfDisposed(),Rn(this,A)},ee().prototype.mul=function(A){return this.throwIfDisposed(),xQ(this,A)},ee().prototype.neg=function(){return this.throwIfDisposed(),Ki(this)},ee().prototype.norm=function(A,g,I){return this.throwIfDisposed(),HE(this,A,g,I)},ee().prototype.notEqual=function(A){return this.throwIfDisposed(),Mn(this,A)},ee().prototype.oneHot=function(A,g=1,I=0){return this.throwIfDisposed(),ni(this,A,g,I)},ee().prototype.onesLike=function(){return this.throwIfDisposed(),Un(this)},ee().prototype.pad=function(A,g){return this.throwIfDisposed(),Jn(this,A,g)},ee().prototype.pool=function(A,g,I,t,C,e){return this.throwIfDisposed(),qn(this,A,g,I,t,C,e)},ee().prototype.pow=function(A){return this.throwIfDisposed(),Ao(this,A)},ee().prototype.prelu=function(A){return this.throwIfDisposed(),Tn(this,A)},ee().prototype.prod=function(A,g){return this.throwIfDisposed(),vn(this,A,g)},ee().prototype.reciprocal=function(){return this.throwIfDisposed(),Is(this)},ee().prototype.relu=function(){return this.throwIfDisposed(),ts(this)},ee().prototype.relu6=function(){return this.throwIfDisposed(),Cs(this)},ee().prototype.reshapeAs=function(A){return this.throwIfDisposed(),Lo(this,A.shape)},ee().prototype.reshape=function(A){return this.throwIfDisposed(),Lo(this,A)},ee().prototype.resizeBilinear=function(A,g,I){return this.throwIfDisposed(),La(this,A,g,I)},ee().prototype.resizeNearestNeighbor=function(A,g,I){return this.throwIfDisposed(),xa(this,A,g,I)},ee().prototype.reverse=function(A){return this.throwIfDisposed(),es(this,A)},ee().prototype.rfft=function(){return this.throwIfDisposed(),Fs(this)},ee().prototype.round=function(){return this.throwIfDisposed(),Es(this)},ee().prototype.rsqrt=function(){return this.throwIfDisposed(),ns(this)},ee().prototype.selu=function(){return this.throwIfDisposed(),ss(this)},ee().prototype.separableConv2d=function(A,g,I,t,C,e){return this.throwIfDisposed(),as(this,A,g,I,t,C,e)},ee().prototype.sigmoid=function(){return this.throwIfDisposed(),qo(this)},ee().prototype.sign=function(){return this.throwIfDisposed(),hs(this)},ee().prototype.sin=function(){return this.throwIfDisposed(),cs(this)},ee().prototype.sinh=function(){return this.throwIfDisposed(),ls(this)},ee().prototype.slice=function(A,g){return this.throwIfDisposed(),To(this,A,g)},ee().prototype.softmax=function(A){return this.throwIfDisposed(),ps(this,A)},ee().prototype.softplus=function(){return this.throwIfDisposed(),Qn(this)},ee().prototype.spaceToBatchND=function(A,g){return this.throwIfDisposed(),Hn(this,A,g)},ee().prototype.split=function(A,g){return this.throwIfDisposed(),Ns(this,A,g)},ee().prototype.sqrt=function(){return this.throwIfDisposed(),bQ(this)},ee().prototype.square=function(){return this.throwIfDisposed(),HQ(this)},ee().prototype.squaredDifference=function(A){return this.throwIfDisposed(),Rs(this,A)},ee().prototype.squeeze=function(A){return this.throwIfDisposed(),ms(this,A)},ee().prototype.stack=function(A,g){this.throwIfDisposed();const I=A instanceof Ce?[this,A]:[this,...A];return ks(I,g)},ee().prototype.step=function(A){return this.throwIfDisposed(),Ss(this,A)},ee().prototype.stridedSlice=function(A,g,I,t,C,e,B,i){return this.throwIfDisposed(),Ms(this,A,g,I,t,C,e,B,i)},ee().prototype.sub=function(A){return this.throwIfDisposed(),go(this,A)},ee().prototype.sum=function(A,g){return this.throwIfDisposed(),xE(this,A,g)},ee().prototype.tan=function(){return this.throwIfDisposed(),Us(this)},ee().prototype.tanh=function(){return this.throwIfDisposed(),vo(this)},ee().prototype.tile=function(A){return this.throwIfDisposed(),WE(this,A)},ee().prototype.toBool=function(){return this.throwIfDisposed(),qB(this,"bool")},ee().prototype.toFloat=function(){return this.throwIfDisposed(),qB(this,"float32")},ee().prototype.toInt=function(){return this.throwIfDisposed(),qB(this,"int32")},ee().prototype.topk=function(A,g){return this.throwIfDisposed(),bs(this,A,g)},ee().prototype.transpose=function(A){return this.throwIfDisposed(),Yi(this,A)},ee().prototype.unique=function(A){return this.throwIfDisposed(),qs(this,A)},ee().prototype.unsortedSegmentSum=function(A,g){return this.throwIfDisposed(),Ts(this,A,g)},ee().prototype.unstack=function(A){return this.throwIfDisposed(),vs(this,A)},ee().prototype.where=function(A,g){return this.throwIfDisposed(),pE(A,this,g)},ee().prototype.zerosLike=function(){return this.throwIfDisposed(),qQ(this)};class bc extends Error{constructor(A){super(A),Object.setPrototypeOf(this,bc.prototype)}}class Hc extends Error{constructor(A){super(A),Object.setPrototypeOf(this,Hc.prototype)}}class qc extends Error{constructor(A){super(A),Object.setPrototypeOf(this,qc.prototype)}}class Tc extends Error{constructor(A){super(A),Object.setPrototypeOf(this,Tc.prototype)}}class vc extends Error{constructor(A){super(A),Object.setPrototypeOf(this,vc.prototype)}}class Vc{constructor(A){this.maxEntries=A||100,this.cache=new Map}get(A){let g;return this.cache.has(A)&&(g=this.cache.get(A),this.cache.delete(A),this.cache.set(A,g)),g}put(A,g){if(this.cache.has(A))this.cache.delete(A);else if(this.cache.size>=this.maxEntries){const A=this.cache.keys().next().value;this.cache.delete(A)}this.cache.set(A,g)}getMaxEntries(){return this.maxEntries}setMaxEntries(A){if(A<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${A}.`);if(this.maxEntries>A)for(let g=0;g<this.maxEntries-A;g++){const A=this.cache.keys().next().value;this.cache.delete(A)}this.maxEntries=A}}function Wc(A,g){if(Array.isArray(A)){let I=[];for(let t=0;t<g;t++)I=I.concat(A);return I}{const I=new Array(g);return I.fill(A),I}}function Oc(A,g){if(!A)throw new vc(g)}function Zc(A,g){let I=0;for(const t of A)t===g&&I++;return I}function Pc(A){return 1===A.length?A[0]:A}function Xc(A){return Array.isArray(A)?A:[A]}function jc(A){const g=A.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==g[0]?g:"private"+g}function zc(A){return A.length<=1||-1===A.indexOf("_")?A:A.replace(/[_]+(\w|$)/g,((A,g)=>g.toUpperCase()))}let _c={};function $c(A){if(null==A)return null;const g={};return g.className=A.getClassName(),g.config=A.getConfig(),g}function Al(A){if(null!=A&&"object"==typeof A)if(Array.isArray(A))A.forEach((A=>Al(A)));else{const g=Object.keys(A);for(const I of g){const g=A[I];null!=g&&"object"==typeof g&&(Array.isArray(g)||"ndarray"!==g.type||"number"!=typeof g.value?Al(g):A[I]=g.value)}}}function gl(A,g={},I={},t="object",C=!1){if("string"==typeof A){const C=A;let e;if(C in I)e=I[C];else if(C in _c)e=_c[C];else if(e=g[C],null==e)throw new qc(`Unknown ${t}: ${A}. This may be due to one of the following reasons:\n1. The ${t} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${t} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return e}{const e=A;if(null==e.className||null==e.config)throw new qc(`${t}: Improper config format: ${JSON.stringify(e)}.\n'className' and 'config' must set.`);const B=e.className;let i,Q;if(B in I?[i,Q]=I[B]:B in _c?[i,Q]=_c.className:B in g&&([i,Q]=g[B]),null==i)throw new qc(`Unknown ${t}: ${B}. This may be due to one of the following reasons:\n1. The ${t} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${t} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=Q){const A={};for(const g of Object.keys(_c))A[g]=_c[g];for(const g of Object.keys(I))A[g]=I[g];e.config.customObjects=A;const g=Object.assign({},_c);for(const A of Object.keys(I))_c[A]=I[A];Al(e.config);const t=Q(i,e.config,I,C);return _c=Object.assign({},g),t}{const A=Object.assign({},_c);for(const A of Object.keys(I))_c[A]=I[A];const g=new i(e.config);return _c=Object.assign({},A),g}}}function Il(A,g){return-1*function(A,g){return A<g?-1:A>g?1:0}(A,g)}function tl(A){if(null==A)return A;const g=[];for(const I of A)-1===g.indexOf(I)&&g.push(I);return g}function Cl(A){if(null==A)throw new qc(`Invalid value in obj: ${JSON.stringify(A)}`);for(const g in A)if(A.hasOwnProperty(g))return!1;return!0}function el(A,g,I){if(null!=I&&A.indexOf(I)<0)throw new qc(`${I} is not a valid ${g}.  Valid values are ${A} or null/undefined.`)}function Bl(A,g,I=0,t=1/0){return Oc(I>=0),Oc(t>=I),Array.isArray(A)&&A.length>=I&&A.length<=t&&A.every((A=>typeof A===g))}function il(A,g){Array.isArray(A)?(CA(A.length>0,(()=>`${g} is unexpectedly an empty array.`)),A.forEach(((A,I)=>il(A,`element ${I+1} of ${g}`)))):CA(Number.isInteger(A)&&A>0,(()=>`Expected ${g} to be a positive integer, but got ${Ql(A)}.`))}function Ql(A){return null===A?"null":Array.isArray(A)?"["+A.map((A=>Ql(A))).join(",")+"]":"string"==typeof A?`"${A}"`:`${A}`}function ol(A){return"relu"===A?"relu":"linear"===A?"linear":"elu"===A?"elu":null}let El=0;function nl(){return El++}const sl={};function al(A=""){return A in sl||(sl[A]=0),sl[A]+=1,A+sl[A].toString()}const rl=["channelsFirst","channelsLast"],hl=["nearest","bilinear"],cl=["valid","same","causal"],ll=["max","avg"],Dl=["sum","mul","concat","ave"],ul=new Map;function wl(A){el(rl,"DataFormat",A)}function dl(A){el(cl,"PaddingMode",A)}function pl(A){el(ll,"PoolMode",A)}const yl=[],Gl="/";function fl(A,g){yl.push(A);try{const A=g();return yl.pop(),A}catch(A){throw yl.pop(),A}}function Nl(A){if(!ml(A))throw new Error("Not a valid tensor name: '"+A+"'");return(0===yl.length?"":yl.join(Gl)+Gl)+A}function Fl(A){if(!ml(A))throw new Error("Not a valid tensor name: '"+A+"'");ul.has(A)||ul.set(A,0);const g=ul.get(A);if(ul.set(A,ul.get(A)+1),g>0){const I=`${A}_${g}`;return ul.set(I,1),I}return A}const Rl=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ml(A){return!!A.match(Rl)}function kl(A,g,I){null==g&&(g=0),null==I&&(I=A.length);let t=1;for(let C=g;C<I;++C)t*=A[C];return t}function Sl(A){if(0===A.length)return Number.NaN;let g=Number.POSITIVE_INFINITY;for(let I=0;I<A.length;I++){const t=A[I];t<g&&(g=t)}return g}function Ml(A){if(0===A.length)return Number.NaN;let g=Number.NEGATIVE_INFINITY;for(let I=0;I<A.length;I++){const t=A[I];t>g&&(g=t)}return g}function Ul(A,g){if(g<A)throw new qc(`end (${g}) < begin (${A}) is forbidden.`);const I=[];for(let t=A;t<g;++t)I.push(t);return I}let Kl;function Jl(){return null==Kl&&(Kl=Si().epsilon()),Kl}function Yl(A,g){return qB(A,g)}function Ll(A,g=-1){const I=A.shape.slice();return g<0&&(g=I.length+g+1),I.splice(g,0,1),Lo(A,I)}function xl(A,g,I){return wi((()=>{switch(A.rank){case 1:return Ds(A,g,I);case 2:return us(A,[g,0],[I,A.shape[1]]);case 3:return ws(A,[g,0,0],[I,A.shape[1],A.shape[2]]);case 4:return ds(A,[g,0,0,0],[I,A.shape[1],A.shape[2],A.shape[3]]);case 5:return To(A,[g,0,0,0,0],[I,A.shape[1],A.shape[2],A.shape[3],A.shape[4]]);case 6:return To(A,[g,0,0,0,0,0],[I,A.shape[1],A.shape[2],A.shape[3],A.shape[4],A.shape[5]]);default:throw new qc(`sliceAlongFirstAxis() received an unsupported tensor rank: ${A.rank}`)}}))}function bl(A,g,I){return wi((()=>{switch(A.rank){case 1:return Ds(A,g,I);case 2:return us(A,[0,g],[A.shape[0],I]);case 3:return ws(A,[0,0,g],[A.shape[0],A.shape[1],I]);case 4:return ds(A,[0,0,0,g],[A.shape[0],A.shape[1],A.shape[2],I]);default:throw new qc(`sliceAlongLastAxis() received an unsupported tensor rank: ${A.rank}`)}}))}function Hl(A,g,I,t){return wi((()=>{switch(A.rank){case 1:return Ds(A,g,I);case 2:switch(t){case 1:return xl(A,g,I);case 2:return bl(A,g,I);default:throw new qc(`The axis is not within the rank of the tensor ${t}`)}case 3:switch(t){case 1:return xl(A,g,I);case 2:return ws(A,[0,g,0],[A.shape[0],I,A.shape[2]]);case 3:return bl(A,g,I);default:throw new qc(`The axis is not within the rank of the tensor ${t}`)}case 4:switch(t){case 1:return xl(A,g,I);case 2:return ds(A,[0,g,0,0],[A.shape[0],I,A.shape[2],A.shape[3]]);case 3:return ds(A,[0,0,g,0],[A.shape[0],A.shape[1],I,A.shape[3]]);case 4:return bl(A,g,I);default:throw new qc(`The axis is not within the rank of the tensor ${t}`)}default:throw new qc(`sliceAlongLastAxis() received an unsupported tensor rank: ${A.rank}`)}}))}function ql(A,g=-1){let I;return g<0&&(I=A[0].rank,g=0!==I?I:0),g===A[0].rank&&(g=-1),Ho(A,g)}function Tl(A,g){switch(A.rank){case 1:return gE([A,g]);case 2:return IE([A,g],0);case 3:return tE([A,g],0);case 4:return CE([A,g],0);default:throw new qc(`concatAlongFirstAxis() received an unsupported tensor rank: ${A.rank}`)}}function vl(A,g){if(Array.isArray(g)||(g=[g]),A.rank!==g.length)throw new qc(`The length of input n (${g.length}) does not match the number of dimensions in input x (${A.rank})`);return WE(A,g)}function Vl(A,g=0,I=1,t,C){return _n(A,g,I,t,C)}function Wl(A,g,I,t){if(A.rank<2||g.rank<2)throw new Tc(`dot requires both inputs to be rank >= 2 but got x shape = ${A.shape} and y shape = ${g.shape}`);if(g.rank>=3){if(A.shape.slice(-1)[0]!==g.shape.slice(-2)[0])throw new Tc(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${A.shape} and  y shape = ${g.shape}`)}if(2===A.rank&&2===g.rank){return sa({a:A,b:g,transposeA:!1,transposeB:!1,bias:t?Pl(A.rank,t,"channelsLast"):null,activation:I})}{const C=A.shape.slice(),e=C.pop();A=Lo(A,[-1,e]);const B=g.shape.slice(),i=B.pop(),Q=B.pop(),o=[...B,i],E=Array.from({length:g.rank},((A,I)=>0===I?g.rank-2:I<=g.rank-2?I-1:I));g=Lo(Yi(g,E),[Q,-1]);const n=[...C,...o];return Lo(sa({a:A,b:g,transposeA:!1,transposeB:!1,bias:t?Pl(A.rank,t,"channelsLast"):null,activation:I}),n)}}function Ol(A,g,I){return wi((()=>(g=Array.isArray(g)?Ks(g,"int32"):qB(g,"int32"),PE(A,g,I))))}function Zl(A){return xQ(A,A)}function Pl(A,g,I){const t=g.shape;if(1!==g.rank&&g.rank!==A)throw new qc(`Unexpected bias dimensions: ${g.rank}; expected it to be 1 or ${A}`);if(5===A){if("channelsFirst"===I)return 1===t.length?Lo(g,[1,t[0],1,1,1]):Lo(g,[1,t[3],t[0],t[1],t[2]]);if("channelsLast"===I)return 1===t.length?Lo(g,[1,1,1,1,t[0]]):Lo(g,[1].concat(t))}else if(4===A){if("channelsFirst"===I)return 1===t.length?Lo(g,[1,t[0],1,1]):Lo(g,[1,t[2],t[0],t[1]]);if("channelsLast"===I)return 1===t.length?Lo(g,[1,1,1,t[0]]):Lo(g,[1].concat(t))}else if(3===A){if("channelsFirst"===I)return 1===t.length?Lo(g,[1,t[0],1]):Lo(g,[1,t[1],t[0]]);if("channelsLast"===I)return 1===t.length?Lo(g,[1,1,t[0]]):Lo(g,[1].concat(t))}else if(A<3)return g;throw new qc(`Unsupported input rank by biasAdd: ${g.rank}`)}function Xl(A,g,I){return wi((()=>(null==I&&(I="channelsLast"),wl(I),JQ(A,Pl(A.rank,g,I)))))}function jl(A,g,I,t){return wi((()=>$s(A,g,I,t)))}function zl(A,g,I=!1){return I?A():g()}const _l=["fanIn","fanOut","fanAvg"],$l=["normal","uniform","truncatedNormal"];class AD extends lQ{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class gD extends AD{apply(A,g){return yn(A,g)}}gD.className="Zeros",uQ(gD);class ID extends AD{apply(A,g){return Gn(A,g)}}ID.className="Ones",uQ(ID);class tD extends AD{constructor(A){if(super(),"object"!=typeof A)throw new qc(`Expected argument of type ConstantConfig but got ${A}`);if(void 0===A.value)throw new qc(`config must have value set but got ${A}`);this.value=A.value}apply(A,g){return wi((()=>xQ(XQ(this.value),Gn(A,g))))}getConfig(){return{value:this.value}}}tD.className="Constant",uQ(tD);class CD extends AD{constructor(A){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=A.minval||this.DEFAULT_MINVAL,this.maxval=A.maxval||this.DEFAULT_MAXVAL,this.seed=A.seed}apply(A,g){return As(A,this.minval,this.maxval,g)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}CD.className="RandomUniform",uQ(CD);class eD extends AD{constructor(A){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=A.mean||this.DEFAULT_MEAN,this.stddev=A.stddev||this.DEFAULT_STDDEV,this.seed=A.seed}apply(A,g){if("float32"!==(g=g||"float32")&&"int32"!==g)throw new Tc(`randomNormal does not support dType ${g}.`);return Vl(A,this.mean,this.stddev,g,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}eD.className="RandomNormal",uQ(eD);class BD extends AD{constructor(A){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=A.mean||this.DEFAULT_MEAN,this.stddev=A.stddev||this.DEFAULT_STDDEV,this.seed=A.seed}apply(A,g){if("float32"!==(g=g||"float32")&&"int32"!==g)throw new Tc(`truncatedNormal does not support dType ${g}.`);return Hs(A,this.mean,this.stddev,g,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}BD.className="TruncatedNormal",uQ(BD);class iD extends AD{constructor(A){super(),this.gain=null!=A.gain?A.gain:1}apply(A,g){return wi((()=>{if(2!==A.length||A[0]!==A[1])throw new qc("Identity matrix initializer can only be used for 2D square matrices.");return xQ(this.gain,OE(A[0]))}))}getConfig(){return{gain:this.gain}}}iD.className="Identity",uQ(iD);class QD extends AD{constructor(A){if(super(),A.scale<0)throw new qc(`scale must be a positive float. Got: ${A.scale}`);var g;this.scale=null==A.scale?1:A.scale,this.mode=null==A.mode?"fanIn":A.mode,g=this.mode,el(_l,"FanMode",g),this.distribution=null==A.distribution?"normal":A.distribution,function(A){el($l,"Distribution",A)}(this.distribution),this.seed=A.seed}apply(A,g){const I=function(A,g="channelsLast"){let I,t;if(wl(g),2===A.length)I=A[0],t=A[1];else if(-1!==[3,4,5].indexOf(A.length)){if("channelsFirst"===g){const g=kl(A,2);I=A[1]*g,t=A[0]*g}else if("channelsLast"===g){const g=kl(A,0,A.length-2);I=A[A.length-2]*g,t=A[A.length-1]*g}}else{const g=kl(A);I=Math.sqrt(g),t=Math.sqrt(g)}return[I,t]}(A),t=I[0],C=I[1];let e=this.scale;if("fanIn"===this.mode?e/=Math.max(1,t):"fanOut"===this.mode?e/=Math.max(1,C):e/=Math.max(1,(t+C)/2),"normal"===this.distribution){const I=Math.sqrt(e);if("float32"!==(g=g||"float32")&&"int32"!==g)throw new Tc(`${this.getClassName()} does not support dType ${g}.`);return Hs(A,0,I,g,this.seed)}{const I=Math.sqrt(3*e);return As(A,-I,I,g)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}QD.className="VarianceScaling",uQ(QD);class oD extends QD{constructor(A){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==A?null:A.seed})}getClassName(){return QD.className}}oD.className="GlorotUniform",uQ(oD);class ED extends QD{constructor(A){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==A?null:A.seed})}getClassName(){return QD.className}}ED.className="GlorotNormal",uQ(ED);class nD extends QD{constructor(A){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==A?null:A.seed})}getClassName(){return QD.className}}nD.className="HeNormal",uQ(nD);class sD extends QD{constructor(A){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==A?null:A.seed})}getClassName(){return QD.className}}sD.className="HeUniform",uQ(sD);class aD extends QD{constructor(A){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==A?null:A.seed})}getClassName(){return QD.className}}aD.className="LeCunNormal",uQ(aD);class rD extends QD{constructor(A){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==A?null:A.seed})}getClassName(){return QD.className}}rD.className="LeCunNormal",uQ(rD);class hD extends AD{constructor(A){if(super(),this.DEFAULT_GAIN=1,this.gain=null==A.gain?this.DEFAULT_GAIN:A.gain,this.seed=A.seed,null!=this.seed)throw new Tc("Random seed is not implemented for Orthogonal Initializer yet.")}apply(A,g){return wi((()=>{if(A.length<2)throw new Tc("Shape must be at least 2D.");A[0]*A[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${A[0]*A[1]}) elements: Slowness may result.`);const g=Vl(A[0]>A[1]?[A[1],A[0]]:A,0,1,"float32");let I=nr.gramSchmidt(g);return A[0]>A[1]&&(I=Yi(I)),xQ(this.gain,I)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}hD.className="Orthogonal",uQ(hD);const cD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function lD(A,g={}){return gl(A,DQ.getMap().classNameMap,g,"initializer")}function DD(A){return $c(A)}function uD(A){if("string"==typeof A){const g=A in cD?cD[A]:A;if("GlorotNormal"===g)return new ED;if("GlorotUniform"===g)return new oD;if("HeNormal"===g)return new nD;if("HeUniform"===g)return new sD;if("LeCunNormal"===g)return new aD;if("LeCunUniform"===g)return new rD;{const A={};return A.className=g,A.config={},lD(A)}}return A instanceof AD?A:lD(A)}function wD(A){return Array.isArray(A)&&Array.isArray(A[0])}function dD(A){return 0===A.length?[]:Array.isArray(A[0])?A:[A]}function pD(A){let g;if(Array.isArray(A)){if(1!==A.length)throw new qc(`Expected Tensor length to be 1; got ${A.length}`);g=A[0]}else g=A;return g}function yD(A){if(Array.isArray(A)&&Array.isArray(A[0])){if(1===A.length)return A[0];throw new qc(`Expected exactly 1 Shape; got ${A.length}`)}return A}function GD(A){let g=0;for(const I of A)0===I.shape.length?g+=1:g+=I.shape.reduce(((A,g)=>A*g));return g}const fD="Variable";class ND{constructor(A,g="float32",I=fD,t=!0,C=null){this.dtype=null==g?"float32":g,this.shape=A.shape,this.id=nl(),I=null==I?fD:I,this.originalName=Nl(I),this.name=Fl(this.originalName),this.trainable_=t,this.constraint=C,this.val=Ws(A,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(A){return this.assertNotDisposed(),function(A,g){if(A.shape.toString()!==g.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(A.shape)+" vs. "+JSON.stringify(g.shape))}(this.val,A),this.val.id!==A.id&&(this.val.assign(A),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(A){this.trainable_=A,this.val.trainable=A}}function FD(A){return A.map((A=>A.read()))}function RD(A){A.forEach((A=>{A[0].write(A[1])}))}class mD{constructor(A){this.dtype=A.dtype,this.shape=A.shape,null!=A.shape?this.ndim=A.shape.length:this.ndim=A.ndim,this.maxNDim=A.maxNDim,this.minNDim=A.minNDim,this.axes=A.axes||{}}}class kD{constructor(A,g,I,t,C,e,B){this.dtype=A,this.shape=g,this.sourceLayer=I,this.inputs=t,this.callArgs=C,this.outputTensorIndex=B,this.id=nl(),null!=e&&(this.originalName=Nl(e),this.name=Fl(this.originalName)),this.rank=g.length}}let SD=0;class MD{constructor(A,g){this.callArgs=g,this.id=SD++,this.outboundLayer=A.outboundLayer,this.inboundLayers=A.inboundLayers,this.nodeIndices=A.nodeIndices,this.tensorIndices=A.tensorIndices,this.inputTensors=A.inputTensors,this.outputTensors=A.outputTensors,this.inputMasks=A.inputMasks,this.outputMasks=A.outputMasks,this.inputShapes=A.inputShapes,this.outputShapes=A.outputShapes;for(const g of A.inboundLayers)null!=g&&g.outboundNodes.push(this);A.outboundLayer.inboundNodes.push(this)}getConfig(){const A=[];for(const g of this.inboundLayers)null!=g?A.push(g.name):A.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:A,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let UD=0;class KD extends lQ{constructor(A={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=UD++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let g=A.name;if(!g){const A=this.getClassName();g=jc(A)+"_"+al(A)}if(this.name=g,this.trainable_=null==A.trainable||A.trainable,null!=A.inputShape||null!=A.batchInputShape){let g;if(null!=A.batchInputShape)g=A.batchInputShape;else if(null!=A.inputShape){let I=null;null!=A.batchSize&&(I=A.batchSize),g=[I].concat(A.inputShape)}this.batchInputShape=g;let I=A.dtype;null==I&&(I=A.inputDType),null==I&&(I="float32"),this.dtype=I}null!=A.weights?this.initialWeights=A.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(A,g){return A.name+"_ib-"+g.toString()}getNodeAtIndex(A,g){if(0===this.inboundNodes.length)throw new Hc(`The layer has never been called and thus has no defined ${g}.`);if(this.inboundNodes.length<=A)throw new qc(`Asked to get ${g} at node ${A}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[A]}getInputAt(A){return Pc(this.getNodeAtIndex(A,"input").inputTensors)}getOutputAt(A){return Pc(this.getNodeAtIndex(A,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new bc(`Layer ${this.name} is not connected, no input to return.`);return Pc(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new bc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new bc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pc(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((A=>A()))}get updates(){return this._updates}get built(){return this._built}set built(A){this._built=A}get trainable(){return this.trainable_}set trainable(A){this._trainableWeights.forEach((g=>g.trainable=A)),this.trainable_=A}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((A=>A.trainable)):[]}set trainableWeights(A){this._trainableWeights=A}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((A=>!A.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(A){this._nonTrainableWeights=A}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(A){if(A=Xc(A),null==this.inputSpec||0===this.inputSpec.length)return;const g=Xc(this.inputSpec);if(A.length!==g.length)throw new qc(`Layer ${this.name} expects ${g.length} inputs, but it received ${A.length} input tensors. Input received: ${A}`);for(let I=0;I<A.length;I++){const t=A[I],C=g[I];if(null==C)continue;const e=t.rank;if(null!=C.ndim&&e!==C.ndim)throw new qc(`Input ${I} is incompatible with layer ${this.name}: expected ndim=${C.ndim}, found ndim=${e}`);if(null!=C.maxNDim&&e>C.maxNDim)throw new qc(`Input ${I} is incompatible with layer ${this.name}: expected max_ndim=${C.maxNDim}, found ndim=${e}`);if(null!=C.minNDim&&e<C.minNDim)throw new qc(`Input ${I} is incompatible with layer ${this.name}: expected min_ndim=${C.minNDim}, found ndim=${e}.`);if(null!=C.dtype&&t.dtype!==C.dtype)throw new qc(`Input ${I} is incompatible with layer ${this.name} : expected dtype=${C.dtype}, found dtype=${t.dtype}.`);if(C.axes){const A=t.shape;for(const g in C.axes){const t=Number(g),e=C.axes[g],B=t>=0?A[t]:A[A.length+t];if(null!=e&&-1===[e,null].indexOf(B))throw new qc(`Input ${I} is incompatible with layer ${this.name}: expected axis ${t} of input shape to have value ${e} but got shape ${A}.`)}}if(null!=C.shape)for(let A=0;A<C.shape.length;++A){const g=C.shape[A],e=t.shape[A];if(null!=g&&null!=e&&g!==e)throw new qc(`Input ${I} is incompatible with layer ${this.name}: expected shape=${C.shape}, found shape=${t.shape}.`)}}}call(A,g){return A}invokeCallHook(A,g){null!=this._callHook&&this._callHook(A,g)}setCallHook(A){this._callHook=A}clearCallHook(){this._callHook=null}apply(A,g){g=g||{},this.assertNotDisposed();const I=Xc(A);let t=!0;for(const A of I)if(!(A instanceof kD)){t=!1;break}let C=!0;for(const A of I)if(A instanceof kD){C=!1;break}if(t===C)throw new qc("Arguments to apply() must be all SymbolicTensors or all Tensors");return fl(this.name,(()=>{if(!this.built){this.assertInputCompatibility(A);const g=[];for(const I of Xc(A))g.push(I.shape);this.build(Pc(g)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&C&&(this._refCount=1)}if(this.assertInputCompatibility(A),C){let t=this.call(A,g);const C=Xc(t),e=[];for(let A of C)-1!==I.indexOf(A)&&(A=A.clone()),e.push(A);if(t=Pc(e),null!=this.activityRegularizer)throw new Tc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return t}{const I=function(A){A=Xc(A);const g=[];for(const I of A)g.push(I.shape);return Pc(g)}(A),t=this.computeOutputShape(I);let C;const e="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(A)?I[0]:I),C=null!=t&&t.length>0&&Array.isArray(t[0])?t.map(((I,t)=>new kD(e,I,this,Xc(A),g,this.name,t))):new kD(e,t,this,Xc(A),g,this.name),this.addInboundNode(A,C,null,null,I,t,g),this._refCount++,null!=this.activityRegularizer)throw new Tc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return C}}))}warnOnIncompatibleInputShape(A){if(null!=this.batchInputShape)if(A.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(A)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let g=!1;this.batchInputShape.forEach(((I,t)=>{null!=I&&null!=A[t]&&A[t]!==I&&(g=!0)})),g&&console.warn(`The shape of the input tensor (${JSON.stringify(A)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const A=[];for(const g of this.inboundNodes){const I=JSON.stringify(g.outputShapes);-1===A.indexOf(I)&&A.push(I)}if(1===A.length){const A=this.inboundNodes[0].outputShapes;return Array.isArray(A)&&Array.isArray(A[0])&&1===A.length?A[0]:A}throw new bc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Hc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return GD(this.weights)}build(A){this.built=!0}getWeights(A=!1){return FD(A?this.trainableWeights:this.weights)}setWeights(A){wi((()=>{const g=this.weights;if(g.length!==A.length)throw new qc(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${A.length}, but the layer was expecting ${g.length} weights. Provided weights: ${A}...`);if(0===g.length)return;const I=[],t=FD(g);for(let C=0;C<t.length;++C){const e=t[C],B=g[C],i=A[C];if(!EA(e.shape,i.shape))throw new qc(`Layer weight shape ${e.shape} not compatible with provided weight shape ${i.shape}`);I.push([B,i])}RD(I)}))}addWeight(A,g,I,t,C,e,B,i){if(-1!==this._addedWeightNames.indexOf(A))throw new qc(`Duplicate weight name ${A} for layer ${this.name}`);this._addedWeightNames.push(A),null==I&&(I="float32"),this.fastWeightInitDuringBuild&&(t=null!=i?i():uD("zeros"));const Q=t.apply(g,I),o=new ND(Q,I,A,e,B);return Q.dispose(),null!=C&&this.addLoss((()=>C.apply(o.read()))),null==e&&(e=!0),e?this._trainableWeights.push(o):this._nonTrainableWeights.push(o),o}setFastWeightInitDuringBuild(A){this.fastWeightInitDuringBuild=A}addLoss(A){null==A||Array.isArray(A)&&0===A.length||(A=Xc(A),void 0!==this._losses&&null!==this._losses&&this.losses.push(...A))}computeOutputShape(A){return A}computeMask(A,g){if(!this.supportsMasking){if(null!=g){if(!Array.isArray(g))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);g.forEach((A=>{if(null!=A)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return g}addInboundNode(A,g,I,t,C,e,B=null){const i=Xc(A);g=Xc(g),I=Xc(I),t=Xc(t),C=dD(C),e=dD(e);const Q=[],o=[],E=[];for(const A of i)Q.push(A.sourceLayer),o.push(A.nodeIndex),E.push(A.tensorIndex);new MD({outboundLayer:this,inboundLayers:Q,nodeIndices:o,tensorIndices:E,inputTensors:i,outputTensors:g,inputMasks:I,outputMasks:t,inputShapes:C,outputShapes:e},B);for(let A=0;A<g.length;A++)g[A].sourceLayer=this,g[A].nodeIndex=this.inboundNodes.length-1,g[A].tensorIndex=A}getConfig(){const A={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(A.batchInputShape=this.batchInputShape),null!=this.dtype&&(A.dtype=this.dtype),A}disposeWeights(){return this.weights.forEach((A=>A.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let A=0;return 0==--this._refCount&&(A=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:A}}}function JD(A,g,I){if((null==g||null!=I&&I>0)&&(g=A.sourceLayer,I=A.nodeIndex),0===g.inboundNodes.length)return[A];{const A=g.inboundNodes[I];if(0===A.inboundLayers.length)return A.inputTensors;{const g=[];for(let I=0;I<A.inboundLayers.length;I++){const t=JD(A.inputTensors[I],A.inboundLayers[I],A.nodeIndices[I]);for(const A of t)-1===g.indexOf(A)&&g.push(A)}return g}}}class YD extends KD{constructor(A){if(super({dtype:A.dtype,name:null!=A.name?A.name:al("input").toString()}),null==A.batchSize&&(A.batchSize=null),null==A.sparse&&(A.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=A.sparse,null!=A.inputShape&&null!=A.batchInputShape)throw new qc("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let g=A.batchInputShape;if(null==g){if(null==A.inputShape)throw new qc("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");g=[A.batchSize].concat(A.inputShape)}else if(null!=A.batchSize)throw new qc("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const I=A.dtype||"float32";this.batchInputShape=g,this.dtype=I,this.inputSpec=[{shape:g}];const t=new kD(this.dtype,this.batchInputShape,this,[],{},this.name);t.nodeIndex=0,t.tensorIndex=0,new MD({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[t],outputTensors:[t],inputMasks:[null],outputMasks:[null],inputShapes:[g],outputShapes:[g]})}apply(A,g){throw new qc(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function LD(A){if(null==A.batchShape&&null==A.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=A.batchShape&&null!=A.shape)throw new qc("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let g=A.batchShape;null!=A.shape&&null==g&&(g=[null].concat(A.shape));let I=A.dtype;null==I&&(I="float32");return new YD({batchInputShape:g,name:A.name,dtype:I,sparse:A.sparse}).inboundNodes[0].outputTensors[0]}YD.className="InputLayer",uQ(YD);class xD{constructor(A){if(this.id2Value={},this.id2Mask={},this.name2Id={},A instanceof xD)for(const g in A.id2Value)this.id2Value[g]=A.id2Value[g],g in A.id2Mask&&(this.id2Mask[g]=A.id2Mask[g]);else{if(null==A)return;for(const g of A)this.add(g.key,g.value)}}add(A,g,I){if(null!=this.id2Value[A.id])throw new qc(`Duplicate key: name=${A.name}, id=${A.id}`);return this.id2Value[A.id]=function(A,g){if(null==A.dtype||A.dtype===g.dtype)return g;try{return qB(g,A.dtype)}catch(I){throw new qc(`The dtype of the feed (${g.dtype}) can not be cast to the dtype of the key '${A.name}' (${A.dtype}).`)}}(A,g),this.name2Id[A.name]=A.id,null!=I&&(this.id2Mask[A.id]=I),this}addFeed(A){this.add(A.key,A.value)}hasKey(A){return null!=this.id2Value[A.id]}names(){return Object.keys(this.name2Id)}getValue(A){if(A instanceof kD){if(null==this.id2Value[A.id])throw new qc(`Nonexistent key: ${A.name}`);return this.id2Value[A.id]}{const g=this.name2Id[A];if(null==g)throw new qc(`Feed dict has no SymbolicTensor name: ${A}`);return this.id2Value[g]}}getMask(A){if(A instanceof kD){if(null==this.id2Value[A.id])throw new qc(`Nonexistent key: ${A.name}`);return this.id2Mask[A.id]}{const g=this.name2Id[A];if(null==g)throw new qc(`Feed dict has no SymbolicTensor name: ${A}`);return this.id2Mask[g]}}disposeMasks(){null!=this.id2Mask&&di(this.id2Mask)}}const bD=new Vc,HD=new Vc;function qD(A,g,I,t){const C=null!=I&&I.training,e=Array.isArray(A),B=e?A:[A],i=B.map((A=>A.name)),Q=[],o=g.names();for(const A of i)-1!==o.indexOf(A)?Q.push(g.getValue(A)):Q.push(null);null!=t&&(t.maxNumTensors=-1/0,t.minNumTensors=1/0);const E=i.join(",")+"|"+g.names().sort().join(",");let n,s=bD.get(E);if(null==s){const A=function(A,g){CA(null!=A&&A.length>0,(()=>"Expected at least one fetch, got none"));let I=[],t={};if(1===A.length){const C=vD(A[0],g);I=C.sorted,t=C.recipientMap}else{const C=new Set;for(const e of A){const{sorted:A,recipientMap:B}=vD(e,g);for(const g of A)C.has(g.name)||(I.push(g),C.add(g.name));for(const A in B)null==t[A]&&(t[A]=new Set),B[A].forEach((g=>t[A].add(g)))}}return{sorted:I,recipientCounts:TD(t)}}(B,g);s=A.sorted,n=A.recipientCounts,bD.put(E,s),HD.put(E,n)}n={},C||Object.assign(n,HD.get(E));const a=new xD(g);for(let A=0;A<s.length;++A){if(null!=t){const A=Di().numTensors;A>t.maxNumTensors&&(t.maxNumTensors=A),A<t.minNumTensors&&(t.minNumTensors=A)}const e=s[A],B=e.sourceLayer;if(B instanceof YD)continue;const o=[],E=[],r=[];let h=!1;for(const A of e.inputs){const I=a.getValue(A),t=a.getMask(A);o.push(I),E.push(t),null!=t&&(h=!0),C||(n[A.name]--,0!==n[A.name]||g.hasKey(A)||-1!==i.indexOf(A.name)||I.isDisposed||!0===A.sourceLayer.stateful||r.push(I))}h&&((I=I||{}).mask=E[0]);const c=Xc(B.apply(o,I));let l=null;B.supportsMasking&&(l=B.computeMask(o,E));const D=VD(e),u=Array.isArray(D)?D:[D];for(let A=0;A<u.length;++A){a.hasKey(u[A])||a.add(u[A],c[A],Array.isArray(l)?l[0]:l);const g=i.indexOf(u[A].name);-1!==g&&(Q[g]=c[A])}C||di(r)}return a.disposeMasks(),e?Q:Q[0]}function TD(A){const g={};for(const I in A)g[I]=A[I].size;return g}function vD(A,g){const I=new Set,t=[],C={};for(const A of g.names())I.add(A);const e=[],B=[];for(e.push(A);e.length>0;){const A=e[e.length-1];if(I.has(A.name)){e.pop();continue}const g=B[B.length-1]===e.length-1;if(0===A.inputs.length||g)e.pop(),t.push(A),I.add(A.name),g&&B.pop();else{B.push(e.length-1);for(const g of A.inputs)null==C[g.name]&&(C[g.name]=new Set),C[g.name].add(A.name),I.has(g.name)||e.push(g)}}return{sorted:t,recipientMap:C}}function VD(A){let g;if(1===A.sourceLayer.inboundNodes.length)g=A.sourceLayer.output;else{let I=null;for(let g=0;g<A.sourceLayer.inboundNodes.length;++g)for(const t of A.sourceLayer.inboundNodes[g].outputTensors)if(t.id===A.id){I=g;break}g=A.sourceLayer.getOutputAt(I)}return g}function WD(A,g){return wi((()=>bQ(xE(xQ(A,A),g,!0))))}ZA().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(A){null!=bD&&bD.setMaxEntries(A),null!=HD&&HD.setMaxEntries(A)}));class OD extends lQ{getConfig(){return{}}}class ZD extends OD{constructor(A){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=A.maxValue?A.maxValue:this.defaultMaxValue,this.axis=null!=A.axis?A.axis:this.defaultAxis}apply(A){return wi((()=>{const g=WD(A,this.axis),I=AE(g,0,this.maxValue);return xQ(A,LQ(I,JQ(Jl(),g)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ZD.className="MaxNorm",uQ(ZD);class PD extends OD{constructor(A){super(),this.defaultAxis=0,this.axis=null!=A.axis?A.axis:this.defaultAxis}apply(A){return wi((()=>LQ(A,JQ(Jl(),WD(A,this.axis)))))}getConfig(){return{axis:this.axis}}}PD.className="UnitNorm",uQ(PD);class XD extends OD{apply(A){return ts(A)}}XD.className="NonNeg",uQ(XD);class jD extends OD{constructor(A){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=A.minValue?A.minValue:this.defaultMinValue,this.maxValue=null!=A.maxValue?A.maxValue:this.defaultMaxValue,this.rate=null!=A.rate?A.rate:this.defaultRate,this.axis=null!=A.axis?A.axis:this.defaultAxis}apply(A){return wi((()=>{const g=WD(A,this.axis),I=JQ(xQ(this.rate,AE(g,this.minValue,this.maxValue)),xQ(1-this.rate,g));return xQ(A,LQ(I,JQ(Jl(),g)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}jD.className="MinMaxNorm",uQ(jD);const zD={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function _D(A){return $c(A)}function $D(A,g={}){return gl(A,DQ.getMap().classNameMap,g,"constraint")}function Au(A){if(null==A)return null;if("string"==typeof A){return $D({className:A in zD?zD[A]:A,config:{}})}return A instanceof OD?A:$D(A)}function gu(A){return new ZD(A)}function Iu(A){return new PD(A)}function tu(){return new XD}function Cu(A){return new jD(A)}function eu(){return new gD}function Bu(){return new ID}function iu(A){return new tD(A)}function Qu(A){return new CD(A)}function ou(A){return new eD(A)}function Eu(A){return new BD(A)}function nu(A){return new iD(A)}function su(A){return new QD(A)}function au(A){return new oD(A)}function ru(A){return new ED(A)}function hu(A){return new nD(A)}function cu(A){return new sD(A)}function lu(A){return new aD(A)}function Du(A){return new rD(A)}function uu(A){return new hD(A)}async function wu(A){if(null==A)return;const g=[],I=[],t=[];for(const C in A){const e=A[C];if("number"!=typeof e){const A=e;g.push(A.data()),I.push(C),t.push(A)}}if(g.length>0){const C=await Promise.all(g);for(let g=0;g<C.length;++g)A[I[g]]=C[g][0];di(t)}}function du(A){if(null!=A)for(const g in A){const I=A[g];"number"!=typeof I&&I.dispose()}}var pu;!function(A){A[A.SILENT=0]="SILENT",A[A.VERBOSE=1]="VERBOSE"}(pu||(pu={}));class yu{constructor(){this.validationData=null}setParams(A){this.params=A}async onEpochBegin(A,g){}async onEpochEnd(A,g){}async onBatchBegin(A,g){}async onBatchEnd(A,g){}async onTrainBegin(A){}async onTrainEnd(A){}setModel(A){}}class Gu{constructor(A,g=10){null==A&&(A=[]),this.callbacks=A,this.queueLength=g}append(A){this.callbacks.push(A)}setParams(A){for(const g of this.callbacks)g.setParams(A)}setModel(A){for(const g of this.callbacks)g.setModel(A)}async onEpochBegin(A,g){null==g&&(g={});for(const I of this.callbacks)await I.onEpochBegin(A,g)}async onEpochEnd(A,g){null==g&&(g={});for(const I of this.callbacks)await I.onEpochEnd(A,g)}async onBatchBegin(A,g){null==g&&(g={});for(const I of this.callbacks)await I.onBatchBegin(A,g)}async onBatchEnd(A,g){null==g&&(g={});for(const I of this.callbacks)await I.onBatchEnd(A,g)}async onTrainBegin(A){null==A&&(A={});for(const g of this.callbacks)await g.onTrainBegin(A)}async onTrainEnd(A){null==A&&(A={});for(const g of this.callbacks)await g.onTrainEnd(A)}}class fu extends yu{constructor(){super()}async onEpochBegin(A){this.seen=0,this.totals={}}async onBatchEnd(A,g){null==g&&(g={});const I=null==g.size?0:g.size;this.seen+=I;for(const A in g){const t=g[A];if("number"==typeof t)this.totals.hasOwnProperty(A)||(this.totals[A]=0),this.totals[A]=this.totals[A]+t*I;else{let g;A in this.totals?g=this.totals[A]:this.totals[A]=0;const C=wi((()=>JQ(this.totals[A],xQ(t,I))));this.totals[A]=C,null!=g&&g.dispose()}}}async onEpochEnd(A,g){if(null!=g)for(const A of this.params.metrics)null!=this.totals[A]&&("number"==typeof this.totals[A]?g[A]=this.totals[A]/this.seen:wi((()=>{const I=xQ(LQ(1,this.seen),this.totals[A]);g[A]=I,this.totals[A].dispose(),pi(g[A])})))}}class Nu extends yu{async onTrainBegin(A){this.epoch=[],this.history={}}async onEpochEnd(A,g){null==g&&(g={}),this.epoch.push(A);for(const A in g)null==this.history[A]&&(this.history[A]=[]),this.history[A].push(g[A])}async syncData(){const A=[],g=[],I=[];for(const t in this.history){const C=this.history[t];for(let e=0;e<C.length;++e)if("number"!=typeof C[e]){const B=C[e];A.push(B.data()),g.push(t),I.push(e)}}const t=await Promise.all(A);for(let A=0;A<t.length;++A){this.history[g[A]][I[A]].dispose(),this.history[g[A]][I[A]]=t[A][0]}}}class Fu extends yu{constructor(A,g){if(super(),this.currentEpoch=0,this.nowFunc=A.nowFunc,this.nextFrameFunc=A.nextFrameFunc||lr,this.yieldEvery=g||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=A.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");kA(this.yieldEvery)&&(this.maybeWait=function(A,g,I){let t,C=null!=I?I():bC();return(...e)=>{const B=null!=I?I():bC();return B-C<g||(C=B,t=A(...e)),t}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=A.onTrainBegin,this.trainEnd=A.onTrainEnd,this.epochBegin=A.onEpochBegin,this.epochEnd=A.onEpochEnd,this.batchBegin=A.onBatchBegin,this.batchEnd=A.onBatchEnd,this.yield=A.onYield}async maybeWait(A,g,I){const t=[];null!=this.yield&&(await wu(I),t.push(this.yield(A,g,I))),t.push(this.nextFrameFunc()),await Promise.all(t)}async onEpochBegin(A,g){this.currentEpoch=A,null!=this.epochBegin&&(await wu(g),await this.epochBegin(A,g))}async onEpochEnd(A,g){const I=[];null!=this.epochEnd&&(await wu(g),I.push(this.epochEnd(A,g))),"epoch"===this.yieldEvery&&I.push(this.nextFrameFunc()),await Promise.all(I)}async onBatchBegin(A,g){null!=this.batchBegin&&(await wu(g),await this.batchBegin(A,g))}async onBatchEnd(A,g){const I=[];null!=this.batchEnd&&(await wu(g),I.push(this.batchEnd(A,g))),"batch"===this.yieldEvery?I.push(this.nextFrameFunc()):kA(this.yieldEvery)&&I.push(this.maybeWait(this.currentEpoch,A,g)),await Promise.all(I)}async onTrainBegin(A){null!=this.trainBegin&&(await wu(A),await this.trainBegin(A))}async onTrainEnd(A){null!=this.trainEnd&&(await wu(A),await this.trainEnd(A))}}function Ru(A,g){if(null==A&&(A={}),A instanceof yu)return[A];if(Array.isArray(A)&&A[0]instanceof yu)return A;return Xc(A).map((A=>new Fu(A,g)))}class mu{constructor(){}static registerCallbackConstructor(A,g){CA(A>=0&&Number.isInteger(A),(()=>`Verbosity level is expected to be an integer >= 0, but got ${A}`)),mu.checkForDuplicate(g),null==mu.constructors[A]&&(mu.constructors[A]=[]),mu.constructors[A].push(g)}static checkForDuplicate(A){for(const g in mu.constructors){mu.constructors[+g].forEach((g=>{if(g===A)throw new qc("Duplicate callback constructor.")}))}}static clear(){mu.constructors={}}static createCallbacks(A){const g=[];for(const I in mu.constructors){const t=+I;A>=t&&g.push(...mu.constructors[t])}return g.map((A=>new A))}}function ku(A,g,I,t,C,e,B,i,Q){const o=new Nu,E=[new fu,...mu.createCallbacks(g)];null!=A&&E.push(...A),E.push(o);const n=new Gu(E);return n.setParams({epochs:I,initialEpoch:t,samples:C,steps:e,batchSize:B,verbose:g,doValidation:i,metrics:Q}),{callbackList:n,history:o}}function Su(A,g={},I=!1){return gl(A,DQ.getMap().classNameMap,g,"layer",I)}function Mu(A,g){return wi((()=>{"float32"!==A.dtype&&(A=qB(A,"float32"));const I=xE(Zl(A),g,!0),t=_Q(I.shape,Jl()),C=bQ(Co(I,t));return LQ(A,C)}))}function Uu(A,g){return wi((()=>pn(Zl(go(g,A)),-1)))}function Ku(A,g){return wi((()=>pn(to(go(g,A)),-1)))}function Ju(A,g){return wi((()=>{const I=go(A,g),t=AE(to(A),Jl(),Number.MAX_VALUE),C=to(LQ(I,t));return xQ(100,pn(C,-1))}))}function Yu(A,g){return wi((()=>{const I=AE(g,Jl(),Number.MAX_VALUE),t=en(JQ(1,I)),C=AE(A,Jl(),Number.MAX_VALUE),e=en(JQ(1,C));return pn(Zl(go(t,e)),-1)}))}function Lu(A,g,I=!1){return wi((()=>{if(I)g=ps(g);else{const A=xE(g,g.shape.length-1,!0);g=LQ(g,A)}return g=AE(g,Jl(),1-Jl()),Ki(xE(xQ(qB(A,"float32"),en(g)),g.shape.length-1))}))}function xu(A,g,I=!1){return wi((()=>{const t=qB(ZE(function(A){const g=[kl(A.shape)];return Lo(A,g)}(A)),"int32"),C=(g=AE(g,Jl(),1-Jl())).shape;return Lu(Lo(ni(t,C[C.length-1]),C),g,I)}))}function bu(A,g){return wi((()=>{let I;return I=AE(g,Jl(),1-Jl()),I=en(LQ(I,go(1,I))),pn(function(A,g){if(!EA(A.shape,g.shape))throw new qc(`logits and labels must have the same shape, but got shapes ${JSON.stringify(A.shape)} and ${JSON.stringify(g.shape)}`);return wi((()=>{const I=ts(g),t=Ki(to(g));return JQ(go(I,xQ(g,A)),Bn(TE(t)))}))}(A,I),-1)}))}function Hu(A,g){return wi((()=>{const I=AE(A,Jl(),1),t=AE(g,Jl(),1);return xE(xQ(A,en(LQ(I,t))),-1)}))}function qu(A,g){return wi((()=>{const I=Mu(A,-1),t=Mu(g,-1),C=xQ(I,t);return Ki(xE(C,-1))}))}mu.constructors={};const Tu={meanSquaredError:Uu,meanAbsoluteError:Ku,meanAbsolutePercentageError:Ju,meanSquaredLogarithmicError:Yu,squaredHinge:function(A,g){return wi((()=>{const I=Co(0,go(1,xQ(A,g)));return pn(Zl(I),-1)}))},hinge:function(A,g){return wi((()=>{const I=Co(0,go(1,xQ(A,g)));return pn(I,-1)}))},categoricalHinge:function(A,g){return wi((()=>{const I=xE(xQ(A,g),-1),t=YE(xQ(go(1,A),g),-1);return Co(0,JQ(1,go(t,I)))}))},logcosh:function(A,g){return wi((()=>{const I=Math.log(2),t=go(g,A),C=go(JQ(t,Qn(xQ(-2,t))),I);return pn(C,-1)}))},categoricalCrossentropy:Lu,sparseCategoricalCrossentropy:xu,binaryCrossentropy:bu,kullbackLeiblerDivergence:Hu,poisson:function(A,g){return wi((()=>{const I=en(JQ(Jl(),g));return pn(go(g,xQ(A,I)),-1)}))},cosineProximity:qu};function vu(A){if("string"==typeof A){if(A in Tu)return Tu[A];let g=`Unknown loss ${A}`;throw A.toLowerCase().includes("softmaxcrossentropy")&&(g=`Unknown loss ${A}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new qc(g)}return A}function Vu(A,g){return wi((()=>{const I=xQ(.5,Un(g)),t=Yl(XE(g,I),A.dtype);return pn(dE(A,t),-1)}))}function Wu(A,g){return wi((()=>Yl(dE(ho(A,-1),ho(g,-1)),"float32")))}function Ou(A,g){return wi((()=>qB(xE(sn(dE(A,1),dE(g,1))),"float32")))}function Zu(A,g){return wi((()=>{const I=Ou(A,g),t=function(A,g){return wi((()=>qB(xE(sn(dE(A,0),dE(g,1))),"float32")))}(A,g),C=JQ(I,t);return qB(pE(XE(C,0),LQ(I,C),0),"float32")}))}function Pu(A,g){return wi((()=>{const I=Ou(A,g),t=function(A,g){return wi((()=>qB(xE(sn(dE(A,1),dE(g,0))),"float32")))}(A,g),C=JQ(I,t);return qB(pE(XE(C,0),LQ(I,C),0),"float32")}))}function Xu(A,g){return bu(A,g)}function ju(A,g){return A.rank===g.rank&&(A=ms(A,[A.rank-1])),(g=ho(g,-1)).dtype!==A.dtype&&(g=qB(g,A.dtype)),qB(dE(A,g),"float32")}const zu=Lu,_u=xu,$u={binaryAccuracy:Vu,categoricalAccuracy:Wu,precision:Zu,categoricalCrossentropy:zu,sparseCategoricalCrossentropy:_u,mse:Uu,MSE:Uu,mae:Ku,MAE:Ku,mape:Ju,MAPE:Ju,cosine:qu};function Aw(A){if("string"==typeof A&&A in $u)return $u[A];if("string"!=typeof A&&null!=A)return A;throw new qc(`Unknown metric ${A}`)}function gw(A){if(Oc(null!==A,`Unknown LossOrMetricFn ${A}`),"string"==typeof A)return A;{let g;for(const I of Object.keys(Tu))if(Tu[I]===A){g=I;break}if(void 0!==g)return g;for(const I of Object.keys($u))if($u[I]===A){g=I;break}return void 0!==g?g:A.name}}const Iw=1048576;function tw(A,g,I=!1){if(null==A||"object"!=typeof A||Object.getPrototypeOf(A)!==Object.prototype||!Cw(A))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(I){const I=JSON.stringify(A);I.length>Iw&&console.warn(`User-defined metadata of model "${g}" is too large in size (length=${I.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Cw(A){if(null===A)return!0;if("object"==typeof A){if(Object.getPrototypeOf(A)===Object.prototype){const g=Object.keys(A);for(const I of g){if("string"!=typeof I)return!1;if(!Cw(A[I]))return!1}return!0}if(Array.isArray(A)){for(const g of A)if(!Cw(g))return!1;return!0}return!1}{const g=typeof A;return"string"===g||"number"===g||"boolean"===g}}function ew(A,g,I,t=console.log){const C=function(A){let g=!0;const I=[],t=[];for(const g in A.nodesByDepth)I.push(A.nodesByDepth[g]);for(const A of I){if(A.length>1||1===A.length&&A[0].inboundLayers.length>1){g=!1;break}t.push(...A)}if(g)for(const I of A.layers){let A=!1;for(const C of I.inboundNodes)if(-1!==t.indexOf(C)){if(A){g=!1;break}A=!0}if(!g)break}return g}(A),e=["Layer (type)","Input Shape","Output shape","Param #"];let B;if(C?(g=g||90,I=I||[.32,.61,.89,1]):(g=g||115,I=I||[.24,.48,.7,.8,1]),I[I.length-1]<=1&&(I=I.map((A=>Math.floor(g*A)))),!C){e.push("Receives inputs"),B=[];for(const g in A.nodesByDepth)B.push(...A.nodesByDepth[g])}t("_".repeat(g)),Bw(e,I,t),t("=".repeat(g));const i=A.layers;for(let A=0;A<i.length;++A)C?iw(i[A],I,t):Qw(i[A],I,B,t),t((A===i.length-1?"=":"_").repeat(g));A.checkTrainableWeightsConsistency();const Q=function(A){let g;g=null!=A.collectedTrainableWeights?GD(A.collectedTrainableWeights):GD(A.trainableWeights);return g}(A),o=GD(A.nonTrainableWeights);t(`Total params: ${Q+o}`),t(`Trainable params: ${Q}`),t(`Non-trainable params: ${o}`),t("_".repeat(g))}function Bw(A,g,I=console.log){let t="";for(let I=0;I<A.length;++I)I>0&&(t=t.slice(0,t.length-1)+" "),t+=A[I],t=t.slice(0,g[I]),t+=" ".repeat(g[I]-t.length);I(t)}function iw(A,g,I){let t,C;try{C=A.inboundNodes.map((A=>JSON.stringify(A.inputShapes))).join(",")}catch(A){C="multiple"}try{t=JSON.stringify(A.outputShape)}catch(A){t="multiple"}Bw([`${A.name} (${A.getClassName()})`,C,t,A.countParams().toString()],g,I)}function Qw(A,g,I,t){let C,e;try{e=A.inboundNodes.map((A=>JSON.stringify(A.inputShapes))).join(",")}catch(A){e="multiple"}try{C=JSON.stringify(A.outputShape)}catch(A){C="multiple"}const B=[];for(const g of A.inboundNodes)if(!(null!=I&&I.length>0&&-1===I.indexOf(g)))for(let A=0;A<g.inboundLayers.length;++A){const I=g.inboundLayers[A].name,t=g.nodeIndices[A],C=g.tensorIndices[A];B.push(`${I}[${t}][${C}]`)}const i=A.name,Q=A.getClassName(),o=0===B.length?"":B[0];Bw([`${i} (${Q})`,e,C,A.countParams().toString(),o],g,t);for(let A=1;A<B.length;++A)Bw(["","","","",B[A]],g,t)}function ow(A,g,I){return("inboundNodes"===A||"outputLayers"===A||"inputLayers"===A)&&0===g&&"string"==typeof I}function Ew(A,g){if(null===A)return null;if("string"==typeof A)return zc(A);if("number"==typeof A||"boolean"==typeof A)return A;if(A instanceof Array){const I=[],t=A.length;for(let C=0;C<t;++C){const t=A[C];ow(g,C,t)?I.push(t):I.push(Ew(t,g))}return I}{const g={};for(const I of Object.keys(A)){const t=A[I];if("name"===I&&"string"==typeof t)g[I]=t;else{const A=zc(I);g[A]=Ew(t,A)}}return g}}function nw(A,g){if(null==A)return null;if("string"==typeof A)return jc(A);if("number"==typeof A||"boolean"==typeof A)return A;if(A instanceof Array){const I=[],t=A.length;for(let C=0;C<t;++C){const t=A[C];ow(g,C,t)?I.push(t):I.push(nw(t,g))}return I}{const g={};for(const I of Object.keys(A)){const t=A[I],C=jc(I);g[C]="name"!==I&&"className"!==I||"string"!=typeof t?nw(t,I):t}return g}}const sw="3.21.0";class aw extends KD{constructor(A){if(super({}),this.containerNodes=new Set,this.name=A.name,null==this.name){const A=this.getClassName().toLowerCase();this.name=al(A)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(A.inputs)?this.inputs=A.inputs.slice():this.inputs=[A.inputs],Array.isArray(A.outputs)?this.outputs=A.outputs.slice():this.outputs=[A.outputs],tl(this.inputs).length!==this.inputs.length)throw new qc(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((A=>A.name))}`);tl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((A=>A.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const A of this.outputs){const g=A.sourceLayer,I=A.nodeIndex,t=A.tensorIndex;this.outputLayers.push(g),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(t)}for(const A of this.inputs){const g=A.sourceLayer,I=A.nodeIndex,t=A.tensorIndex;Oc(0===I,"input layer has >1 nodes"),Oc(0===t,"input layer has >1 tensors"),this.inputLayers.push(g),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(t)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let g=0;g<this.inputLayers.length;g++){const I=this.inputLayers[g];if(!(I instanceof YD))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${A.inputs}. Input ${g} (0-based) originates from layer type ${I.getClassName()}.`);this.inputNames.push(I.name),this.feedInputShapes.push(I.batchInputShape),this.feedInputNames.push(I.name)}for(const A of this.outputLayers)this.outputNames.push(A.name);this.internalInputShapes=this.inputs.map((A=>A.shape)),this.internalOutputShapes=this.outputs.map((A=>A.shape));const g={},I={},t={},C={},e={},B=[],i=(A,g,I,t,C,Q)=>{null!=t&&null!=C&&null!=Q||(t=A.sourceLayer,C=A.nodeIndex,Q=A.tensorIndex);const o=t.inboundNodes[C];if(-1!==I.indexOf(o))throw new Hc(`The tensor ${A.name} at layer "${t.name}" is part of a cycle.`);if(-1!==g.indexOf(o))return;this.containerNodes.add(aw.nodeKey(t,C)),t.id in e||(e[t.id]=Object.keys(e).length),-1===I.indexOf(o)&&I.push(o);const E=o.inboundLayers.length;for(let A=0;A<E;A++){const t=o.inputTensors[A],C=o.inboundLayers[A],e=o.nodeIndices[A],B=o.tensorIndices[A];i(t,g,I,C,e,B)}for(g.push(o);I.indexOf(o)>=0;)I.splice(I.indexOf(o),1);B.push(o)},Q=[],o=[];for(const A of this.outputs)i(A,Q,o);const E=B.slice().reverse();for(const A of E){I[A.id]=A,A.id in g||(g[A.id]=0);let e=g[A.id];const B=null==t[A.outboundLayer.id]?0:t[A.outboundLayer.id];e=Math.max(e,B),t[A.outboundLayer.id]=e,C[A.outboundLayer.id]=A.outboundLayer,g[A.id]=e;for(let t=0;t<A.inboundLayers.length;t++){const C=A.inboundLayers[t],B=A.nodeIndices[t],i=C.inboundNodes[B],Q=null==g[i.id]?0:g[i.id];g[i.id]=Math.max(e+1,Q),I[i.id]=i}}const n={};for(const A in g){const t=g[A];t in n||(n[t]=[]),n[t].push(I[A])}const s={};for(const A in t){const g=t[A];g in s||(s[g]=[]),s[g].push(C[A])}let a=Object.keys(s).map((A=>parseInt(A,10))).sort(Il);this.layers=[];for(const A of a){const g=s[A];g.sort(((A,g)=>{const I=e[A.id],t=e[g.id];return I<t?-1:I>t?1:0}));for(const A of g)A instanceof aw&&this.internalContainerRefs.push(A),this.layers.push(A)}this.layersByDepth=s,a=Object.keys(n).map((A=>parseInt(A,10))).sort(Il);const r=this.inputs.slice(),h=[];for(const A of a)for(const g of n[A]){const A=g.outboundLayer;if(null!=A){for(const I of g.inputTensors)if(-1===r.indexOf(I))throw new Hc(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${A.name}". The following previous layers were accessed without issue: ${h}`);for(const A of g.outputTensors)r.push(A);h.push(A.name)}}this.nodesByDepth=n;const c=this.layers.map((A=>A.name));for(const A of c){const g=c.filter((g=>g===A)).length;if(1!==g)throw new Hc(`The name "${A}" is used ${g} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(c))}this.outboundNodes=[],this.inboundNodes=[],new MD({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((A=>null)),outputMasks:this.outputs.map((A=>null)),inputShapes:this.inputs.map((A=>A.shape)),outputShapes:this.outputs.map((A=>A.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const A={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const g of this.layers)A.numDisposedVariables+=g.dispose().numDisposedVariables;for(const g of this.internalContainerRefs)A.numDisposedVariables+=g.dispose().numDisposedVariables}return A.refCountAfterDispose=this._refCount,A}get trainable(){return this.trainable_}set trainable(A){this.layers.forEach((g=>{g._trainableWeights.forEach((g=>g.trainable=A))})),this.trainable_=A}get trainableWeights(){if(this._trainableWeights.length>0)throw new qc("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let A=[];for(const g of this.layers)A=A.concat(g.trainableWeights);return A}get nonTrainableWeights(){const A=[];for(const g of this.layers)A.push(...g.nonTrainableWeights);if(!this.trainable){const g=[];for(const A of this.layers)g.push(...A.trainableWeights);return g.concat(A)}return A}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(A,g=!0){const I={};let t=0;for(const A of this.layers)for(const g of A.weights){if(null!=I[g.originalName])throw new qc(`Duplicate weight name: ${g.originalName}`);I[g.originalName]=g,t++}const C=[];for(const t in A){let e=t;if(null==I[t]){const A=t.split("/");e=A.slice(0,-2).concat([A[A.length-1]]).join("/")}if(null!=I[e])C.push([I[e],A[t]]);else if(g)throw new qc(`Provided weight data has no target variable: ${t}`);delete I[e]}if(g){const A=[];for(const g in I)A.push(g);if(A.length>0)throw new qc(`${A.length} of ${t} weights are not set: ${A}`)}RD(C)}updatedConfig(){const A=this.getConfig(),g={};return g.className=this.getClassName(),g.config=A,g.kerasVersion=`tfjs-layers ${sw}`,g.backend="TensorFlow.js",g}toJSON(A,g=!0){const I=nw(this.updatedConfig());return g?JSON.stringify(I):I}call(A,g){return wi((()=>{A=Xc(A);const I=new xD;for(let g=0;g<this.inputs.length;++g)I.add(this.inputs[g],A[g]);return qD(this.outputs,I,g)}))}computeMask(A,g){return wi((()=>{let I;return A=Xc(A),I=null==g?Wc(null,A.length):Xc(g),this.runInternalGraph(A,I)[1]}))}computeOutputShape(A){const g=dD(A);if(g.length!==this.inputLayers.length)throw new qc(`Invalid inputShape argument ${A}: model has ${this.inputLayers.length} tensor inputs.`);const I={};for(let A=0;A<g.length;A++){const t=this.inputLayers[A],C=g[A];I[t.name+"_0_0"]=C}const t=Object.keys(this.nodesByDepth).map((A=>parseInt(A,10))).sort(Il);if(t.length>1)for(const A of t){const g=this.nodesByDepth[A];for(const A of g){const g=A.outboundLayer;if(-1!==this.inputLayers.map((A=>A.id)).indexOf(g.id))continue;const t=[];for(let g=0;g<A.inboundLayers.length;g++){const C=A.inboundLayers[g],e=A.nodeIndices[g],B=A.tensorIndices[g],i=I[`${C.name}_${e}_${B}`];t.push(i)}const C=dD(g.computeOutputShape(Pc(t))),e=g.inboundNodes.indexOf(A);for(let A=0;A<C.length;A++){I[`${g.name}_${e}_${A}`]=C[A]}}}const C=[],e=[];for(let A=0;A<this.outputLayers.length;A++){const g=this.outputLayers[A],I=this.outputLayersNodeIndices[A],t=this.outputLayersTensorIndices[A],C=`${g.name}_${I}_${t}`;e.push(C)}for(let A=0;A<e.length;A++){const g=e[A];Oc(g in I),C.push(I[g])}return Pc(C)}runInternalGraph(A,g){null==g&&(g=Wc(null,A.length));const I={};for(let t=0;t<this.inputs.length;++t){const C=this.inputs[t],e=A[t],B=g[t];I[C.id]=[e,B]}const t=Object.keys(this.nodesByDepth).map((A=>parseInt(A,10))).sort(Il);for(const A of t){const g=this.nodesByDepth[A];for(const A of g){const g=A.outboundLayer,t=A.inputTensors,C=A.outputTensors,e=new Array;for(const A of t)A.id in I&&e.push(I[A.id]);if(e.length===t.length){let t,B,i,Q,o={};if(null!=A.callArgs&&(o=A.callArgs),1===e.length){const[A,I]=e[0];null==o.mask&&(o.mask=I),i=Xc(g.call(A,o)),Q=Xc(g.computeMask(A,I)),t=[A],B=[I]}else t=e.map((A=>A[0])),B=e.map((A=>A[1])),null==o.mask&&(o.mask=B),i=Xc(g.call(t,o)),Q=Xc(g.computeMask(t,B));if(g.activityRegularizer)throw new Tc("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let A=0;A<C.length;++A){const g=C[A],t=i[A],e=Q[A];I[g.id]=[t,e]}}}}const C=[],e=[],B=[];for(const A of this.outputs){Oc(A.id in I,`Could not compute output ${A.name} : ${A.id}`);const[g,t]=I[A.id];B.push(g.shape),C.push(g),e.push(t)}return[C,e,B]}buildNodeConversionMap(A){const g={};let I;for(const A of this.layers){I=A instanceof aw?1:0;for(let t=0;t<A.inboundNodes.length;t++){const C=aw.nodeKey(A,t);this.containerNodes.has(C)&&(g[C]=I,I+=1)}}return g}getLayer(A,g){if(null!=g){if(this.layers.length<=g)throw new qc(`Was asked to retrieve layer at index ${g}, but model only has ${this.layers.length} layer(s).`);return this.layers[g]}if(null==A)throw new qc("Provide either a layer name or layer index");for(const g of this.layers)if(g.name===A)return g;throw new qc(`No such layer: ${A}`)}calculateLosses(){return wi((()=>{const A=[];for(const g of this.layers)for(let I=0;I<g.inboundNodes.length;++I){const t=aw.nodeKey(g,I);this.containerNodes.has(t)&&A.push(...g.calculateLosses())}return A}))}getConfig(){const A={name:this.name},g=this.buildNodeConversionMap(this.layers),I=[];for(const A of this.layers){const t=A.getClassName(),C=A.getConfig(),e=[];for(let I=0;I<A.inboundNodes.length;I++){const t=A.inboundNodes[I],C=aw.nodeKey(A,I);let B={};if(this.containerNodes.has(C)){if(t.callArgs)try{JSON.stringify(t.callArgs),B=t.callArgs}catch(g){console.warn(`Layer ${A.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),B={}}if(t.inboundLayers.length>0){const A=[];for(let I=0;I<t.inboundLayers.length;I++){const C=t.inboundLayers[I],e=t.nodeIndices[I],i=t.tensorIndices[I];let Q=g[aw.nodeKey(C,e)];null==Q&&(Q=0),A.push([C.name,Q,i,B])}e.push(A)}}}const B={};B.name=A.name,B.className=t,B.config=C,B.inboundNodes=e,I.push(B)}A.layers=I;const t=[];for(let A=0;A<this.inputLayers.length;A++){const I=this.inputLayers[A],C=this.inputLayersNodeIndices[A],e=aw.nodeKey(I,C);if(!this.containerNodes.has(e))continue;let B=g[e];null==B&&(B=0);const i=this.inputLayersTensorIndices[A];t.push([I.name,B,i])}A.inputLayers=t;const C=[];for(let A=0;A<this.outputLayers.length;A++){const I=this.outputLayers[A],t=this.outputLayersNodeIndices[A],e=aw.nodeKey(I,t);if(!this.containerNodes.has(e))continue;let B=g[e];null==B&&(B=0);const i=this.outputLayersTensorIndices[A];C.push([I.name,B,i])}return A.outputLayers=C,A}static fromConfig(A,g,I={},t=!1){const C={},e={};function B(A,g){A.name in e?e[A.name].push(g):e[A.name]=[g]}function i(A,g){const I=[];let t;for(const e of g){const i=e[0],Q=e[1],o=e[2];if(t=null==e[3]?{}:e[3],!(i in C))return void B(A,g);const E=C[i];if(E.inboundNodes.length<=Q)return void B(A,g);const n=E.inboundNodes[Q];I.push(n.outputTensors[o])}I.length>0&&A.apply(Pc(I),t)}function Q(A){const I=A.name,e=Su(A,null!=g.customObjects?g.customObjects:{});e.setFastWeightInitDuringBuild(t),C[I]=e;A.inboundNodes.forEach((A=>{if(!(A instanceof Array))throw new qc(`Corrupted configuration, expected array for nodeData: ${A}`);B(e,A)}))}const o=g.name,E=g.layers;for(const A of E)Q(A);for(;!Cl(e);)for(const A of E){const g=C[A.name];if(g.name in e){const A=e[g.name];delete e[g.name];for(const I of A)i(g,I)}}const n=[],s=[],a=g.inputLayers;for(const A of a){const g=A[0],I=A[1],t=A[2];Oc(g in C);const e=C[g].inboundNodes[I].outputTensors;n.push(e[t])}const r=g.outputLayers;for(const A of r){const g=A[0],I=A[1],t=A[2];Oc(g in C);const e=C[g].inboundNodes[I].outputTensors;s.push(e[t])}return new A({inputs:n,outputs:s,name:o})}get stateful(){if(this._stateful)throw new qc("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const A of this.layers)if(A.stateful)return!0;return!1}resetStates(){wi((()=>{this.layers.forEach((A=>{A.stateful&&A.resetStates()}))}))}}function rw(A,g,I){const t=g.length;if(null==A||Array.isArray(A)&&0===A.length)return g.map((A=>null));if(1===t)return Array.isArray(A)&&1===A.length?A:"object"==typeof A&&g[0]in A?[A[g[0]]]:[A];if(Array.isArray(A)){if(A.length!==t)throw new Error(`Provided ${I} is an array of ${A.length} element(s), but the model has ${t} outputs. Make sure a set of weights is provided for each model output.`);return A}if("object"==typeof A&&Object.keys(A).length>0&&"object"==typeof A[Object.keys(A)[0]]){const I=[];return g.forEach((g=>{g in A?I.push(A[g]):I.push(null)})),I}throw new Error(`The model has multiple (${t}) outputs, so ${I} must be either an array with ${t} elements or an object with ${g} keys. Provided ${I} not understood: ${JSON.stringify(A)}`)}function hw(A,g){return rw(A,g,"classWeight")}async function cw(A,g,I,t){if(null!=g||null!=t)throw new Error("Support sampleWeight is not implemented yet");if(null!=I){const g=wi((()=>{if(1===A.shape.length)return TB(A);if(2===A.shape.length){if(A.shape[1]>1){return ho(A,1)}if(1===A.shape[1])return Lo(A,[A.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${A.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${A.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),t=Array.from(await g.data());di(g);const C=[];return t.forEach((A=>{if(null==I[A])throw new Error(`classWeight must contain all classes in the training data. The class ${A} exists in the data but not in classWeight`);C.push(I[A])})),Ks(C,"float32")}return null}function lw(A,g){return xQ(A,g)}function Dw(A,g){let I,t;const C=g;I=C.xs,t=C.ys,CA(null!=I&&null!=t,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${g}`));const e=uw("input",A.inputNames,I),B=uw("output",A.outputNames,t),i=e[0].shape[0];CA(e.length===A.inputs.length,(()=>`LayersModel has ${A.inputs.length} inputs, but the dataset provides ${e.length} inputs.  (Expected input keys: ${JSON.stringify(A.inputNames)})`)),CA(B.length===A.outputs.length,(()=>`LayersModel has ${A.outputs.length} outputs, but the dataset provides ${B.length} outputs.  (Expected output keys: ${JSON.stringify(A.outputNames)})`));for(let g=0;g<e.length;g++)CA(e[g].shape[0]===i,(()=>`Batch size mismatch: input ${A.inputNames[g]} has ${e[g].shape[0]}; expected  ${i} based on input ${A.inputNames[0]}.`));for(let g=0;g<B.length;g++)CA(B[g].shape[0]===i,(()=>`Batch size mismatch: output ${A.outputNames[g]} has ${B[g].shape[0]}; expected  ${i} based on input ${A.inputNames[0]}.`));return{xs:e,ys:B}}function uw(A,g,I){if(I instanceof Ce)return[I];if(Array.isArray(I))return CA(I.length===g.length,(()=>`Received an array of ${I.length} Tensors, but expected ${g.length} to match the ${A} keys ${g}.`)),I;{const t=[];for(const C of g){if(null==I[C])throw new qc(`The feature data generated by the dataset lacks the required ${A} key '${C}'.`);t.push(I[C])}return t}}async function ww(A,g,I){const t=null!=I.batchesPerEpoch;if(CA(null!=A.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),CA(null!=I,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),CA(null!=I.epochs&&I.epochs>0&&Number.isInteger(I.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${I.epochs}`)),CA(!t||I.batchesPerEpoch>0&&Number.isInteger(I.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${I.batchesPerEpoch}`)),CA(null==I.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),A.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");A.isTraining=!0;try{const C=null!=I.validationData;let e,B;if(C)if(dw(I.validationData))CA(null==I.validationBatches||I.validationBatches>0&&Number.isInteger(I.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${I.validationBatches}`));else{const A=function(A){if(3===A.length)throw new Tc("Validation with sample weights is not implemented yet.");return{xs:A[0],ys:A[1]}}(I.validationData);e=A.xs,B=A.ys}const i=A.makeTrainFunction(),Q=A.getDedupedMetricsNames();let o;o=C?Q.slice().concat(Q.map((A=>"val_"+A))):Q.slice();const E=Ru(I.callbacks,I.yieldEvery),n=null==I.verbose?1:I.verbose,{callbackList:s,history:a}=ku(E,n,I.epochs,null,null,function(A,g){let I=null;null!=g.batchesPerEpoch?I=g.batchesPerEpoch:Number.isFinite(A.size)&&(I=A.size);return I}(g,I),null,C,o);s.setModel(A),A.history=a,await s.onTrainBegin(),A.stopTraining_=!1;let r=null==I.initialEpoch?0:I.initialEpoch,h=await g.iterator();for(;r<I.epochs;){const o={};await s.onEpochBegin(r);let E=0,n=0;for(t||(h=await g.iterator());!t||E<I.batchesPerEpoch;){const g=await h.next();if(t&&g.done){console.warn(`You provided \`batchesPerEpoch\` as ${I.batchesPerEpoch}, but your dataset iterator ran out of data after ${E} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+I.batchesPerEpoch*I.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=g.value){const{xs:t,ys:C}=Dw(A,g.value),e={};e.batch=n,e.size=t[0].shape[0],await s.onBatchBegin(n,e);const B=[];if(null!=I.classWeight){const g=hw(I.classWeight,A.outputNames);for(let A=0;A<g.length;++A)B.push(await cw(C[A],null,g[A]))}const o=t.concat(C).concat(B),a=i(o);di(o);for(let A=0;A<Q.length;++A){const g=Q[A],I=a[A];e[g]=I,pi(I)}await s.onBatchEnd(n,e),du(e),n++,E++}if(t?E>=I.batchesPerEpoch:g.done){if(C){let g;g=dw(I.validationData)?Xc(await A.evaluateDataset(I.validationData,{batches:I.validationBatches})):Xc(A.evaluate(e,B,{batchSize:null==I.validationBatchSize?32:I.validationBatchSize,verbose:0}));for(let I=0;I<A.metricsNames.length;++I)o[`val_${A.metricsNames[I]}`]=g[I]}break}if(A.stopTraining_)break}if(await s.onEpochEnd(r,o),r++,A.stopTraining_)break}return await s.onTrainEnd(),await A.history.syncData(),A.history}finally{A.isTraining=!1}}function dw(A){return"function"==typeof A.iterator}function pw(A){CA(A>0&&Number.isInteger(A),(()=>`batchSize is required to be a positive integer, but got ${A}`))}function yw(A,g,I){return null==A?[null]:Array.isArray(A)?A.map((A=>xl(A,g,I-g))):xl(A,g,I-g)}function Gw(A,g){return wi((()=>null==A?null:Array.isArray(A)?A.map((A=>Gw(A,g))):Ol(A,"int32"===g.dtype?g:qB(g,"int32"))))}function fw(A,g){const I=[];let t=0,C=null;for(;t<A;)C=t+g,C>=A&&(C=A),I.push([t,C]),t=C;return I}async function Nw(A,g,I,t={}){if(A.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let C,e,B,i,Q,o,E,n,s;A.isTraining=!0;try{const a=null==t.batchSize?32:t.batchSize;pw(a);const r=!1,h=await A.standardizeUserData(g,I,t.sampleWeight,t.classWeight,r,a);C=h[0],e=h[1],s=h[2];let c,l=!1;if(null!=t.validationData&&t.validationData.length>0){if(l=!0,2!==t.validationData.length)throw 3===t.validationData.length?new Tc("validationData including sample weights is not supported yet."):new qc(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${t.validationData} is invalid.`);Q=t.validationData[0],o=t.validationData[1];const g=!0,I=await A.standardizeUserData(Q,o,null,null,g,a);E=I[0],n=I[1],c=E.concat(n)}else if(null!=t.validationSplit&&t.validationSplit>0&&t.validationSplit<1){l=!0;const A=Math.floor(C[0].shape[0]*(1-t.validationSplit)),g=C[0].shape[0];E=yw(C,A,g),B=C,C=yw(C,0,A),n=yw(e,A,g),i=e,e=yw(e,0,A),c=E.concat(n)}else null!=t.validationSteps&&(l=!0);const D=C.concat(e).concat(s);A.checkTrainableWeightsConsistency();const u=A.makeTrainFunction(),w=A.getDedupedMetricsNames();let d,p;l?(A.makeTestFunction(),d=A.testFunction,p=w.slice().concat(w.map((A=>"val_"+A)))):(d=null,c=[],p=w.slice());const y=Ru(t.callbacks,t.yieldEvery),G=await async function(A,g,I,t,C,e,B,i,Q,o,E,n,s,a,r){null==C&&(C=32),null==e&&(e=1),null==E&&(E=!0),null==s&&(s=0);let h=!1;if(null!=Q&&null!=o&&(h=!0),null!=r&&(h=!0,null==a))throw new qc("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const c=A.checkNumSamples(I,C,a,"steps_per_epoch");let l;null!=c&&(l=Ul(0,c)),null==B&&(B=1);const{callbackList:D,history:u}=ku(i,B,e,s,c,a,C,h,n);D.setModel(A),A.history=u,await D.onTrainBegin(),A.stopTraining_=!1;for(let B=s;B<e;++B){await D.onEpochBegin(B);const e={};if(null!=a)throw new Tc("stepsPerEpoch mode is not implemented yet.");{if("batch"===E)throw new Tc("batch shuffling is not implemneted yet");E&&j(l);const B=Ks(l),i=fw(c,C);for(let E=0;E<i.length;++E){const n={};if(await D.onBatchBegin(E,n),wi((()=>{const s=i[E][0],a=i[E][1],r=xl(B,s,a-s);n.batch=E,n.size=a-s;const c=Gw(I,r),l=g(c);for(let A=0;A<t.length;++A){const g=t[A],I=l[A];n[g]=I,pi(I)}if(E===i.length-1&&h){const g=A.testLoop(Q,o,C);for(let A=0;A<t.length;++A){const I=t[A],C=g[A];pi(C),e["val_"+I]=C}}})),await D.onBatchEnd(E,n),du(n),A.stopTraining_)break}B.dispose()}if(await D.onEpochEnd(B,e),A.stopTraining_)break}return await D.onTrainEnd(),await A.history.syncData(),A.history}(A,u,D,w,a,t.epochs,t.verbose,y,d,c,t.shuffle,p,t.initialEpoch,null,null);return G}finally{A.isTraining=!1,Rw(C,g),Rw(e,I),Rw(B,g),Rw(i,I),Rw(E,Q),Rw(n,o),null!=s&&di(s)}}function Fw(A){const g=[];A instanceof Ce&&(A=[A]);for(let I=0;I<A.length;++I){const t=A[I];if(1===t.rank)g.push(Ll(t,1));else{if(0===t.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");g.push(t)}}return g}function Rw(A,g){if(null==A)return;const I=[];if(g instanceof Ce)I.push(g.id);else if(Array.isArray(g))g.forEach((A=>I.push(A.id)));else if(null!=g)for(const A in g){const t=g[A];I.push(t.id)}const t=[];if(A instanceof Ce)-1===I.indexOf(A.id)&&t.push(A);else if(Array.isArray(A))A.forEach((A=>{-1===I.indexOf(A.id)&&t.push(A)}));else if(null!=A)for(const g in A){const C=A[g];-1===I.indexOf(C.id)&&t.push(C)}t.forEach((A=>{A.isDisposed||A.dispose()}))}function mw(A){return Array.isArray(A)}function kw(A){return!function(A){return A instanceof Ce}(A)&&!mw(A)}function Sw(A,g,I,t=!0,C=""){if(null==g||0===g.length){if(null!=A){let g=!1;if(mw(A)&&A.length>0)g=!0;else if(kw(A)){for(const I in A)if(A.hasOwnProperty(I)){g=!0;break}}else g=!0;if(g)throw new qc(`Error when checking model ${C} expected no data, but got ${A}`)}return[]}if(null==A)return g.map((A=>null));let e;if(kw(A)){e=[];for(const I of g){if(null==A[I])throw new qc(`No data provided for "${I}". Need data for each key in: ${g}`);e.push(A[I])}}else if(mw(A)){if(A.length!==g.length)throw new qc(`Error when checking model ${C}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${g.length} Tensor(s), but instead got the following list of Tensor(s): ${A}`);e=A}else{if(g.length>1)throw new qc(`The model ${C} expects ${g.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${A.shape}`);e=[A]}if(e=Fw(e),null!=I)for(let A=0;A<g.length;++A){if(null==I[A])continue;const B=e[A];if(B.shape.length!==I[A].length)throw new qc(`Error when checking ${C}: expected ${g[A]} to have ${I[A].length} dimension(s). but got array with shape ${B.shape}`);for(let g=0;g<I[A].length;++g){if(0===g&&!t)continue;const e=B.shape[g],i=I[A][g];if(null!=i&&i>=0&&e!==i)throw new qc(`${C} expected a batch of elements where each example has shape [${I[A].slice(1,I[A].length)}] (i.e.,tensor shape [*,${I[A].slice(1,I[A].length)}]) but the ${C} received an input with ${B.shape[0]} examples, each with shape [${B.shape.slice(1,B.shape.length)}] (tensor shape [${B.shape}])`)}}return e}function Mw(A,g,I,t=!0,C=""){let e;if(Array.isArray(A)){if(A.length!==g.length)throw new qc(`Error when checking model ${C}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${g.length} Tensor(s), but instead got ${A.length} Tensors(s).`);e=A}else{if(g.length>1)throw new qc(`The model expects ${g.length} ${C} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(A.shape)}.`);e=[A]}if(null!=I)for(let A=0;A<g.length;++A){if(null==I[A])continue;const B=e[A];if(B.shape.length!==I[A].length)throw new qc(`Error when checking ${C}: expected ${g[A]} to have ${I[A].length} dimension(s), but got array with shape ${JSON.stringify(B.shape)}`);for(let e=0;e<I[A].length;++e){if(0===e&&!t)continue;const i=B.shape[e],Q=I[A][e];if(null!=Q&&Q!==i)throw new qc(`Error when checking ${C}: expected ${g[A]} to have shape ${JSON.stringify(I[A])} but got array with shape ${JSON.stringify(B.shape)}.`)}}}class Uw extends aw{constructor(A){super(A),this.isTraining=!1}summary(A,g,I=console.log){if(!this.built)throw new qc("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ew(this,A,g,I)}compile(A){if(null==A.loss&&(A.loss=[]),this.loss=A.loss,"string"==typeof A.optimizer)this.optimizer_=function(A){const g={Adagrad:()=>hr.adagrad(.01),Adadelta:()=>hr.adadelta(1,.95,Jl()),Adam:()=>hr.adam(.001,.9,.999,Jl()),Adamax:()=>hr.adamax(.002,.9,.999,Jl(),0),RMSProp:()=>hr.rmsprop(.001,.9,0,Jl()),SGD:()=>hr.sgd(.01)};if(g.adagrad=g.Adagrad,g.adadelta=g.Adadelta,g.adam=g.Adam,g.adamax=g.Adamax,g.rmsprop=g.RMSProp,g.sgd=g.SGD,A in g)return g[A]();throw new qc(`Unknown Optimizer ${A}`)}(A.optimizer),this.isOptimizerOwned=!0;else{if(!(A.optimizer instanceof jQ))throw new qc("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=A.optimizer,this.isOptimizerOwned=!1}let g=[];if(Array.isArray(A.loss)||"string"==typeof A.loss||"function"==typeof A.loss)if(Array.isArray(A.loss)){if(A.loss.length!==this.outputs.length)throw new qc(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${A.loss}.`);const I=A.loss;g=I.map((A=>vu(A)))}else{const I=vu(A.loss);this.outputs.forEach((A=>{g.push(I)}))}else{A.loss=A.loss;for(const g in A.loss)if(-1===this.outputNames.indexOf(g))throw new qc(`Unknown entry in loss dictionary: "${g}". Only expected the following keys: ${this.outputNames}`);for(const I of this.outputNames)null==A.loss[I]&&console.warn(`Output "${I}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${I} during training`),g.push(vu(A.loss[I]))}this.lossFunctions=g,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let A=0;A<this.outputs.length;++A){const g=this.internalOutputShapes[A],I=this.outputNames[A];this.feedOutputNames.push(I),this.feedOutputShapes.push(g),this.feedLossFns.push(this.lossFunctions[A])}const I=[];this.metrics=A.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fl("loss",(()=>{for(let A=0;A<this.outputs.length;++A){if(-1!==I.indexOf(A))continue;const g=this.lossFunctions[A];this.outputs.length>1&&(this.metricsTensors.push([g,A]),this.metricsNames.push(this.outputNames[A]+"_loss"))}}));const t=function(A,g){if(null==A||Array.isArray(A)&&0===A.length)return g.map((A=>[]));let I;if("string"==typeof A||"function"==typeof A)I=[A];else{if(!Array.isArray(A)&&"object"!=typeof A)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${A}`);I=A}if(Array.isArray(I))return g.map((A=>I));{const A=[];for(const t of g){let g=I.hasOwnProperty(t)?I[t]:[];Array.isArray(g)||(g=[g]),A.push(g)}return A}}(A.metrics,this.outputNames),C=(A,g,I)=>{this.outputNames.length>1&&(g=this.outputNames[A]+"_"+g),this.metricsNames.push(g),this.metricsTensors.push([I,A])};fl("metric",(()=>{for(let A=0;A<this.outputs.length;++A){if(-1!==I.indexOf(A))continue;(g=>{let I,t,e;for(const B of g){if("string"==typeof B&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(B)){const g=this.internalOutputShapes[A];let C;1===g[g.length-1]||this.lossFunctions[A]===bu?-1!==["accuracy","acc"].indexOf(B)?t=Vu:-1!==["crossentropy","ce"].indexOf(B)&&(t=Xu):this.lossFunctions[A]===xu?-1!==["accuracy","acc"].indexOf(B)?t=ju:-1!==["crossentropy","ce"].indexOf(B)&&(t=_u):-1!==["accuracy","acc"].indexOf(B)?t=Wu:-1!==["crossentropy","ce"].indexOf(B)&&(t=zu),-1!==["accuracy","acc"].indexOf(B)?C="acc":-1!==["crossentropy","ce"].indexOf(B)&&(C="ce"),e=t,I=""+C}else{const A=Aw(B);e=A,I=""+gw(B)}let g;fl(I,(()=>{g=e})),C(A,I,g)}})(t[A])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(A,g,I={}){const t=null==I.batchSize?32:I.batchSize;pw(t);const C=this.standardizeUserDataXY(A,g,!0,t);try{const A=C[0].concat(C[1]);this.makeTestFunction();const g=this.testFunction;return Pc(this.testLoop(g,A,t,I.verbose,I.steps))}finally{Rw(C[0],A),Rw(C[1],g)}}async evaluateDataset(A,g){return this.makeTestFunction(),async function(A,g,I){const t=null!=(I=I||{}).batches,C=A.testFunction;let e=[];if(I.verbose>0)throw new Tc("Verbose mode is not implemented yet.");CA(!t||I.batches>0&&Number.isInteger(I.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(I.batches)}`));const B="function"==typeof g.next?g:await g.iterator();let i=0,Q=0;for(;!t||Q<I.batches;){const g=await B.next();if(e=wi((()=>{if(g.value){const{xs:I,ys:t}=Dw(A,g.value),B=I.concat(t),o=wi((()=>C(B)));if(di(B),0===Q)for(let A=0;A<o.length;++A)e.push(XQ(0));const E=B[0].shape[0];for(let A=0;A<o.length;++A){const g=o[A],I=e[A];e[A]=wi((()=>JQ(e[A],xQ(E,g)))),Q>0&&di(I)}di(o),i+=E,++Q}return e})),g.done){t&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${I.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let A=0;A<e.length;++A){const g=e[A];e[A]=LQ(e[A],i),di(g)}return Pc(e)}(this,A,g)}checkNumSamples(A,g,I,t="steps"){let C;if(null!=I){if(C=null,null!=g)throw new qc(`If ${t} is set, batchSize must be null or undefined.Got batchSize = ${g}`)}else{if(null==A)throw new qc(`Either the input data should have a defined shape, or ${t} shoud be specified.`);C=Array.isArray(A)?A[0].shape[0]:A.shape[0]}return C}execute(A,g){if(Array.isArray(g)&&0===g.length)throw new qc("`outputs` is an empty Array, which is not allowed.");const I=Array.isArray(g),t=I?g:[g],C=this.retrieveSymbolicTensors(t),e=new xD;if(A instanceof Ce&&(A=[A]),Array.isArray(A)){if(A.length!==this.inputs.length)throw new qc(`The number of inputs provided (${A.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let g=0;g<this.inputs.length;++g)e.add(this.inputs[g],A[g])}else for(const g of this.inputs){const I=A[g.name];if(null==I)throw new qc(`No value is provided for the model's input ${g.name}`);e.add(g,I)}const B=qD(C,e);return I?B:B[0]}retrieveSymbolicTensors(A){const g=Wc(null,A.length);let I=A.length;for(const t of this.layers){const C=Array.isArray(t.output)?t.output:[t.output],e=C.map((A=>A.name));for(let t=0;t<A.length;++t){const B=e.indexOf(A[t]);if(-1!==B&&(g[t]=C[B],I--),0===I)break}if(0===I)break}if(I>0){const I=[];throw g.forEach(((g,t)=>{null==g&&I.push(A[t])})),new qc(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(I)}`)}return g}predictLoop(A,g=32,I=!1){return wi((()=>{const t=this.checkNumSamples(A);if(I)throw new Tc("Verbose predictLoop() is not implemented yet.");const C=fw(t,g),e=this.outputs.map((A=>[]));for(let g=0;g<C.length;++g){wi((()=>{const I=C[g][0],t=C[g][1],e=yw(A,I,t),B=[];if(Array.isArray(e))for(let A=0;A<e.length;++A)B.push({key:this.inputs[A],value:e[A]});else B.push({key:this.inputs[0],value:e});const i=new xD(B);return qD(this.outputs,i)})).forEach(((A,g)=>e[g].push(A)))}return Pc(e.map((A=>Ho(A,0))))}))}predict(A,g={}){const I=Fw(A);Mw(I,this.inputNames,this.feedInputShapes,!1);try{const A=null==g.batchSize?32:g.batchSize;return pw(A),this.predictLoop(I,A)}finally{Rw(I,A)}}predictOnBatch(A){Mw(A,this.inputNames,this.feedInputShapes,!0);const g=(Array.isArray(A)?A[0]:A).shape[0];return this.predictLoop(A,g)}standardizeUserDataXY(A,g,I=!0,t){if(null==this.optimizer_)throw new Hc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const C=[];for(let A=0;A<this.feedOutputShapes.length;++A){const g=this.feedOutputShapes[A];this.feedLossFns[A]===xu?C.push(g.slice(0,g.length-1).concat([1])):C.push(g)}if(function(A,g,I){const t=tl(A.map((A=>A.shape[0])));t.sort();const C=tl(g.map((A=>A.shape[0])));if(C.sort(),t.length>1)throw new qc(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(A.map((A=>A.shape)))}`);if(C.length>1)throw new qc(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(g.map((A=>A.shape)))}`);if(t.length>0&&C.length>0&&!EA(t,C))throw new qc(`Input Tensors should have the same number of samples as target Tensors. Found ${t[0]} input sample(s) and ${C[0]} target sample(s).`)}(A=Sw(A,this.feedInputNames,this.feedInputShapes,!1,"input"),g=Sw(g,this.feedOutputNames,C,!1,"target")),function(A,g,I){const t=[Uu,bu,Lu];for(let C=0;C<A.length;++C){const e=A[C],B=g[C],i=I[C];if(null!=B){if(B===Lu&&1===e.shape[e.shape.length-1])throw new qc(`You are passing a target array of shape ${e.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==t.indexOf(B)){const A=e.shape.slice(1),g=i.slice(1);for(let I=0;I<A.length;++I){const t=A[I],C=g[I];if(null!=C&&t!==C)throw new qc(`A target Tensor with shape ${e.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(g,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=t&&t>0&&A[0].shape[0]%t!=0)throw new qc(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${t}. Found: ${A[0].shape[0]} sample(s).`);return[A,g]}async standardizeUserData(A,g,I,t,C=!0,e){const[B,i]=this.standardizeUserDataXY(A,g,C,e);if(null!=I)throw new Error("sample weight is not supported yet.");let Q=null;if(null!=t){const A=hw(t,this.outputNames);Q=[];for(let g=0;g<A.length;++g)Q.push(await cw(i[g],null,A[g]))}return[B,i,Q]}testLoop(A,g,I,t=0,C){return wi((()=>{const e=this.checkNumSamples(g,I,C,"steps"),B=[];if(t>0)throw new Tc("Verbose mode is not implemented yet.");if(null!=C)throw new Tc("steps mode in testLoop() is not implemented yet");{const t=fw(e,I),C=Ks(Ul(0,e));for(let I=0;I<t.length;++I){const e=t[I][0],i=t[I][1],Q=xl(C,e,i-e),o=Gw(g,Q),E=A(o);if(0===I)for(let A=0;A<E.length;++A)B.push(XQ(0));for(let A=0;A<E.length;++A){const g=E[A];B[A]=JQ(B[A],xQ(i-e,g))}}for(let A=0;A<B.length;++A)B[A]=LQ(B[A],e)}return B}))}getDedupedMetricsNames(){const A=this.metricsNames,g=[];for(let I=0;I<A.length;++I){const t=A[I];let C=t;if(Zc(A,t)>1){C+=`_${Zc(A.slice(0,I),t)}`}g.push(C)}return g}makeTrainFunction(){return A=>{const g=[],I=A.slice(0,this.inputs.length),t=A.slice(this.inputs.length,this.inputs.length+this.outputs.length),C=A.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),e=[],B=this.collectedTrainableWeights.map((A=>A.read()));return[this.optimizer_.minimize((()=>{const A=[];for(let g=0;g<this.inputs.length;++g)A.push({key:this.inputs[g],value:I[g]});const B=new xD(A),i=qD(this.outputs,B,{training:!0});let Q;for(let A=0;A<this.lossFunctions.length;++A){let I=(0,this.lossFunctions[A])(t[A],i[A]);null!=C[A]&&(I=lw(I,C[A]));const e=pn(I);g.push(e),Q=0===A?I:JQ(Q,I)}for(let A=0;A<this.metricsTensors.length;++A){let I;if(this.outputs.length>1&&A<this.outputs.length)I=g[A];else{const g=this.metricsTensors[A][0],C=this.metricsTensors[A][1];I=pn(g(t[C],i[C]))}pi(I),e.push(I)}return Q=pn(Q),this.calculateLosses().forEach((A=>{Q=JQ(Q,A)})),Q}),!0,B)].concat(e)}}makeTestFunction(){this.testFunction=A=>wi((()=>{const g=[];let I;const t=A.slice(0,this.inputs.length),C=A.slice(this.inputs.length,this.inputs.length+this.outputs.length),e=[];for(let A=0;A<this.inputs.length;++A)e.push({key:this.inputs[A],value:t[A]});const B=new xD(e),i=qD(this.outputs,B);for(let A=0;A<this.lossFunctions.length;++A){const t=this.lossFunctions[A],e=pn(t(C[A],i[A]));I=0===A?e:JQ(I,e),g.push(I)}for(let A=0;A<this.metricsTensors.length;++A){const I=this.metricsTensors[A][0],t=this.metricsTensors[A][1],e=pn(I(C[t],i[t]));g.push(e)}return g}))}async fit(A,g,I={}){return Nw(this,A,g,I)}async fitDataset(A,g){return ww(this,A,g)}async trainOnBatch(A,g){const I=await this.standardizeUserData(A,g),t=I[0],C=I[1],e=this.makeTrainFunction()(t.concat(C)),B=[];for(const A of e){const g=await A.data();B.push(g[0])}return di(e),Rw(I[0],A),Rw(I[1],g),Pc(B)}getNamedWeights(A){const g=[],I=null!=A&&A.trainableOnly,t=I?this.trainableWeights:this.weights,C=this.getWeights(I);for(let A=0;A<t.length;++A)I&&!t[A].trainable||g.push({name:t[A].originalName,tensor:C[A]});return g}set stopTraining(A){this.stopTraining_=A}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(A){this.optimizer_!==A&&(this.optimizer_=A,this.isOptimizerOwned=!1)}dispose(){const A=super.dispose();if(0===A.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const g=Di().numTensors;this.optimizer_.dispose(),A.numDisposedVariables+=g-Di().numTensors}return A}getLossIdentifiers(){let A;if("string"==typeof this.loss)A=jc(this.loss);else if(Array.isArray(this.loss)){for(const A of this.loss)if("string"!=typeof A)throw new Error("Serialization of non-string loss is not supported.");A=this.loss.map((A=>jc(A)))}else{const g=Object.keys(this.loss);A={};const I=this.loss;for(const t of g){if("string"!=typeof I[t])throw new Error("Serialization of non-string loss is not supported.");A[t]=jc(I[t])}}return A}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[jc(gw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((A=>jc(gw(A))));{const A={};for(const g in this.metrics)A[g]=jc(gw(this.metrics[g]));return A}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(A){if(null!=A.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=A.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=A.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const g=Su(Ew(A.optimizer_config));let I,t;if("string"==typeof A.loss)I=zc(A.loss);else if(Array.isArray(A.loss))I=A.loss.map((A=>zc(A)));else if(null!=A.loss){I={};for(const g in A.loss)I[g]=zc(A.loss[g])}if(Array.isArray(A.metrics))t=A.metrics.map((A=>zc(A)));else if(null!=A.metrics){t={};for(const g in A.metrics)t[g]=zc(A.metrics[g])}this.compile({loss:I,metrics:t,optimizer:g})}async save(A,g){if("string"==typeof A){const g=eB(A);if(0===g.length)throw new qc(`Cannot find any save handlers for URL '${A}'`);if(g.length>1)throw new qc(`Found more than one (${g.length}) save handlers for URL '${A}'`);A=g[0]}if(null==A.save)throw new qc("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const I=await ve(this.getNamedWeights(g)),t={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${sw}`,convertedBy:null};if(null!=g&&g.includeOptimizer&&null!=this.optimizer){t.trainingConfig=this.getTrainingConfig();const A="optimizer",{data:g,specs:C}=await ve(await this.optimizer.getWeights(),A);I.specs.push(...C),I.data=Pe([I.data,g])}if(null!=this.userDefinedMetadata){const A=!0;tw(this.userDefinedMetadata,this.name,A),t.userDefinedMetadata=this.userDefinedMetadata}return t.weightData=I.data,t.weightSpecs=I.specs,A.save(t)}setUserDefinedMetadata(A){tw(A,this.name),this.userDefinedMetadata=A}getUserDefinedMetadata(){return this.userDefinedMetadata}}Uw.className="Model",uQ(Uw);class Kw extends Uw{}async function Jw(A,g){"modelTopology"in A||(A={modelTopology:A});let I=A.modelTopology;null!=I.model_config&&(I=I.model_config);const t=Su(Ew(I),g);if(null!=A.weightsManifest){const g=await jB(A.weightsManifest,A.pathPrefix,t.weights.map((A=>A.originalName))),I={};for(const A of t.weights)I[A.originalName]=g[A.originalName];t.loadWeights(I),di(g)}return t}async function Yw(A,g){if(null==g&&(g={}),"string"==typeof A){const I=BB(A,g);if(0===I.length)I.push(Ii(A,g));else if(I.length>1)throw new qc(`Found more than one (${I.length}) load handlers for URL '${A}'`);A=I[0]}return async function(A,g,I){null==I&&(I={});if(null==A.load)throw new qc("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await A.load();let C=t.modelTopology;null!=C.model_config&&(C=C.model_config);const e=null==I.strict||I.strict,B=null!=t.weightData&&null!=t.weightSpecs&&e,i=Su(Ew(C),g,B),Q=t.trainingConfig;null!=Q&&i.loadTrainingConfig(Q);null!=t.userDefinedMetadata&&i.setUserDefinedMetadata(t.userDefinedMetadata);if(null!=t.weightData){if(null==t.weightSpecs)throw new qc("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:A,optimizerWeights:g}=function(A,g){const I=Ve(A,g),t={},C=[];return g.forEach((A=>{"optimizer"===A.group?C.push({name:A.name,tensor:I[A.name]}):t[A.name]=I[A.name]})),{modelWeights:t,optimizerWeights:C}}(t.weightData,t.weightSpecs);i.loadWeights(A,e),null!=i.optimizer&&g.length>0&&await i.optimizer.setWeights(g),di(A),di(g.map((A=>A.tensor)))}return i}(A,void 0,g)}Kw.className="Functional",uQ(Kw);class Lw extends Uw{constructor(A){if(super({inputs:[],outputs:[]}),A=A||{},this.trainable=!0,this.built=!1,this.name=null!=A.name?A.name:al("sequential_"),null!=A.layers)for(const g of A.layers)this.add(g)}checkShape(A){if(A.inboundNodes[0].outputTensors[0].shape.some((A=>A<0)))throw new qc(`Negative dimension size caused by adding layer ${A.name} with input shape [${A.inboundNodes[0].inputTensors[0].shape}]`)}add(A){const g=A instanceof Lw||A instanceof Uw;let I;if(g){if(I=A,1!==I.outputs.length)throw new qc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==I.inputs.length)throw new qc("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===A.inboundNodes.length){if(null==A.batchInputShape)throw new qc("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const g=LD({batchShape:A.batchInputShape,dtype:A.dtype,name:A.name+"_input"});A.apply(g)}if(g)this.outputs=I.outputs,this.inputs=I.inputs;else{if(1!==A.inboundNodes.length)throw new qc(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${A.name} which has ${A.inboundNodes.length} pre-existing inbound connections.`);if(1!==A.inboundNodes[0].outputTensors.length)throw new qc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(A),this.outputs=[A.inboundNodes[0].outputTensors[0]],this.inputs=JD(this.outputs[0])}this.inboundNodes=[],new MD({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Wc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((A=>A.shape)),outputShapes:this.outputs[0].shape})}else{const g=A.apply(this.outputs[0]);if(Array.isArray(g))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(A),this.outputs=[g],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(A),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const A=this.layers.length-1;this.layers[A].outboundNodes=[],this.outputs=[this.layers[A].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(A,g){return null==this.model&&this.build(),this.model.call(A,g)}build(A){if(yD(A),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Uw({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(A,g,I=console.log){this.built||this.build(),super.summary(A,g,I)}setWeights(A){null==this.model&&this.build(),this.model.setWeights(A)}evaluate(A,g,I={}){if(!this.built)throw new Hc("The model needs to be compiled before being used.");return this.model.evaluate(A,g,I)}async evaluateDataset(A,g){if(!this.built)throw new Hc("The model needs to be compiled before being used.");return this.model.evaluateDataset(A,g)}predict(A,g={}){return null==this.model&&this.build(),this.model.predict(A,g)}predictOnBatch(A){return null==this.model&&this.build(),this.model.predictOnBatch(A)}compile(A){this.build(),this.model.compile(A),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(A){this.model.optimizer=A}async fit(A,g,I={}){if(!this.built)throw new Hc("The model needs to be compiled before being used.");return this.model.fit(A,g,I)}async fitDataset(A,g){if(!this.built)throw new Hc("The model needs to be compiled before being used.");return this.model.fitDataset(A,g)}async trainOnBatch(A,g){return this.model.trainOnBatch(A,g)}static fromConfig(A,g,I={},t=!1){let C,e={};if(g instanceof Array){if(null==g[0].className||"Merge"===g[0].className)throw new qc("Legacy serialization format not supported yet.");C=g}else CA(null!=g.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),C=g.layers,delete g.layers,e=g;const B=new A(e);if(!(B instanceof Lw))throw new Tc(`Sequential.fromConfig called on non-Sequential input: ${B}`);for(const A of C){const g=Su(A,void 0,t);t&&g.setFastWeightInitDuringBuild(!0),B.add(g)}return B}set stopTraining(A){if(null==this.model)throw new qc("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=A}get stopTraining(){if(null==this.model)throw new qc("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const A=[];for(const g of this.layers){const I={};I.className=g.getClassName(),I.config=g.getConfig(),A.push(I)}return{name:this.name,layers:A}}}function xw(A){return new Uw(A)}function bw(A){return new Lw(A)}function Hw(A,g){return null==g&&(g={}),Yw(A,g)}function qw(A){return LD(A)}function Tw(A,g){mu.registerCallbackConstructor(A,g)}Lw.className="Sequential",uQ(Lw);class vw extends lQ{getConfig(){return{}}}class Vw extends vw{apply(A,g=1){return function(A,g=1){if(1!==g)throw new Tc(`Support for alpha values other than 1 (${g}) is not implemented yet.`);return NE(A)}(A,g)}}Vw.className="elu",uQ(Vw);class Ww extends vw{apply(A){return ss(A)}}Ww.className="selu",uQ(Ww);class Ow extends vw{apply(A){return ts(A)}}Ow.className="relu",uQ(Ow);class Zw extends vw{apply(A){return wi((()=>Nn(6,ts(A))))}}Zw.className="relu6",uQ(Zw);class Pw extends vw{apply(A){return A}}Pw.className="linear",uQ(Pw);class Xw extends vw{apply(A){return qo(A)}}Xw.className="sigmoid",uQ(Xw);class jw extends vw{apply(A){return function(A){return wi((()=>{const g=JQ(.5,xQ(.2,A));return AE(g,0,1)}))}(A)}}jw.className="hardSigmoid",uQ(jw);class zw extends vw{apply(A){return Qn(A)}}zw.className="softplus",uQ(zw);class _w extends vw{apply(A){return function(A){return wi((()=>LQ(A,JQ(to(A),1))))}(A)}}_w.className="softsign",uQ(_w);class $w extends vw{apply(A){return vo(A)}}$w.className="tanh",uQ($w);class Ad extends vw{apply(A,g=-1){return ps(A,g)}}Ad.className="softmax",uQ(Ad);class gd extends vw{apply(A,g=-1){return En(A,g)}}gd.className="logSoftmax",uQ(gd);class Id extends vw{apply(A,g=1){return wi((()=>xQ(qo(xQ(A,g)),A)))}}Id.className="swish",uQ(Id);class td extends vw{apply(A){return wi((()=>xQ(A,vo(Qn(A)))))}}function Cd(A){return A.getClassName()}function ed(A,g={}){return gl(A,DQ.getMap().classNameMap,g,"activation")}function Bd(A){if(null==A){const A={className:"linear",config:{}};return ed(A)}if("string"==typeof A){const g={};return g.className=A,g.config={},ed(g)}return A instanceof vw?A:ed(A)}function id(A){if(null!=A&&"object"!=typeof A)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${A}`)}td.className="mish",uQ(td);class Qd extends lQ{}class od extends Qd{constructor(A){super(),id(A),this.l1=null==A||null==A.l1?.01:A.l1,this.l2=null==A||null==A.l2?.01:A.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(A){return wi((()=>{let g=yn([1]);return this.hasL1&&(g=JQ(g,xE(xQ(this.l1,to(A))))),this.hasL2&&(g=JQ(g,xE(xQ(this.l2,Zl(A))))),Lo(g,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(A,g){return new A({l1:g.l1,l2:g.l2})}}od.className="L1L2",uQ(od);const Ed={l1l2:"L1L2"};function nd(A){return $c(A)}function sd(A,g={}){return gl(A,DQ.getMap().classNameMap,g,"regularizer")}function ad(A){if(null==A)return null;if("string"==typeof A){return sd({className:A in Ed?Ed[A]:A,config:{}})}return A instanceof Qd?A:sd(A)}class rd extends KD{constructor(A){super(null==A?{}:A),this.supportsMasking=!0,null!=A&&(this.maxValue=A.maxValue)}call(A,g){A=pD(A);let I=ts(A);return null!=this.maxValue&&(I=AE(I,0,this.maxValue)),I}computeOutputShape(A){return A}getConfig(){const A={maxValue:this.maxValue},g=super.getConfig();return Object.assign(A,g),A}}rd.className="ReLU",uQ(rd);class hd extends KD{constructor(A){super(null==A?{}:A),this.DEFAULT_ALPHA=.3,null==A&&(A={}),this.alpha=null==A.alpha?this.DEFAULT_ALPHA:A.alpha}call(A,g){const I=pD(A);return An(I,this.alpha)}computeOutputShape(A){return A}getConfig(){const A={alpha:this.alpha},g=super.getConfig();return Object.assign(A,g),A}}hd.className="LeakyReLU",uQ(hd);class cd extends KD{constructor(A){if(super(null==A?{}:A),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==A&&(A={}),this.supportsMasking=!0,this.alphaInitializer=uD(A.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ad(A.alphaRegularizer),this.alphaConstraint=Au(A.alphaConstraint),null==A.sharedAxes)this.sharedAxes=null;else if(Array.isArray(A.sharedAxes))this.sharedAxes=A.sharedAxes;else{if("number"!=typeof A.sharedAxes)throw new qc(`Expected sharedAxes to be a number or an array of numbers, but got ${A.sharedAxes}`);this.sharedAxes=[A.sharedAxes]}}build(A){const g=(A=yD(A)).slice(1);if(null!=this.sharedAxes)for(const A of this.sharedAxes)g[A-1]=1;this.alpha=this.addWeight("alpha",g,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const I={};if(null!=this.sharedAxes)for(let g=1;g<A.length;++g)I[g]=A[g];this.inputSpec=[new mD({ndim:A.length,axes:I})],this.built=!0}call(A,g){return A=pD(A),Tn(A,this.alpha.read())}getConfig(){const A={alphaInitializer:DD(this.alphaInitializer),alphaRegularizer:nd(this.alphaRegularizer),alphaConstraint:_D(this.alphaConstraint),sharedAxes:this.sharedAxes},g=super.getConfig();return Object.assign(A,g),A}}cd.className="PReLU",uQ(cd);class ld extends KD{constructor(A){if(super(null==A?{}:A),this.DEFAULT_ALPHA=1,null==A&&(A={}),null!=A.alpha&&A.alpha!==this.DEFAULT_ALPHA)throw new Tc(`Non-default alpha value (${A.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==A.alpha?this.DEFAULT_ALPHA:A.alpha}call(A,g){const I=pD(A);return NE(I)}computeOutputShape(A){return A}getConfig(){const A={alpha:this.alpha},g=super.getConfig();return Object.assign(A,g),A}}ld.className="ELU",uQ(ld);class Dd extends KD{constructor(A){super(null==A?{}:A),this.DEFAULT_THETA=1,null==A&&(A={}),this.theta=null==A.theta?this.DEFAULT_THETA:A.theta}call(A,g){const I=pD(A);return xQ(I,qB(XE(I,this.theta),"float32"))}computeOutputShape(A){return A}getConfig(){const A={theta:this.theta},g=super.getConfig();return Object.assign(A,g),A}}Dd.className="ThresholdedReLU",uQ(Dd);class ud extends KD{constructor(A){super(null==A?{}:A),this.DEFAULT_AXIS=1,null==A&&(A={}),this.softmax=(new Ad).apply,this.axis=null==A.axis?this.DEFAULT_AXIS:A.axis}call(A,g){const I=pD(A);return this.softmax(I,this.axis)}computeOutputShape(A){return A}getConfig(){const A={axis:this.axis},g=super.getConfig();return Object.assign(A,g),A}}function wd(A,g,I){if("number"==typeof A)return Wc(A,g);if(A.length!==g)throw new qc(`The ${I} argument must be an integer or tuple of ${g} integers. Received: ${A.length} elements.`);for(let C=0;C<g;++C){const e=A[C];if((t=e)!==parseInt(t.toString(),10))throw new qc(`The ${I} argument must be an integer or tuple of ${g} integers. Received: ${JSON.stringify(A)} including a non-integer number ${e}`)}return A;var t}function dd(A,g,I,t,C=1){if(null==A)return A;let e;return e="same"===I?A:A-(g+(g-1)*(C-1))+1,Math.floor((e+t-1)/t)}function pd(A,g,I,t){if(null==A)return null;if("valid"===t)A=A*g+Ml([I-g,0]);else{if("same"!==t)throw new qc(`Unsupport padding mode: ${t}.`);A*=g}return A}function yd(A,g){return wi((()=>(wl(g),"channelsFirst"===g?Yi(A,[0,2,3,1]):A)))}function Gd(A,g){return wi((()=>(wl(g),"channelsFirst"===g?Yi(A,[0,2,3,4,1]):A)))}function fd(A,g,I,t=1,C="valid",e,B=1){return wi((()=>{if(null==e&&(e="channelsLast"),wl(e),3!==A.shape.length)throw new qc(`The input of a conv1dWithBias operation should be 3, but is ${A.shape.length} instead.`);if(3!==g.shape.length)throw new qc(`The kernel for a conv1dWithBias operation should be 3, but is ${g.shape.length} instead`);if(null!=I&&1!==I.shape.length)throw new qc(`The bias for a conv1dWithBias operation should be 1, but is ${g.shape.length} instead`);if("channelsFirst"===e&&(A=Yi(A,[0,2,1])),"causal"===C)throw new Tc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=BE(A,g,t,"same"===C?"same":"valid","NWC",B);return null!=I&&(i=Xl(i,I)),i}))}function Nd(A,g,I,t=[1,1],C="valid",e,B,i=null){return wi((()=>{if(null==e&&(e="channelsLast"),wl(e),3!==A.rank&&4!==A.rank)throw new qc(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${A.rank}.`);if(3!==g.rank&&4!==g.rank)throw new qc(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${A.rank}.`);let Q=yd(A,e);if("causal"===C)throw new Tc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return Q=Qa({x:Q,filter:g,strides:t,pad:"same"===C?"same":"valid",dilations:B,dataFormat:"NHWC",bias:I,activation:i}),"channelsFirst"===e&&(Q=Yi(Q,[0,3,1,2])),Q}))}function Fd(A,g,I,t=[1,1,1],C="valid",e,B){return wi((()=>{if(null==e&&(e="channelsLast"),wl(e),4!==A.rank&&5!==A.rank)throw new qc(`conv3dWithBias expects input to be of rank 4 or 5, but received ${A.rank}.`);if(4!==g.rank&&5!==g.rank)throw new qc(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${A.rank}.`);let i=Gd(A,e);if("causal"===C)throw new Tc("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=oE(i,g,t,"same"===C?"same":"valid","NDHWC",B),null!=I&&(i=Xl(i,I)),"channelsFirst"===e&&(i=Yi(i,[0,4,1,2,3])),i}))}ud.className="Softmax",uQ(ud);class Rd extends KD{constructor(A,g){if(super(g),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Rd.verifyArgs(g),this.rank=A,il(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Tc(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=wd(g.kernelSize,A,"kernelSize"),this.strides=wd(null==g.strides?1:g.strides,A,"strides"),this.padding=null==g.padding?"valid":g.padding,dl(this.padding),this.dataFormat=null==g.dataFormat?"channelsLast":g.dataFormat,wl(this.dataFormat),this.activation=Bd(g.activation),this.useBias=null==g.useBias||g.useBias,this.biasInitializer=uD(g.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Au(g.biasConstraint),this.biasRegularizer=ad(g.biasRegularizer),this.activityRegularizer=ad(g.activityRegularizer),this.dilationRate=wd(null==g.dilationRate?1:g.dilationRate,A,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new qc(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new qc(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new qc(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(A){if(Oc("kernelSize"in A,"required key 'kernelSize' not in config"),"number"!=typeof A.kernelSize&&!Bl(A.kernelSize,"number",1,3))throw new qc(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(A.kernelSize)}.`)}getConfig(){const A={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Cd(this.activation),useBias:this.useBias,biasInitializer:DD(this.biasInitializer),biasRegularizer:nd(this.biasRegularizer),activityRegularizer:nd(this.activityRegularizer),biasConstraint:_D(this.biasConstraint)},g=super.getConfig();return Object.assign(A,g),A}}class md extends Rd{constructor(A,g){super(A,g),this.kernel=null,md.verifyArgs(g),this.filters=g.filters,il(this.filters,"filters"),this.kernelInitializer=uD(g.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Au(g.kernelConstraint),this.kernelRegularizer=ad(g.kernelRegularizer)}build(A){A=yD(A);const g="channelsFirst"===this.dataFormat?1:A.length-1;if(null==A[g])throw new qc(`The channel dimension of the input should be defined. Found ${A[g]}`);const I=A[g],t=this.kernelSize.concat([I,this.filters]);this.kernel=this.addWeight("kernel",t,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[g]:I}}],this.built=!0}call(A,g){return wi((()=>{let g;A=pD(A);const I=null==this.bias?null:this.bias.read(),t=ol(this.activation.getClassName());if(null!=t&&2===this.rank)g=Nd(A,this.kernel.read(),I,this.strides,this.padding,this.dataFormat,this.dilationRate,t);else{if(1===this.rank)g=fd(A,this.kernel.read(),I,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)g=Nd(A,this.kernel.read(),I,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Tc("convolutions greater than 3D are not implemented yet.");g=Fd(A,this.kernel.read(),I,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(g=this.activation.apply(g))}return g}))}computeOutputShape(A){A=yD(A);const g=[],I="channelsLast"===this.dataFormat?A.slice(1,A.length-1):A.slice(2);for(let A=0;A<I.length;++A){const t=dd(I[A],this.kernelSize[A],this.padding,this.strides[A],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[A]);g.push(t)}let t=[A[0]];return"channelsLast"===this.dataFormat?(t=t.concat(g),t.push(this.filters)):(t.push(this.filters),t=t.concat(g)),t}getConfig(){const A={filters:this.filters,kernelInitializer:DD(this.kernelInitializer),kernelRegularizer:nd(this.kernelRegularizer),kernelConstraint:_D(this.kernelConstraint)},g=super.getConfig();return Object.assign(A,g),A}static verifyArgs(A){if(!("filters"in A)||"number"!=typeof A.filters||A.filters<1)throw new qc(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(A.filters)}`)}}class kd extends md{constructor(A){super(2,A),kd.verifyArgs(A)}getConfig(){const A=super.getConfig();return delete A.rank,A}static verifyArgs(A){if("number"!=typeof A.kernelSize&&!Bl(A.kernelSize,"number",1,2))throw new qc(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(A.kernelSize)}.`)}}kd.className="Conv2D",uQ(kd);class Sd extends md{constructor(A){super(3,A),Sd.verifyArgs(A)}getConfig(){const A=super.getConfig();return delete A.rank,A}static verifyArgs(A){if("number"!=typeof A.kernelSize&&(!Array.isArray(A.kernelSize)||1!==A.kernelSize.length&&3!==A.kernelSize.length))throw new qc(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(A.kernelSize)}.`)}}Sd.className="Conv3D",uQ(Sd);class Md extends kd{constructor(A){if(super(A),this.inputSpec=[new mD({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new qc(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(A){if(4!==(A=yD(A)).length)throw new qc("Input should have rank 4; Received input shape: "+JSON.stringify(A));const g="channelsFirst"===this.dataFormat?1:A.length-1;if(null==A[g])throw new qc("The channel dimension of the inputs should be defined. Found `None`.");const I=A[g],t=this.kernelSize.concat([this.filters,I]);this.kernel=this.addWeight("kernel",t,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new mD({ndim:4,axes:{[g]:I}})],this.built=!0}call(A,g){return wi((()=>{let g=pD(A);if(4!==g.shape.length)throw new qc(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${g.shape.length}`);const I=g.shape,t=I[0];let C,e;"channelsFirst"===this.dataFormat?(C=2,e=3):(C=1,e=2);const B=I[C],i=I[e],Q=this.kernelSize[0],o=this.kernelSize[1],E=this.strides[0],n=this.strides[1],s=[t,pd(B,E,Q,this.padding),pd(i,n,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(g=Yi(g,[0,2,3,1]));let a=QE(g,this.kernel.read(),s,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(a=Yi(a,[0,3,1,2])),null!=this.bias&&(a=Xl(a,this.bias.read(),this.dataFormat)),null!=this.activation&&(a=this.activation.apply(a)),a}))}computeOutputShape(A){const g=(A=yD(A)).slice();let I,t,C;"channelsFirst"===this.dataFormat?(I=1,t=2,C=3):(I=3,t=1,C=2);const e=this.kernelSize[0],B=this.kernelSize[1],i=this.strides[0],Q=this.strides[1];return g[I]=this.filters,g[t]=pd(g[t],i,e,this.padding),g[C]=pd(g[C],Q,B,this.padding),g}getConfig(){const A=super.getConfig();return delete A.dilationRate,A}}Md.className="Conv2DTranspose",uQ(Md);class Ud extends Sd{constructor(A){if(super(A),this.inputSpec=[new mD({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new qc(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(A){if(5!==(A=yD(A)).length)throw new qc("Input should have rank 5; Received input shape: "+JSON.stringify(A));const g="channelsFirst"===this.dataFormat?1:A.length-1;if(null==A[g])throw new qc("The channel dimension of the inputs should be defined. Found `None`.");const I=A[g],t=this.kernelSize.concat([this.filters,I]);this.kernel=this.addWeight("kernel",t,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new mD({ndim:5,axes:{[g]:I}})],this.built=!0}call(A,g){return wi((()=>{let g=pD(A);if(5!==g.shape.length)throw new qc(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${g.shape.length}`);const I=g.shape,t=I[0];let C,e,B;"channelsFirst"===this.dataFormat?(B=2,C=3,e=4):(B=1,C=2,e=3);const i=I[B],Q=I[C],o=I[e],E=this.kernelSize[0],n=this.kernelSize[1],s=this.kernelSize[2],a=this.strides[0],r=this.strides[1],h=this.strides[2],c=[t,pd(i,a,E,this.padding),pd(Q,r,n,this.padding),pd(o,h,s,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(g=Yi(g,[0,2,3,4,1]));let l=nE(g,this.kernel.read(),c,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(l=Yi(l,[0,4,1,2,3])),null!==this.bias&&(l=Xl(l,this.bias.read(),this.dataFormat)),null!==this.activation&&(l=this.activation.apply(l)),l}))}computeOutputShape(A){const g=(A=yD(A)).slice();let I,t,C,e;"channelsFirst"===this.dataFormat?(I=1,t=2,C=3,e=4):(I=4,t=1,C=2,e=3);const B=this.kernelSize[0],i=this.kernelSize[1],Q=this.kernelSize[2],o=this.strides[0],E=this.strides[1],n=this.strides[2];return g[I]=this.filters,g[t]=pd(g[t],o,B,this.padding),g[C]=pd(g[C],E,i,this.padding),g[e]=pd(g[e],n,Q,this.padding),g}getConfig(){const A=super.getConfig();return delete A.dilationRate,A}}Ud.className="Conv3DTranspose",uQ(Ud);class Kd extends md{constructor(A,g){if(super(A,g),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==g.filters)throw new qc("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=g.kernelInitializer||null!=g.kernelRegularizer||null!=g.kernelConstraint)throw new qc("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=g.padding&&"same"!==g.padding&&"valid"!==g.padding)throw new qc(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(g.padding)}`);this.depthMultiplier=null==g.depthMultiplier?1:g.depthMultiplier,this.depthwiseInitializer=uD(g.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ad(g.depthwiseRegularizer),this.depthwiseConstraint=Au(g.depthwiseConstraint),this.pointwiseInitializer=uD(g.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ad(g.pointwiseRegularizer),this.pointwiseConstraint=Au(g.pointwiseConstraint)}build(A){if((A=yD(A)).length<this.rank+2)throw new qc(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(A)}`);const g="channelsFirst"===this.dataFormat?1:A.length-1;if(null==A[g]||A[g]<0)throw new qc(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(A[g])}`);const I=A[g],t=this.kernelSize.concat([I,this.depthMultiplier]),C=[];for(let A=0;A<this.rank;++A)C.push(1);C.push(I*this.depthMultiplier,this.filters);const e=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",t,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,e,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",C,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,e,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,e,this.biasConstraint):this.bias=null,this.inputSpec=[new mD({ndim:this.rank+2,axes:{[g]:I}})],this.built=!0}call(A,g){return wi((()=>{let g;if(A=pD(A),1===this.rank)throw new Tc("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(A=Yi(A,[0,2,3,1])),g=as(A,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(g=Xl(g,this.bias.read(),this.dataFormat)),null!=this.activation&&(g=this.activation.apply(g)),"channelsFirst"===this.dataFormat&&(g=Yi(g,[0,3,1,2])),g}))}getConfig(){const A=super.getConfig();return delete A.rank,delete A.kernelInitializer,delete A.kernelRegularizer,delete A.kernelConstraint,A.depthwiseInitializer=DD(this.depthwiseInitializer),A.pointwiseInitializer=DD(this.pointwiseInitializer),A.depthwiseRegularizer=nd(this.depthwiseRegularizer),A.pointwiseRegularizer=nd(this.pointwiseRegularizer),A.depthwiseConstraint=_D(this.depthwiseConstraint),A.pointwiseConstraint=_D(this.pointwiseConstraint),A}}Kd.className="SeparableConv";class Jd extends Kd{constructor(A){super(2,A)}}Jd.className="SeparableConv2D",uQ(Jd);class Yd extends md{constructor(A){super(1,A),Yd.verifyArgs(A),this.inputSpec=[{ndim:3}]}getConfig(){const A=super.getConfig();return delete A.rank,delete A.dataFormat,A}static verifyArgs(A){if("number"!=typeof A.kernelSize&&!Bl(A.kernelSize,"number",1,1))throw new qc(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(A.kernelSize)}.`)}}Yd.className="Conv1D",uQ(Yd);class Ld extends KD{constructor(A){super(A),"number"==typeof A.cropping?this.cropping=[[A.cropping,A.cropping],[A.cropping,A.cropping]]:"number"==typeof A.cropping[0]?this.cropping=[[A.cropping[0],A.cropping[0]],[A.cropping[1],A.cropping[1]]]:this.cropping=A.cropping,this.dataFormat=void 0===A.dataFormat?"channelsLast":A.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(A){return"channelsFirst"===this.dataFormat?[A[0],A[1],A[2]-this.cropping[0][0]-this.cropping[0][1],A[3]-this.cropping[1][0]-this.cropping[1][1]]:[A[0],A[1]-this.cropping[0][0]-this.cropping[0][1],A[2]-this.cropping[1][0]-this.cropping[1][1],A[3]]}call(A,g){return wi((()=>{if(A=pD(A),"channelsLast"===this.dataFormat){const g=Hl(A,this.cropping[0][0],A.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Hl(g,this.cropping[1][0],A.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const g=Hl(A,this.cropping[0][0],A.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Hl(g,this.cropping[1][0],A.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const A={cropping:this.cropping,dataFormat:this.dataFormat},g=super.getConfig();return Object.assign(A,g),A}}Ld.className="Cropping2D",uQ(Ld);class xd extends KD{constructor(A){var g;super(A),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==A.size?this.DEFAULT_SIZE:A.size,this.dataFormat=null==A.dataFormat?"channelsLast":A.dataFormat,wl(this.dataFormat),this.interpolation=null==A.interpolation?"nearest":A.interpolation,g=this.interpolation,el(hl,"InterpolationFormat",g)}computeOutputShape(A){if("channelsFirst"===this.dataFormat){const g=null==A[2]?null:this.size[0]*A[2],I=null==A[3]?null:this.size[1]*A[3];return[A[0],A[1],g,I]}{const g=null==A[1]?null:this.size[0]*A[1],I=null==A[2]?null:this.size[1]*A[2];return[A[0],g,I,A[3]]}}call(A,g){return wi((()=>{let g=pD(A);const I=g.shape;if("channelsFirst"===this.dataFormat){g=Yi(g,[0,2,3,1]);const A=this.size[0]*I[2],t=this.size[1]*I[3],C="nearest"===this.interpolation?Er.resizeNearestNeighbor(g,[A,t]):Er.resizeBilinear(g,[A,t]);return Yi(C,[0,3,1,2])}{const A=this.size[0]*I[1],t=this.size[1]*I[2];return"nearest"===this.interpolation?Er.resizeNearestNeighbor(g,[A,t]):Er.resizeBilinear(g,[A,t])}}))}getConfig(){const A={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},g=super.getConfig();return Object.assign(A,g),A}}xd.className="UpSampling2D",uQ(xd);class bd extends Rd{constructor(A){super(2,A),this.depthwiseKernel=null,this.depthMultiplier=null==A.depthMultiplier?1:A.depthMultiplier,this.depthwiseInitializer=uD(A.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Au(A.depthwiseConstraint),this.depthwiseRegularizer=ad(A.depthwiseRegularizer)}build(A){if((A=yD(A)).length<4)throw new qc(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(A)}.`);const g="channelsFirst"===this.dataFormat?1:3;if(null==A[g]||A[g]<0)throw new qc(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${A[g]}).`);const I=A[g],t=[this.kernelSize[0],this.kernelSize[1],I,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",t,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[I*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(A,g){return wi((()=>{let g=function(A,g,I=[1,1],t="valid",C,e){return wi((()=>{null==C&&(C="channelsLast"),wl(C);let B=yd(A,C);if(4!==A.rank)throw new qc(`Input for depthwiseConv2d is required to be 4-D, but is instead ${A.rank}-D`);if(4!==g.rank)throw new qc(`depthwiseKernel is required to be 4-D, but is instead ${g.rank}-D`);return B=DE(B,g,I,"same"===t?"same":"valid","NHWC",e),"channelsFirst"===C&&(B=Yi(B,[0,3,1,2])),B}))}(A=pD(A),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(g=Xl(g,this.bias.read(),this.dataFormat)),null!=this.activation&&(g=this.activation.apply(g)),g}))}computeOutputShape(A){A=yD(A);const g="channelsFirst"===this.dataFormat?A[2]:A[1],I="channelsFirst"===this.dataFormat?A[3]:A[2],t="channelsFirst"===this.dataFormat?A[1]*this.depthMultiplier:A[3]*this.depthMultiplier,C=dd(g,this.kernelSize[0],this.padding,this.strides[0]),e=dd(I,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[A[0],t,C,e]:[A[0],C,e,t]}getConfig(){const A=super.getConfig();return A.depthMultiplier=this.depthMultiplier,A.depthwiseInitializer=DD(this.depthwiseInitializer),A.depthwiseRegularizer=nd(this.depthwiseRegularizer),A.depthwiseConstraint=_D(this.depthwiseRegularizer),A}}function Hd(A,g,I,t){if(Array.isArray(A)){if(null!=g||null!=I)throw new qc("When inputs is an array, neither initialState or constants should be provided");null!=t&&(I=A.slice(A.length-t,A.length),A=A.slice(0,A.length-t)),A.length>1&&(g=A.slice(1,A.length)),A=A[0]}function C(A){return null==A||Array.isArray(A)?A:[A]}return{inputs:A,initialState:g=C(g),constants:I=C(I)}}function qd(A,g,I,t=!1,C,e,B=!1,i=!1){return wi((()=>{const Q=g.shape.length;if(Q<3)throw new qc(`Input should be at least 3D, but is ${Q}D.`);const o=[1,0].concat(Ul(2,Q));if(g=Yi(g,o),null!=e)throw new Tc("The rnn() functoin of the deeplearn.js backend does not support constants yet.");B&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=C&&((C=qB(qB(C,"bool"),"float32")).rank===Q-1&&(C=vE(C,-1)),C=Yi(C,o)),t&&(g=es(g,0),null!=C&&(C=es(C,0)));const E=[];let n,s=I;const a=g.shape[0],r=vs(g);let h,c;null!=C&&(h=vs(C));for(let g=0;g<a;++g){const I=r[g],t=wi((()=>A(I,s)));if(null==C)n=t[0],s=t[1];else{const A=wi((()=>{const A=h[g],I=go(Un(A),A);return{output:JQ(xQ(t[0],A),xQ(s[0],I)),newStates:s.map(((g,C)=>JQ(xQ(t[1][C],A),xQ(g,I))))}}));n=A.output,s=A.newStates}i&&E.push(n)}if(i){c=ks(E,1)}return[n,c,s]}))}bd.className="DepthwiseConv2D",uQ(bd);class Td extends KD{constructor(A){let g;if(super(A),null==A.cell)throw new qc("cell property is missing for the constructor of RNN.");if(g=Array.isArray(A.cell)?new jd({cells:A.cell}):A.cell,null==g.stateSize)throw new qc("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=g,this.returnSequences=null!=A.returnSequences&&A.returnSequences,this.returnState=null!=A.returnState&&A.returnState,this.goBackwards=null!=A.goBackwards&&A.goBackwards,this._stateful=null!=A.stateful&&A.stateful,this.unroll=null!=A.unroll&&A.unroll,this.supportsMasking=!0,this.inputSpec=[new mD({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return Ul(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((A=>null))}return this.states_}setStates(A){this.states_=A}computeOutputShape(A){wD(A)&&(A=A[0]);let g=this.cell.stateSize;Array.isArray(g)||(g=[g]);const I=g[0];let t;if(t=this.returnSequences?[A[0],A[1],I]:[A[0],I],this.returnState){const I=[];for(const t of g)I.push([A[0],t]);return[t].concat(I)}return t}computeMask(A,g){return wi((()=>{Array.isArray(g)&&(g=g[0]);const A=this.returnSequences?g:null;if(this.returnState){const g=this.states.map((A=>null));return[A].concat(g)}return A}))}get states(){if(null==this.states_){const A=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,g=[];for(let I=0;I<A;++I)g.push(null);return g}return this.states_}set states(A){this.states_=A}build(A){if(null!=this.numConstants)throw new Tc("Constants support is not implemented in RNN yet.");wD(A)&&(A=A[0]);const g=this.stateful?A[0]:null,I=A.slice(2);this.inputSpec[0]=new mD({shape:[g,null,...I]});const t=[A[0]].concat(A.slice(2));let C;if(this.cell.build(t),C=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!EA(this.stateSpec.map((A=>A.shape[A.shape.length-1])),C))throw new qc(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=C.map((A=>new mD({shape:[null,A]})));this.stateful&&this.resetStates()}resetStates(A,g=!1){wi((()=>{if(!this.stateful)throw new bc("Cannot call resetStates() on an RNN Layer that is not stateful.");const I=this.inputSpec[0].shape[0];if(null==I)throw new qc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((A=>yn([I,A]))):this.states_=[yn([I,this.cell.stateSize])];else if(null==A)di(this.states_),null!=this.keptStates&&(di(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((A=>yn([I,A]))):this.states_[0]=yn([I,this.cell.stateSize]);else{if(Array.isArray(A)||(A=[A]),A.length!==this.states_.length)throw new qc(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${A.length} state value(s). Input received: ${A}`);!0===g?this.keptStates.push(this.states_.slice()):di(this.states_);for(let g=0;g<this.states_.length;++g){const t=A[g],C=Array.isArray(this.cell.stateSize)?this.cell.stateSize[g]:this.cell.stateSize,e=[I,C];if(!EA(t.shape,e))throw new qc(`State ${g} is incompatible with layer ${this.name}: expected shape=${e}, received shape=${t.shape}`);this.states_[g]=t}}this.states_=this.states_.map((A=>pi(A.clone())))}))}apply(A,g){let I=null==g?null:g.initialState,t=null==g?null:g.constants;null==g&&(g={});const C=Hd(A,I,t,this.numConstants);A=C.inputs,I=C.initialState,t=C.constants;let e=[],B=[];if(null!=I){g.initialState=I,e=e.concat(I),this.stateSpec=[];for(const A of I)this.stateSpec.push(new mD({shape:A.shape}));B=B.concat(this.stateSpec)}null!=t&&(g.constants=t,e=e.concat(t),this.numConstants=t.length);if(e[0]instanceof kD){const I=[A].concat(e),t=this.inputSpec.concat(B),C=this.inputSpec;this.inputSpec=t;const i=super.apply(I,g);return this.inputSpec=C,i}return super.apply(A,g)}call(A,g){return wi((()=>{const I=null==g?null:g.mask,t=null==g?null:g.training;let C=null==g?null:g.initialState;A=pD(A),null==C&&(C=this.stateful?this.states_:this.getInitialState(A));const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(C.length!==e)throw new qc(`RNN Layer has ${e} state(s) but was passed ${C.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const B={training:t},i=qd(((A,g)=>{const I=this.cell.call([A].concat(g),B);return[I[0],I.slice(1)]}),A,C,this.goBackwards,I,null,this.unroll,this.returnSequences),Q=i[0],o=i[1],E=i[2];this.stateful&&this.resetStates(E,t);const n=this.returnSequences?o:Q;return this.returnState?[n].concat(E):n}))}getInitialState(A){return wi((()=>{let g=yn(A.shape);return g=xE(g,[1,2]),g=Ll(g),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((A=>A>1?vl(g,[1,A]):g)):this.cell.stateSize>1?[vl(g,[1,this.cell.stateSize])]:[g]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(A){super.setFastWeightInitDuringBuild(A),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(A)}getConfig(){const A=super.getConfig(),g={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(g.numConstants=this.numConstants);const I=this.cell.getConfig();return this.getClassName()===Td.className&&(g.cell={className:this.cell.getClassName(),config:I}),Object.assign({},I,A,g)}static fromConfig(A,g,I={}){const t=Su(g.cell,I);return new A(Object.assign(g,{cell:t}))}}Td.className="RNN",uQ(Td);class vd extends KD{}class Vd extends vd{constructor(A){super(A),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=A.units,il(this.units,"units"),this.activation=Bd(null==A.activation?this.DEFAULT_ACTIVATION:A.activation),this.useBias=null==A.useBias||A.useBias,this.kernelInitializer=uD(A.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=uD(A.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=uD(A.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ad(A.kernelRegularizer),this.recurrentRegularizer=ad(A.recurrentRegularizer),this.biasRegularizer=ad(A.biasRegularizer),this.kernelConstraint=Au(A.kernelConstraint),this.recurrentConstraint=Au(A.recurrentConstraint),this.biasConstraint=Au(A.biasConstraint),this.dropout=Sl([1,Ml([0,null==A.dropout?0:A.dropout])]),this.recurrentDropout=Sl([1,Ml([0,null==A.recurrentDropout?0:A.recurrentDropout])]),this.dropoutFunc=A.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(A){A=yD(A),this.kernel=this.addWeight("kernel",[A[A.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(A,g){return wi((()=>{if(2!==A.length)throw new qc(`SimpleRNNCell expects 2 input Tensors, got ${A.length}.`);let I=A[1];A=A[0];const t=null!=g.training&&g.training;let C;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zd({ones:()=>Un(A),rate:this.dropout,training:t,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zd({ones:()=>Un(I),rate:this.recurrentDropout,training:t,dropoutFunc:this.dropoutFunc}));const e=this.dropoutMask,B=this.recurrentDropoutMask;C=Wl(null!=e?xQ(A,e):A,this.kernel.read()),null!=this.bias&&(C=Xl(C,this.bias.read())),null!=B&&(I=xQ(I,B));let i=JQ(C,Wl(I,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const A=super.getConfig(),g={units:this.units,activation:Cd(this.activation),useBias:this.useBias,kernelInitializer:DD(this.kernelInitializer),recurrentInitializer:DD(this.recurrentInitializer),biasInitializer:DD(this.biasInitializer),kernelRegularizer:nd(this.kernelRegularizer),recurrentRegularizer:nd(this.recurrentRegularizer),biasRegularizer:nd(this.biasRegularizer),activityRegularizer:nd(this.activityRegularizer),kernelConstraint:_D(this.kernelConstraint),recurrentConstraint:_D(this.recurrentConstraint),biasConstraint:_D(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},A,g)}}Vd.className="SimpleRNNCell",uQ(Vd);class Wd extends Td{constructor(A){A.cell=new Vd(A),super(A)}call(A,g){return wi((()=>{null!=this.cell.dropoutMask&&(di(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(di(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const I=null==g?null:g.mask,t=null==g?null:g.training,C=null==g?null:g.initialState;return super.call(A,{mask:I,training:t,initialState:C})}))}static fromConfig(A,g){return new A(g)}}Wd.className="SimpleRNN",uQ(Wd);class Od extends vd{constructor(A){if(super(A),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",A.resetAfter)throw new qc("GRUCell does not support reset_after parameter set to true.");this.units=A.units,il(this.units,"units"),this.activation=Bd(void 0===A.activation?this.DEFAULT_ACTIVATION:A.activation),this.recurrentActivation=Bd(void 0===A.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:A.recurrentActivation),this.useBias=null==A.useBias||A.useBias,this.kernelInitializer=uD(A.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=uD(A.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=uD(A.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ad(A.kernelRegularizer),this.recurrentRegularizer=ad(A.recurrentRegularizer),this.biasRegularizer=ad(A.biasRegularizer),this.kernelConstraint=Au(A.kernelConstraint),this.recurrentConstraint=Au(A.recurrentConstraint),this.biasConstraint=Au(A.biasConstraint),this.dropout=Sl([1,Ml([0,null==A.dropout?0:A.dropout])]),this.recurrentDropout=Sl([1,Ml([0,null==A.recurrentDropout?0:A.recurrentDropout])]),this.dropoutFunc=A.dropoutFunc,this.implementation=A.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(A){const g=(A=yD(A))[A.length-1];this.kernel=this.addWeight("kernel",[g,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(A,g){return wi((()=>{if(2!==A.length)throw new qc(`GRUCell expects 2 input Tensors (inputs, h, c), got ${A.length}.`);const I=null!=g.training&&g.training;let t=A[1];A=A[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zd({ones:()=>Un(A),rate:this.dropout,training:I,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zd({ones:()=>Un(t),rate:this.recurrentDropout,training:I,count:3,dropoutFunc:this.dropoutFunc}));const C=this.dropoutMask,e=this.recurrentDropoutMask;let B,i,Q;0<this.dropout&&this.dropout<1&&(A=xQ(A,C[0]));let o=Wl(A,this.kernel.read());this.useBias&&(o=Xl(o,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(t=xQ(t,e[0]));const E=this.recurrentKernel.read(),[n,s]=Ns(E,[2*this.units,this.units],E.rank-1),a=Wl(t,n),[r,h,c]=Ns(o,3,o.rank-1),[l,D]=Ns(a,2,a.rank-1);B=this.recurrentActivation.apply(JQ(r,l)),i=this.recurrentActivation.apply(JQ(h,D));const u=Wl(xQ(i,t),s);Q=this.activation.apply(JQ(c,u));const w=JQ(xQ(B,t),xQ(JQ(1,Ki(B)),Q));return[w,w]}))}getConfig(){const A=super.getConfig(),g={units:this.units,activation:Cd(this.activation),recurrentActivation:Cd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:DD(this.kernelInitializer),recurrentInitializer:DD(this.recurrentInitializer),biasInitializer:DD(this.biasInitializer),kernelRegularizer:nd(this.kernelRegularizer),recurrentRegularizer:nd(this.recurrentRegularizer),biasRegularizer:nd(this.biasRegularizer),activityRegularizer:nd(this.activityRegularizer),kernelConstraint:_D(this.kernelConstraint),recurrentConstraint:_D(this.recurrentConstraint),biasConstraint:_D(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},A,g)}}Od.className="GRUCell",uQ(Od);class Zd extends Td{constructor(A){0===A.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),A.cell=new Od(A),super(A)}call(A,g){return wi((()=>{null!=this.cell.dropoutMask&&(di(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(di(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const I=null==g?null:g.mask,t=null==g?null:g.training,C=null==g?null:g.initialState;return super.call(A,{mask:I,training:t,initialState:C})}))}static fromConfig(A,g){return 0===g.implmentation&&(g.implementation=1),new A(g)}}Zd.className="GRU",uQ(Zd);class Pd extends vd{constructor(A){super(A),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=A.units,il(this.units,"units"),this.activation=Bd(void 0===A.activation?this.DEFAULT_ACTIVATION:A.activation),this.recurrentActivation=Bd(void 0===A.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:A.recurrentActivation),this.useBias=null==A.useBias||A.useBias,this.kernelInitializer=uD(A.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=uD(A.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=uD(A.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=A.unitForgetBias,this.kernelRegularizer=ad(A.kernelRegularizer),this.recurrentRegularizer=ad(A.recurrentRegularizer),this.biasRegularizer=ad(A.biasRegularizer),this.kernelConstraint=Au(A.kernelConstraint),this.recurrentConstraint=Au(A.recurrentConstraint),this.biasConstraint=Au(A.biasConstraint),this.dropout=Sl([1,Ml([0,null==A.dropout?0:A.dropout])]),this.recurrentDropout=Sl([1,Ml([0,null==A.recurrentDropout?0:A.recurrentDropout])]),this.dropoutFunc=A.dropoutFunc,this.implementation=A.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(A){var g;const I=(A=yD(A))[A.length-1];let t;if(this.kernel=this.addWeight("kernel",[I,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const A=this.biasInitializer,I=this.units;t=new((g=class extends AD{apply(g,t){const C=A.apply([I]),e=(new ID).apply([I]),B=A.apply([2*I]);return Tl(Tl(C,e),B)}}).className="CustomInit",g)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,t,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(A,g){return wi((()=>{const I=null!=g.training&&g.training;if(3!==A.length)throw new qc(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${A.length}.`);let t=A[1];const C=A[2];A=A[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zd({ones:()=>Un(A),rate:this.dropout,training:I,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zd({ones:()=>Un(t),rate:this.recurrentDropout,training:I,count:4,dropoutFunc:this.dropoutFunc}));const e=this.dropoutMask,B=this.recurrentDropoutMask;let i,Q,o,E;0<this.dropout&&this.dropout<1&&(A=xQ(A,e[0]));let n=Wl(A,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(t=xQ(t,B[0])),n=JQ(n,Wl(t,this.recurrentKernel.read())),this.useBias&&(n=Xl(n,this.bias.read()));const[s,a,r,h]=Ns(n,4,n.rank-1);i=this.recurrentActivation.apply(s),Q=this.recurrentActivation.apply(a),o=JQ(xQ(Q,C),xQ(i,this.activation.apply(r))),E=this.recurrentActivation.apply(h);const c=xQ(E,this.activation.apply(o));return[c,c,o]}))}getConfig(){const A=super.getConfig(),g={units:this.units,activation:Cd(this.activation),recurrentActivation:Cd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:DD(this.kernelInitializer),recurrentInitializer:DD(this.recurrentInitializer),biasInitializer:DD(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:nd(this.kernelRegularizer),recurrentRegularizer:nd(this.recurrentRegularizer),biasRegularizer:nd(this.biasRegularizer),activityRegularizer:nd(this.activityRegularizer),kernelConstraint:_D(this.kernelConstraint),recurrentConstraint:_D(this.recurrentConstraint),biasConstraint:_D(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},A,g)}}Pd.className="LSTMCell",uQ(Pd);class Xd extends Td{constructor(A){0===A.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),A.cell=new Pd(A),super(A)}call(A,g){return wi((()=>{null!=this.cell.dropoutMask&&(di(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(di(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const I=null==g?null:g.mask,t=null==g?null:g.training,C=null==g?null:g.initialState;return super.call(A,{mask:I,training:t,initialState:C})}))}static fromConfig(A,g){return 0===g.implmentation&&(g.implementation=1),new A(g)}}Xd.className="LSTM",uQ(Xd);class jd extends vd{constructor(A){super(A),this.cells=A.cells}get stateSize(){const A=[];for(const g of this.cells.slice().reverse())Array.isArray(g.stateSize)?A.push(...g.stateSize):A.push(g.stateSize);return A}call(A,g){return wi((()=>{let I=A.slice(1);const t=[];for(const A of this.cells.slice().reverse())Array.isArray(A.stateSize)?t.push(I.splice(0,A.stateSize.length)):t.push(I.splice(0,1));t.reverse();const C=[];let e;for(let B=0;B<this.cells.length;++B){const i=this.cells[B];I=t[B],e=0===B?[A[0]].concat(I):[e[0]].concat(I),e=i.call(e,g),C.push(e.slice(1))}I=[];for(const A of C.slice().reverse())I.push(...A);return[e[0]].concat(I)}))}build(A){let g;wD(A)&&(A=A[0]),this.cells.forEach(((I,t)=>{fl(`RNNCell_${t}`,(()=>{I.build(A),g=Array.isArray(I.stateSize)?I.stateSize[0]:I.stateSize,A=[A[0],g]}))})),this.built=!0}getConfig(){const A=super.getConfig(),g={cells:this.cells.map((A=>({className:A.getClassName(),config:A.getConfig()})))};return Object.assign({},A,g)}static fromConfig(A,g,I={}){const t=[];for(const A of g.cells)t.push(Su(A,I));return new A({cells:t})}get trainableWeights(){if(!this.trainable)return[];const A=[];for(const g of this.cells)A.push(...g.trainableWeights);return A}get nonTrainableWeights(){const A=[];for(const g of this.cells)A.push(...g.nonTrainableWeights);if(!this.trainable){const g=[];for(const A of this.cells)g.push(...A.trainableWeights);return g.concat(A)}return A}getWeights(){const A=[];for(const g of this.cells)A.push(...g.weights);return FD(A)}setWeights(A){const g=[];for(const I of this.cells){const t=I.weights.length,C=A.splice(t);for(let A=0;A<I.weights.length;++A)g.push([I.weights[A],C[A]])}RD(g)}}function zd(A){const{ones:g,rate:I,training:t=!1,count:C=1,dropoutFunc:e}=A,B=()=>null!=e?e(g(),I):jl(g(),I),i=()=>zl(B,g,t);if(!C||C<=1)return pi(i().clone());return Array(C).fill(void 0).map(i).map((A=>pi(A.clone())))}jd.className="StackedRNNCells",uQ(jd);var _d=function(A,g){var I={};for(var t in A)Object.prototype.hasOwnProperty.call(A,t)&&g.indexOf(t)<0&&(I[t]=A[t]);if(null!=A&&"function"==typeof Object.getOwnPropertySymbols){var C=0;for(t=Object.getOwnPropertySymbols(A);C<t.length;C++)g.indexOf(t[C])<0&&Object.prototype.propertyIsEnumerable.call(A,t[C])&&(I[t[C]]=A[t[C]])}return I};class $d extends Td{constructor(A){if(A.unroll)throw new Tc("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(A.cell))throw new Tc("It is not possible at the moment to stack convolutional cells.");super(A),this.inputSpec=[new mD({ndim:5})]}call(A,g){return wi((()=>{if(null!=this.cell.dropoutMask&&(di(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(di(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),g&&g.constants)throw new qc("ConvRNN2D cell does not support constants");const I=null==g?null:g.mask,t=null==g?null:g.training,C=null==g?null:g.initialState;return super.call(A,{mask:I,training:t,initialState:C})}))}computeOutputShape(A){let g=this.computeSingleOutputShape(A);return this.returnSequences||(g=[g[0],...g.slice(2)]),this.returnState&&(g=[g,...Array(2).fill([A[0],...g.slice(-3)])]),g}getInitialState(A){return wi((()=>{const{stateSize:g}=this.cell,I=A.shape,t=this.computeSingleOutputShape(I),C=yn([t[0],...t.slice(2)]);return Array.isArray(g)?Array(g.length).fill(C):[C]}))}resetStates(A,g=!1){wi((()=>{if(!this.stateful)throw new bc("Cannot call resetStates() on an RNN Layer that is not stateful.");const I=this.inputSpec[0].shape,t=this.computeSingleOutputShape(I),C=[t[0],...t.slice(2)];if(null==I[0])throw new qc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>yn(C))):this.states_=[yn(C)];else if(null==A)di(this.states_),null!=this.keptStates&&(di(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>yn(C))):this.states_[0]=yn(C);else{if(Array.isArray(A)||(A=[A]),A.length!==this.states_.length)throw new qc(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${A.length} state value(s). Input received: ${A}`);g?this.keptStates.push(this.states_.slice()):di(this.states_);for(let g=0;g<this.states_.length;++g){const I=A[g],t=C;if(!EA(I.shape,t))throw new qc(`State ${g} is incompatible with layer ${this.name}: expected shape=${t}, received shape=${I.shape}`);this.states_[g]=I}}this.states_=this.states_.map((A=>pi(A.clone())))}))}computeSingleOutputShape(A){const{dataFormat:g,filters:I,kernelSize:t,padding:C,strides:e,dilationRate:B}=this.cell,i="channelsFirst"===g,Q=A[i?3:2],o=A[i?4:3],E=dd(Q,t[0],C,e[0],B[0]),n=dd(o,t[1],C,e[1],B[1]);return[...A.slice(0,2),...i?[I,E,n]:[E,n,I]]}}$d.className="ConvRNN2D";class Ap extends Pd{constructor(A){const{filters:g,kernelSize:I,strides:t,padding:C,dataFormat:e,dilationRate:B}=A;super(Object.assign({},A,{units:g})),this.filters=g,il(this.filters,"filters"),this.kernelSize=wd(I,2,"kernelSize"),this.kernelSize.forEach((A=>il(A,"kernelSize"))),this.strides=wd(t||1,2,"strides"),this.strides.forEach((A=>il(A,"strides"))),this.padding=C||"valid",dl(this.padding),this.dataFormat=e||"channelsLast",wl(this.dataFormat),this.dilationRate=wd(B||1,2,"dilationRate"),this.dilationRate.forEach((A=>il(A,"dilationRate")))}build(A){var g;A=yD(A);const I="channelsFirst"===this.dataFormat?1:A.length-1;if(null==A[I])throw new qc(`The channel dimension of the input should be defined. Found ${A[I]}`);const t=A[I],C=this.kernelSize.concat([t,4*this.filters]);this.kernel=this.addWeight("kernel",C,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const e=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",e,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let A;if(this.unitForgetBias){const I=this.biasInitializer,t=this.filters;A=new((g=class extends AD{apply(A,g){return ql([I.apply([t]),Gn([t]),I.apply([2*t])])}}).className="CustomInit",g)}else A=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,A,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(A,g){return wi((()=>{if(3!==A.length)throw new qc(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${A.length}.`);const I=g.training||!1,t=A[0],C=A[1],e=A[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zd({ones:()=>Un(t),rate:this.dropout,training:I,count:4,dropoutFunc:this.dropoutFunc}));const B=this.dropoutMask,i=(A,g,I)=>g&&g[I]?xQ(g[I],A):A;let Q=i(t,B,0),o=i(t,B,1),E=i(t,B,2),n=i(t,B,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zd({ones:()=>Un(C),rate:this.recurrentDropout,training:I,count:4,dropoutFunc:this.dropoutFunc}));const s=this.recurrentDropoutMask;let a=i(C,s,0),r=i(C,s,1),h=i(C,s,2),c=i(C,s,3);const[l,D,u,w]=Ns(this.kernel.read(),4,3),[d,p,y,G]=this.useBias?Ns(this.bias.read(),4):[null,null,null,null];Q=this.inputConv(Q,l,d,this.padding),o=this.inputConv(o,D,p,this.padding),E=this.inputConv(E,u,y,this.padding),n=this.inputConv(n,w,G,this.padding);const[f,N,F,R]=Ns(this.recurrentKernel.read(),4,3);a=this.recurrentConv(a,f),r=this.recurrentConv(r,N),h=this.recurrentConv(h,F),c=this.recurrentConv(c,R);const m=this.recurrentActivation.apply(JQ(Q,a)),k=this.recurrentActivation.apply(JQ(o,r)),S=JQ(xQ(k,e),xQ(m,this.activation.apply(JQ(E,h)))),M=xQ(this.recurrentActivation.apply(JQ(n,c)),this.activation.apply(S));return[M,M,S]}))}getConfig(){const A=super.getConfig(),{units:g}=A,I=_d(A,["units"]),t={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},I,t)}inputConv(A,g,I,t){const C=eE(A,g,this.strides,t||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return I?Xl(C,I,this.dataFormat):C}recurrentConv(A,g){return eE(A,g,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Ap.className="ConvLSTM2DCell",uQ(Ap);class gp extends $d{constructor(A){const g=new Ap(A);super(Object.assign({},A,{cell:g}))}static fromConfig(A,g){return new A(g)}}gp.className="ConvLSTM2D",uQ(gp);class Ip extends KD{constructor(A){super(A),this.rate=Math.max(Math.min(A.rate,1),0),this.noiseShape=A.noiseShape,this.seed=A.seed,this.supportsMasking=!0}getNoiseShape(A){if(null==this.noiseShape)return this.noiseShape;const g=A.shape,I=[];for(let A=0;A<this.noiseShape.length;++A)I.push(null==this.noiseShape[A]?g[A]:this.noiseShape[A]);return I}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A);if(0<this.rate&&this.rate<1){const A=null!=g.training&&g.training,t=this.getNoiseShape(I);return zl((()=>jl(I,this.rate,t,this.seed)),(()=>I),A)}return A}))}getConfig(){const A={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},g=super.getConfig();return Object.assign(A,g),A}dispose(){return super.dispose()}}Ip.className="Dropout",uQ(Ip);class tp extends Ip{constructor(A){super(A),this.inputSpec=[{ndim:3}]}getNoiseShape(A){const g=A.shape;return[g[0],1,g[2]]}}tp.className="SpatialDropout1D",uQ(tp);class Cp extends KD{constructor(A){if(super(A),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==A.batchInputShape&&null==A.inputShape&&null!=A.inputDim){let g=null;null!=A.batchSize&&(g=A.batchSize),this.batchInputShape=[g,A.inputDim]}this.units=A.units,il(this.units,"units"),this.activation=Bd(A.activation),null!=A.useBias&&(this.useBias=A.useBias),this.kernelInitializer=uD(A.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=uD(A.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Au(A.kernelConstraint),this.biasConstraint=Au(A.biasConstraint),this.kernelRegularizer=ad(A.kernelRegularizer),this.biasRegularizer=ad(A.biasRegularizer),this.activityRegularizer=ad(A.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(A){const g=(A=yD(A))[A.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[g,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:g}}],this.built=!0}computeOutputShape(A){const g=(A=yD(A)).slice();return g[g.length-1]=this.units,g}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A),t=ol(this.activation.getClassName());let C;return null!=t?C=Wl(I,this.kernel.read(),t,this.bias?this.bias.read():null):(C=Wl(I,this.kernel.read()),null!=this.bias&&(C=Xl(C,this.bias.read())),null!=this.activation&&(C=this.activation.apply(C))),C}))}getConfig(){const A={units:this.units,activation:Cd(this.activation),useBias:this.useBias,kernelInitializer:DD(this.kernelInitializer),biasInitializer:DD(this.biasInitializer),kernelRegularizer:nd(this.kernelRegularizer),biasRegularizer:nd(this.biasRegularizer),activityRegularizer:nd(this.activityRegularizer),kernelConstraint:_D(this.kernelConstraint),biasConstraint:_D(this.biasConstraint)},g=super.getConfig();return Object.assign(A,g),A}}Cp.className="Dense",uQ(Cp);class ep extends KD{constructor(A){super(A=A||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=A.dataFormat}computeOutputShape(A){A=yD(A);for(const g of A.slice(1))if(null==g)throw new qc(`The shape of the input to "Flatten" is not fully defined (got ${A.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[A[0],kl(A,1)]}call(A,g){return wi((()=>{this.invokeCallHook(A,g);let I=pD(A);if("channelsFirst"===this.dataFormat&&I.rank>1){const A=[0];for(let g=2;g<I.rank;++g)A.push(g);A.push(1),I=Yi(I,A)}return function(A){if(A.rank<=1)throw new qc(`batchFlatten requires a minimum rank of 2. Got rank: ${A.rank}.`);const g=[A.shape[0],kl(A.shape,1)];return Lo(A,g)}(I)}))}getConfig(){const A={};null!=this.dataFormat&&(A.dataFormat=this.dataFormat);const g=super.getConfig();return Object.assign(A,g),A}}ep.className="Flatten",uQ(ep);class Bp extends KD{constructor(A){super(A),this.supportsMasking=!0,this.activation=Bd(A.activation)}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A);return this.activation.apply(I)}))}getConfig(){const A={activation:Cd(this.activation)},g=super.getConfig();return Object.assign(A,g),A}}Bp.className="Activation",uQ(Bp);class ip extends KD{constructor(A){super(A),this.n=A.n,this.inputSpec=[{ndim:2}]}computeOutputShape(A){return[A[0],this.n,A[1]]}call(A,g){return wi((()=>{return A=pD(A),g=A,I=this.n,wi((()=>{if(2!==g.shape.length)throw new qc(`repeat() expects a rank-2 tensor, but received a rank-${g.shape.length} tensor.`);return vl(Ll(g,1),[1,I,1])}));var g,I}))}getConfig(){const A={n:this.n},g=super.getConfig();return Object.assign(A,g),A}}ip.className="RepeatVector",uQ(ip);class Qp extends KD{constructor(A){super(A),this.targetShape=A.targetShape;for(let A=0;A<this.targetShape.length;++A)this.isUnknown(this.targetShape[A])&&(this.targetShape[A]=null)}isUnknown(A){return A<0||null==A}fixUnknownDimension(A,g){const I="Total size of new array must be unchanged.",t=g.slice();let C=1,e=null;for(let A=0;A<t.length;++A){const g=t[A];if(this.isUnknown(g)){if(null!==e)throw new qc("Can only specifiy one unknown dimension.");e=A}else C*=g}const B=kl(A);if(null!==e){if(0===C||B%C!=0)throw new qc(I);t[e]=B/C}else if(B!==C)throw new qc(I);return t}computeOutputShape(A){let g=!1;for(let I=0;I<A.length;++I)if(this.isUnknown(A[I])){g=!0;break}return g?A.slice(0,1).concat(this.targetShape):A.slice(0,1).concat(this.fixUnknownDimension(A.slice(1),this.targetShape))}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A),t=I.shape,C=t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape));return Lo(I,C)}))}getConfig(){const A={targetShape:this.targetShape},g=super.getConfig();return Object.assign(A,g),A}}Qp.className="Reshape",uQ(Qp);class op extends KD{constructor(A){if(super(A),null==A.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(A.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${A.dims} instead.`);const g=Ul(1,A.dims.length+1);if(!EA(A.dims.slice().sort(),g))throw new Error("Invalid permutation `dims`: "+JSON.stringify(A.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=A.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new mD({ndim:this.dims.length+1})]}computeOutputShape(A){const g=(A=yD(A)).slice();return this.dims.forEach(((I,t)=>{g[t+1]=A[I]})),g}call(A,g){return Yi(pD(A),this.dimsIncludingBatch)}getConfig(){const A={dims:this.dims},g=super.getConfig();return Object.assign(A,g),A}}op.className="Permute",uQ(op);class Ep extends KD{constructor(A){super(null==A?{}:A),this.supportsMasking=!0,this.maskValue=null!=A?null==A.maskValue?0:A.maskValue:0}computeOutputShape(A){return A}getConfig(){const A=super.getConfig(),g={maskValue:this.maskValue};return Object.assign(g,A),g}computeMask(A,g){const I=pD(A);return ro(Mn(I,this.maskValue),-1)}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A),t=ro(Mn(I,this.maskValue),-1,!0);return xQ(I,qB(t,I.dtype))}))}}Ep.className="Masking",uQ(Ep);class np extends KD{constructor(A){if(super(A),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==A.batchInputShape&&null==A.inputShape){let g=null;null!=A.batchSize&&(g=A.batchSize),null==A.inputLength?this.batchInputShape=[g,null]:this.batchInputShape=[g].concat(Xc(A.inputLength))}this.inputDim=A.inputDim,il(this.inputDim,"inputDim"),this.outputDim=A.outputDim,il(this.outputDim,"outputDim"),this.embeddingsInitializer=uD(A.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ad(A.embeddingsRegularizer),this.activityRegularizer=ad(A.activityRegularizer),this.embeddingsConstraint=Au(A.embeddingsConstraint),this.maskZero=A.maskZero,this.supportsMasking=A.maskZero,this.inputLength=A.inputLength}build(A){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(A){}computeMask(A,g){return wi((()=>this.maskZero?(A=pD(A),Mn(A,qQ(A))):null))}computeOutputShape(A){if(A=yD(A),null==this.inputLength)return[...A,this.outputDim];const g=Xc(this.inputLength);if(g.length!==A.length-1)throw new qc(`"inputLength" is ${this.inputLength}, but received input shape has shape ${A}`);{let I=0;for(let t=0;t<g.length;++t){const C=g[t],e=A[t+1];if(null!=C&&null!=e&&C!==e)throw new qc(`"inputLength" is ${this.inputLength}, but received input shape has shape ${A}`);null==C&&(g[I]=e),I++}}return[A[0],...g,this.outputDim]}call(A,g){return wi((()=>{this.invokeCallHook(A,g);let I=pD(A);"int32"!==I.dtype&&(I=Yl(I,"int32"));const t=Ol(this.embeddings.read(),Lo(I,[I.size]));return Lo(t,yD(this.computeOutputShape(I.shape)))}))}getConfig(){const A={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:DD(this.embeddingsInitializer),embeddingsRegularizer:nd(this.embeddingsRegularizer),activityRegularizer:nd(this.activityRegularizer),embeddingsConstraint:_D(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},g=super.getConfig();return Object.assign(A,g),A}}np.className="Embedding",uQ(np);class sp extends KD{constructor(A){super(A||{}),this.supportsMasking=!0}mergeFunction(A){throw new Tc}computeElementwiseOpOutputShape(A,g){if(null==A||null==g)return null;if(A.length<g.length)return this.computeElementwiseOpOutputShape(g,A);if(0===g.length)return A;const I=A.slice(0,A.length-g.length);for(let t=0;t<g.length;++t){const C=A[A.length-g.length+t],e=g[t];if(null==C||null==e||C<0||e<0)I.push(null);else if(1===C)I.push(e);else if(1===e)I.push(C);else{if(C!==e)throw new qc("Operands could not be broadcast together with shapes "+JSON.stringify(A)+" "+JSON.stringify(g));I.push(C)}}return I}build(A){if(Array.isArray(A)&&!Array.isArray(A[0])&&(A=[yD(A)]),A.length<2)throw new qc(`A merge layer should be called on an Array of at least 2 inputs. Got ${A.length} input(s).`);let g=[];for(const I of A)null!=I&&null!==I[0]&&g.push(I[0]);if(g=tl(g),g.length>1)throw new qc(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(A)}.`);let I=null==A[0]?null:A[0].slice(1);for(let g=1;g<A.length;++g){const t=null==A[g]?null:A[g].slice(1);I=this.computeElementwiseOpOutputShape(I,t)}const t=A.map((A=>A.length));-1===A.indexOf(null)&&1===tl(t).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(A,g){return wi((()=>{if(this.reshapeRequired){const g=[],I=A.map((A=>A.rank));if(-1===I.indexOf(null)){const t=Ml(I);for(let I of A){const A=I.rank;for(let g=0;g<t-A;++g)I=Ll(I,1);g.push(I)}return this.mergeFunction(g)}{let I=!1;for(const t of A){const A=t.rank;if(null==A){const A=t.shape,C=A[0],e=A.slice(1).concat([C]);let B=Lo(t,[C].concat(kl(A.slice(1))));B=Yi(B,[1,0]),B=Lo(B,e),g.push(B),I=!0}else if(A>1){const C=Ul(1,A).concat([0]);g.push(Yi(t,C)),I=!0}else g.push(t)}let t=this.mergeFunction(g);const C=t.rank;if(I)if(null==C){const A=t.shape,g=A[A.length-1],I=[g].concat(A.slice(0,A.length-1));t=Lo(Yi(Lo(t,[-1,g]),[1,0]),I)}else if(C>1){const A=[C-1].concat(Ul(0,C-1));t=Yi(t,A)}return t}}return this.mergeFunction(A)}))}computeOutputShape(A){let g;g=null==A[0]?null:A[0].slice(1);for(let I=1;I<A.length;++I){const t=null==A[I]?null:A[I].slice(1);g=this.computeElementwiseOpOutputShape(g,t)}let I=[];for(const g of A)null!=g&&null!==g[0]&&I.push(g[0]);return I=tl(I),g=1===I.length?I.concat(g):[null].concat(g),g}computeMask(A,g){return wi((()=>{if(null==g)return null;if(!Array.isArray(g))throw new qc("`mask` should be an Array");if(!Array.isArray(A))throw new qc("`inputs` should be an Array");if(g.length!==A.length)throw new qc(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${A.length} vs ${g.length})`);if(g.every((A=>null==A)))return null;let I=(g=g.map((A=>null==A?A:vE(A,0))))[0];for(let A=1;A<g.length-1;++A)I=sn(I,g[A]);return I}))}}class ap extends sp{constructor(A){super(A)}mergeFunction(A){return wi((()=>{let g=A[0].clone();for(let I=1;I<A.length;++I)g=JQ(g,A[I]);return g}))}}ap.className="Add",uQ(ap);class rp extends sp{constructor(A){super(A)}mergeFunction(A){return wi((()=>{let g=A[0].clone();for(let I=1;I<A.length;++I)g=xQ(g,A[I]);return g}))}}rp.className="Multiply",uQ(rp);class hp extends sp{constructor(A){super(A)}mergeFunction(A){return wi((()=>{let g=A[0].clone();for(let I=1;I<A.length;++I)g=JQ(g,A[I]);return xQ(1/A.length,g)}))}}hp.className="Average",uQ(hp);class cp extends sp{constructor(A){super(A)}mergeFunction(A){return wi((()=>{let g=A[0];for(let I=1;I<A.length;++I)g=Co(g,A[I]);return g}))}}cp.className="Maximum",uQ(cp);class lp extends sp{constructor(A){super(A)}mergeFunction(A){return wi((()=>{let g=A[0];for(let I=1;I<A.length;++I)g=Nn(g,A[I]);return g}))}}lp.className="Minimum",uQ(lp);class Dp extends sp{constructor(A){super(A),this.DEFAULT_AXIS=-1,null==A&&(A={}),this.axis=null==A.axis?this.DEFAULT_AXIS:A.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(A){if(!Array.isArray(A)||!Array.isArray(A[0])||1===A.length)throw new qc("A `Concatenate` layer should be called on a list of at least 2 inputs");let g=!0;for(const I of A)if(null!=I){g=!1;break}if(g)return;const I=[];for(let g=0;g<A.length;++g){const t=A[g].slice();t.splice(this.axis,1);let C=!1;for(const A of I)if(EA(A,t)){C=!0;break}C||I.push(t)}if(I.length>1)throw new qc("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(A))}mergeFunction(A){return wi((()=>ql(A,this.axis)))}computeOutputShape(A){if(!Array.isArray(A)||!Array.isArray(A[0]))throw new qc("A `Concatenate` layer should be called on a list of inputs.");const g=A,I=g[0].slice(),t=this.axis<0?I.length+this.axis:this.axis;for(const A of g.slice(1)){if(null==I[t]||null==A[t]){I[t]=null;break}I[t]+=A[t]}return I}computeMask(A,g){if(null==g)return null;if(!Array.isArray(g))throw new qc("`mask` should be an array for Concatenate");if(!Array.isArray(A))throw new qc("`inputs` should be an array for Concatenate");if(g.length!==A.length)throw new qc(`Mismatch in the length of mask (${g.length}) and the legnth of inputs (${A.length})`);return wi((()=>{let I=!0;if(g.forEach((A=>{null==A||(I=!1)})),I)return null;const t=[];for(let I=0;I<A.length;++I)null==g[I]?t.push(qB(Un(A[I]),"bool")):g[I].rank<A[I].rank?t.push(vE(g[I],-1)):t.push(g[I]);const C=Ho(t,this.axis);return ao(C,-1,!1)}))}getConfig(){const A={axis:this.axis},g=super.getConfig();return Object.assign(A,g),A}}function up(A,g){for(;A<0;)A+=g;return A}Dp.className="Concatenate",uQ(Dp);class wp extends sp{constructor(A){super(A),this.axes=A.axes,this.normalize=null!=A.normalize&&A.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(A){CA(Array.isArray(A)&&2===A.length&&Array.isArray(A[0])&&Array.isArray(A[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const g=A[0],I=A[1];if(g.length>3||I.length>3)throw new Tc("Dot layer does not support tensors of 4D or higher rank yet.");const t=this.interpretAxes(g,I);if(g[t[0]]!==I[t[1]])throw new qc(`Dimension incompatibility: ${g[t[0]]} !== ${I[t[1]]}`)}mergeFunction(A){if(2!==A.length)throw new qc(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${A.length} input(s).`);let g,I=A[0],t=A[1];return g=Array.isArray(this.axes)?this.axes.map(((g,I)=>up(g,A[I].shape.length))):[up(this.axes,I.shape.length),up(this.axes,t.shape.length)],this.normalize&&(I=Mu(I,g[0]),t=Mu(t,g[1])),function(A,g,I){if(A.shape.length>3||g.shape.length>3)throw new Tc("batchDot is not implemented for tensors of 4D or higher rank yet");if(CA(A.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${A.shape.length}`)),CA(A.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${g.shape.length}`)),"number"==typeof I&&(I=[I,I]),"complex64"===A.dtype||"complex64"===g.dtype)throw new Tc("batchDot is not implemented for complex64-type Tensors yet.");const t=A.shape.length,C=g.shape.length;null==I&&(I=[t-1,C-2]);const e=I;return wi((()=>{let I,B;if(t>C){I=t-C;const A=[];for(let g=0;g<I;++g)A.push(1);g=Lo(g,g.shape.concat(A))}else if(C>t){I=C-t;const g=[];for(let A=0;A<I;++A)g.push(1);A=Lo(A,A.shape.concat(g))}else I=0;if(2===A.shape.length&&2===g.shape.length)B=e[0]===e[1]?xE(xQ(A,g),e[0]):xE(xQ(Yi(A,[1,0]),g),e[1]);else{const I=e[0]!==A.shape.length-1,t=e[1]===g.shape.length-1;B=Ei(A,g,I,t)}if(I>0){let A;A=t>C?t+C-3:t-1;const g=[];for(let t=A;t<A+I;++t)g.push(t);B=ms(B,g)}return 1===B.shape.length&&(B=vE(B,1)),B}))}(I,t,g)}interpretAxes(A,g){let I;return I=Array.isArray(this.axes)?this.axes:[up(this.axes,A.length),up(this.axes,g.length)],I}computeOutputShape(A){CA(Array.isArray(A)&&2===A.length&&Array.isArray(A[0])&&Array.isArray(A[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const g=A[0].slice(),I=A[1].slice();if(g.length>3||I.length>3)throw new Tc("Dot layer does not support tensors of 4D or higher rank yet.");const t=this.interpretAxes(g,I);g.splice(t[0],1),I.splice(t[1],1),I.splice(0,1);const C=g.concat(I);return 1===C.length&&C.push(1),C}computeMask(A,g){return null}getConfig(){const A={axes:this.axes,normalize:this.normalize},g=super.getConfig();return Object.assign(A,g),A}}wp.className="Dot",uQ(wp);class dp extends KD{constructor(A){super(A),this.supportsMasking=!0,this.stddev=A.stddev}computeOutputShape(A){return A}getConfig(){const A=super.getConfig(),g={stddev:this.stddev};return Object.assign(g,A),g}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A);return zl((()=>JQ(Vl(I.shape,0,this.stddev),I)),(()=>I),g.training||!1)}))}}dp.className="GaussianNoise",uQ(dp);class pp extends KD{constructor(A){super(A),this.supportsMasking=!0,this.rate=A.rate}computeOutputShape(A){return A}getConfig(){const A=super.getConfig(),g={rate:this.rate};return Object.assign(g,A),g}call(A,g){return wi((()=>{this.invokeCallHook(A,g);const I=pD(A);if(this.rate>0&&this.rate<1){return zl((()=>{const A=Math.sqrt(this.rate/(1-this.rate));return xQ(I,Vl(I.shape,1,A))}),(()=>I),g.training||!1)}return I}))}}pp.className="GaussianDropout",uQ(pp);class yp extends KD{constructor(A){super(A),this.supportsMasking=!0,this.rate=A.rate,this.noiseShape=A.noiseShape}_getNoiseShape(A){return this.noiseShape||pD(A).shape}computeOutputShape(A){return A}getConfig(){const A=super.getConfig(),g={rate:this.rate};return Object.assign(g,A),g}call(A,g){return wi((()=>{if(this.rate<1&&this.rate>0){const I=this._getNoiseShape(A),t=()=>{const g=pD(A),t=-1.7580993408473766;let C=jE(As(I),this.rate);C=Yl(C,"float32");const e=((1-this.rate)*(1+this.rate*t**2))**-.5,B=-e*t*this.rate,i=JQ(xQ(g,C),xQ(JQ(C,-1),t));return JQ(xQ(i,e),B)};return zl(t,(()=>pD(A)),g.training||!1)}return A}))}}function Gp(A,g,I,t,C,e=.001){let B;if(2===A.rank)B=Zo(A,g,I,t,C,e);else if(3===A.rank)B=Po(A,g,I,t,C,e);else{if(4!==A.rank)throw new Tc(`batchNormalization is not implemented for array of rank ${A.rank} yet`);B=Xo(A,g,I,t,C,e)}return B}function fp(A,g,I,t,C=.001){return EA(t.slice().sort(),Ul(0,A.rank-1))?function(A,g,I,t,C=.001){return wi((()=>{const e=mn(A,t),B=e.mean,i=e.variance;return[Gp(A,B,i,I,g,C),B,i]}))}(A,g,I,t,C):function(A,g,I,t,C=.001){return wi((()=>{const e=mn(A,t),B=e.mean,i=e.variance,Q=[];for(const g of Ul(0,A.rank))-1!==t.indexOf(g)?Q.push(1):Q.push(A.shape[g]);const o=Lo(B,Q),E=Lo(i,Q),n=null==g?null:Lo(g,Q),s=null==I?null:Lo(I,Q);return[Gp(A,o,E,s,n,C),B,i]}))}(A,g,I,t,C)}yp.className="AlphaDropout",uQ(yp);class Np extends KD{constructor(A){null==A&&(A={}),super(A),this.supportsMasking=!0,this.axis=null==A.axis?-1:A.axis,this.momentum=null==A.momentum?.99:A.momentum,this.epsilon=null==A.epsilon?.001:A.epsilon,this.center=null==A.center||A.center,this.scale=null==A.scale||A.scale,this.betaInitializer=uD(A.betaInitializer||"zeros"),this.gammaInitializer=uD(A.gammaInitializer||"ones"),this.movingMeanInitializer=uD(A.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=uD(A.movingVarianceInitializer||"ones"),this.betaConstraint=Au(A.betaConstraint),this.gammaConstraint=Au(A.gammaConstraint),this.betaRegularizer=ad(A.betaRegularizer),this.gammaRegularizer=ad(A.gammaRegularizer)}build(A){A=yD(A);const g=this.axis>=0?this.axis:this.axis+A.length,I=A[g];if(null==I)throw new qc(`Axis ${g} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(A)}.`);this.inputSpec=[new mD({ndim:A.length,axes:{[g]:I}})];const t=[I];this.scale&&(this.gamma=this.addWeight("gamma",t,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",t,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",t,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",t,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(A,g){return wi((()=>{const I=null!=g.training&&g.training,t=pD(A),C=t.shape,e=C.length,B=Ul(0,e),i=this.axis>=0?this.axis:this.axis+e;B.splice(i,1);const Q=Wc(1,e);Q[i]=C[i];const o=B.slice();o.sort();const E=!EA(o,Ul(0,e).slice(0,e-1));if(!I)return(()=>{if(E){const A=Lo(this.movingMean.read(),Q),g=Lo(this.movingVariance.read(),Q),I=this.center?Lo(this.beta.read(),Q):null,C=this.scale?Lo(this.gamma.read(),Q):null;return Gp(t,A,g,I,C,this.epsilon)}return Gp(t,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[n,s,a]=fp(t,this.gamma.read(),this.beta.read(),B,this.epsilon),r=(A,g,I)=>{wi((()=>{const t=1-I,C=A.read(),e=xQ(go(C,g),t);A.write(go(C,e))}))};return(()=>{r(this.movingMean,s,this.momentum),r(this.movingVariance,a,this.momentum)})(),n}))}getConfig(){const A={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:DD(this.betaInitializer),gammaInitializer:DD(this.gammaInitializer),movingMeanInitializer:DD(this.movingMeanInitializer),movingVarianceInitializer:DD(this.movingVarianceInitializer),betaRegularizer:nd(this.betaRegularizer),gammaRegularizer:nd(this.gammaRegularizer),betaConstraint:_D(this.betaConstraint),gammaConstraint:_D(this.gammaConstraint)},g=super.getConfig();return Object.assign(A,g),A}}Np.className="BatchNormalization",uQ(Np);class Fp extends KD{constructor(A){if(null==A&&(A={}),super(A),this.axis=null==A.axis?-1:A.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const A of this.axis)if(!Number.isInteger(A))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==A.epsilon?.001:A.epsilon,this.center=null==A.center||A.center,this.scale=null==A.scale||A.scale,this.betaInitializer=uD(A.betaInitializer||"zeros"),this.gammaInitializer=uD(A.gammaInitializer||"ones"),this.betaRegularizer=ad(A.betaRegularizer),this.gammaRegularizer=ad(A.gammaRegularizer),this.supportsMasking=!0}build(A){const g=(A=yD(A)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let A=0;A<this.axis.length;++A)this.axis[A]<0&&(this.axis[A]+=g);for(const A of this.axis)if(A<0||A>=g)throw new Error(`Invalid axis: ${A}`);if(this.axis.length!==tl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const I=this.axis.map((g=>A[g]));this.scale?this.gamma=this.addWeight("gamma",I,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",I,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(A,g){const I=pD(A),t=I.shape,C=t.length;return wi((()=>{let{mean:A,variance:g}=mn(I,this.axis,!0);const e=Wc(1,C);for(const A of this.axis)e[A]=t[A];const B=A=>null!=A&&A.shape.length!==C?Lo(A,e):A;let i=this.scale?B(this.gamma.read()):null,Q=this.center?B(this.beta.read()):null;const o=[],E=[];for(let A=0;A<C;++A)-1!==this.axis.indexOf(A)?(o.push(t[A]),E.push(1)):(o.push(1),E.push(t[A]));return A=WE(A,o),g=WE(g,o),null!=i&&(i=WE(i,E)),null!=Q&&(Q=WE(Q,E)),Gp(I,A,g,Q,i,this.epsilon)}))}getConfig(){const A={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:DD(this.betaInitializer),gammaInitializer:DD(this.gammaInitializer),betaRegularizer:nd(this.betaRegularizer),gammaRegularizer:nd(this.gammaRegularizer)},g=super.getConfig();return Object.assign(A,g),A}}Fp.className="LayerNormalization",uQ(Fp);class Rp extends KD{constructor(A){if(null==A&&(A={}),super(A),this.dataFormat=null==A.dataFormat?"channelsLast":A.dataFormat,null==A.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof A.padding)this.padding=[[A.padding,A.padding],[A.padding,A.padding]];else{if(A.padding=A.padding,2!==A.padding.length)throw new qc(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${A.padding.length} array.`);let g,I;if("number"==typeof A.padding[0])g=[A.padding[0],A.padding[0]],I=[A.padding[1],A.padding[1]];else{if(A.padding=A.padding,2!==A.padding[0].length)throw new qc(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${A.padding[0].length} array.`);if(g=A.padding[0],2!==A.padding[1].length)throw new qc(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${A.padding[1].length} array.`);I=A.padding[1]}this.padding=[g,I]}this.inputSpec=[new mD({ndim:4})]}computeOutputShape(A){let g,I;return A=yD(A),"channelsFirst"===this.dataFormat?(g=null!=A[2]&&A[2]>=0?A[2]+this.padding[0][0]+this.padding[0][1]:null,I=null!=A[3]&&A[3]>=0?A[3]+this.padding[1][0]+this.padding[1][1]:null,[A[0],A[1],g,I]):(g=null!=A[1]&&A[1]>=0?A[1]+this.padding[0][0]+this.padding[0][1]:null,I=null!=A[2]&&A[2]>=0?A[2]+this.padding[1][0]+this.padding[1][1]:null,[A[0],g,I,A[3]])}call(A,g){return wi((()=>{return g=pD(A),I=this.padding,t=this.dataFormat,wi((()=>{if(4!==g.rank)throw new qc(`temporalPadding expects input tensor to be 4-D, but received a ${g.rank}-D tensor.`);if(null==I&&(I=[[1,1],[1,1]]),2!==I.length||2!==I[0].length||2!==I[1].length)throw new qc("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==t&&(t="channelsLast"),"channelsLast"!==t&&"channelsFirst"!==t)throw new qc(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let A;return A="channelsFirst"===t?[[0,0],[0,0],I[0],I[1]]:[[0,0],I[0],I[1],[0,0]],Jn(g,A)}));var g,I,t}))}getConfig(){const A={padding:this.padding,dataFormat:this.dataFormat},g=super.getConfig();return Object.assign(A,g),A}}function mp(A,g,I,t,C,e){return wi((()=>{let B;wl(C),pl(e),dl(t),null==I&&(I=[1,1]),null==t&&(t="valid"),null==C&&(C="channelsLast"),null==e&&(e="max"),A=yd(A,C);const i="same"===t?"same":"valid";return B="max"===e?un(A,g,I,i):xo(A,g,I,i),"channelsFirst"===C&&(B=Yi(B,[0,3,1,2])),B}))}function kp(A,g,I,t,C,e){return wi((()=>{let B;wl(C),pl(e),dl(t),null==I&&(I=[1,1,1]),null==t&&(t="valid"),null==C&&(C="channelsLast"),null==e&&(e="max"),A=Gd(A,C);const i="same"===t?"same":"valid";return B="max"===e?wn(A,g,I,i):bo(A,g,I,i),"channelsFirst"===C&&(B=Yi(B,[0,4,1,2,3])),B}))}Rp.className="ZeroPadding2D",uQ(Rp);class Sp extends KD{constructor(A){if(null==A.poolSize&&(A.poolSize=2),super(A),"number"==typeof A.poolSize)this.poolSize=[A.poolSize];else{if(!Array.isArray(A.poolSize)||1!==A.poolSize.length||"number"!=typeof A.poolSize[0])throw new qc(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(A.poolSize)}`);this.poolSize=A.poolSize}if(il(this.poolSize,"poolSize"),null==A.strides)this.strides=this.poolSize;else if("number"==typeof A.strides)this.strides=[A.strides];else{if(!Array.isArray(A.strides)||1!==A.strides.length||"number"!=typeof A.strides[0])throw new qc(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(A.strides)}`);this.strides=A.strides}il(this.strides,"strides"),this.padding=null==A.padding?"valid":A.padding,dl(this.padding),this.inputSpec=[new mD({ndim:3})]}computeOutputShape(A){const g=dd((A=yD(A))[1],this.poolSize[0],this.padding,this.strides[0]);return[A[0],g,A[2]]}call(A,g){return wi((()=>{this.invokeCallHook(A,g),A=Ll(pD(A),2);const I=this.poolingFunction(pD(A),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ms(I,[2])}))}getConfig(){const A={poolSize:this.poolSize,padding:this.padding,strides:this.strides},g=super.getConfig();return Object.assign(A,g),A}}class Mp extends Sp{constructor(A){super(A)}poolingFunction(A,g,I,t,C){return wl(C),dl(t),mp(A,g,I,t,C,"max")}}Mp.className="MaxPooling1D",uQ(Mp);class Up extends Sp{constructor(A){super(A)}poolingFunction(A,g,I,t,C){return wl(C),dl(t),mp(A,g,I,t,C,"avg")}}Up.className="AveragePooling1D",uQ(Up);class Kp extends KD{constructor(A){if(null==A.poolSize&&(A.poolSize=[2,2]),super(A),this.poolSize=Array.isArray(A.poolSize)?A.poolSize:[A.poolSize,A.poolSize],null==A.strides)this.strides=this.poolSize;else if(Array.isArray(A.strides)){if(2!==A.strides.length)throw new qc(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${A.strides.length}.`);this.strides=A.strides}else this.strides=[A.strides,A.strides];il(this.poolSize,"poolSize"),il(this.strides,"strides"),this.padding=null==A.padding?"valid":A.padding,this.dataFormat=null==A.dataFormat?"channelsLast":A.dataFormat,wl(this.dataFormat),dl(this.padding),this.inputSpec=[new mD({ndim:4})]}computeOutputShape(A){A=yD(A);let g="channelsFirst"===this.dataFormat?A[2]:A[1],I="channelsFirst"===this.dataFormat?A[3]:A[2];return g=dd(g,this.poolSize[0],this.padding,this.strides[0]),I=dd(I,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[A[0],A[1],g,I]:[A[0],g,I,A[3]]}call(A,g){return wi((()=>(this.invokeCallHook(A,g),this.poolingFunction(pD(A),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const A={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},g=super.getConfig();return Object.assign(A,g),A}}class Jp extends Kp{constructor(A){super(A)}poolingFunction(A,g,I,t,C){return wl(C),dl(t),mp(A,g,I,t,C,"max")}}Jp.className="MaxPooling2D",uQ(Jp);class Yp extends Kp{constructor(A){super(A)}poolingFunction(A,g,I,t,C){return wl(C),dl(t),mp(A,g,I,t,C,"avg")}}Yp.className="AveragePooling2D",uQ(Yp);class Lp extends KD{constructor(A){if(null==A.poolSize&&(A.poolSize=[2,2,2]),super(A),this.poolSize=Array.isArray(A.poolSize)?A.poolSize:[A.poolSize,A.poolSize,A.poolSize],null==A.strides)this.strides=this.poolSize;else if(Array.isArray(A.strides)){if(3!==A.strides.length)throw new qc(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${A.strides.length}.`);this.strides=A.strides}else this.strides=[A.strides,A.strides,A.strides];il(this.poolSize,"poolSize"),il(this.strides,"strides"),this.padding=null==A.padding?"valid":A.padding,this.dataFormat=null==A.dataFormat?"channelsLast":A.dataFormat,wl(this.dataFormat),dl(this.padding),this.inputSpec=[new mD({ndim:5})]}computeOutputShape(A){A=yD(A);let g="channelsFirst"===this.dataFormat?A[2]:A[1],I="channelsFirst"===this.dataFormat?A[3]:A[2],t="channelsFirst"===this.dataFormat?A[4]:A[3];return g=dd(g,this.poolSize[0],this.padding,this.strides[0]),I=dd(I,this.poolSize[1],this.padding,this.strides[1]),t=dd(t,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[A[0],A[1],g,I,t]:[A[0],g,I,t,A[4]]}call(A,g){return wi((()=>(this.invokeCallHook(A,g),this.poolingFunction(pD(A),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const A={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},g=super.getConfig();return Object.assign(A,g),A}}class xp extends Lp{constructor(A){super(A)}poolingFunction(A,g,I,t,C){return wl(C),dl(t),kp(A,g,I,t,C,"max")}}xp.className="MaxPooling3D",uQ(xp);class bp extends Lp{constructor(A){super(A)}poolingFunction(A,g,I,t,C){return wl(C),dl(t),kp(A,g,I,t,C,"avg")}}bp.className="AveragePooling3D",uQ(bp);class Hp extends KD{constructor(A){super(A),this.inputSpec=[new mD({ndim:3})]}computeOutputShape(A){return[A[0],A[2]]}call(A,g){throw new Tc}}class qp extends Hp{constructor(A){super(A||{})}call(A,g){return wi((()=>{const g=pD(A);return pn(g,1)}))}}qp.className="GlobalAveragePooling1D",uQ(qp);class Tp extends Hp{constructor(A){super(A||{})}call(A,g){return wi((()=>{const g=pD(A);return YE(g,1)}))}}Tp.className="GlobalMaxPooling1D",uQ(Tp);class vp extends KD{constructor(A){super(A),this.dataFormat=null==A.dataFormat?"channelsLast":A.dataFormat,wl(this.dataFormat),this.inputSpec=[new mD({ndim:4})]}computeOutputShape(A){return"channelsLast"===this.dataFormat?[A[0],A[3]]:[A[0],A[1]]}call(A,g){throw new Tc}getConfig(){const A={dataFormat:this.dataFormat},g=super.getConfig();return Object.assign(A,g),A}}class Vp extends vp{call(A,g){return wi((()=>{const g=pD(A);return"channelsLast"===this.dataFormat?pn(g,[1,2]):pn(g,[2,3])}))}}Vp.className="GlobalAveragePooling2D",uQ(Vp);class Wp extends vp{call(A,g){return wi((()=>{const g=pD(A);return"channelsLast"===this.dataFormat?YE(g,[1,2]):YE(g,[2,3])}))}}Wp.className="GlobalMaxPooling2D",uQ(Wp);class Op extends KD{constructor(A){super(A),this.layer=A.layer}build(A){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(A){null!=this.layer&&(this.layer.trainable=A)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(A){this.layer.setWeights(A)}getConfig(){const A={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},g=super.getConfig();return Object.assign(A,g),A}setFastWeightInitDuringBuild(A){super.setFastWeightInitDuringBuild(A),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(A)}static fromConfig(A,g,I={}){const t=Su(g.layer,I);delete g.layer;const C={layer:t};return Object.assign(C,g),new A(C)}}class Zp extends Op{constructor(A){super(A),this.supportsMasking=!0}build(A){if((A=yD(A)).length<3)throw new qc(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(A)}`);this.inputSpec=[{shape:A}];const g=[A[0]].concat(A.slice(2));this.layer.built||(this.layer.build(g),this.layer.built=!0),super.build(A)}computeOutputShape(A){const g=[(A=yD(A))[0]].concat(A.slice(2)),I=this.layer.computeOutputShape(g),t=A[1];return[I[0],t].concat(I.slice(1))}call(A,g){return wi((()=>qd(((A,I)=>[pD(this.layer.call(A,g)),[]]),A=pD(A),[],!1,null,null,!1,!0)[1]))}}Zp.className="TimeDistributed",uQ(Zp);class Pp extends Op{constructor(A){super(A);const g=A.layer.getConfig(),I={};I.className=A.layer.getClassName(),I.config=g,this.forwardLayer=Su(I),g.goBackwards=!0!==g.goBackwards;const t={};var C;if(t.className=A.layer.getClassName(),t.config=g,this.backwardLayer=Su(t),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===A.mergeMode?"concat":A.mergeMode,C=this.mergeMode,el(Dl,"BidirectionalMergeMode",C),A.weights)throw new Tc("weights support is not implemented for Bidirectional layer yet.");this._stateful=A.layer.stateful,this.returnSequences=A.layer.returnSequences,this.returnState=A.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=A.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(A){this._trainable=A,null!=this.forwardLayer&&(this.forwardLayer.trainable=A),null!=this.backwardLayer&&(this.backwardLayer.trainable=A)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(A){const g=A.length,I=Math.floor(g/2);this.forwardLayer.setWeights(A.slice(0,I)),this.backwardLayer.setWeights(A.slice(I))}computeOutputShape(A){let g,I,t,C=this.forwardLayer.computeOutputShape(A);return Array.isArray(C)&&Array.isArray(C[0])||(C=[C]),this.returnState?(t=C.slice(1),g=C[0]):g=C[0],"concat"===this.mergeMode?(g[g.length-1]*=2,I=[g]):I=null==this.mergeMode?[g,g.slice()]:[g],this.returnState?null==this.mergeMode?I.concat(t).concat(t.slice()):[g].concat(t).concat(t.slice()):Pc(I)}apply(A,g){let I=null==g?null:g.initialState,t=null==g?null:g.constants;null==g&&(g={});const C=Hd(A,I,t,this.numConstants);if(A=C.inputs,I=C.initialState,t=C.constants,Array.isArray(A)&&(I=A.slice(1),A=A[0]),(null==I||0===I.length)&&null==t)return super.apply(A,g);const e=[],B=[];if(null!=I){const A=I.length;if(A%2>0)throw new qc("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");g.initialState=I,e.push(...I);const t=I.map((A=>new mD({shape:A.shape})));this.forwardLayer.stateSpec=t.slice(0,A/2),this.backwardLayer.stateSpec=t.slice(A/2),B.push(...t)}if(null!=t)throw new Tc("Support for constants in Bidirectional layers is not implemented yet.");const i=e[0]instanceof kD;for(const A of e)if(A instanceof kD!==i)throw new qc("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const I=[A].concat(e),t=this.inputSpec.concat(B),C=this.inputSpec;this.inputSpec=t;const i=super.apply(I,g);return this.inputSpec=C,i}return super.apply(A,g)}call(A,g){return wi((()=>{const I=g.initialState;let t,C,e,B;if(null==I)t=this.forwardLayer.call(A,g),C=this.backwardLayer.call(A,g);else{const e=I.slice(0,I.length/2),B=I.slice(I.length/2);t=this.forwardLayer.call(A,Object.assign(g,{initialState:e})),C=this.backwardLayer.call(A,Object.assign(g,{initialState:B}))}return this.returnState&&(Array.isArray(t)&&(e=t.slice(1).concat(C.slice(1))),t=t[0],C=C[0]),this.returnSequences&&(C=es(C,1)),"concat"===this.mergeMode?B=ql([t,C]):"sum"===this.mergeMode?B=JQ(t,C):"ave"===this.mergeMode?B=xQ(.5,JQ(t,C)):"mul"===this.mergeMode?B=xQ(t,C):null==this.mergeMode&&(B=[t,C]),this.returnState?null==this.mergeMode?B.concat(e):[B].concat(e):B}))}resetStates(A){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(A){fl(this.forwardLayer.name,(()=>{this.forwardLayer.build(A)})),fl(this.backwardLayer.name,(()=>{this.backwardLayer.build(A)})),this.built=!0}computeMask(A,g){let I;if(Array.isArray(g)&&(g=g[0]),I=this.returnSequences?null==this.mergeMode?[g,g]:g:null==this.mergeMode?[null,null]:null,this.returnState){const A=this.forwardLayer.states.map((A=>null));return Array.isArray(I)?I.concat(A).concat(A):[I].concat(A).concat(A)}return I}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(A){super.setFastWeightInitDuringBuild(A),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(A),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(A)}getConfig(){const A={mergeMode:this.mergeMode},g=super.getConfig();return Object.assign(A,g),A}static fromConfig(A,g){const I=Su(g.layer);if(delete g.layer,null!=g.numConstants)throw new Tc("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const t=g;return t.layer=I,new A(t)}}Pp.className="Bidirectional",uQ(Pp);class Xp extends KD{constructor(A){super(A),this.scale=A.scale,A.offset?this.offset=A.offset:this.offset=0}getConfig(){const A={scale:this.scale,offset:this.offset},g=super.getConfig();return Object.assign(A,g),A}call(A,g){return wi((()=>("float32"!==(A=pD(A)).dtype&&(A=Yl(A,"float32")),JQ(xQ(A,this.scale),this.offset))))}}function jp(A){return new YD(A)}function zp(A){return new ld(A)}function _p(A){return new rd(A)}function $p(A){return new hd(A)}function Ay(A){return new cd(A)}function gy(A){return new ud(A)}function Iy(A){return new Dd(A)}function ty(A){return new Yd(A)}function Cy(A){return new kd(A)}function ey(A){return new Md(A)}function By(A){return new Sd(A)}function iy(A){return new Ud(A)}function Qy(A){return new Jd(A)}function oy(A){return new Ld(A)}function Ey(A){return new xd(A)}function ny(A){return new bd(A)}function sy(A){return new Bp(A)}function ay(A){return new Cp(A)}function ry(A){return new Ip(A)}function hy(A){return new tp(A)}function cy(A){return new ep(A)}function ly(A){return new ip(A)}function Dy(A){return new Qp(A)}function uy(A){return new op(A)}function wy(A){return new np(A)}function dy(A){return new ap(A)}function py(A){return new hp(A)}function yy(A){return new Dp(A)}function Gy(A){return new cp(A)}function fy(A){return new lp(A)}function Ny(A){return new rp(A)}function Fy(A){return new wp(A)}function Ry(A){return new Np(A)}function my(A){return new Fp(A)}function ky(A){return new Rp(A)}function Sy(A){return new Up(A)}function My(A){return Sy(A)}function Uy(A){return Sy(A)}function Ky(A){return new Yp(A)}function Jy(A){return Ky(A)}function Yy(A){return Ky(A)}function Ly(A){return new bp(A)}function xy(A){return Ly(A)}function by(A){return Ly(A)}function Hy(A){return new qp(A)}function qy(A){return new Vp(A)}function Ty(A){return new Tp(A)}function vy(A){return new Wp(A)}function Vy(A){return new Mp(A)}function Wy(A){return new Jp(A)}function Oy(A){return new xp(A)}function Zy(A){return new Zd(A)}function Py(A){return new Od(A)}function Xy(A){return new Xd(A)}function jy(A){return new Pd(A)}function zy(A){return new Wd(A)}function _y(A){return new Vd(A)}function $y(A){return new gp(A)}function AG(A){return new Ap(A)}function gG(A){return new Td(A)}function IG(A){return new jd(A)}function tG(A){return new Pp(A)}function CG(A){return new Zp(A)}Xp.className="Rescaling",uQ(Xp);const eG=Ty,BG=vy,iG=Vy,QG=Wy;function oG(A){return new dp(A)}function EG(A){return new pp(A)}function nG(A){return new yp(A)}function sG(A){return new Ep(A)}function aG(A){return new Xp(A)}function rG(A,g){return Vu(A,g)}function hG(A,g){return Xu(A,g)}function cG(A,g){return ju(A,g)}function lG(A,g){return Wu(A,g)}function DG(A,g){return zu(A,g)}function uG(A,g){return Zu(A,g)}function wG(A,g){return Pu(A,g)}function dG(A,g){return qu(A,g)}function pG(A,g){return Ku(A,g)}function yG(A,g){return Ju(A,g)}function GG(A,g){return Ju(A,g)}function fG(A,g){return Ju(A,g)}function NG(A,g){return Uu(A,g)}function FG(A,g){return Uu(A,g)}function RG(A,g){return Uu(A,g)}function mG(A){return new od(A)}function kG(A){return id(g=A),new od({l1:null!=g?g.l1:null,l2:0});var g}function SG(A){return id(g=A),new od({l2:null!=g?g.l2:null,l1:0});var g}class MG extends yu{constructor(){super(...arguments),this.model=null}setModel(A){if(!(A instanceof Uw))throw new Error("model must be a LayersModel, not some other Container");this.model=A}}function UG(A,g){return A<g}function KG(A,g){return A>g}class JG extends MG{constructor(A){if(super(),null==A&&(A={}),A.restoreBestWeights)throw new Tc("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=A.monitor||"val_loss",this.minDelta=Math.abs(A.minDelta||0),this.patience=A.patience||0,this.verbose=A.verbose||0,this.mode=A.mode||"auto",this.baseline=A.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=UG:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=KG:this.monitorFunc=UG,this.monitorFunc===UG&&(this.minDelta*=-1)}async onTrainBegin(A){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===UG?1/0:-1/0}async onEpochEnd(A,g){await wu(g);const I=this.getMonitorValue(g);null!=I&&(this.monitorFunc(I-this.minDelta,this.best)?(this.best=I,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=A,this.model.stopTraining=!0)))}async onTrainEnd(A){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(A){null==A&&(A={});const g=A[this.monitor];return null==g&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(A)}`),g}}const YG={earlyStopping:function(A){return new JG(A)}};var LG,xG;ZA().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(A=>{A&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(A){A[A.DT_INVALID=0]="DT_INVALID",A[A.DT_FLOAT=1]="DT_FLOAT",A[A.DT_DOUBLE=2]="DT_DOUBLE",A[A.DT_INT32=3]="DT_INT32",A[A.DT_UINT8=4]="DT_UINT8",A[A.DT_INT16=5]="DT_INT16",A[A.DT_INT8=6]="DT_INT8",A[A.DT_STRING=7]="DT_STRING",A[A.DT_COMPLEX64=8]="DT_COMPLEX64",A[A.DT_INT64=9]="DT_INT64",A[A.DT_BOOL=10]="DT_BOOL",A[A.DT_QINT8=11]="DT_QINT8",A[A.DT_QUINT8=12]="DT_QUINT8",A[A.DT_QINT32=13]="DT_QINT32",A[A.DT_BFLOAT16=14]="DT_BFLOAT16",A[A.DT_QINT16=15]="DT_QINT16",A[A.DT_QUINT16=16]="DT_QUINT16",A[A.DT_UINT16=17]="DT_UINT16",A[A.DT_COMPLEX128=18]="DT_COMPLEX128",A[A.DT_HALF=19]="DT_HALF",A[A.DT_RESOURCE=20]="DT_RESOURCE",A[A.DT_VARIANT=21]="DT_VARIANT",A[A.DT_UINT32=22]="DT_UINT32",A[A.DT_UINT64=23]="DT_UINT64",A[A.DT_FLOAT_REF=101]="DT_FLOAT_REF",A[A.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",A[A.DT_INT32_REF=103]="DT_INT32_REF",A[A.DT_UINT8_REF=104]="DT_UINT8_REF",A[A.DT_INT16_REF=105]="DT_INT16_REF",A[A.DT_INT8_REF=106]="DT_INT8_REF",A[A.DT_STRING_REF=107]="DT_STRING_REF",A[A.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",A[A.DT_INT64_REF=109]="DT_INT64_REF",A[A.DT_BOOL_REF=110]="DT_BOOL_REF",A[A.DT_QINT8_REF=111]="DT_QINT8_REF",A[A.DT_QUINT8_REF=112]="DT_QUINT8_REF",A[A.DT_QINT32_REF=113]="DT_QINT32_REF",A[A.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",A[A.DT_QINT16_REF=115]="DT_QINT16_REF",A[A.DT_QUINT16_REF=116]="DT_QUINT16_REF",A[A.DT_UINT16_REF=117]="DT_UINT16_REF",A[A.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",A[A.DT_HALF_REF=119]="DT_HALF_REF",A[A.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",A[A.DT_VARIANT_REF=121]="DT_VARIANT_REF",A[A.DT_UINT32_REF=122]="DT_UINT32_REF",A[A.DT_UINT64_REF=123]="DT_UINT64_REF"}(LG||(LG={})),function(A){let g;!function(A){A[A.LEGACY=0]="LEGACY",A[A.V1=1]="V1",A[A.V2=2]="V2"}(g=A.CheckpointFormatVersion||(A.CheckpointFormatVersion={}))}(xG||(xG={}));const bG={};function HG(A,g){const I={tfOpName:A,category:"custom",inputs:[],attrs:[],customExecutor:g};bG[A]=I}function qG(A){return bG[A]}function TG(A){delete bG[A]}function vG(A,g,I,t,C){const e=g.inputParams[A];if(e&&void 0!==e.inputIndexStart){const A=e.inputIndexStart,B=0===e.inputIndexEnd?void 0:void 0===e.inputIndexEnd?A+1:e.inputIndexEnd;if("tensor"===e.type)return VG(g.inputNames[e.inputIndexStart],I,t,C);if("tensors"===e.type){return g.inputNames.slice(A,B).map((A=>VG(A,I,t,C)))}const i=VG(g.inputNames.slice(A)[0],I,t,C),Q=i.dataSync();return"number"===e.type?Q[0]:YA(i.shape,Q)}const B=g.attrParams[A];return B&&B.value}function VG(A,g,I,t){const[C,e]=ZG(A);if(null!=t){const A=t.getHashTableHandleByName(C);if(null!=A)return A}const B=I.currentContextIds.find((A=>!!g[OG(C,A)]));return void 0!==B?g[OG(C,B)][e]:void 0}function WG(A,g){const[I,t,C]=ZG(A);return[OG(I,g&&g.currentContextId),t,C]}function OG(A,g){return g?`${A}-${g}`:A}function ZG(A){const g=A.split(":");if(1===g.length)return[A,0,void 0];const I=g[0],t=3===g.length?g[1]:void 0;return[I,Number(g[g.length-1]),t]}function PG(A,g,I){let t=vG("pad",A,g,I);if("explicit"===t){t=vG("explicitPaddings",A,g,I);const C=[[0,0],[0,0],[0,0],[0,0]];for(let A=0;A<4;A++)C[A][0]=t[2*A],C[A][1]=t[2*A+1];return C}return t}function XG(A){return A.kept?A:TB(A)}const jG=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zG=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_G=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],$G=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Af=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],gf=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],If=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],tf=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Cf=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],ef=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Bf=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qf=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],of=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Ef=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],nf=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sf=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],af=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],rf=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],hf=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class cf{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const A=[].concat(...[f,N,F,R,m,k,S,M,U,K,J,Y,L,x,b,H,q,T,v].map((A=>A.json)));this.opMappers=A.reduce(((A,g)=>(A[g.tfOpName]=g,A)),{})}transformGraph(A,g={}){const I=A.node,t=[],C=[],e=[],B=I.reduce(((A,g)=>(A[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?t.push(A[g.name]):"Const"===g.op?C.push(A[g.name]):null!=g.input&&0!==g.input.length||e.push(A[g.name]),A)),{});let i=[];const Q=[];let o={},E={};null!=g&&(o=this.mapSignatureEntries(g.inputs),E=this.mapSignatureEntries(g.outputs));const n=Object.keys(B);n.forEach((A=>{const g=B[A];g.inputNames.forEach(((A,I)=>{const[t,,C]=WG(A),e=B[t];if(null!=e.outputs){const A=e.outputs.indexOf(C);if(-1!==A){const C=`${t}:${A}`;g.inputNames[I]=C}}g.inputs.push(e),e.children.push(g)}))})),0===Object.keys(E).length?n.forEach((A=>{const g=B[A];0===g.children.length&&Q.push(g)})):Object.keys(E).forEach((A=>{const[g]=WG(A),I=B[g];null!=I&&(I.signatureKey=E[A],Q.push(I))})),Object.keys(o).length>0?Object.keys(o).forEach((A=>{const[g]=WG(A),I=B[g];I&&(I.signatureKey=o[A],i.push(I))})):i=t;let s={};null!=A.library&&null!=A.library.function&&(s=A.library.function.reduce(((A,g)=>(A[g.signature.name]=this.mapFunction(g),A)),{}));const a={nodes:B,inputs:i,outputs:Q,weights:C,placeholders:t,signature:g,functions:s};return e.length>0&&(a.initNodes=e),a}mapSignatureEntries(A){return Object.keys(A||{}).reduce(((g,I)=>(g[A[I].name]=I,g)),{})}mapNode(A){const g=qG(A.op)||this.opMappers[A.op]||{};null==A.attr&&(A.attr={});const I={name:A.name,op:A.op,category:g.category,inputNames:(A.input||[]).map((A=>A.startsWith("^")?A.slice(1):A)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:A.attr,outputs:g.outputs};return null!=g.inputs&&(I.inputParams=g.inputs.reduce(((A,g)=>(A[g.name]={type:g.type,inputIndexStart:g.start,inputIndexEnd:g.end},A)),{})),null!=g.attrs&&(I.attrParams=g.attrs.reduce(((g,I)=>{const t=I.type;let C;switch(I.type){case"string":C=Df(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=Df(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"string[]":C=Rf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=Rf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"number":C=wf(A.attr,I.tfName,I.defaultValue||0),void 0===C&&I.tfDeprecatedName&&(C=wf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"number[]":C=Ff(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=Ff(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"bool":C=uf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=uf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"bool[]":C=kf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=kf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"shape":C=Nf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=Nf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"shape[]":C=mf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=mf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"dtype":C=yf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=yf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"dtype[]":C=Gf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=Gf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"func":C=pf(A.attr,I.tfName,I.defaultValue),void 0===C&&I.tfDeprecatedName&&(C=pf(A.attr,I.tfDeprecatedName,I.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${I.type} for op: ${A.op}`)}return g[I.name]={value:C,type:t},g}),{})),I}mapFunction(A){const g=A.nodeDef,I=[];let t={};null!=g&&(t=g.reduce(((A,g)=>(A[g.name]=this.mapNode(g),"Const"===g.op&&I.push(A[g.name]),A)),{}));const C=[],e=[];A.signature.inputArg.forEach((A=>{const[g]=WG(A.name),I={name:g,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:df(A.type),type:"dtype"}},children:[]};I.signatureKey=A.name,C.push(I),t[g]=I}));Object.keys(t).forEach((A=>{const g=t[A];g.inputNames.forEach(((A,I)=>{const[C,,e]=WG(A),B=t[C];if(null!=B.outputs){const A=B.outputs.indexOf(e);if(-1!==A){const t=`${C}:${A}`;g.inputNames[I]=t}}g.inputs.push(B),B.children.push(g)}))}));const B=A.ret;A.signature.outputArg.forEach((A=>{const[g,I]=WG(B[A.name]),C=t[g];null!=C&&(C.defaultOutput=I,e.push(C))}));const i=this.mapArgsToSignature(A);return{nodes:t,inputs:C,outputs:e,weights:I,placeholders:[],signature:i}}mapArgsToSignature(A){return{methodName:A.signature.name,inputs:A.signature.inputArg.reduce(((A,g)=>(A[g.name]=this.mapArgToTensorInfo(g),A)),{}),outputs:A.signature.outputArg.reduce(((g,I)=>(g[I.name]=this.mapArgToTensorInfo(I,A.ret),g)),{})}}mapArgToTensorInfo(A,g){let I=A.name;return null!=g&&(I=g[I]),{name:I,dtype:A.type}}}function lf(A,g){const I=Array.isArray(A)?String.fromCharCode.apply(null,A):function(A){const g=ZA().global;if(void 0!==g.atob)return g.atob(A);if("undefined"!=typeof Buffer)return new Buffer(A,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(A);return g?I:I.toLowerCase()}function Df(A,g,I,t=!1){const C=A[g];return null!=C?lf(C.s,t):I}function uf(A,g,I){const t=A[g];return t?t.b:I}function wf(A,g,I){const t=A[g]||{},C=null!=t.i?t.i:null!=t.f?t.f:I;return"number"==typeof C?C:parseInt(C,10)}function df(A){switch("string"==typeof A&&(A=LG[A]),A){case LG.DT_FLOAT:case LG.DT_HALF:return"float32";case LG.DT_INT32:case LG.DT_INT64:case LG.DT_INT8:case LG.DT_UINT8:return"int32";case LG.DT_BOOL:return"bool";case LG.DT_DOUBLE:return"float32";case LG.DT_STRING:return"string";default:return null}}function pf(A,g,I){const t=A[g];return t&&t.func?t.func.name:I}function yf(A,g,I){const t=A[g];return t&&t.type?df(t.type):I}function Gf(A,g,I){const t=A[g];return t&&t.list&&t.list.type?t.list.type.map((A=>df(A))):I}function ff(A){if(!A.unknownRank)return null!=A.dim?A.dim.map((A=>"number"==typeof A.size?A.size:parseInt(A.size,10))):[]}function Nf(A,g,I){const t=A[g];return t&&t.shape?ff(t.shape):I}function Ff(A,g,I){const t=A[g];return t?((t.list.f&&t.list.f.length?t.list.f:t.list.i)||[]).map((A=>"number"==typeof A?A:parseInt(A,10))):I}function Rf(A,g,I,t=!1){const C=A[g];return C&&C.list&&C.list.s?C.list.s.map((A=>lf(A,t))):I}function mf(A,g,I){const t=A[g];return t&&t.list&&t.list.shape?t.list.shape.map((A=>ff(A))):I}function kf(A,g,I){const t=A[g];return t&&t.list&&t.list.b?t.list.b:I}class Sf{constructor(A,g,I){this.node=A,this.tensorMap=g,this.context=I,this.inputs=[],this.attrs={},this.inputs=A.inputNames.map((A=>this.getInput(A))),null!=A.rawAttrs&&(this.attrs=Object.keys(A.rawAttrs).reduce(((A,g)=>(A[g]=this.getAttr(g),A)),{}))}getInput(A){return VG(A,this.tensorMap,this.context)}getAttr(A,g){const I=this.node.rawAttrs[A];if(null!=I.tensor)return VG(A,this.tensorMap,this.context);if(null!=I.i||null!=I.f)return wf(this.node.rawAttrs,A,g);if(null!=I.s)return Df(this.node.rawAttrs,A,g);if(null!=I.b)return uf(this.node.rawAttrs,A,g);if(null!=I.shape)return Nf(this.node.rawAttrs,A,g);if(null!=I.type)return yf(this.node.rawAttrs,A,g);if(null!=I.list){if(null!=I.list.i||null!=I.list.f)return Ff(this.node.rawAttrs,A,g);if(null!=I.list.s)return Rf(this.node.rawAttrs,A,g);if(null!=I.list.shape)return mf(this.node.rawAttrs,A,g);if(null!=I.list.b)return kf(this.node.rawAttrs,A,g);if(null!=I.list.type)return Gf(this.node.rawAttrs,A,g)}return g}}function Mf(A,g,I=""){if("number"!=typeof A&&"number"!=typeof g){CA(A.length===g.length,(()=>I+` Shapes ${A} and ${g} must match`));for(let t=0;t<A.length;t++){const C=A[t],e=g[t];CA(C<0||e<0||C===e,(()=>I+` Shapes ${A} and ${g} must match`))}}}function Uf(A){return"number"!=typeof A&&!A.some((A=>A<0))}function Kf(A,g,I){let t=Jf(A,I);const C=!Uf(t);if(C&&0===g.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${t}`);if(C&&g.forEach((A=>{t=Jf(A.shape,t)})),!Uf(t))throw new Error(`Non-fully-defined elementShape: ${t}`);return t}function Jf(A,g){if("number"==typeof A)return g;if("number"==typeof g)return A;if(A.length!==g.length)throw new Error(`Incompatible ranks during merge: ${A} vs. ${g}`);const I=[];for(let t=0;t<A.length;++t){const C=A[t],e=g[t];if(C>=0&&e>=0&&C!==e)throw new Error(`Incompatible shape during merge: ${A} vs. ${g}`);I[t]=C>=0?C:e}return I}class Yf{constructor(A,g,I,t,C,e,B){this.name=A,this.dtype=g,this.maxSize=I,this.elementShape=t,this.identicalElementShapes=C,this.dynamicSize=e,this.clearAfterRead=B,this.tensors=[],this.closed_=!1,this.idTensor=XQ(0),pi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(A){this.tensors.forEach((g=>{null!=A&&A.has(g.tensor.id)||g.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(A){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(A<0||A>=this.size())throw new Error(`Tried to read from index ${A}, but array size is: ${this.size()}`);const g=this.tensors[A];if(g.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${A} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(g.cleared=!0),g.read=!0,g.tensor}readMany(A){return A.map((A=>this.read(A)))}write(A,g){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(A<0||!this.dynamicSize&&A>=this.maxSize)throw new Error(`Tried to write to index ${A}, but array is not resizeable and size is: ${this.maxSize}`);const I=this.tensors[A]||{};if(g.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${A},\n          because the value dtype is ${g.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=g.shape),Mf(this.elementShape,g.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${A}.`),I.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${A}, because it has already been read.`);if(I.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${A}, because it has already been written.`);I.tensor=g,pi(g),I.written=!0,this.tensors[A]=I}writeMany(A,g){if(A.length!==g.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${A.length} is not the same as tensors size: ${g.length}.`);A.forEach(((A,I)=>this.write(A,g[I])))}gather(A,g){if(g&&g!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${g}`);if(A)A=A.slice(0,this.size());else{A=[];for(let g=0;g<this.size();g++)A.push(g)}if(0===A.length)return He([],[0].concat(this.elementShape));const I=this.readMany(A);return Mf(this.elementShape,I[0].shape,"TensorArray shape mismatch: "),ks(I,0)}concat(A){if(A&&A!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${A}`);if(0===this.size())return He([],[0].concat(this.elementShape));const g=[];for(let A=0;A<this.size();A++)g.push(A);const I=this.readMany(g);return Mf(this.elementShape,I[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${I[0].shape})`),Ho(I,0)}scatter(A,g){if(g.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${g.dtype}`);if(A.length!==g.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${A.length} vs. ${g.shape[0]}`);const I=Math.max(...A);if(!this.dynamicSize&&I>=this.maxSize)throw new Error(`Max index must be < array size (${I}  vs. ${this.maxSize})`);this.writeMany(A,vs(g,0))}split(A,g){if(g.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${g.dtype}`);let I=0;const t=A.map((A=>(I+=A,I)));if(I!==g.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${I}, and tensor's shape is: ${g.shape}`);if(!this.dynamicSize&&A.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${A.length}), and the TensorArray is not marked as dynamically resizeable`);const C=0===I?0:g.size/I,e=[];wi((()=>{g=Lo(g,[1,I,C]);for(let I=0;I<A.length;++I){const B=[0,0===I?0:t[I-1],0],i=[1,A[I],C];e[I]=Lo(To(g,B,i),this.elementShape)}return e}));const B=[];for(let g=0;g<A.length;g++)B[g]=g;this.writeMany(B,e)}}class Lf{constructor(A,g,I,t=-1){this.tensors=A,this.elementShape=g,this.elementDtype=I,null!=A&&A.forEach((A=>{if(I!==A.dtype)throw new Error(`Invalid data types; op elements ${I}, but list elements ${A.dtype}`);Mf(g,A.shape,"TensorList shape mismatch: "),pi(A)})),this.idTensor=XQ(0),this.maxNumElements=t,pi(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Lf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(A){this.tensors.forEach((g=>{null!=A&&A.has(g.id)||g.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(A,g,I=-1){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);if(-1!==I&&this.tensors.length!==I)throw new Error(`Operation expected a list with ${I} elements but got a list with ${this.tensors.length} elements.`);Mf(A,this.elementShape,"TensorList shape mismatch: ");const t=Kf(this.elementShape,this.tensors,A);return wi((()=>{const A=this.tensors.map((A=>Lo(A,t)));return ks(A,0)}))}popBack(A,g){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const I=Kf(this.elementShape,this.tensors,A),t=this.tensors.pop();return t.kept=!1,Mf(t.shape,A,"TensorList shape mismatch: "),Lo(t,I)}pushBack(A){if(A.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${A.dtype}, but list elements ${this.elementDtype}`);if(Mf(A.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");pi(A),this.tensors.push(A)}resize(A){if(A<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${A}`);if(-1!==this.maxNumElements&&A>this.maxNumElements)throw new Error(`TensorListResize input size ${A} is greater maxNumElement ${this.maxNumElements}.`);const g=new Lf([],this.elementShape,this.elementDtype,this.maxNumElements);g.tensors.length=A;for(let I=0;I<Math.min(this.tensors.length,A);++I)g.tensors[I]=this.tensors[I];return g}getItem(A,g,I){if(I!==this.elementDtype)throw new Error(`Invalid data types; op elements ${I}, but list elements ${this.elementDtype}`);if(A<0||A>this.tensors.length)throw new Error(`Trying to access element ${A} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[A])throw new Error(`element at index ${A} is null.`);Mf(this.tensors[A].shape,g,"TensorList shape mismatch: ");const t=Kf(this.elementShape,this.tensors,g);return Lo(this.tensors[A],t)}setItem(A,g){if(g.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g.dtype}, but list elements ${this.elementDtype}`);if(A<0||-1!==this.maxNumElements&&A>=this.maxNumElements)throw new Error(`Trying to set element ${A} in a list with max ${this.maxNumElements} elements.`);Mf(this.elementShape,g.shape,"TensorList shape mismatch: "),pi(g),null!=this.tensors[A]&&(this.tensors[A].kept=!1),this.tensors[A]=g}gather(A,g,I){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);Mf(this.elementShape,I,"TensorList shape mismatch: "),A=A.slice(0,this.size());const t=Kf(this.elementShape,this.tensors,I);return 0===A.length?He([],[0].concat(t)):wi((()=>{const g=A.map((A=>Lo(this.tensors[A],t)));return ks(g,0)}))}concat(A,g){if(A&&A!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${A}`);Mf(this.elementShape,g,"TensorList shape mismatch: ");const I=Kf(this.elementShape,this.tensors,g);return 0===this.size()?He([],[0].concat(I)):wi((()=>{const A=this.tensors.map((A=>Lo(A,I)));return Ho(A,0)}))}}const xf=async(A,g,I)=>{switch(A.op){case"If":case"StatelessIf":{const t=vG("thenBranch",A,g,I),C=vG("elseBranch",A,g,I),e=vG("cond",A,g,I),B=vG("args",A,g,I);return(await e.data())[0]?I.functionMap[t].executeFunctionAsync(B,I.tensorArrayMap,I.tensorListMap):I.functionMap[C].executeFunctionAsync(B,I.tensorArrayMap,I.tensorListMap)}case"While":case"StatelessWhile":{const t=vG("body",A,g,I),C=vG("cond",A,g,I),e=vG("args",A,g,I),B=await I.functionMap[C].executeFunctionAsync(e,I.tensorArrayMap,I.tensorListMap),i=e.map((A=>A.id));let Q=await B[0].data();B.forEach((A=>{A.kept||-1!==i.indexOf(A.id)||A.dispose()}));let o=e;for(;Q[0];){const A=o;o=await I.functionMap[t].executeFunctionAsync(o,I.tensorArrayMap,I.tensorListMap);const g=o.map((A=>A.id));A.forEach((A=>{A.kept||-1!==i.indexOf(A.id)||-1!==g.indexOf(A.id)||A.dispose()}));const e=await I.functionMap[C].executeFunctionAsync(o,I.tensorArrayMap,I.tensorListMap);Q=await e[0].data(),e.forEach((A=>{A.kept||-1!==i.indexOf(A.id)||-1!==g.indexOf(A.id)||A.dispose()}))}return o}case"LoopCond":return[XG(vG("pred",A,g,I))];case"Switch":{const t=vG("pred",A,g,I);let C=vG("data",A,g,I);return C.kept||(C=XG(C)),(await t.data())[0]?[void 0,C]:[C,void 0]}case"Merge":{const t=A.inputNames.find((A=>void 0!==VG(A,g,I)));if(t){return[XG(VG(t,g,I))]}return}case"Enter":{const t=vG("frameName",A,g,I),C=vG("tensor",A,g,I);return I.enterFrame(t),[XG(C)]}case"Exit":{const t=vG("tensor",A,g,I);return I.exitFrame(),[XG(t)]}case"NextIteration":{const t=vG("tensor",A,g,I);return I.nextIteration(),[XG(t)]}case"TensorArrayV3":{const t=vG("size",A,g,I),C=vG("dtype",A,g,I),e=vG("elementShape",A,g,I),B=vG("dynamicSize",A,g,I),i=vG("clearAfterRead",A,g,I),Q=vG("identicalElementShapes",A,g,I),o=vG("name",A,g,I),E=new Yf(o,C,t,e,Q,B,i);return I.addTensorArray(E),[E.idTensor,XQ(1)]}case"TensorArrayWriteV3":{const t=vG("tensorArrayId",A,g,I),C=vG("index",A,g,I),e=vG("tensor",A,g,I),B=I.getTensorArray(t.id);return B.write(C,e),[B.idTensor]}case"TensorArrayReadV3":{const t=vG("tensorArrayId",A,g,I),C=vG("index",A,g,I);return[I.getTensorArray(t.id).read(C)]}case"TensorArrayGatherV3":{const t=vG("tensorArrayId",A,g,I),C=vG("indices",A,g,I),e=vG("dtype",A,g,I);return[I.getTensorArray(t.id).gather(C,e)]}case"TensorArrayScatterV3":{const t=vG("tensorArrayId",A,g,I),C=vG("indices",A,g,I),e=vG("tensor",A,g,I),B=I.getTensorArray(t.id);return B.scatter(C,e),[B.idTensor]}case"TensorArrayConcatV3":{const t=vG("tensorArrayId",A,g,I),C=I.getTensorArray(t.id),e=vG("dtype",A,g,I);return[C.concat(e)]}case"TensorArraySplitV3":{const t=vG("tensorArrayId",A,g,I),C=vG("tensor",A,g,I),e=vG("lengths",A,g,I),B=I.getTensorArray(t.id);return B.split(e,C),[B.idTensor]}case"TensorArraySizeV3":{const t=vG("tensorArrayId",A,g,I);return[XQ(I.getTensorArray(t.id).size(),"int32")]}case"TensorArrayCloseV3":{const t=vG("tensorArrayId",A,g,I),C=I.getTensorArray(t.id);return C.clearAndClose(),[C.idTensor]}case"TensorListSetItem":{const t=vG("tensorListId",A,g,I),C=vG("index",A,g,I),e=vG("tensor",A,g,I),B=I.getTensorList(t.id);return B.setItem(C,e),[B.idTensor]}case"TensorListGetItem":{const t=vG("tensorListId",A,g,I),C=vG("index",A,g,I),e=vG("elementShape",A,g,I),B=vG("elementDType",A,g,I);return[I.getTensorList(t.id).getItem(C,e,B)]}case"TensorListScatterV2":case"TensorListScatter":{const t=vG("indices",A,g,I),C=function(A,g,I,t){if(g.length!==A.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${g.length} vs. ${A.shape[0]}`);const C=Math.max(...g);if(null!=t&&-1!==t&&C>=t)throw new Error(`Max index must be < array size (${C}  vs. ${t})`);const e=new Lf([],I,A.dtype,t),B=vs(A,0);return g.forEach(((A,g)=>{e.setItem(A,B[g])})),e}(vG("tensor",A,g,I),t,vG("elementShape",A,g,I),vG("numElements",A,g,I));return I.addTensorList(C),[C.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const t=vG("elementShape",A,g,I),C=vG("elementDType",A,g,I);let e;e="TensorListReserve"===A.op?"numElements":"maxNumElements";const B=vG(e,A,g,I),i=function(A,g,I,t){return new Lf([],A,g,t)}(t,C,0,"TensorListReserve"===A.op?-1:B);return I.addTensorList(i),[i.idTensor]}case"TensorListGather":{const t=vG("tensorListId",A,g,I),C=vG("indices",A,g,I),e=vG("elementShape",A,g,I),B=vG("elementDType",A,g,I);return[I.getTensorList(t.id).gather(C,B,e)]}case"TensorListStack":{const t=vG("tensorListId",A,g,I),C=vG("elementShape",A,g,I),e=vG("elementDType",A,g,I),B=vG("numElements",A,g,I);return[I.getTensorList(t.id).stack(C,e,B)]}case"TensorListFromTensor":{const t=function(A,g,I){const t=A.dtype;if(A.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${A.shape}`);if(A.dtype!==I)throw new Error(`Invalid data types; op elements ${A.dtype}, but list elements ${I}`);Mf(A.shape.slice(1),g,"TensorList shape mismatch: ");const C=vs(A);return new Lf(C,g,t)}(vG("tensor",A,g,I),vG("elementShape",A,g,I),vG("elementDType",A,g,I));return I.addTensorList(t),[t.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const t=vG("tensorListId",A,g,I),C=I.getTensorList(t.id),e=vG("dtype",A,g,I),B=vG("elementShape",A,g,I);return[C.concat(e,B)]}case"TensorListPushBack":{const t=vG("tensorListId",A,g,I),C=vG("tensor",A,g,I),e=I.getTensorList(t.id);return e.pushBack(C),[e.idTensor]}case"TensorListPopBack":{const t=vG("tensorListId",A,g,I),C=vG("elementShape",A,g,I),e=vG("elementDType",A,g,I);return[I.getTensorList(t.id).popBack(C,e)]}case"TensorListSplit":{const t=vG("tensor",A,g,I),C=vG("elementShape",A,g,I),e=function(A,g,I){let t=0;const C=g.map((A=>(t+=A,t)));if(t!==A.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${t}, and tensor's shape is: ${A.shape}`);const e=Jf(A.shape.slice(1),I),B=0===t?0:A.size/t,i=wi((()=>{const I=[];A=Lo(A,[1,t,B]);for(let t=0;t<g.length;++t){const i=[0,0===t?0:C[t-1],0],Q=[1,g[t],B];I[t]=Lo(To(A,i,Q),e)}return A.dispose(),I})),Q=new Lf([],I,A.dtype,g.length);for(let A=0;A<i.length;A++)Q.setItem(A,i[A]);return Q}(t,vG("lengths",A,g,I),C);return I.addTensorList(e),[e.idTensor]}case"TensorListLength":{const t=vG("tensorListId",A,g,I);return[XQ(I.getTensorList(t.id).size(),"int32")]}case"TensorListResize":{const t=vG("tensorListId",A,g,I),C=vG("size",A,g,I),e=I.getTensorList(t.id).resize(C);return I.addTensorList(e),[e.idTensor]}default:throw TypeError(`Node type ${A.op} is not implemented`)}};function bf(A,g,I){const[t,C]=vG("fusedOps",A,g,I),e="biasadd"===t,B=!e,i="prelu"===C,Q="fusedbatchnorm"===t,o=vG("numArgs",A,g,I);if(e){if(i&&2!==o)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&e&&1!==o)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(Q)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const E=vG("strides",A,g,I),n=PG(A,g,I),s=vG("dataFormat",A,g,I).toUpperCase(),a=vG("dilations",A,g,I);let[r,h]=vG("args",A,g,I);B&&(h=r,r=void 0);return{stride:E,pad:n,dataFormat:s,dilations:a,biasArg:r,preluArg:h,activationFunc:C,leakyreluAlpha:vG("leakyreluAlpha",A,g,I)}}function Hf(A,g,I){return{boxes:vG("boxes",A,g,I),scores:vG("scores",A,g,I),maxOutputSize:vG("maxOutputSize",A,g,I),iouThreshold:vG("iouThreshold",A,g,I),scoreThreshold:vG("scoreThreshold",A,g,I),softNmsSigma:vG("softNmsSigma",A,g,I)}}class qf{constructor(A,g){this.keyDType=A,this.valueDType=g,this.handle=XQ(0),this.tensorMap=new Map,pi(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((A=>A.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return XQ(this.size(),"int32")}async import(A,g){this.checkKeyAndValueTensor(A,g);const I=await A.data();return this.tensorMap.forEach((A=>A.dispose())),this.tensorMap.clear(),wi((()=>{const A=vs(g),t=I.length,C=A.length;CA(t===C,(()=>`The number of elements doesn't match, keys has ${t} elements, the values has ${C} elements.`));for(let g=0;g<t;g++){const t=I[g],C=A[g];pi(C),this.tensorMap.set(t,C)}return this.handle}))}async find(A,g){this.checkKeyAndValueTensor(A,g);const I=await A.data();return wi((()=>{const A=[];for(let t=0;t<I.length;t++){const C=I[t],e=this.findWithDefault(C,g);A.push(e)}return ks(A)}))}findWithDefault(A,g){const I=this.tensorMap.get(A);return null!=I?I:g}checkKeyAndValueTensor(A,g){if(A.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${A.dtype}`);if(g.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${g.dtype}`)}}function Tf(A,g,I,t,C=wi){const e=((A,g,I)=>{switch(A.category){case"arithmetic":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"BiasAdd":case"AddV2":case"Add":return[t.add(vG("a",A,g,I),vG("b",A,g,I))];case"AddN":return[t.addN(vG("tensors",A,g,I))];case"FloorMod":case"Mod":return[t.mod(vG("a",A,g,I),vG("b",A,g,I))];case"Mul":return[t.mul(vG("a",A,g,I),vG("b",A,g,I))];case"RealDiv":case"Div":return[t.div(vG("a",A,g,I),vG("b",A,g,I))];case"DivNoNan":return[t.divNoNan(vG("a",A,g,I),vG("b",A,g,I))];case"FloorDiv":return[t.floorDiv(vG("a",A,g,I),vG("b",A,g,I))];case"Sub":return[t.sub(vG("a",A,g,I),vG("b",A,g,I))];case"Minimum":return[t.minimum(vG("a",A,g,I),vG("b",A,g,I))];case"Maximum":return[t.maximum(vG("a",A,g,I),vG("b",A,g,I))];case"Pow":return[t.pow(vG("a",A,g,I),vG("b",A,g,I))];case"SquaredDifference":return[t.squaredDifference(vG("a",A,g,I),vG("b",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"basic_math":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Abs":case"ComplexAbs":return[t.abs(vG("x",A,g,I))];case"Acos":return[t.acos(vG("x",A,g,I))];case"Acosh":return[t.acosh(vG("x",A,g,I))];case"Asin":return[t.asin(vG("x",A,g,I))];case"Asinh":return[t.asinh(vG("x",A,g,I))];case"Atan":return[t.atan(vG("x",A,g,I))];case"Atan2":return[t.atan2(vG("x",A,g,I),vG("y",A,g,I))];case"Atanh":return[t.atanh(vG("x",A,g,I))];case"Ceil":return[t.ceil(vG("x",A,g,I))];case"Complex":return[t.complex(vG("real",A,g,I),vG("imag",A,g,I))];case"Cos":return[t.cos(vG("x",A,g,I))];case"Cosh":return[t.cosh(vG("x",A,g,I))];case"Elu":return[t.elu(vG("x",A,g,I))];case"Erf":return[t.erf(vG("x",A,g,I))];case"Exp":return[t.exp(vG("x",A,g,I))];case"Expm1":return[t.expm1(vG("x",A,g,I))];case"Floor":return[t.floor(vG("x",A,g,I))];case"Log":return[t.log(vG("x",A,g,I))];case"Log1p":return[t.log1p(vG("x",A,g,I))];case"Imag":return[t.imag(vG("x",A,g,I))];case"Neg":return[t.neg(vG("x",A,g,I))];case"Reciprocal":return[t.reciprocal(vG("x",A,g,I))];case"Real":return[t.real(vG("x",A,g,I))];case"Relu":return[t.relu(vG("x",A,g,I))];case"Round":return[t.round(vG("x",A,g,I))];case"Selu":return[t.selu(vG("x",A,g,I))];case"Sigmoid":return[t.sigmoid(vG("x",A,g,I))];case"Sin":return[t.sin(vG("x",A,g,I))];case"Sign":return[t.sign(vG("x",A,g,I))];case"Sinh":return[t.sinh(vG("x",A,g,I))];case"Softplus":return[t.softplus(vG("x",A,g,I))];case"Sqrt":return[t.sqrt(vG("x",A,g,I))];case"Square":return[t.square(vG("x",A,g,I))];case"Tanh":return[t.tanh(vG("x",A,g,I))];case"Tan":return[t.tan(vG("x",A,g,I))];case"ClipByValue":return[t.clipByValue(vG("x",A,g,I),vG("clipValueMin",A,g,I),vG("clipValueMax",A,g,I))];case"Relu6":return[t.relu6(vG("x",A,g,I))];case"Rsqrt":return[t.rsqrt(VG(A.inputNames[0],g,I))];case"Prod":return[t.prod(vG("x",A,g,I),vG("axes",A,g,I))];case"LeakyRelu":return[t.leakyRelu(vG("x",A,g,I),vG("alpha",A,g,I))];case"Prelu":return[t.prelu(vG("x",A,g,I),vG("alpha",A,g,I))];case"IsNan":return[t.isNaN(VG(A.inputNames[0],g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"control":return xf(A,g,I);case"convolution":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Conv1D":{const C=vG("stride",A,g,I),e=vG("pad",A,g,I),B=vG("dataFormat",A,g,I).toUpperCase(),i=vG("dilation",A,g,I);return[t.conv1d(vG("x",A,g,I),vG("filter",A,g,I),C,e,B,i)]}case"Conv2D":{const C=vG("strides",A,g,I),e=PG(A,g,I),B=vG("dataFormat",A,g,I).toUpperCase(),i=vG("dilations",A,g,I);return[t.conv2d(vG("x",A,g,I),vG("filter",A,g,I),[C[1],C[2]],e,B,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:C,pad:e,dataFormat:B,dilations:i,biasArg:Q,preluArg:o,activationFunc:E,leakyreluAlpha:n}=bf(A,g,I);return[t.fused.conv2d({x:vG("x",A,g,I),filter:vG("filter",A,g,I),strides:[C[1],C[2]],pad:e,dataFormat:B,dilations:[i[1],i[2]],bias:Q,activation:E,preluActivationWeights:o,leakyreluAlpha:n})]}case"FusedDepthwiseConv2dNative":{const{stride:C,pad:e,dataFormat:B,dilations:i,biasArg:Q,preluArg:o,activationFunc:E,leakyreluAlpha:n}=bf(A,g,I);return[t.fused.depthwiseConv2d({x:vG("x",A,g,I),filter:vG("filter",A,g,I),strides:[C[1],C[2]],pad:e,dataFormat:B,dilations:[i[1],i[2]],bias:Q,activation:E,preluActivationWeights:o,leakyreluAlpha:n})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const C=vG("outputShape",A,g,I),e=vG("strides",A,g,I),B=PG(A,g,I);return[t.conv2dTranspose(vG("x",A,g,I),vG("filter",A,g,I),C,[e[1],e[2]],B)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const C=vG("strides",A,g,I),e=PG(A,g,I),B=vG("dilations",A,g,I),i=vG("dataFormat",A,g,I).toUpperCase();return[t.depthwiseConv2d(vG("input",A,g,I),vG("filter",A,g,I),[C[1],C[2]],e,i,[B[1],B[2]])]}case"Conv3D":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("dataFormat",A,g,I).toUpperCase(),i=vG("dilations",A,g,I);return[t.conv3d(vG("x",A,g,I),vG("filter",A,g,I),[C[1],C[2],C[3]],e,B,[i[1],i[2],i[3]])]}case"AvgPool":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("kernelSize",A,g,I);return[t.avgPool(vG("x",A,g,I),[B[1],B[2]],[C[1],C[2]],e)]}case"MaxPool":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("kernelSize",A,g,I);return[t.maxPool(vG("x",A,g,I),[B[1],B[2]],[C[1],C[2]],e)]}case"MaxPoolWithArgmax":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("kernelSize",A,g,I),i=vG("includeBatchInIndex",A,g,I),{result:Q,indexes:o}=t.maxPoolWithArgmax(vG("x",A,g,I),[B[1],B[2]],[C[1],C[2]],e,i);return[Q,o]}case"AvgPool3D":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("kernelSize",A,g,I);return[t.avgPool3d(vG("x",A,g,I),[B[1],B[2],B[3]],[C[1],C[2],C[3]],e)]}case"MaxPool3D":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("kernelSize",A,g,I);return[t.maxPool3d(vG("x",A,g,I),[B[1],B[2],B[3]],[C[1],C[2],C[3]],e)]}case"Dilation2D":{const C=vG("strides",A,g,I),e=vG("pad",A,g,I),B=vG("dilations",A,g,I),i=C[1],Q=C[2],o=B[1],E=B[2];return[t.dilation2d(vG("x",A,g,I),vG("filter",A,g,I),[i,Q],e,[o,E],"NHWC")]}default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"creation":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Fill":{const C=vG("shape",A,g,I),e=vG("dtype",A,g,I),B=vG("value",A,g,I);return[t.fill(C,B,e)]}case"LinSpace":{const C=vG("start",A,g,I),e=vG("stop",A,g,I),B=vG("num",A,g,I);return[t.linspace(C,e,B)]}case"Multinomial":{const C=vG("logits",A,g,I),e=vG("numSamples",A,g,I),B=vG("seed",A,g,I);return[t.multinomial(C,e,B)]}case"OneHot":{const C=vG("indices",A,g,I),e=vG("depth",A,g,I),B=vG("onValue",A,g,I),i=vG("offValue",A,g,I),Q=vG("dtype",A,g,I);return[t.oneHot(C,e,B,i,Q)]}case"Ones":return[t.ones(vG("shape",A,g,I),vG("dtype",A,g,I))];case"OnesLike":return[t.onesLike(vG("x",A,g,I))];case"RandomStandardNormal":return[t.randomStandardNormal(vG("shape",A,g,I),vG("dtype",A,g,I),vG("seed",A,g,I))];case"RandomUniform":return[t.randomUniform(vG("shape",A,g,I),vG("minval",A,g,I),vG("maxval",A,g,I),vG("dtype",A,g,I))];case"Range":{const C=vG("start",A,g,I),e=vG("stop",A,g,I),B=vG("step",A,g,I);return[t.range(C,e,B,vG("dtype",A,g,I))]}case"TruncatedNormal":{const C=vG("shape",A,g,I),e=vG("mean",A,g,I),B=vG("stdDev",A,g,I),i=vG("seed",A,g,I);return[t.truncatedNormal(C,e,B,vG("dtype",A,g,I),i)]}case"Zeros":return[t.zeros(vG("shape",A,g,I),vG("dtype",A,g,I))];case"ZerosLike":return[t.zerosLike(vG("x",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"dynamic":return(async(A,g,I,t,C=V)=>{switch(A.op){case"NonMaxSuppressionV5":{const{boxes:t,scores:e,maxOutputSize:B,iouThreshold:i,scoreThreshold:Q,softNmsSigma:o}=Hf(A,g,I),E=await C.image.nonMaxSuppressionWithScoreAsync(t,e,B,i,Q,o);return[E.selectedIndices,E.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:t,scores:e,maxOutputSize:B,iouThreshold:i,scoreThreshold:Q}=Hf(A,g,I),o=vG("padToMaxOutputSize",A,g,I),E=await C.image.nonMaxSuppressionPaddedAsync(t,e,B,i,Q,o);return[E.selectedIndices,E.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:t,scores:e,maxOutputSize:B,iouThreshold:i,scoreThreshold:Q}=Hf(A,g,I);return[await C.image.nonMaxSuppressionAsync(t,e,B,i,Q)]}case"Where":{const t=C.cast(vG("condition",A,g,I),"bool"),e=[await C.whereAsync(t)];return t.dispose(),e}case"ListDiff":return C.setdiff1dAsync(vG("x",A,g,I),vG("y",A,g,I));default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I);case"evaluation":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"LowerBound":{const C=vG("sortedSequence",A,g,I),e=vG("values",A,g,I);return[t.lowerBound(C,e)]}case"TopKV2":{const C=vG("x",A,g,I),e=vG("k",A,g,I),B=vG("sorted",A,g,I),i=t.topk(C,e,B);return[i.values,i.indices]}case"UpperBound":{const C=vG("sortedSequence",A,g,I),e=vG("values",A,g,I);return[t.upperBound(C,e)]}case"Unique":{const C=vG("x",A,g,I),e=t.unique(C);return[e.values,e.indices]}case"UniqueV2":{const C=vG("x",A,g,I),e=vG("axis",A,g,I),B=t.unique(C,e);return[B.values,B.indices]}default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"image":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"ResizeBilinear":{const C=vG("images",A,g,I),e=vG("size",A,g,I),B=vG("alignCorners",A,g,I),i=vG("halfPixelCenters",A,g,I);return[t.image.resizeBilinear(C,[e[0],e[1]],B,i)]}case"ResizeNearestNeighbor":{const C=vG("images",A,g,I),e=vG("size",A,g,I),B=vG("alignCorners",A,g,I),i=vG("halfPixelCenters",A,g,I);return[t.image.resizeNearestNeighbor(C,[e[0],e[1]],B,i)]}case"CropAndResize":{const C=vG("image",A,g,I),e=vG("boxes",A,g,I),B=vG("boxInd",A,g,I),i=vG("cropSize",A,g,I),Q=vG("method",A,g,I),o=vG("extrapolationValue",A,g,I);return[t.image.cropAndResize(C,e,B,i,Q,o)]}case"ImageProjectiveTransformV3":{const C=vG("images",A,g,I),e=vG("transforms",A,g,I),B=vG("outputShape",A,g,I),i=vG("fillValue",A,g,I),Q=vG("interpolation",A,g,I),o=vG("fillMode",A,g,I);return[t.image.transform(C,e,Q.toLowerCase(),o.toLowerCase(),i,B)]}default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"graph":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Const":return g[A.name];case"PlaceholderWithDefault":const C=vG("default",A,g,I);return[VG(A.name,g,I)||C];case"Placeholder":return[VG(A.name,g,I)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[XG(vG("x",A,g,I))];case"IdentityN":return vG("x",A,g,I).map((A=>XG(A)));case"Shape":return[t.tensor1d(vG("x",A,g,I).shape,"int32")];case"ShapeN":return vG("x",A,g,I).map((A=>t.tensor1d(A.shape)));case"Size":return[t.scalar(vG("x",A,g,I).size,"int32")];case"Rank":return[t.scalar(vG("x",A,g,I).rank,"int32")];case"NoOp":return[t.scalar(1)];case"Print":const e=vG("x",A,g,I),B=vG("data",A,g,I),i=vG("message",A,g,I),Q=vG("summarize",A,g,I);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let A=0;A<B.length;A++)console.log(Array.prototype.slice.call(B[A].dataSync()).slice(0,Q));return[e];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"logical":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Equal":return[t.equal(vG("a",A,g,I),vG("b",A,g,I))];case"NotEqual":return[t.notEqual(vG("a",A,g,I),vG("b",A,g,I))];case"Greater":return[t.greater(vG("a",A,g,I),vG("b",A,g,I))];case"GreaterEqual":return[t.greaterEqual(vG("a",A,g,I),vG("b",A,g,I))];case"Less":return[t.less(vG("a",A,g,I),vG("b",A,g,I))];case"LessEqual":return[t.lessEqual(vG("a",A,g,I),vG("b",A,g,I))];case"LogicalAnd":return[t.logicalAnd(vG("a",A,g,I),vG("b",A,g,I))];case"LogicalNot":return[t.logicalNot(vG("a",A,g,I))];case"LogicalOr":return[t.logicalOr(vG("a",A,g,I),vG("b",A,g,I))];case"Select":case"SelectV2":return[t.where(vG("condition",A,g,I),vG("a",A,g,I),vG("b",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"matrices":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[t.matMul(vG("a",A,g,I),vG("b",A,g,I),vG("transposeA",A,g,I),vG("transposeB",A,g,I))];case"Einsum":return[t.einsum(vG("equation",A,g,I),...vG("tensors",A,g,I))];case"Transpose":return[t.transpose(vG("x",A,g,I),vG("perm",A,g,I))];case"_FusedMatMul":const[C,e]=vG("fusedOps",A,g,I),B="biasadd"===C,i="prelu"===e,Q=vG("numArgs",A,g,I),o=vG("leakyreluAlpha",A,g,I);if(B){if(i&&2!==Q)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==Q)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[E,n]=vG("args",A,g,I);return[t.fused.matMul({a:vG("a",A,g,I),b:vG("b",A,g,I),transposeA:vG("transposeA",A,g,I),transposeB:vG("transposeB",A,g,I),bias:E,activation:e,preluActivationWeights:n,leakyreluAlpha:o})];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"normalization":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"EuclideanNorm":return[t.euclideanNorm(vG("x",A,g,I),vG("axis",A,g,I),vG("keepDims",A,g,I))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[t.batchNorm(vG("x",A,g,I),vG("mean",A,g,I),vG("variance",A,g,I),vG("offset",A,g,I),vG("scale",A,g,I),vG("epsilon",A,g,I))];case"LRN":return[t.localResponseNormalization(vG("x",A,g,I),vG("radius",A,g,I),vG("bias",A,g,I),vG("alpha",A,g,I),vG("beta",A,g,I))];case"Softmax":return[t.softmax(vG("x",A,g,I))];case"LogSoftmax":return[t.logSoftmax(vG("x",A,g,I))];case"SparseToDense":return[t.sparseToDense(vG("sparseIndices",A,g,I),vG("outputShape",A,g,I),vG("sparseValues",A,g,I),vG("defaultValue",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"reduction":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Max":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.max(vG("x",A,g,I),C,e)]}case"Mean":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.mean(vG("x",A,g,I),C,e)]}case"Min":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.min(vG("x",A,g,I),C,e)]}case"Sum":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.sum(vG("x",A,g,I),C,e)]}case"All":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.all(vG("x",A,g,I),C,e)]}case"Any":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.any(vG("x",A,g,I),C,e)]}case"ArgMax":{const C=vG("axis",A,g,I);return[t.argMax(vG("x",A,g,I),C)]}case"ArgMin":{const C=vG("axis",A,g,I);return[t.argMin(vG("x",A,g,I),C)]}case"Prod":{const C=vG("axis",A,g,I),e=vG("keepDims",A,g,I);return[t.prod(vG("x",A,g,I),C,e)]}case"Cumprod":{const C=vG("axis",A,g,I),e=vG("exclusive",A,g,I),B=vG("reverse",A,g,I);return[t.cumprod(vG("x",A,g,I),C,e,B)]}case"Cumsum":{const C=vG("axis",A,g,I),e=vG("exclusive",A,g,I),B=vG("reverse",A,g,I);return[t.cumsum(vG("x",A,g,I),C,e,B)]}case"Bincount":const C=vG("x",A,g,I),e=vG("weights",A,g,I),B=vG("size",A,g,I);return[t.bincount(C,e,B)];case"DenseBincount":{const C=vG("x",A,g,I),e=vG("weights",A,g,I),B=vG("size",A,g,I),i=vG("binaryOutput",A,g,I);return[t.denseBincount(C,e,B,i)]}default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"slice_join":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"ConcatV2":case"Concat":{const C=vG("n",A,g,I),e=vG("axis",A,g,I);let B=vG("tensors",A,g,I);return B=B.slice(0,C),[t.concat(B,e)]}case"Gather":{const C=vG("x",A,g,I),e=vG("indices",A,g,I);return[t.gather(C,t.cast(e,"int32"),0)]}case"GatherV2":{const C=vG("axis",A,g,I),e=vG("batchDims",A,g,I),B=vG("x",A,g,I),i=vG("indices",A,g,I);return[t.gather(B,t.cast(i,"int32"),C,e)]}case"Reverse":{const C=vG("dims",A,g,I),e=[];for(let A=0;A<C.length;A++)C[A]&&e.push(A);const B=vG("x",A,g,I);return[t.reverse(B,e)]}case"ReverseV2":{const C=vG("axis",A,g,I),e=vG("x",A,g,I);return[t.reverse(e,C)]}case"Slice":{const C=vG("begin",A,g,I),e=vG("size",A,g,I);return[t.slice(vG("x",A,g,I),C,e)]}case"StridedSlice":{const C=vG("begin",A,g,I),e=vG("end",A,g,I),B=vG("strides",A,g,I),i=vG("beginMask",A,g,I),Q=vG("endMask",A,g,I),o=vG("ellipsisMask",A,g,I),E=vG("newAxisMask",A,g,I),n=vG("shrinkAxisMask",A,g,I),s=vG("x",A,g,I);return[t.stridedSlice(s,C,e,B,i,Q,o,E,n)]}case"Pack":return wi((()=>{const C=vG("axis",A,g,I),e=vG("tensors",A,g,I),B=e[0].shape,i=t.squeeze(e[0]).shape,Q=e.map((A=>{const g=EA(A.shape,B);if(!g&&!EA(t.squeeze(A).shape,i))throw new Error("the input tensors shape does not match");return g?A:t.reshape(A,B)}));return[t.stack(Q,C)]}));case"Unpack":{const C=vG("axis",A,g,I),e=vG("tensor",A,g,I);return t.unstack(e,C)}case"Tile":{const C=vG("reps",A,g,I);return[t.tile(vG("x",A,g,I),C)]}case"Split":case"SplitV":{const C=vG("axis",A,g,I),e=vG("numOrSizeSplits",A,g,I),B=vG("x",A,g,I);return t.split(B,e,C)}case"ScatterNd":{const C=vG("indices",A,g,I),e=vG("values",A,g,I),B=vG("shape",A,g,I);return[t.scatterND(C,e,B)]}case"GatherNd":{const C=vG("x",A,g,I),e=vG("indices",A,g,I);return[t.gatherND(C,e)]}case"SparseToDense":{const C=vG("sparseIndices",A,g,I),e=vG("outputShape",A,g,I),B=vG("sparseValues",A,g,I),i=vG("defaultValue",A,g,I);return[t.sparseToDense(C,B,e,B.dtype===i.dtype?i:t.cast(i,B.dtype))]}default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"sparse":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"SparseFillEmptyRows":{const{outputIndices:C,outputValues:e,emptyRowIndicator:B,reverseIndexMap:i}=t.sparse.sparseFillEmptyRows(vG("indices",A,g,I),vG("values",A,g,I),vG("denseShape",A,g,I),vG("defaultValue",A,g,I));return[C,e,B,i]}case"SparseReshape":{const{outputIndices:C,outputShape:e}=t.sparse.sparseReshape(vG("inputIndices",A,g,I),vG("inputShape",A,g,I),vG("newShape",A,g,I));return[C,e]}case"SparseSegmentMean":return[t.sparse.sparseSegmentMean(vG("data",A,g,I),vG("indices",A,g,I),vG("segmentIds",A,g,I))];case"SparseSegmentSum":return[t.sparse.sparseSegmentSum(vG("data",A,g,I),vG("indices",A,g,I),vG("segmentIds",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"spectral":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"FFT":return[t.fft(vG("x",A,g,I))];case"IFFT":return[t.ifft(vG("x",A,g,I))];case"RFFT":return[t.rfft(vG("x",A,g,I))];case"IRFFT":return[t.irfft(vG("x",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"string":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"StringNGrams":{const{nGrams:C,nGramsSplits:e}=t.string.stringNGrams(vG("data",A,g,I),vG("dataSplits",A,g,I),vG("separator",A,g,I),vG("nGramWidths",A,g,I),vG("leftPad",A,g,I),vG("rightPad",A,g,I),vG("padWidth",A,g,I),vG("preserveShortSequences",A,g,I));return[C,e]}case"StringSplit":{const{indices:C,values:e,shape:B}=t.string.stringSplit(vG("input",A,g,I),vG("delimiter",A,g,I),vG("skipEmpty",A,g,I));return[C,e,B]}case"StringToHashBucketFast":return[t.string.stringToHashBucketFast(vG("input",A,g,I),vG("numBuckets",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"transformation":return C((()=>((A,g,I,t=V)=>{switch(A.op){case"Cast":return[t.cast(vG("x",A,g,I),vG("dtype",A,g,I))];case"ExpandDims":{const C=vG("axis",A,g,I);return[t.expandDims(vG("x",A,g,I),C)]}case"Squeeze":{const C=vG("axis",A,g,I);return[t.squeeze(vG("x",A,g,I),C)]}case"Reshape":return[t.reshape(vG("x",A,g,I),vG("shape",A,g,I))];case"MirrorPad":return[t.mirrorPad(vG("x",A,g,I),vG("padding",A,g,I),vG("mode",A,g,I))];case"PadV2":case"Pad":return[t.pad(vG("x",A,g,I),vG("padding",A,g,I),vG("constantValue",A,g,I))];case"SpaceToBatchND":{const C=vG("blockShape",A,g,I),e=vG("paddings",A,g,I);return[t.spaceToBatchND(vG("x",A,g,I),C,e)]}case"BatchToSpaceND":{const C=vG("blockShape",A,g,I),e=vG("crops",A,g,I);return[t.batchToSpaceND(vG("x",A,g,I),C,e)]}case"DepthToSpace":{const C=vG("blockSize",A,g,I),e=vG("dataFormat",A,g,I).toUpperCase();return[t.depthToSpace(vG("x",A,g,I),C,e)]}case"BroadcastTo":return[t.broadcastTo(vG("x",A,g,I),vG("shape",A,g,I))];case"BroadcastArgs":return[t.broadcastArgs(vG("s0",A,g,I),vG("s1",A,g,I))];default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I)));case"hash_table":return(async(A,g,I,t)=>{switch(A.op){case"HashTable":case"HashTableV2":{const C=vG("keyDType",A,g,I),e=vG("valueDType",A,g,I),B=new qf(C,e);return t.addHashTable(A.name,B),[B.handle]}case"LookupTableImport":case"LookupTableImportV2":{const C=vG("tableHandle",A,g,I,t),e=vG("keys",A,g,I),B=vG("values",A,g,I),i=t.getHashTableById(C.id);return[await i.import(e,B)]}case"LookupTableFind":case"LookupTableFindV2":{const C=vG("tableHandle",A,g,I,t),e=vG("keys",A,g,I),B=vG("defaultValue",A,g,I),i=t.getHashTableById(C.id);return[await i.find(e,B)]}case"LookupTableSize":case"LookupTableSizeV2":{const C=vG("tableHandle",A,g,I,t);return[t.getHashTableById(C.id).tensorSize()]}default:throw TypeError(`Node type ${A.op} is not implemented`)}})(A,g,I,t);case"custom":const e=qG(A.op);if(e&&e.customExecutor)return e.customExecutor(new Sf(A,g,I));throw TypeError(`Custom op ${A.op} is not registered.`);default:throw TypeError(`Unknown op '${A.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(A,g,I);return vA(e)?e.then((A=>[].concat(A))):[].concat(e)}class vf{constructor(A={},g={},I={},t={}){this.weightMap=A,this.tensorArrayMap=g,this.tensorListMap=I,this.functionMap=t,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(A,g){return{id:A,frameName:g,iterationId:0}}set currentContext(A){this.contexts!==A&&(this.contexts=A,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const A=[];for(let g=0;g<this.contexts.length-1;g++){const I=this.contexts.slice(0,this.contexts.length-g);A.push(this.contextIdforContexts(I))}A.push(""),this._currentContextIds=A}contextIdforContexts(A){return A?A.map((A=>0===A.id&&0===A.iterationId?"":`${A.frameName}-${A.iterationId}`)).join("/"):""}enterFrame(A){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,A)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const A=Object.assign({},this.contexts[this.contexts.length-1]);A.iterationId+=1,A.id=this.lastId,this.contexts.splice(-1,1,A),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(A){return this.weightMap[A]}addTensorArray(A){this.tensorArrayMap[A.id]=A}getTensorArray(A){return this.tensorArrayMap[A]}addTensorList(A){this.tensorListMap[A.id]=A}getTensorList(A){return this.tensorListMap[A]}dispose(A){for(const g in this.tensorArrayMap)this.tensorArrayMap[g].clearAndClose(A);for(const g in this.tensorListMap)this.tensorListMap[g].clearAndClose(A)}}function Vf(A,g,I,t){const C=new Set,e=[];let B=null,i=null;const Q=new Set,o=Object.keys(A).map((A=>ZG(A)[0]));let E=[];null!=t&&(E=t.map((A=>ZG(A.name)[0])));const n=[...g];for(;n.length>0;){const A=n.pop();(Pf(A)||Xf(A)||jf(A))&&null==B&&(B=A,i=B.children.map((A=>A.name)).filter((A=>C.has(A)))),C.add(A.name),null==I[A.name]&&(-1===o.indexOf(A.name)&&-1===E.indexOf(A.name)&&(0!==A.inputs.length?A.inputs.forEach((A=>{Q.has(A.name)||(Q.add(A.name),n.push(A))})):e.push(A.name)))}return{inputs:A,outputs:g,usedNodes:C,missingInputs:e,dynamicNode:B,syncInputs:i}}const Wf=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Of=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Zf=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Pf(A){return Wf.indexOf(A.op)>=0}function Xf(A){return Of.indexOf(A.op)>=0}function jf(A){return Zf.indexOf(A.op)>=0}class zf{constructor(A,g){this.graph=A,this.parent=g,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=A.outputs,this._inputs=A.inputs,this._initNodes=A.initNodes,this._signature=A.signature,this._functions=A.functions,null!=A.functions&&Object.keys(A.functions).forEach((g=>{this._functionExecutorMap[g]=new zf(A.functions[g],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(A){const g=Object.keys(A).map((g=>A[g].map((A=>A.id))));this._weightIds=[].concat(...g),this._weightMap=A}set resourceManager(A){this._resourceManager=A}get inputs(){return this._inputs.map((A=>({name:A.name,shape:A.attrParams.shape?A.attrParams.shape.value:void 0,dtype:A.attrParams.dtype?A.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((A=>({name:A.name,shape:A.attrParams.shape?A.attrParams.shape.value:void 0,dtype:A.attrParams.dtype?A.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((A=>A.signatureKey||A.name))}get outputNodes(){return this._outputs.map((A=>{const g=A.signatureKey||A.name;return A.defaultOutput?`${g}:${A.defaultOutput}`:g}))}get functions(){return Object.keys(this._functions).reduce(((A,g)=>(A[g]=this._functions[g].signature,A)),{})}getCompilationKey(A,g){const I=A.map((A=>A.name)).sort(),t=g.map((A=>A.name)).sort();return I.join(this.SEPERATOR)+"--"+t.join(this.SEPERATOR)}compile(A,g){const I=Vf(A,g,this.weightMap,this._initNodes),{missingInputs:t,dynamicNode:C,syncInputs:e}=I;if(null!=C)throw new Error(`This execution contains the node '${C.name}', which has the dynamic op '${C.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${e}]`);if(t.length>0){const I=g.map((A=>A.name)),C=Object.keys(A);throw new Error(`Cannot compute the outputs [${I}] from the provided inputs [${C}]. Missing the following inputs: [${t}]`)}return function(A,g,I){const{usedNodes:t,inputs:C}=I,e=[],B=Object.keys(C).map((A=>ZG(A)[0])).map((g=>A.nodes[g])),i=A.initNodes;B.forEach((A=>{t.has(A.name)&&e.push(A)})),A.weights.forEach((A=>{t.has(A.name)&&e.push(A)})),null!=i&&i.forEach((A=>{t.has(A.name)&&e.push(A)}));const Q=new Set,o=[];for(;e.length>0;){const A=e.pop();Q.add(A.name),g[A.name]||o.push(A),A.children.forEach((A=>{!Q.has(A.name)&&t.has(A.name)&&A.inputs.every((A=>Q.has(A.name)))&&e.push(A)}))}return o}(this.graph,this.weightMap,I)}execute(A,g){A=this.mapInputs(A);const I=Object.keys(A).sort();this.checkInputs(A),this.checkInputShapeAndType(A),g=this.mapOutputs(g),this.checkOutputs(g);const t=I.map((A=>this.graph.nodes[ZG(A)[0]])),C=g.map((A=>ZG(A)[0]));let e=C.map((A=>this.graph.nodes[A]));this.resetIntermediateTensors(),0===e.length&&(e=this._outputs);const B=this.getCompilationKey(t,e);let i=this.compiledMap.get(B);null==i&&(i=this.compile(A,e),this.compiledMap.set(B,i));const Q={},o={};return wi((()=>{const I=new vf(this.weightMap,Q,o,this.functionExecutorMap),t=Object.assign({},this.weightMap);Object.keys(A).forEach((g=>{const[I,C]=ZG(g),e=[];e[C]=A[g],t[I]=e}));const e=this.getFrozenTensorIds(t),B={};for(let A=0;A<i.length;A++){const g=i[A];if(!t[g.name]){const A=Tf(g,t,I,this._resourceManager);if(vA(A))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);t[g.name]=A,this.checkTensorForDisposal(g.name,g,t,I,e,C,B)}}return null==this.parent&&I.dispose(e),g.map((A=>VG(A,t,I)))}))}getFrozenTensorIds(A){const g=[].concat.apply([],Object.keys(A).map((g=>A[g])).map((A=>A.map((A=>A.id)))));return new Set(g)}checkTensorForDisposal(A,g,I,t,C,e,B){"control"!==g.category&&-1===e.indexOf(A)&&(I[A].forEach((A=>{null!=A&&(B[A.id]=(B[A.id]||0)+g.children.length)})),g.inputs.forEach((A=>{if("control"!==A.category){const e=function(A,g,I){return g[OG(A,I.currentContextId)]}(A.name,I,t);null!=e&&e.forEach((A=>{if(A&&!A.kept&&!C.has(A.id)){const I=B[A.id];if(1===I){if(this.keepTensorForDebug){const[I,C]=WG(g.name,t);this.intermediateTensors[I]||(this.intermediateTensors[I]=[]),this.intermediateTensors[I][C]=A}else A.dispose();delete B[A.id]}else null!=I&&B[A.id]--}}))}})))}async executeAsync(A,g){return this._executeAsync(A,g)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((A=>this.intermediateTensors[A].forEach((A=>A.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((A=>{this.tensorsMap[A].forEach((A=>{!A||A.kept||A.isDisposed||this.keepIds.has(A.id)||A.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const A in this.intermediateTensors)this.intermediateTensors[A].forEach((A=>A.dispose())),delete this.intermediateTensors[A]}async _executeAsync(A,g,I=!1,t={},C={}){I||(A=this.mapInputs(A),this.checkInputs(A),this.checkInputShapeAndType(A),g=this.mapOutputs(g),this.checkOutputs(g));try{this.keepTensorForDebug=ZA().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(A){console.warn(A.message)}this.resetIntermediateTensors();const e=new vf(this.weightMap,t,C,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(A,e,g,I);const B=g.map((A=>VG(A,this.tensorsMap,e))),i=B.map((A=>A.id)),Q=Object.keys(A).map((g=>A[g].id));return this.keepIds=new Set([...i,...Q,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&e.dispose(this.keepIds),B}async executeFunctionAsync(A,g,I){const t=A.reduce(((A,g,I)=>(A[this.inputs[I].name]=g,A)),{});return this._executeAsync(t,this.outputNodes,!0,g,I)}async executeWithControlFlow(A,g,I,t){const C=Object.keys(A),e=C.map((A=>this.graph.nodes[ZG(A)[0]])),B=I.map((A=>ZG(A)[0]));let i=B.map((A=>this.graph.nodes[A]));0===i.length&&(i=this._outputs);const{usedNodes:Q,missingInputs:o,dynamicNode:E,syncInputs:n}=Vf(A,i,this.weightMap,this._initNodes),s=[...e,...this.graph.weights,...this._initNodes||[]].map((A=>({node:A,contexts:g.currentContext}))),a=Object.assign({},this.weightMap);Object.keys(A).forEach((g=>{const[I,t]=ZG(g),C=[];C[t]=A[g],a[I]=C}));const r={},h=this.getFrozenTensorIds(a),c={};for(;s.length>0;){const A=this.processStack(e,s,g,a,c,h,B,r,Q);await Promise.all(A)}null!=E||t||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const l=i.filter((A=>!Pf(A)&&!VG(A.name,a,g))).map((A=>A.name));if(l.length>0){let A="";throw null!=E&&(A=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${n}]`),new Error(`Cannot compute the outputs [${l}] from the provided inputs [${C}]. Consider providing the following inputs: [${o}]. ${A}`)}return a}processStack(A,g,I,t,C,e,B,i,Q){const o=[];for(;g.length>0;){const A=g.pop();I.currentContext=A.contexts;let E="";if("Enter"===A.node.op&&vG("isConstant",A.node,t,I)&&([E]=WG(A.node.name,I)),null==t[A.node.name]){const n=Tf(A.node,t,I,this._resourceManager);E||([E]=WG(A.node.name,I));const s=I.currentContext;vA(n)?o.push(n.then((o=>(t[E]=o,I.currentContext=s,this.checkTensorForDisposal(E,A.node,t,I,e,B,i),this.processChildNodes(A.node,g,I,t,C,Q),o)))):(t[E]=n,this.checkTensorForDisposal(E,A.node,t,I,e,B,i),this.processChildNodes(A.node,g,I,t,C,Q))}else this.processChildNodes(A.node,g,I,t,C,Q)}return o}processChildNodes(A,g,I,t,C,e){A.children.forEach((A=>{const[B]=WG(A.name,I);!C[B]&&e.has(A.name)&&("Merge"===A.op?A.inputNames.some((A=>!!VG(A,t,I)))&&(C[B]=!0,g.push({contexts:I.currentContext,node:A})):A.inputNames.every((A=>!!VG(A,t,I)))&&(C[B]=!0,g.push({contexts:I.currentContext,node:A})))}))}dispose(){Object.keys(this.weightMap).forEach((A=>this.weightMap[A].forEach((A=>A.dispose()))))}checkInputShapeAndType(A){Object.keys(A).forEach((g=>{const I=A[g],[t]=ZG(g),C=this.graph.nodes[t];if(C.attrParams.shape&&C.attrParams.shape.value){const A=C.attrParams.shape.value;CA(A.length===I.shape.length&&I.shape.every(((g,I)=>-1===A[I]||A[I]===g)),(()=>`The shape of dict['${C.name}'] provided in model.execute(dict) must be [${A}], but was [${I.shape}]`))}C.attrParams.dtype&&C.attrParams.dtype.value&&CA(I.dtype===C.attrParams.dtype.value,(()=>`The dtype of dict['${C.name}'] provided in model.execute(dict) must be ${C.attrParams.dtype.value}, but was ${I.dtype}`))}))}mapInputs(A){const g={};for(const I in A)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[I]){g[this._signature.inputs[I].name]=A[I]}else g[I]=A[I];return g}checkInputs(A){const g=Object.keys(A).filter((A=>{const[g]=ZG(A);return null==this.graph.nodes[g]}));if(g.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${g}] that are not part of graph`)}mapOutputs(A){return A.map((A=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[A]){return this._signature.outputs[A].name}return A}),{})}checkOutputs(A){A.forEach((A=>{const[g]=ZG(A);if(!this.graph.nodes[g])throw new Error(`The output '${A}' is not found in the graph`)}))}}class _f{constructor(A={},g={}){this.hashTableNameToHandle=A,this.hashTableMap=g}addHashTable(A,g){this.hashTableNameToHandle[A]=g.handle,this.hashTableMap[g.id]=g}getHashTableHandleByName(A){return this.hashTableNameToHandle[A]}getHashTableById(A){return this.hashTableMap[A]}dispose(){for(const A in this.hashTableMap)this.hashTableMap[A].clearAndClose(),delete this.hashTableMap[A];for(const A in this.hashTableNameToHandle)this.hashTableNameToHandle[A].dispose(),delete this.hashTableNameToHandle[A]}}const $f="?tfjs-format=file",AN="model.json";class gN{constructor(A,g={},I=B){this.modelUrl=A,this.loadOptions=g,this.version="n/a",this.io=I,null==g&&(this.loadOptions={}),this.resourceManager=new _f}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const A=this.modelUrl;if(null!=A.load)this.handler=A;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(A,this.loadOptions);else{const g=this.io.getLoadHandlers(A,this.loadOptions);if(0===g.length)g.push(this.io.browserHTTPRequest(A,this.loadOptions));else if(g.length>1)throw new Error(`Found more than one (${g.length}) load handlers for URL '${[A]}'`);this.handler=g[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const A=this.handler.load();return vA(A)?A.then((A=>this.loadSync(A))):this.loadSync(A)}loadSync(A){this.artifacts=A;const g=this.artifacts.modelTopology;let I=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const A=this.artifacts.userDefinedMetadata;null!=A.signature&&(I=A.signature),null!=A.structuredOutputKeys&&(this.structuredOutputKeys=A.structuredOutputKeys)}this.signature=I,this.version=`${g.versions.producer}.${g.versions.minConsumer}`;const t=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new zf(cf.Instance.transformGraph(g,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=A.modelInitializer&&null!=A.modelInitializer.node){const g=cf.Instance.transformGraph(A.modelInitializer);this.initializer=new zf(g),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(A,g){if("string"==typeof A){const g=this.io.getSaveHandlers(A);if(0===g.length)throw new Error(`Cannot find any save handlers for URL '${A}'`);if(g.length>1)throw new Error(`Found more than one (${g.length}) save handlers for URL '${A}'`);A=g[0]}if(null==A.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return A.save(this.artifacts)}predict(A,g){const I=this.execute(A,this.outputNodes);if(this.structuredOutputKeys){const A={};return(I instanceof Ce?[I]:I).forEach(((g,I)=>A[this.structuredOutputKeys[I]]=g)),A}return I}normalizeInputs(A){if(!(A instanceof Ce||Array.isArray(A)))return A;if((A=Array.isArray(A)?A:[A]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${A.length} input tensors.`);return this.inputNodes.reduce(((g,I,t)=>(g[I]=A[t],g)),{})}normalizeOutputs(A){return A=A||this.outputNodes,Array.isArray(A)?A:[A]}execute(A,g){A=this.normalizeInputs(A),g=this.normalizeOutputs(g);const I=this.executor.execute(A,g);return I.length>1?I:I[0]}async executeAsync(A,g){A=this.normalizeInputs(A),g=this.normalizeOutputs(g);const I=await this.executor.executeAsync(A,g);return I.length>1?I:I[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(A){return Object.keys(A).reduce(((g,I)=>(g[I]=[A[I]],g)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function IN(A,g={},I=B){if(null==A)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==g&&(g={}),g.fromTFHub&&"string"==typeof A&&(A=function(A){A.endsWith("/")||(A+="/");return`${A}${AN}${$f}`}(A));const t=new gN(A,g,I);return await t.load(),t}function tN(A){if(null==A)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let g;if(A instanceof Array){const[I,t]=A;if(!I)throw new Error("modelJSON must be the first element of the array");if(!(t&&t instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in I))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in I))throw new Error("Model JSON is missing 'weightsManifest'");g=ii(ze(I,AB(I.weightsManifest),t))}else if("load"in A)g=A;else{if(!("modelTopology"in A&&"weightSpecs"in A&&"weightData"in A))throw new Error("Unknown model format");g=ii(A)}const I=new gN(g);return I.load(),I}const CN="3.21.0";function eN(A,g,I=new Map,t=new Set){if(null==A)return null;if("function"==typeof Blob&&A instanceof Blob)return A.slice();if(t.has(A))throw new Error("Circular references are not supported.");if(I.has(A))return I.get(A);const C=g(A);if(C.recurse&&null!==C.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(C.recurse){if(EN(A)){const C=Array.isArray(A)?[]:{};t.add(A);for(const e in A){const B=eN(A[e],g,I,t);C[e]=B}return t.delete(A),A.__proto__&&(C.__proto__=A.__proto__),C}throw new Error(`Can't recurse into non-iterable type: ${A}`)}return I.set(A,C.value),C.value}function BN(A,g=QN){return iN(A,g)}function iN(A,g,I=new Set){const t=A[0];if(I.has(t))throw new Error("Circular references are not supported.");const C=g(A);if(C.recurse&&null!==C.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(C.recurse){if(EN(t)){const C=Array.isArray(t)?[]:{};I.add(t);for(const e in t){const t=iN(A.map((A=>A[e])),g,I);C[e]=t}return I.delete(t),C}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return C.value}function QN(A){return null===A?null:EN(A[0])?{value:null,recurse:!0}:{value:A,recurse:!1}}async function oN(A,g){const I=new Map;eN(A,g,I);for(const A of Array.from(I.keys())){const g=I.get(A);if(vA(g)){const t=await g;I.set(A,t)}}return eN(A,g,I)}function EN(A){let g=!1;if(ZA().get("IS_BROWSER"))g=A instanceof TextDecoder;else{const{StringDecoder:t}=I(977);g=A instanceof t}return null!=A&&!ArrayBuffer.isView(A)&&(Array.isArray(A)||"object"==typeof A&&!(A instanceof Ce)&&!(A instanceof Promise)&&!g)}function nN(A){return function(A,g){return eN(A,g)}(A,sN)}function sN(A){return A instanceof Ce?{value:A.clone(),recurse:!1}:EN(A)?{value:null,recurse:!0}:{value:A,recurse:!1}}class aN{constructor(A){if(this.capacity=A,this.begin=0,this.end=0,null==A)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(A<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(A),this.doubledCapacity=2*A}wrap(A){for(;A<0;)A+=this.doubledCapacity;return A%this.doubledCapacity}get(A){if(A<0)throw new RangeError("Can't get item at a negative index.");return this.data[A%this.capacity]}set(A,g){if(A<0)throw new RangeError("Can't set item at a negative index.");this.data[A%this.capacity]=g}length(){let A=this.end-this.begin;return A<0&&(A=this.doubledCapacity+A),A}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(A){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,A),this.end=this.wrap(this.end+1)}pushAll(A){for(const g of A)this.push(g)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const A=this.get(this.end);return this.set(this.end,void 0),A}unshift(A){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,A)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const A=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),A}shuffleExcise(A){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const g=this.wrap(this.begin+A),I=this.get(g);return this.set(g,this.pop()),I}}class rN extends aN{constructor(){super(rN.INITIAL_CAPACITY)}isFull(){return!1}push(A){super.isFull()&&this.expand(),super.push(A)}unshift(A){super.isFull()&&this.expand(),super.unshift(A)}expand(){const A=2*this.capacity,g=new Array(A),I=this.length();for(let A=0;A<I;A++)g[A]=this.get(this.wrap(this.begin+A));this.data=g,this.capacity=A,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=I}}function hN(A){return new uN(A)}function cN(A){return new wN(A)}function lN(A,g){return new SN(A,g)}rN.INITIAL_CAPACITY=32;class DN{async toArray(){const A=[];let g=await this.next();for(;!g.done;)A.push(g.value),g=await this.next();return A}async toArrayForTest(){const A=this.prefetch(100),g=[];let I=await A.next();for(;!I.done;)g.push(I.value),I=await A.next();return g}async resolveFully(){let A=await this.next();for(;!A.done;)A=await this.next()}async resolveWhile(A){let g=await this.next(),I=A(g.value);for(;!g.done&&I;)g=await this.next(),I=A(g.value)}handleErrors(A){return new FN(this,A)}filter(A){return new fN(this,A)}map(A){return new NN(this,A)}mapAsync(A){return new RN(this,A)}serialMapAsync(A){return new RN(this,A).serial()}flatmap(A){return new kN(this,A)}async forEachAsync(A){return this.map(A).resolveFully()}async serialForEach(A){return this.serialMapAsync(A).resolveWhile((A=>!0===A))}rowMajorBatch(A,g=!0){return new GN(this,A,g)}columnMajorBatch(A,g=!0,I=QN){return this.rowMajorBatch(A,g).map((A=>BN(A,I)))}concatenate(A,g){return new SN(hN([this,A]),g)}take(A){return A<0||null==A?this:new yN(this,A)}skip(A){return A<0||null==A?this:new pN(this,A)}prefetch(A){return new KN(this,A)}shuffle(A,g){return new JN(this,A,g)}serial(){return new dN(this)}}class uN extends DN{constructor(A){super(),this.items=A,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const A=this.items[this.trav];return this.trav++,{value:nN(A),done:!1}}}class wN extends DN{constructor(A){super(),this.nextFn=A}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(A){throw A.message=`Error thrown while iterating through a dataset: ${A.message}`,A}}}class dN extends DN{constructor(A){super(),this.upstream=A,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class pN extends DN{constructor(A,g){super(),this.upstream=A,this.maxCount=g,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const A=await this.upstream.next();if(A.done)return A;di(A.value)}return this.upstream.next()}}class yN extends DN{constructor(A,g){super(),this.upstream=A,this.maxCount=g,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class GN extends DN{constructor(A,g,I=!0){super(),this.upstream=A,this.batchSize=g,this.enableSmallLastBatch=I,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const A=[];for(;A.length<this.batchSize;){const g=await this.upstream.next();if(g.done)return this.enableSmallLastBatch&&A.length>0?{value:A,done:!1}:{value:null,done:!0};A.push(g.value)}return{value:A,done:!1}}}class fN extends DN{constructor(A,g){super(),this.upstream=A,this.predicate=g,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const A=await this.upstream.next();if(A.done||this.predicate(A.value))return A;di(A.value)}}}class NN extends DN{constructor(A,g){super(),this.upstream=A,this.transform=g}summary(){return`${this.upstream.summary()} -> Map`}async next(){const A=await this.upstream.next();if(A.done)return{value:null,done:!0};const g=De(A.value),I=this.transform(A.value),t=De(I);for(const A of g)le(A,t)||A.dispose();return{value:I,done:!1}}}class FN extends DN{constructor(A,g){super(),this.upstream=A,this.handler=g,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(A){if(!this.handler(A))return{value:null,done:!0}}}}class RN extends DN{constructor(A,g){super(),this.upstream=A,this.transform=g}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const A=await this.upstream.next();if(A.done)return{value:null,done:!0};const g=De(A.value),I=await this.transform(A.value),t=De(I);for(const A of g)le(A,t)||A.dispose();return{value:I,done:!1}}}class mN extends DN{constructor(){super(),this.outputQueue=new rN,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class kN extends mN{constructor(A,g){super(),this.upstream=A,this.transform=g}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const A=await this.upstream.next();if(A.done)return!1;const g=De(A.value),I=this.transform(A.value),t=De(I);this.outputQueue.pushAll(I);for(const A of g)le(A,t)||A.dispose();return!0}}class SN extends DN{constructor(A,g){super(),this.baseErrorHandler=g,this.lastRead=null,this.iterator=null,this.moreIterators=A}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(A){if(await A,null==this.iterator){const A=await this.moreIterators.next();if(A.done)return{value:null,done:!0};this.iterator=A.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const g=await this.iterator.next();return g.done?(this.iterator=null,this.readFromChain(A)):g}}var MN;!function(A){A[A.FAIL=0]="FAIL",A[A.SHORTEST=1]="SHORTEST",A[A.LONGEST=2]="LONGEST"}(MN||(MN={}));class UN extends DN{constructor(A,g=MN.FAIL){super(),this.iterators=A,this.mismatchMode=g,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(A){await A;let g=0,I=0;const t=await oN(this.iterators,(function(A){if(A instanceof DN){return{value:A.next().then((A=>(g++,A.done&&I++,A.value))),recurse:!1}}return{value:null,recurse:!0}}));if(g===I)return{value:null,done:!0};if(I>0)switch(this.mismatchMode){case MN.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case MN.SHORTEST:return{value:null,done:!0};case MN.LONGEST:}return this.count++,{value:t,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class KN extends DN{constructor(A,g){super(),this.upstream=A,this.bufferSize=g,this.buffer=new aN(g)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const A=this.upstream.next();this.buffer.push(A)}}next(){return this.refill(),this.buffer.shift()}}class JN extends KN{constructor(A,g,I){super(A,g),this.upstream=A,this.windowSize=g,this.upstreamExhausted=!1,this.random=Zn.alea(I||bC().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(A){return Math.floor(this.random()*A)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const A=this.chooseIndex(),g=await this.buffer.shuffleExcise(A);if(!g.done)return this.refill(),g;this.upstreamExhausted=!0}return{value:null,done:!0}}}class YN{constructor(){this.size=null}batch(A,g=!0){const I=this;let t;return CA(A>0,(()=>`batchSize needs to be positive, but it is\n      ${A}`)),t=this.size===1/0||null==this.size?this.size:g?Math.ceil(this.size/A):Math.floor(this.size/A),LN((async()=>(await I.iterator()).columnMajorBatch(A,g,HN)),t)}concatenate(A){const g=this;let I;return I=this.size===1/0||A.size===1/0?1/0:null!=this.size&&null!=A.size?this.size+A.size:null,LN((async()=>(await g.iterator()).concatenate(await A.iterator())),I)}filter(A){const g=this;let I;return I=this.size===1/0?1/0:null,LN((async()=>(await g.iterator()).filter((g=>wi((()=>A(g)))))),I)}async forEachAsync(A){return(await this.iterator()).forEachAsync(A)}map(A){const g=this;return LN((async()=>(await g.iterator()).map((g=>wi((()=>A(g)))))),this.size)}mapAsync(A){const g=this;return LN((async()=>(await g.iterator()).mapAsync(A)),this.size)}prefetch(A){if(null==A)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const g=this;return LN((async()=>(await g.iterator()).prefetch(A)),this.size)}repeat(A){const g=this;let I;return I=null!=this.size&&A>0?this.size*A:0===A?0:null!=this.size&&(void 0===A||A<0)?1/0:null,LN((async()=>lN(cN((async()=>({value:await g.iterator(),done:!1}))).take(A))),I)}skip(A){const g=this;let I;return I=null!=this.size&&A>=0&&this.size>=A?this.size-A:null!=this.size&&(this.size<A||void 0===A||A<0)?0:null,LN((async()=>(await g.iterator()).skip(A)),I)}shuffle(A,g,I=!0){if(null==A||A<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const t=this,C=Zn.alea(g||bC().toString());return LN((async()=>{let g=C.int32();return I&&(g+=C.int32()),(await t.iterator()).shuffle(A,g.toString())}),this.size)}take(A){const g=this;let I;return I=null!=this.size&&this.size>A?A:null!=this.size&&this.size<=A?this.size:null,LN((async()=>(await g.iterator()).take(A)),I)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function LN(A,g=null){return new class extends YN{constructor(){super(...arguments),this.size=g}async iterator(){return A()}}}function xN(A){return LN((async()=>hN(A)),A.length)}function bN(A){if(!EN(A))throw new Error("The argument to zip() must be an object or array.");let g;if(Array.isArray(A))for(let I=0;I<A.length;I++)g=null==g?A[I].size:Math.min(g,A[I].size);else if(A instanceof Object)for(const I in A)g=null==g?A[I].size:Math.min(g,A[I].size);return LN((async()=>function(A,g=MN.FAIL){return new UN(A,g)}(await oN(A,(A=>{if(A instanceof YN)return{value:A.iterator(),recurse:!1};if(EN(A))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),MN.SHORTEST)),g)}function HN(A){if(null===A)return null;const g=A[0];if(null==(I=g)||null===(t=I)||"object"!=typeof t&&"function"!=typeof t||Array.isArray(I)||"object"==typeof I&&I instanceof Ce||fA(I)){return{value:function(A){if(0===A.length)throw new Error("Can't make a batch of zero elements.");return A[0]instanceof Ce?ks(A):He(A)}(A),recurse:!1}}var I,t;return{value:null,recurse:!0}}YN.MAX_BUFFER_SIZE=1e4;class qN extends YN{constructor(A){super(),this.input=A}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((A=>(A.endsWith("\r")&&(A=A.slice(0,-1)),A)))}}const TN='"',vN=Symbol("out"),VN=Symbol("field"),WN=Symbol("quote"),ON=Symbol("quoteafterquote"),ZN=Symbol("quoteinquote");class PN extends YN{constructor(A,g){super(),this.input=A,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new qN(A),g||(g={}),this.hasHeader=!1!==g.hasHeader,this.fullColumnNames=g.columnNames,this.columnConfigs=g.columnConfigs,this.configuredColumnsOnly=g.configuredColumnsOnly,g.delimWhitespace?(CA(null==g.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=g.delimiter?g.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const A=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!A)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&A&&CA(A.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+A.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=A);const g=this.fullColumnNames.reduce(((A,g)=>(A[g]=A[g]+1||1,A)),{}),I=Object.keys(g).filter((A=>g[A]>1));if(CA(0===I.length,(()=>"Duplicate column names found: "+I.toString())),this.columnConfigs)for(const A of Object.keys(this.columnConfigs)){if(-1===this.fullColumnNames.indexOf(A))throw new Error('The key "'+A+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const A=await this.base.iterator(),g=await A.next();if(g.done)throw new Error("No data was found for CSV parsing.");const I=g.value;return this.parseRow(I,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let A=await this.base.iterator();return this.hasHeader&&(A=A.skip(1)),A.map((A=>this.makeDataElement(A)))}makeDataElement(A){const g=this.parseRow(A),I={},t={};for(let C=0;C<this.fullColumnNames.length;C++){const e=this.fullColumnNames[C],B=this.columnConfigs?this.columnConfigs[e]:null;if(!this.configuredColumnsOnly||B){const i=g[C];let Q=null;if(""===i)if(B&&void 0!==B.default)Q=B.default;else{if(B&&(B.required||B.isLabel))throw new Error(`Required column ${e} is empty in this line: ${A}`);Q=void 0}else{const A=Number(i);if(isNaN(A))Q=B&&"bool"===B.dtype?this.getBoolean(i):i;else if(B&&B.dtype)switch(B.dtype){case"float32":default:Q=A;break;case"int32":Q=Math.floor(A);break;case"bool":Q=this.getBoolean(i)}else Q=A}B&&B.isLabel?t[e]=Q:I[e]=Q}}return 0===Object.keys(t).length?I:{xs:I,ys:t}}getBoolean(A){return"1"===A||"true"===A.toLowerCase()?1:0}parseRow(A,g=!0){const I=[];let t=0;const C=A.length;let e=vN;for(let g=0;g<C;g++)switch(e){case vN:switch(A.charAt(g)){case TN:t=g+1,e=WN;break;case this.delimiter:if(t=g+1," "===this.delimiter&&this.delimWhitespace)break;I.push(""),e=vN;break;default:e=VN,t=g}break;case VN:if(A.charAt(g)===this.delimiter)I.push(A.substring(t,g)),e=vN,t=g+1;break;case WN:if(A.charAt(g)===TN)e=ON;break;case ON:switch(A.charAt(g)){case this.delimiter:I.push(A.substring(t,g-1)),e=vN,t=g+1;break;case TN:e=WN;break;default:e=ZN}break;case ZN:if(A.charAt(g)===TN)e=WN}if(e===ON?I.push(A.substring(t,C-1)):I.push(A.substring(t)),g&&I.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${I}`);return I}}class XN extends DN{constructor(A){super(),this.microphoneConfig=A,this.isClosed=!1,this.fftSize=A.fftSize||1024;const g=Math.log2(this.fftSize);if(this.fftSize<0||g<4||g>14||!Number.isInteger(g))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=A.numFramesPerSpectrogram||43,this.sampleRateHz=A.sampleRateHz,this.columnTruncateLength=A.columnTruncateLength||this.fftSize,this.audioTrackConstraints=A.audioTrackConstraints,this.smoothingTimeConstant=A.smoothingTimeConstant||0,this.includeSpectrogram=!1!==A.includeSpectrogram,this.includeWaveform=!0===A.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(A={}){if(!ZA().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const g=new XN(A);return await g.start(),g}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(A){throw new Error(`Error thrown while initializing video stream: ${A.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const A=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new A,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const g=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,g.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let A,g;const I=await this.getAudioData();if(this.includeSpectrogram){const g=this.flattenQueue(I.freqDataQueue);A=this.getTensorFromAudioDataArray(g,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const A=this.flattenQueue(I.timeDataQueue);g=this.getTensorFromAudioDataArray(A,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:A,waveform:g},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const A=[],g=[];let I=0;return new Promise((t=>{const C=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&t({freqDataQueue:A,timeDataQueue:g}),A.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),g.push(this.timeData.slice())),++I===this.numFrames&&(clearInterval(C),t({freqDataQueue:A,timeDataQueue:g}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(A){const g=A[0].length,I=new Float32Array(A.length*g);return A.forEach(((A,t)=>I.set(A,t*g))),I}getTensorFromAudioDataArray(A,g){const I=new Float32Array(QA(g));return I.set(A,I.length-A.length),He(I,g)}}class jN extends DN{constructor(A,g){if(super(),this.webcamVideoElement=A,this.webcamConfig=g,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ks([0],"int32"),this.webcamConfig.centerCrop){const A=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,g=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,I=(1-A)/2,t=(1-g)/2,C=I+A,e=g+t;this.cropBox=Js([t,I,e,C],[1,4])}else this.cropBox=Js([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(A,g={}){if(!ZA().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!A){if(A=document.createElement("video"),!g.resizeWidth||!g.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");A.width=g.resizeWidth,A.height=g.resizeHeight}const I=new jN(A,g);return await I.start(),I}async start(){this.webcamConfig.facingMode&&CA("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(A){throw A.message=`Error thrown while initializing video stream: ${A.message}`,A}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(A){console.log(A),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((A=>{this.webcamVideoElement.onloadedmetadata=()=>{A()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let A;try{A=Zi(this.webcamVideoElement)}catch(A){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(A)}`)}if(!this.resize)return{value:A,done:!1};try{return{value:this.cropAndResizeFrame(A),done:!1}}catch(A){throw new Error(`Error thrown cropping the video: ${A.message}`)}finally{A.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(A){return wi((()=>{const g=vE(qB(A,"float32"),0);let I;I=Er.cropAndResize(g,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const t=I.shape;return Lo(I,t.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((A=>A.stop()));try{this.webcamVideoElement.srcObject=null}catch(A){console.log(A),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class zN{}class _N extends DN{split(A){return new $N(this,A)}}class $N extends _N{constructor(A,g){super(),this.upstream=A,this.impl=new AF(A,g)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class AF extends mN{constructor(A,g){super(),this.upstream=A,this.separator=g,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const A=await this.upstream.next();if(A.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const g=A.value.split(this.separator);g[0]=this.carryover+g[0];for(const A of g.slice(0,-1))this.outputQueue.push(A);return this.carryover=g[g.length-1],!0}}class gF extends DN{decodeUTF8(){return new IF(this)}}class IF extends _N{constructor(A){super(),this.upstream=A,this.impl=new tF(A)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class tF extends mN{constructor(A){if(super(),this.upstream=A,ZA().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:A}=I(601);this.decoder=new A("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const A=await this.upstream.next();let g,I;return!A.done&&(g=A.value,I=ZA().get("IS_BROWSER")?this.decoder.decode(g,{stream:!0}):this.decoder.write(Buffer.from(g.buffer)),this.outputQueue.push(I),!0)}}class CF extends gF{constructor(A,g={}){super(),this.file=A,this.options=g,CA(A instanceof Uint8Array||!!ZA().get("IS_BROWSER")&&(A instanceof File||A instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=g.offset||0,this.chunkSize=g.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const A=new Promise(((A,g)=>{const I=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)A(new Uint8Array(this.file.slice(this.offset,I)));else{const t=new FileReader;t.onload=I=>{let C=t.result;if(C instanceof ArrayBuffer&&(C=new Uint8Array(C)),!(C instanceof Uint8Array))return g(new TypeError("FileReader returned unknown type."));A(C)},t.onabort=A=>g(new Error("Aborted")),t.onerror=A=>g(new Error(A.type));const C=this.file.slice(this.offset,I);t.readAsArrayBuffer(C)}this.offset=I}));return{value:await A,done:!1}}}const eF=A=>({method:A.method,headers:A.headers,body:A.body,mode:A.mode,credentials:A.credentials,cache:A.cache,redirect:A.redirect,referrer:A.referrer,integrity:A.integrity});function BF(A){return"string"==typeof A&&"file://"===A.slice(0,7)}class iF extends zN{constructor(A,g={}){super(),this.input=A,this.options=g}async iterator(){if(BF(this.input)&&ZA().get("IS_NODE")){const A=I(792);this.input=A.readFileSync(this.input.slice(7))}return new CF(this.input,this.options)}}class QF extends zN{constructor(A,g={}){super(),this.url=A,this.fileOptions=g}async iterator(){return BF(this.url)?new iF(this.url,this.fileOptions).iterator():async function(A,g={},I){let t,C;"string"==typeof A?t=A:(t=A.url,C=eF(A));const e=await(I||HC)(t,C);if(e.ok){const A=new Uint8Array(await e.arrayBuffer());return new CF(A,g)}throw new Error(e.statusText)}(this.url,this.fileOptions)}}function oF(A,g={}){return new PN(new QF(A),g)}function EF(A){const g=cN(A);return LN((async()=>g))}function nF(A){return LN((async()=>{const g=await A();return cN((()=>g.next()))}))}async function sF(A,g){return jN.create(A,g)}async function aF(A){return XN.create(A)}const rF="3.21.0";function hF(A,g){Array.isArray(A)||(A=[A]),A.forEach((A=>{null!=A&&CA("complex64"!==A.dtype,(()=>`${g} does not support complex64 tensors in the CPU backend.`))}))}const cF=Os;class lF extends P{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Z(this,li())}nextDataId(){return lF.nextDataId++}write(A,g,I){this.firstUse&&(this.firstUse=!1,ZA().get("IS_NODE")&&EC("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const t={id:this.nextDataId()};return this.data.set(t,{values:A,dtype:I,refCount:1}),t}makeTensorInfo(A,g,I){let t;if("string"===g&&null!=I&&I.length>0&&RA(I[0])){const C=I.map((A=>qC(A)));t=this.write(C,A,g)}else t=this.write(I,A,g);return{dataId:t,shape:A,dtype:g}}refCount(A){if(this.data.has(A)){return this.data.get(A).refCount}return 0}incRef(A){this.data.get(A).refCount++}decRef(A){if(this.data.has(A)){this.data.get(A).refCount--}}move(A,g,I,t,C){this.data.set(A,{values:g,dtype:t,refCount:C})}numDataIds(){return this.data.numDataIds()}async read(A){return this.readSync(A)}readSync(A){const{dtype:g,complexTensorInfos:I}=this.data.get(A);if("complex64"===g){return qr(this.readSync(I.real.dataId),this.readSync(I.imag.dataId))}return this.data.get(A).values}bufferSync(A){const g=this.readSync(A.dataId);if("string"===A.dtype)try{const I=g.map((A=>TC(A)));return HB(A.shape,A.dtype,I)}catch(A){throw new Error("Failed to decode encoded string bytes into utf-8")}return HB(A.shape,A.dtype,g)}makeOutput(A,g,I){return li().makeTensorFromTensorInfo(this.makeTensorInfo(g,I,A),this)}disposeData(A,g=!1){if(this.data.has(A)){if(this.data.get(A).refCount--,!g&&this.data.get(A).refCount>0)return!1;const{complexTensorInfos:I}=this.data.get(A);null!=I&&(this.disposeData(I.real.dataId,!0),this.disposeData(I.imag.dataId,!0)),this.data.delete(A)}return!0}disposeIntermediateTensorInfo(A){this.disposeData(A.dataId)}async time(A){const g=bC();A();return{kernelMs:bC()-g}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(A){hF([A],"where");const g=this.readSync(A.dataId);return cF(A.shape,g)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}lF.nextDataId=0;function DF(A,g,I){return({inputs:t,attrs:C,backend:e})=>{const{x:B}=t;if(hF(B,A),"string"===B.dtype||"string"===I)throw new Error("unaryKernelFunc does not support string input/output");const i=e,Q=i.data.get(B.dataId).values,o=QA(B.shape),E=I||B.dtype,n=dA(E,o);for(let A=0;A<o;++A)n[A]=g(Q[A],C);return i.makeTensorInfo(B.shape,E,n)}}function uF(A,g,I){return({inputs:t,attrs:C,backend:e})=>{const{x:B}=t;if(hF(B,A),"string"===B.dtype||"string"===I)throw new Error("unaryKernelFunc does not support string input/output");const i=e,Q=i.data.get(B.dataId).values,o=I||B.dtype,E=g(Q,o,C);return i.makeTensorInfo(B.shape,o,E)}}ki("cpu",(()=>new lF),1);const wF=DF(Xg,(A=>A>=0?A:Math.exp(A)-1)),dF={kernelName:Xg,backendName:"cpu",kernelFunc:wF};function pF(A){const{inputs:g,backend:I}=A,{x:t}=g;return I.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const yF={kernelName:sI,backendName:"cpu",kernelFunc:pF};function GF(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{alpha:e}=t;hF([C],"leakyRelu");const B=QA(C.shape),i=I.data.get(C.dataId).values,Q=wA("float32",B);for(let A=0;A<i.length;A++)Q[A]=i[A]<0?e*i[A]:i[A];return I.makeTensorInfo(C.shape,"float32",Q)}const fF={kernelName:DI,backendName:"cpu",kernelFunc:GF};function NF(A){return(g,I,t,C,e)=>{const B=Hi(g,I),i=B.length,Q=KA(B),o=wA(e,QA(B)),E=g.length,n=I.length,s=KA(g),a=KA(I),r=xi(g,B),h=xi(I,B);if(r.length+h.length===0)for(let g=0;g<o.length;++g)o[g]=A(t[g%t.length],C[g%C.length]);else for(let g=0;g<o.length;++g){const I=TA(g,i,Q),e=I.slice(-E);r.forEach((A=>e[A]=0));const B=qA(e,E,s),c=I.slice(-n);h.forEach((A=>c[A]=0));const l=qA(c,n,a);o[g]=A(t[B],C[l])}return[o,B]}}const FF=NF(((A,g)=>A<0?g*A:A));function RF(A){const{inputs:g,backend:I}=A,{x:t,alpha:C}=g;hF([t,C],"prelu");const e=I.data.get(t.dataId).values,B=I.data.get(C.dataId).values,[i,Q]=FF(t.shape,C.shape,e,B,"float32");return I.makeTensorInfo(Q,"float32",i)}const mF={kernelName:tt,backendName:"cpu",kernelFunc:RF},kF=DF(Et,(A=>Math.max(0,A))),SF={kernelName:Et,backendName:"cpu",kernelFunc:kF},MF=DF(ct,(A=>Math.min(Math.max(0,A),6))),UF={kernelName:ct,backendName:"cpu",kernelFunc:MF};function KF(A){return(g,I,t)=>{const C=wA(I,g.length);for(let I=0;I<g.length;++I)C[I]=A(g[I],t);return C}}const JF=KF((A=>1/(1+Math.exp(-A)))),YF=DF(Rt,(A=>1/(1+Math.exp(-A)))),LF={kernelName:Rt,backendName:"cpu",kernelFunc:YF};function xF(A,g,I,t,C){if("linear"===I)return pF({inputs:{x:g},backend:A});if("relu"===I)return kF({inputs:{x:g},backend:A});if("elu"===I)return wF({inputs:{x:g},backend:A});if("relu6"===I)return MF({inputs:{x:g},backend:A});if("prelu"===I)return RF({inputs:{x:g,alpha:t},backend:A});if("leakyrelu"===I)return GF({inputs:{x:g},backend:A,attrs:{alpha:C}});if("sigmoid"===I)return YF({inputs:{x:g},backend:A});throw new Error(`Activation ${I} has not been implemented for the CPU backend.`)}function bF(A){const{inputs:g,backend:I}=A,{real:t,imag:C}=g,e=I.data.get(t.dataId).values,B=I.data.get(C.dataId).values,i=I.makeTensorInfo(t.shape,"complex64");return I.data.get(i.dataId).complexTensorInfos={real:I.makeTensorInfo(t.shape,"float32",e),imag:I.makeTensorInfo(C.shape,"float32",B)},i}const HF={kernelName:Gg,backendName:"cpu",kernelFunc:bF};function qF(A,g,I="float32"){if("complex64"===I){return bF({inputs:{real:qF(A,g,"float32"),imag:qF(A,g,"float32")},backend:A})}const t=xA(QA(g),I);return A.makeTensorInfo(g,I,t)}function TF(A){const{inputs:g,backend:I}=A,{input:t}=g,C=I.data.get(t.dataId).complexTensorInfos.real,e=I.data.get(C.dataId).values;return I.makeTensorInfo(C.shape,C.dtype,e)}const vF={kernelName:Qt,backendName:"cpu",kernelFunc:TF};function VF(A,g,I,t){if("int32"===t){return[g,"int32",Int32Array.from(A)]}if("bool"===t){const t=xC([0],I),[C,e]=NF(((A,g)=>A!==g?1:0))(g,[],A,t,"bool");return[e,"bool",C]}throw new Error(`Error in Cast: failed to cast ${I} to ${t}`)}function WF(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{dtype:e}=t;if("complex64"===e){if("complex64"===C.dtype)return pF({inputs:{x:C},backend:I});const A=qF(I,C.shape,C.dtype),g=WF({inputs:{x:C},backend:I,attrs:{dtype:"float32"}}),t=bF({inputs:{real:g,imag:A},backend:I});return I.disposeIntermediateTensorInfo(A),I.disposeIntermediateTensorInfo(g),t}if("complex64"===C.dtype){const A=TF({inputs:{input:C},backend:I}),g=WF({inputs:{x:A},backend:I,attrs:{dtype:e}});return I.disposeIntermediateTensorInfo(A),g}if(!GA(C.dtype,e)){const A=pF({inputs:{x:C},backend:I});return{dataId:A.dataId,shape:A.shape,dtype:e}}const B=I.data.get(C.dataId).values,[i,Q,o]=VF(B,C.shape,C.dtype,e);return I.makeTensorInfo(i,Q,o)}const OF={kernelName:dg,backendName:"cpu",kernelFunc:WF};function ZF(A,g,I,t){return null==I?({inputs:I,backend:C})=>{const{a:e,b:B}=I,i=C;hF([e,B],A);const Q=i.data.get(e.dataId).values,o=i.data.get(B.dataId).values,E="string"===e.dtype?dh(Q):Q,n="string"===e.dtype?dh(o):o,s=t||e.dtype,[a,r]=g(e.shape,B.shape,E,n,s);return i.makeTensorInfo(r,s,a)}:({inputs:A,backend:C})=>{const{a:e,b:B}=A,i=C;if("complex64"===e.dtype||"complex64"===B.dtype){const A=WF({inputs:{x:e},backend:i,attrs:{dtype:"complex64"}}),g=i.data.get(A.dataId),t=g.complexTensorInfos.real,C=g.complexTensorInfos.imag,Q=i.data.get(t.dataId).values,o=i.data.get(C.dataId).values,E=WF({inputs:{x:B},backend:i,attrs:{dtype:"complex64"}}),n=i.data.get(E.dataId),s=n.complexTensorInfos.real,a=n.complexTensorInfos.imag,r=i.data.get(s.dataId).values,h=i.data.get(a.dataId).values,[c,l,D]=I(e.shape,B.shape,Q,o,r,h),u=i.makeTensorInfo(D,"float32",c),w=i.makeTensorInfo(D,"float32",l),d=bF({inputs:{real:u,imag:w},backend:i});return i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(w),d}{const A=i.data.get(e.dataId).values,I=i.data.get(B.dataId).values,C=t||e.dtype,[Q,o]=g(e.shape,B.shape,A,I,C);return i.makeTensorInfo(o,C,Q)}}}function PF(A){return(g,I,t,C,e,B)=>{const i=Hi(g,I),Q=QA(i),o=i.length,E=KA(i),n=wA("float32",Q),s=wA("float32",Q),a=xi(g,i),r=xi(I,i),h=qr(t,C),c=qr(e,B),l=g.length,D=KA(g),u=I.length,w=KA(I);if(a.length+r.length===0)for(let g=0;g<n.length;g++){const I=g%h.length,t=g%c.length,C=A(h[2*I],h[2*I+1],c[2*t],c[2*t+1]);n[g]=C.real,s[g]=C.imag}else for(let g=0;g<n.length;g++){const I=TA(g,o,E),t=I.slice(-l);a.forEach((A=>t[A]=0));const C=qA(t,l,D),e=I.slice(-u);r.forEach((A=>e[A]=0));const B=qA(e,u,w),i=A(h[2*C],h[2*C+1],c[2*B],c[2*B+1]);n[g]=i.real,s[g]=i.imag}return[n,s,i]}}const XF=NF(((A,g)=>A+g)),jF=PF(((A,g,I,t)=>({real:A+I,imag:g+t}))),zF=ZF(gg,XF,jF),_F={kernelName:gg,backendName:"cpu",kernelFunc:zF};function $F(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{shape:e}=t,B=QA(C.shape),i=lA(e,B),Q=QA(i);CA(B===Q,(()=>`The new shape (${i}) has ${Q} elements and the old shape (${C.shape}) has ${B} elements. The new shape and old shape must have the same number of elements.`)),I.incRef(C.dataId);const o=I.data.get(C.dataId);if(null!=o.complexTensorInfos){const A=o.complexTensorInfos.real,g=o.complexTensorInfos.imag;A.shape=i,g.shape=i}return{dataId:C.dataId,shape:i,dtype:C.dtype}}const AR={kernelName:nt,backendName:"cpu",kernelFunc:$F};function gR(A){const{inputs:g,backend:I,attrs:t}=A,{a:C,b:e}=g,{transposeA:B,transposeB:i}=t;hF([C,e],"matMul");const Q=C.shape.length,o=e.shape.length,E=B?C.shape[Q-2]:C.shape[Q-1],n=i?e.shape[o-1]:e.shape[o-2],s=B?C.shape[Q-1]:C.shape[Q-2],a=i?e.shape[o-2]:e.shape[o-1],r=C.shape.slice(0,-2),h=e.shape.slice(0,-2),c=QA(r),l=QA(h),D=Hi(C.shape.slice(0,-2),e.shape.slice(0,-2)).concat([s,a]);CA(E===n,(()=>`Error in matMul: inner shapes (${E}) and (${n}) of Tensors with shapes ${C.shape} and ${e.shape} and transposeA=${B} and transposeB=${i} must match.`));const u=i?[l,a,n]:[l,n,a],w=$F({inputs:{x:C},backend:I,attrs:{shape:B?[c,E,s]:[c,s,E]}}),d=$F({inputs:{x:e},backend:I,attrs:{shape:u}}),p=B?w.shape[1]:w.shape[2],y=B?w.shape[2]:w.shape[1],G=i?d.shape[1]:d.shape[2],f=Math.max(c,l),N=I.data.get(w.dataId).values,F=I.data.get(d.dataId).values,R=KA(w.shape),m=KA(d.shape),[k,S,M]=B?[R[0],1,R[1]]:[R[0],R[1],1],[U,K,J]=i?[1,m[1],m[0]]:[m[1],1,m[0]],Y=y*G,L=HB([f,y,G],w.dtype),x=L.values,b=I.blockSize;for(let A=0;A<f;A++)for(let g=0;g<y;g+=b)for(let I=0;I<G;I+=b)for(let t=0;t<p;t+=b){const C=Math.min(g+b,y),e=Math.min(I+b,G),B=Math.min(t+b,p);for(let i=g;i<C;i++)for(let g=I;g<e;g++){let I=0;for(let C=t;C<B;C++){const t=Math.min(A,c-1)*k,e=Math.min(A,l-1)*J;I+=N[t+i*S+C*M]*F[C*U+g*K+e]}x[A*Y+(i*G+g)]+=I}}return I.disposeIntermediateTensorInfo(w),I.disposeIntermediateTensorInfo(d),I.makeTensorInfo(D,L.dtype,L.values)}const IR={kernelName:cg,backendName:"cpu",kernelFunc:gR};const tR={kernelName:iC,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{a:C,b:e,bias:B,preluActivationWeights:i}=g,{transposeA:Q,transposeB:o,activation:E,leakyreluAlpha:n}=t;let s,a,r;const h=[];s=gR({inputs:{a:C,b:e},attrs:{transposeA:Q,transposeB:o},backend:I}),B&&(a=zF({inputs:{a:s,b:B},backend:I}),h.push(s),s=a),E&&(r=xF(I,s,E,i,n),h.push(s),s=r);for(const A of h)I.disposeIntermediateTensorInfo(A);return s}};function CR(A){const g=new Float32Array(A.length);for(let I=0;I<A.length;++I)g[I]=Math.abs(A[I]);return g}const eR={kernelName:_A,backendName:"cpu",kernelFunc:A=>{const{x:g}=A.inputs,I=A.backend;hF(g,"abs");let t=new Float32Array(QA(g.shape));return t=CR(I.data.get(g.dataId).values),I.makeOutput(t,g.shape,g.dtype)}},BR=DF($A,(A=>Math.acos(A))),iR={kernelName:$A,backendName:"cpu",kernelFunc:BR},QR=DF(Ag,(A=>Math.acosh(A))),oR={kernelName:Ag,backendName:"cpu",kernelFunc:QR};const ER={kernelName:Ig,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,t=g;hF(g,"addN");const C=t.map((A=>I.data.get(A.dataId).values)),e=HB(t[0].shape,t[0].dtype),B=e.values;for(let A=0;A<t.length;A++){const g=C[A];for(let A=0;A<B.length;A++)B[A]+=g[A]}return I.makeTensorInfo(e.shape,e.dtype,e.values)}};function nR(A,g,I,t,C){const e=g.length,B=QA(g),i=KA(g),Q=KA(C),o=wA(I,QA(C));for(let g=0;g<B;++g){const I=TA(g,e,i),C=new Array(I.length);for(let A=0;A<C.length;A++)C[A]=I[t[A]];o[qA(C,e,Q)]=A[g]}return o}function sR(A){const{inputs:g,attrs:I,backend:t}=A,{x:C}=g,{perm:e}=I;hF(C,"transpose");const B=C.shape.length,i=new Array(B);for(let A=0;A<i.length;A++)i[A]=C.shape[e[A]];const Q=nR(t.data.get(C.dataId).values,C.shape,C.dtype,e,i);return{dataId:t.write(Q,i,C.dtype),shape:i,dtype:C.dtype}}const aR={kernelName:_t,backendName:"cpu",kernelFunc:sR};const rR={kernelName:tg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t;hF(C,"all");const i=DA(e,C.shape);let Q=i;const o=UE(Q,C.shape.length);let E=C;null!=o&&(E=sR({inputs:{x:C},backend:I,attrs:{perm:o}}),Q=JE(Q.length,C.shape.length)),ME("all",Q,E.shape.length);const[n,s]=kE(E.shape,Q),a=QA(s),r=xA(QA(n),E.dtype),h=I.data.get(E.dataId).values;for(let A=0;A<r.length;++A){const g=A*a;let I=h[g];for(let A=0;A<a;++A){const t=h[g+A];I=I&&t}r[A]=I}null!=o&&I.disposeIntermediateTensorInfo(E);const c=I.makeTensorInfo(n,E.dtype,r);if(B){const A=$F({inputs:{x:c},backend:I,attrs:{shape:SE(n,i)}});return I.disposeIntermediateTensorInfo(c),A}return c}};const hR={kernelName:Cg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t;hF(C,"any");const i=DA(e,C.shape);let Q=i;const o=UE(Q,C.shape.length);let E=C;null!=o&&(E=sR({inputs:{x:C},backend:I,attrs:{perm:o}}),Q=JE(Q.length,C.shape.length)),ME("any",Q,E.shape.length);const[n,s]=kE(E.shape,Q),a=QA(s),r=xA(QA(n),E.dtype),h=I.data.get(E.dataId).values;for(let A=0;A<r.length;++A){const g=A*a;let I=h[g];for(let A=0;A<a;++A){const t=h[g+A];I=I||t}r[A]=I}null!=o&&I.disposeIntermediateTensorInfo(E);const c=I.makeTensorInfo(n,E.dtype,r);if(B){const A=$F({inputs:{x:c},backend:I,attrs:{shape:SE(n,i)}});return I.disposeIntermediateTensorInfo(c),A}return c}};const cR={kernelName:eg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e}=t;hF(C,"argMax");let B=DA(e,C.shape);const i=UE(B,C.shape.length);let Q=C;const o=[];null!=i&&(Q=sR({inputs:{x:C},backend:I,attrs:{perm:i}}),o.push(Q),B=JE(B.length,Q.shape.length)),B=[B[0]],ME("argMax",B,Q.shape.length);const[E,n]=kE(Q.shape,B),s=xA(QA(E),"int32"),a=QA(n),r=I.data.get(Q.dataId).values;for(let A=0;A<s.length;++A){const g=A*a;let I=r[g],t=0;for(let A=0;A<a;++A){const C=r[g+A];C>I&&(I=C,t=A)}s[A]=t}return o.forEach((A=>I.disposeIntermediateTensorInfo(A))),I.makeTensorInfo(E,"int32",s)}};const lR={kernelName:Bg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e}=t;hF(C,"argMin");let B=DA(e,C.shape);const i=UE(B,C.shape.length);let Q=C;const o=[];null!=i&&(Q=sR({inputs:{x:C},backend:I,attrs:{perm:i}}),o.push(Q),B=JE(B.length,Q.shape.length)),B=[B[0]],ME("argMin",B,Q.shape.length);const[E,n]=kE(Q.shape,B),s=xA(QA(E),"int32"),a=QA(n),r=I.data.get(Q.dataId).values;for(let A=0;A<s.length;++A){const g=A*a;let I=r[g],t=0;for(let A=0;A<a;++A){const C=r[g+A];C<I&&(I=C,t=A)}s[A]=t}return o.forEach((A=>I.disposeIntermediateTensorInfo(A))),I.makeTensorInfo(E,"int32",s)}},DR=DF(ig,(A=>Math.asin(A))),uR={kernelName:ig,backendName:"cpu",kernelFunc:DR},wR=DF(Qg,(A=>Math.asinh(A))),dR={kernelName:Qg,backendName:"cpu",kernelFunc:wR},pR=DF(og,(A=>Math.atan(A))),yR={kernelName:og,backendName:"cpu",kernelFunc:pR},GR=NF(((A,g)=>Math.atan2(A,g))),fR=ZF(ng,GR),NR={kernelName:ng,backendName:"cpu",kernelFunc:fR},FR=DF(Eg,(A=>Math.atanh(A))),RR={kernelName:Eg,backendName:"cpu",kernelFunc:FR};function mR(A,g,I,t,C,e){const B=C.strideHeight,i=C.strideWidth,Q=C.dilationHeight,o=C.dilationWidth,E=C.effectiveFilterHeight,n=C.effectiveFilterWidth,s=C.padInfo.top,a=C.padInfo.left,r="max"===e?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=HB(C.outShape,I),c=h.values,l=C.outShape[1]*C.outShape[2]*C.outShape[3],D=C.outShape[2]*C.outShape[3],u=C.outShape[3];for(let g=0;g<C.batchSize;++g){const I=g*l,h=g*t[0];for(let g=0;g<C.inChannels;++g)for(let l=0;l<C.outHeight;++l){const w=l*B-s,d=Math.max(0,w),p=Math.min(C.inHeight,E+w),y=I+l*D;for(let I=0;I<C.outWidth;++I){const B=I*i-a,E=Math.max(0,B),s=Math.min(C.inWidth,n+B);let l=r,D=0,w=0;for(let I=d;I<p;I+=Q){const C=h+I*t[1];for(let I=E;I<s;I+=o){const B=A[C+I*t[2]+g];"max"===e&&B>l?l=B:"avg"===e&&(D+=B,w++)}if(isNaN(l))break}c[y+I*u+g]="avg"===e?D/w:l}}}return h}function kR(A,g,I,t,C=!1,e=!1){const B=HB(t.outShape,"int32"),i=t.strideHeight,Q=t.strideWidth,o=t.dilationHeight,E=t.dilationWidth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth,a=t.padInfo.top,r=t.padInfo.left,h=HB(g,I,A);for(let A=0;A<t.batchSize;++A)for(let g=0;g<t.inChannels;++g)for(let I=0;I<t.outHeight;++I){const c=I*i-a;let l=c;for(;l<0;)l+=o;const D=Math.min(t.inHeight,n+c);for(let i=0;i<t.outWidth;++i){const n=i*Q-r;let a=n;for(;a<0;)a+=E;const u=Math.min(t.inWidth,s+n);let w=Number.NEGATIVE_INFINITY,d=-1;for(let I=l;I<D;I+=o){const B=I-c;for(let i=a;i<u;i+=E){const Q=i-n,o=h.get(A,I,i,g);o>w&&(w=o,d=C?e?((A*t.inHeight+I)*t.inWidth+i)*t.inChannels+g:(I*t.inWidth+i)*t.inChannels+g:B*s+Q)}}B.set(d,A,I,i,g)}}return B}function SR(A,g,I,t,C,e){const B=C.strideDepth,i=C.strideHeight,Q=C.strideWidth,o=C.dilationDepth,E=C.dilationHeight,n=C.dilationWidth,s=C.effectiveFilterDepth,a=C.effectiveFilterHeight,r=C.effectiveFilterWidth,h=C.padInfo.front,c=C.padInfo.top,l=C.padInfo.left,D="max"===e?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,u=HB(C.outShape,I),w=u.values,d=C.outShape[1]*C.outShape[2]*C.outShape[3]*C.outShape[4],p=C.outShape[2]*C.outShape[3]*C.outShape[4],y=C.outShape[3]*C.outShape[4],G=C.outShape[4];for(let g=0;g<C.batchSize;++g){const I=g*d,u=g*t[0];for(let g=0;g<C.inChannels;++g)for(let d=0;d<C.outDepth;++d){const f=d*B-h;let N=f;for(;N<0;)N+=o;const F=Math.min(C.inDepth,s+f),R=I+d*p;for(let I=0;I<C.outHeight;++I){const B=I*i-c;let s=B;for(;s<0;)s+=E;const h=Math.min(C.inHeight,a+B),d=R+I*y;for(let I=0;I<C.outWidth;++I){const B=I*Q-l;let i=B;for(;i<0;)i+=n;const a=Math.min(C.inWidth,r+B),c=d+I*G;let p=D,y=0,f=0;for(let I=N;I<F;I+=o){const C=u+I*t[1];for(let I=s;I<h;I+=E){const B=C+I*t[2];for(let I=i;I<a;I+=n){const C=A[B+I*t[3]+g];if("max"===e&&C>p?p=C:"avg"===e&&(y+=C,f++),isNaN(p))break}if(isNaN(p))break}if(isNaN(p))break}w[c+g]="avg"===e?y/f:p}}}}return u}const MR={kernelName:sg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g;hF(C,"avgPool");const{filterSize:e,strides:B,pad:i,dimRoundingMode:Q}=t;CA(Ko(B,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${B} and dilations '1'`));const o=Go(C.shape,e,B,1,i,Q);let E;if(1===o.filterWidth&&1===o.filterHeight&&EA(o.inShape,o.outShape))E=pF({inputs:{x:C},backend:I});else{const A=I.data.get(C.dataId).values,g=KA(C.shape),t=mR(A,C.shape,C.dtype,g,o,"avg");E=I.makeTensorInfo(o.outShape,C.dtype,t.values)}return E}};const UR={kernelName:rg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{filterSize:e,strides:B,pad:i,dimRoundingMode:Q,dataFormat:o}=t;hF(C,"avgPool3d");const E=fo(C.shape,e,B,1,i,Q,o),n=SR(I.data.get(C.dataId).values,C.shape,C.dtype,KA(C.shape),E,"avg");return I.makeTensorInfo(n.shape,"float32",n.values)}};const KR={kernelName:hg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e}=g,{filterSize:B,strides:i,pad:Q,dimRoundingMode:o}=t;hF([C,e],"avgPool3DGrad");const E=fo(e.shape,B,i,1,Q,o),n=E.strideDepth,s=E.strideHeight,a=E.strideWidth,r=E.filterDepth,h=E.filterHeight,c=E.filterWidth,l=E.dilationDepth,D=E.dilationHeight,u=E.dilationWidth,w=E.effectiveFilterDepth,d=E.effectiveFilterHeight,p=E.effectiveFilterWidth,y=w-1-E.padInfo.front,G=p-1-E.padInfo.left,f=d-1-E.padInfo.top,N=HB(e.shape,"float32"),F=1/(r*h*c),R=I.bufferSync(C);for(let A=0;A<E.batchSize;++A)for(let g=0;g<E.inChannels;++g)for(let I=0;I<E.inDepth;++I)for(let t=0;t<E.inHeight;++t)for(let C=0;C<E.inWidth;++C){const e=I-y,B=t-f,i=C-G;let Q=0;for(let I=0;I<w;I+=l){const t=(e+I)/n;if(!(t<0||t>=E.outDepth||Math.floor(t)!==t))for(let I=0;I<d;I+=D){const C=(B+I)/s;if(!(C<0||C>=E.outHeight||Math.floor(C)!==C))for(let I=0;I<p;I+=u){const e=(i+I)/a;if(e<0||e>=E.outWidth||Math.floor(e)!==e)continue;Q+=R.get(A,t,C,e,g)}}}N.set(Q*F,A,I,t,C,g)}return I.makeTensorInfo(N.shape,N.dtype,N.values)}};const JR={kernelName:ag,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e}=g,B=e;hF([C,e],"avgPoolGrad");const{filterSize:i,strides:Q,pad:o}=t,E=Go(B.shape,i,Q,1,o),n=E.strideHeight,s=E.strideWidth,a=E.filterHeight,r=E.filterWidth,h=E.dilationHeight,c=E.dilationWidth,l=E.effectiveFilterHeight,D=E.effectiveFilterWidth,u=D-1-E.padInfo.left,w=l-1-E.padInfo.top,d=HB(B.shape,"float32"),p=1/(a*r),y=I.data.get(C.dataId).values,G=HB(C.shape,"float32",y);for(let A=0;A<E.batchSize;++A)for(let g=0;g<E.inChannels;++g)for(let I=0;I<E.inHeight;++I)for(let t=0;t<E.inWidth;++t){const C=I-w,e=t-u;let B=0;for(let I=0;I<l;I+=h){const t=(C+I)/n;if(!(t<0||t>=E.outHeight||Math.floor(t)!==t))for(let I=0;I<D;I+=c){const C=(e+I)/s;if(C<0||C>=E.outWidth||Math.floor(C)!==C)continue;B+=G.get(A,t,C,g)}}d.set(B*p,A,I,t,g)}return I.makeTensorInfo(d.shape,d.dtype,d.values)}};const YR={kernelName:iI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,scale:e,offset:B,mean:i,variance:Q}=g;CA(i.shape.length===Q.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),CA(null==B||i.shape.length===B.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),CA(null==e||i.shape.length===e.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),hF([C,i,Q,e,B],"batchNorm");let{varianceEpsilon:o}=t;null==o&&(o=.001);const E=I.data.get(C.dataId).values,n=I.data.get(i.dataId).values,s=I.data.get(Q.dataId).values,a=e?I.data.get(e.dataId).values:new Float32Array([1]),r=B?I.data.get(B.dataId).values:new Float32Array([0]),h=new Float32Array(E.length),c=r.length,l=a.length,D=s.length,u=n.length;let w=0,d=0,p=0,y=0;for(let A=0;A<E.length;++A)h[A]=r[w++]+(E[A]-n[d++])*a[p++]/Math.sqrt(s[y++]+o),w>=c&&(w=0),d>=u&&(d=0),p>=l&&(p=0),y>=D&&(y=0);return I.makeTensorInfo(C.shape,C.dtype,h)}};function LR(A,g,I,t,C){const e=sQ(t,g,I),B=QA(I),i=KA(t);if(e){const I=aQ(g,i);return"string"===C?A.slice(I,I+B):A.subarray(I,I+B)}const Q=HB(t,C,"string"===C?dh(A):A),o=HB(I,C);for(let A=0;A<o.size;++A){const I=o.indexToLoc(A),t=I.map(((A,I)=>A+g[I]));o.set(Q.get(...t),...I)}return"string"===C?ph(o.values):o.values}function xR(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{begin:e,size:B}=t;hF(C,"slice");const[i,Q]=rQ(C,e,B);AQ(C,i,Q);const o=LR(I.data.get(C.dataId).values,i,Q,C.shape,C.dtype);return I.makeTensorInfo(Q,C.dtype,o)}const bR={kernelName:Gt,backendName:"cpu",kernelFunc:xR};const HR={kernelName:lg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{blockShape:e,crops:B}=t;hF([C],"batchToSpaceND");const i=e.reduce(((A,g)=>A*g)),Q=Rr(C.shape,e,i),o=mr(Q.length,e.length),E=kr(C.shape,e,i),n=Sr(B,e.length),s=Mr(E,B,e.length),a=$F({inputs:{x:C},backend:I,attrs:{shape:Q}}),r=sR({inputs:{x:a},backend:I,attrs:{perm:o}}),h=$F({inputs:{x:r},backend:I,attrs:{shape:E}}),c=xR({inputs:{x:h},backend:I,attrs:{begin:n,size:s}});return I.disposeIntermediateTensorInfo(a),I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(h),c}};function qR(A,g,I,t,C){const e=QA(t),B=xA(C,I);for(let I=0;I<A.length;I++){const t=A[I];if(t<0)throw new Error("Input x must be non-negative!");t>=C||(B[t]+=e>0?g[I]:1)}return B}function TR(A,g,I,t=!1){const C=A.shape[0],e=A.shape[1],B=HB([C,I],g.dtype);for(let i=0;i<C;i++)for(let C=0;C<e;C++){const e=A.get(i,C);if(e<0)throw new Error("Input x must be non-negative!");e>=I||(t?B.set(1,i,e):g.size>0?B.set(B.get(i,e)+g.get(i,C),i,e):B.set(B.get(i,e)+1,i,e))}return B}const vR={kernelName:Dg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,weights:e}=g,{size:B}=t,i=qR(I.data.get(C.dataId).values,I.data.get(e.dataId).values,e.dtype,e.shape,B);return I.makeTensorInfo([B],e.dtype,i)}};const VR={kernelName:wg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{s0:t,s1:C}=g,e=I.data.get(t.dataId).values,B=I.data.get(C.dataId).values,i=Hi(Array.from(e),Array.from(B));return I.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},WR=KF((A=>Math.ceil(A))),OR=uF(pg,WR),ZR={kernelName:pg,backendName:"cpu",kernelFunc:OR},PR=DF(yg,((A,g)=>{const I=g;return A>I.clipValueMax?I.clipValueMax:A<I.clipValueMin?I.clipValueMin:A})),XR={kernelName:yg,backendName:"cpu",kernelFunc:PR},jR={kernelName:fg,backendName:"cpu",kernelFunc:A=>{const{x:g}=A.inputs,I=A.backend,t=new Float32Array(QA(g.shape)),C=I.data.get(g.dataId),e=C.complexTensorInfos.real,B=C.complexTensorInfos.imag,i=I.data.get(e.dataId).values,Q=I.data.get(B.dataId).values;for(let A=0;A<i.length;A++){const g=i[A],I=Q[A];t[A]=Math.hypot(g,I)}return I.makeOutput(t,g.shape,"float32")}};function zR(A,g,I,t){const C=dA(I,QA(g));if(t&&"string"!==I){let g=0;A.forEach((A=>{const I=QA(A.shape);C.set(A.vals,g),g+=I}))}else{let t=0;A.forEach((A=>{const e="string"===I?dh(A.vals):A.vals;let B=0;for(let I=0;I<A.shape[0];++I){const i=I*g[1]+t;for(let g=0;g<A.shape[1];++g)C[i+g]=e[B++]}t+=A.shape[1]}))}return C}function _R(A){const{inputs:g,backend:I}=A,{input:t}=g,C=I.data.get(t.dataId).complexTensorInfos.imag,e=I.data.get(C.dataId).values;return I.makeTensorInfo(C.shape,C.dtype,e)}const $R={kernelName:rI,backendName:"cpu",kernelFunc:_R};function Am(A){const{inputs:g,backend:I,attrs:t}=A,{axis:C}=t,e=DA(C,g[0].shape)[0];Dr(g.map((A=>A.shape)),e);let B=ur(g.map((A=>A.shape)),e);if(0===QA(B))return I.makeTensorInfo(B,g[0].dtype,[]);const i=g.filter((A=>QA(A.shape)>0));if(1===i.length)return pF({inputs:{x:i[0]},backend:I});if("complex64"===i[0].dtype){const A=i.map((A=>TF({inputs:{input:A},backend:I}))),g=i.map((A=>_R({inputs:{input:A},backend:I}))),t=Am({inputs:A,backend:I,attrs:{axis:e}}),C=Am({inputs:g,backend:I,attrs:{axis:e}}),B=bF({inputs:{real:t,imag:C},backend:I});return A.forEach((A=>I.disposeIntermediateTensorInfo(A))),g.forEach((A=>I.disposeIntermediateTensorInfo(A))),I.disposeIntermediateTensorInfo(t),I.disposeIntermediateTensorInfo(C),B}const Q=i.map((A=>{const g=QA(A.shape.slice(e));return $F({inputs:{x:A},backend:I,attrs:{shape:[-1,g]}})})),o=Q.map((A=>({vals:I.data.get(A.dataId).values,shape:A.shape})));B=ur(Q.map((A=>A.shape)),1);const E=1===Q[0].shape[0],n=zR(o,B,g[0].dtype,E),s=ur(i.map((A=>A.shape)),e),a=I.makeTensorInfo(s,g[0].dtype,n);return Q.forEach((A=>I.disposeIntermediateTensorInfo(A))),a}const gm={kernelName:Ng,backendName:"cpu",kernelFunc:Am};function Im(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dataFormat:Q,dilations:o,dimRoundingMode:E}=t;hF([C,e],"conv2d");const n=Jo(Q),s=No(C.shape,e.shape,B,o,i,E,!1,n),a=s.filterHeight,r=s.filterWidth,h=s.dilationHeight,c=s.dilationWidth,l=s.padInfo.left,D=s.padInfo.top,u="channelsLast"===s.dataFormat,w=new Ae(s.outShape,C.dtype),d=KA(C.shape),p=KA(e.shape),y=d[0],G=u?d[1]:d[2],f=u?d[2]:1,N=u?1:d[1],F=w.strides[0],R=u?w.strides[1]:w.strides[2],m=u?w.strides[2]:1,k=u?1:w.strides[1],S=I.data.get(C.dataId).values,M=I.data.get(e.dataId).values,U=w.values;for(let A=0;A<s.batchSize;++A){const g=A*y,I=A*F;for(let A=0;A<s.outHeight;++A){const t=I+A*R,C=A*s.strideHeight-D;for(let A=0;A<a;++A){const I=C+A*h;if(I<0||I>=s.inHeight)continue;const e=A*p[0],B=g+I*G;for(let A=0;A<s.outWidth;++A){const g=t+A*m,I=A*s.strideWidth-l;for(let A=0;A<r;++A){const t=I+A*c;if(t<0||t>=s.inWidth)continue;const C=B+t*f;let i=e+A*p[1];for(let A=0;A<s.inChannels;++A){const I=S[C+A*N];for(let A=0;A<s.outChannels;++A)U[g+A*k]+=I*M[i+A];i+=s.outChannels}}}}}}return I.makeTensorInfo(w.shape,w.dtype,U)}const tm={kernelName:Fg,backendName:"cpu",kernelFunc:Im};const Cm={kernelName:Rg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,dy:e}=g,{strides:B,pad:i,dataFormat:Q,dimRoundingMode:o,filterShape:E}=t;hF([C,e],"conv2dBackpropFilter");const n=Jo(Q),s=No(C.shape,E,B,1,i,o,!1,n),{strideHeight:a,strideWidth:r,filterHeight:h,filterWidth:c}=s,l="channelsLast"===s.dataFormat,D=new Ae(s.filterShape,"float32"),u=s.padInfo.left,w=s.padInfo.top,d=I.data.get(C.dataId).values,p=I.data.get(e.dataId).values,y=new Ae(C.shape,C.dtype,d),G=new Ae(e.shape,e.dtype,p);for(let A=0;A<h;++A){const g=Math.max(0,Math.ceil((w-A)/a)),I=Math.min(s.outHeight,(s.inHeight+w-A)/a);for(let t=0;t<c;++t){const C=Math.max(0,Math.ceil((u-t)/r)),e=Math.min(s.outWidth,(s.inWidth+u-t)/r);for(let B=0;B<s.inChannels;++B)for(let i=0;i<s.outChannels;++i){let Q=0;for(let o=0;o<s.batchSize;++o)for(let E=g;E<I;++E){const g=A+E*a-w;for(let A=C;A<e;++A){const I=t+A*r-u;Q+=l?y.get(o,g,I,B)*G.get(o,E,A,i):y.get(o,B,g,I)*G.get(o,i,E,A)}}D.set(Q,A,t,B,i)}}}return I.makeTensorInfo(D.shape,D.dtype,D.values)}};const em={kernelName:mg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,filter:e}=g,{inputShape:B,strides:i,pad:Q,dataFormat:o,dimRoundingMode:E}=t;hF([C,e],"conv2dBackpropInput");const n=KA(e.shape),s=KA(C.shape);let a=Jo(o);const r=No(B,e.shape,i,1,Q,E,!1,a),h=new Ae(r.inShape,"float32"),c=h.values,l=I.data.get(C.dataId).values,D=I.data.get(e.dataId).values,[u,w,d]=n,{batchSize:p,filterHeight:y,filterWidth:G,inChannels:f,inHeight:N,inWidth:F,outChannels:R,outHeight:m,outWidth:k,strideHeight:S,strideWidth:M}=r;a=r.dataFormat;const U=y-1-r.padInfo.top,K=G-1-r.padInfo.left,J="channelsLast"===a,Y=h.strides[0],L=J?h.strides[1]:h.strides[2],x=J?h.strides[2]:1,b=J?1:h.strides[1],H=s[0],q=J?s[1]:s[2],T=J?s[2]:1,v=J?1:s[1];for(let A=0;A<p;++A)for(let g=0;g<f;++g)for(let I=0;I<N;++I){const t=I-U,C=Math.max(0,Math.ceil(t/S)),e=Math.min(m,(y+t)/S);for(let B=0;B<F;++B){const i=B-K,Q=Math.max(0,Math.ceil(i/M)),o=Math.min(k,(G+i)/M);let E=0;for(let I=C;I<e;++I){const C=I*S-t;for(let t=Q;t<o;++t){const e=H*A+q*I+T*t,B=u*(y-1-C)+w*(G-1-(t*M-i))+d*g;for(let A=0;A<R;++A){E+=l[e+v*A]*D[B+A]}}}c[Y*A+L*I+x*B+b*g]=E}}return I.makeTensorInfo(h.shape,h.dtype,h.values)}};const Bm={kernelName:kg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dilations:Q}=t;hF([C,e],"conv3d");const o=Fo(C.shape,e.shape,B,Q,i),{filterDepth:E,filterHeight:n,filterWidth:s,dilationDepth:a,dilationHeight:r,dilationWidth:h,padInfo:c}=o,l=c.front,D=c.left,u=c.top,w=new Ae(o.outShape,C.dtype),d=I.data.get(C.dataId).values,p=I.data.get(e.dataId).values,y=w.values,G=KA(C.shape),f=KA(e.shape);for(let A=0;A<o.batchSize;++A){const g=A*G[0],I=A*w.strides[0];for(let A=0;A<o.outDepth;++A){const t=I+A*w.strides[1],C=A*o.strideDepth-l;for(let A=0;A<E;++A){const I=C+A*a;if(I<0||I>=o.inDepth)continue;const e=A*f[0],B=g+I*G[1];for(let A=0;A<o.outHeight;++A){const g=t+A*w.strides[2],I=A*o.strideHeight-u;for(let A=0;A<n;++A){const t=I+A*r;if(t<0||t>=o.inHeight)continue;const C=e+A*f[1],i=B+t*G[2];for(let A=0;A<o.outWidth;++A){const I=g+A*o.outChannels,t=A*o.strideWidth-D;for(let A=0;A<s;++A){const g=t+A*h;if(g<0||g>=o.inWidth)continue;const e=C+A*f[2],B=i+g*o.inChannels;let Q=e;for(let A=0;A<o.inChannels;++A){const g=d[B+A];for(let A=0;A<o.outChannels;++A)y[I+A]+=g*p[Q+A];Q+=o.outChannels}}}}}}}}return I.makeTensorInfo(w.shape,w.dtype,w.values)}};const im={kernelName:Sg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,dy:e}=g,{strides:B,pad:i,filterShape:Q}=t;hF([C,e],"conv3dBackpropFilterV2");const o=KA(C.shape),E=KA(e.shape),n=Fo(C.shape,Q,B,1,i),s=n.strideDepth,a=n.strideHeight,r=n.strideWidth,h=n.filterDepth,c=n.filterHeight,l=n.filterWidth,D=new Ae(n.filterShape,"float32"),u=D.values,[w,d,p,y]=D.strides,G=I.data.get(e.dataId).values,[f,N,F,R]=E,m=I.data.get(C.dataId).values,[k,S,M,U]=o,K=n.padInfo.front,J=n.padInfo.left,Y=n.padInfo.top;for(let A=0;A<h;++A){const g=Math.max(0,Math.ceil((K-A)/s)),I=Math.min(n.outDepth,(n.inDepth+K-A)/s),t=A*w;for(let C=0;C<c;++C){const e=Math.max(0,Math.ceil((Y-C)/a)),B=Math.min(n.outHeight,(n.inHeight+Y-C)/a),i=C*d+t;for(let t=0;t<l;++t){const Q=Math.max(0,Math.ceil((J-t)/r)),o=Math.min(n.outWidth,(n.inWidth+J-t)/r),E=t*p+i;for(let i=0;i<n.inChannels;++i){const h=i*y+E;for(let E=0;E<n.outChannels;++E){let c=0;for(let h=0;h<n.batchSize;++h){const n=h*k,l=h*f;for(let h=g;h<I;++h){const g=(A+h*s-K)*S+n,I=h*N+l;for(let A=e;A<B;++A){const e=(C+A*a-Y)*M+g,B=A*F+I;for(let A=Q;A<o;++A){const g=A*R+B;c+=m[(t+A*r-J)*U+e+i]*G[g+E]}}}}u[h+E]=c}}}}}return I.makeTensorInfo(D.shape,D.dtype,D.values)}};const Qm={kernelName:Mg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,filter:e}=g,{pad:B,strides:i,inputShape:Q}=t;hF([C],"conv3dBackpropInputV2");const o=KA(C.shape),E=KA(e.shape),n=Fo(Q,e.shape,i,1,B),s=new Ae(n.inShape,"float32"),a=s.values,[r,h,c,l]=s.strides,D=I.data.get(C.dataId).values,[u,w,d,p]=o,y=I.data.get(e.dataId).values,[G,f,N,F]=E,{batchSize:R,filterDepth:m,filterHeight:k,filterWidth:S,inChannels:M,inDepth:U,inHeight:K,inWidth:J,outChannels:Y,outDepth:L,outHeight:x,outWidth:b,strideDepth:H,strideHeight:q,strideWidth:T}=n,v=m-1-n.padInfo.front,V=k-1-n.padInfo.top,W=S-1-n.padInfo.left;for(let A=0;A<R;++A)for(let g=0;g<M;++g)for(let I=0;I<U;++I){const t=I-v,C=Math.max(0,Math.ceil(t/H)),e=Math.min(L,(m+t)/H);for(let B=0;B<K;++B){const i=B-V,Q=Math.max(0,Math.ceil(i/q)),o=Math.min(x,(k+i)/q);for(let E=0;E<J;++E){const n=E-W,s=Math.max(0,Math.ceil(n/T)),R=Math.min(b,(S+n)/T);let M=0;for(let I=C;I<e;++I){const C=I*H-t;for(let t=Q;t<o;++t){const e=t*q-i;for(let B=s;B<R;++B){const i=u*A+w*I+d*t+p*B,Q=G*(m-1-C)+f*(k-1-e)+N*(S-1-(B*T-n))+F*g;for(let A=0;A<Y;++A){M+=D[i+A]*y[Q+A]}}}}a[r*A+h*I+c*B+l*E+g]=M}}}return I.makeTensorInfo(s.shape,s.dtype,s.values)}},om=DF(Ug,(A=>Math.cos(A))),Em={kernelName:Ug,backendName:"cpu",kernelFunc:om},nm=DF(Kg,(A=>Math.cosh(A))),sm={kernelName:Kg,backendName:"cpu",kernelFunc:nm};const am={kernelName:Lg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{image:C,boxes:e,boxInd:B}=g,{cropSize:i,method:Q,extrapolationValue:o}=t,[E,n,s,a]=C.shape,r=e.shape[0],[h,c]=i,l=HB([r,h,c,a],"float32"),D=I.data.get(e.dataId).values,u=I.data.get(B.dataId).values,w=I.data.get(C.dataId).values,d=KA(C.shape),p=KA(l.shape);for(let A=0;A<r;A++){const g=4*A,I=D[g],t=D[g+1],C=D[g+2],e=D[g+3],B=u[A];if(B>=E)continue;const i=h>1?(C-I)*(n-1)/(h-1):0,r=c>1?(e-t)*(s-1)/(c-1):0;for(let g=0;g<h;g++){const E=h>1?I*(n-1)+g*i:.5*(I+C)*(n-1);if(E<0||E>n-1)for(let I=0;I<c;I++)for(let t=0;t<a;t++){const C=t+I*p[2]+g*p[1]+A*p[0];l.values[C]=o}else if("bilinear"===Q){const I=Math.floor(E),C=Math.ceil(E),i=E-I;for(let Q=0;Q<c;Q++){const E=c>1?t*(s-1)+Q*r:.5*(t+e)*(s-1);if(E<0||E>s-1){for(let I=0;I<a;I++){const t=I+Q*p[2]+g*p[1]+A*p[0];l.values[t]=o}continue}const n=Math.floor(E),h=Math.ceil(E),D=E-n;for(let t=0;t<a;t++){let e=t+n*d[2]+I*d[1]+B*d[0];const o=w[e];e=t+h*d[2]+I*d[1]+B*d[0];const E=w[e];e=t+n*d[2]+C*d[1]+B*d[0];const s=w[e];e=t+h*d[2]+C*d[1]+B*d[0];const a=o+(E-o)*D,r=s+(w[e]-s)*D;e=t+Q*p[2]+g*p[1]+A*p[0],l.values[e]=a+(r-a)*i}}}else for(let I=0;I<c;++I){const C=c>1?t*(s-1)+I*r:.5*(t+e)*(s-1);if(C<0||C>s-1){for(let t=0;t<a;t++){const C=t+I*p[2]+g*p[1]+A*p[0];l.values[C]=o}continue}const i=Math.round(C),Q=Math.round(E);for(let t=0;t<a;t++){const C=t+i*d[2]+Q*d[1]+B*d[0],e=t+I*p[2]+g*p[1]+A*p[0];l.values[e]=w[C]}}}}return I.makeTensorInfo(l.shape,l.dtype,l.values)}};const rm={kernelName:Jg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,exclusive:B,reverse:i}=t;hF(C,"cumprod");const Q=UE([e],C.shape.length);let o=C;null!=Q&&(o=sR({inputs:{x:C},backend:I,attrs:{perm:Q}}));const E=JE(1,C.shape.length)[0];if(E!==o.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${o.shape.length-1} but got axis=${E}`);const n=ae(o.dtype,"int32"),s=LA(QA(o.shape),n),a=I.data.get(o.dataId).values,r=o.shape[o.shape.length-1],h=i?(A,g)=>A+r-g-1:(A,g)=>A+g;for(let A=0;A<a.length;A+=r)for(let g=0;g<r;g++){const I=h(A,g);if(0===g)s[I]=B?1:a[I];else{const t=h(A,g-1);s[I]=B?a[t]*s[t]:a[I]*s[t]}}const c=I.makeTensorInfo(o.shape,n,s);if(null!=Q){const A=sR({inputs:{x:c},backend:I,attrs:{perm:KE(Q)}});return I.disposeIntermediateTensorInfo(c),I.disposeIntermediateTensorInfo(o),A}return c}};const hm={kernelName:Yg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,exclusive:B,reverse:i}=t;hF(C,"cumsum");const Q=UE([e],C.shape.length);let o=C;null!=Q&&(o=sR({inputs:{x:C},backend:I,attrs:{perm:Q}}));const E=JE(1,C.shape.length)[0];if(E!==o.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${o.shape.length-1} but got axis=${E}`);const n=ae(o.dtype,"int32"),s=xA(QA(o.shape),n),a=I.data.get(o.dataId).values,r=o.shape[o.shape.length-1],h=i?(A,g)=>A+r-g-1:(A,g)=>A+g;for(let A=0;A<a.length;A+=r)for(let g=0;g<r;g++){const I=h(A,g);if(0===g)s[I]=B?0:a[I];else{const t=h(A,g-1);s[I]=B?a[t]+s[t]:a[I]+s[t]}}const c=I.makeTensorInfo(o.shape,n,s);if(null!=Q){const A=sR({inputs:{x:c},backend:I,attrs:{perm:KE(Q)}});return I.disposeIntermediateTensorInfo(c),I.disposeIntermediateTensorInfo(o),A}return c}};const cm={kernelName:xg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,weights:e}=g,{size:B,binaryOutput:i}=t;if(1===C.shape.length){const A=qR(I.data.get(C.dataId).values,I.data.get(e.dataId).values,e.dtype,e.shape,B);return I.makeTensorInfo([B],e.dtype,A)}if(2===C.shape.length){const A=TR(I.bufferSync(C),I.bufferSync(e),B,i);return I.makeTensorInfo(A.shape,e.dtype,A.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${C.shape.length}.`)}};const lm={kernelName:bg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{blockSize:e,dataFormat:B}=t;CA("NHWC"===B,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${B}`));const i=C.shape[0],Q=C.shape[1],o=C.shape[2],E=C.shape[3],n=Q*e,s=o*e,a=E/(e*e),r=I.data.get(C.dataId).values,h=new Float32Array(i*n*s*a);let c=0;for(let A=0;A<i;++A)for(let g=0;g<n;++g){const I=Math.floor(g/e),t=g%e;for(let g=0;g<s;++g){const C=Math.floor(g/e),B=(t*e+g%e)*a;for(let g=0;g<a;++g){const t=g+B+E*(C+o*(I+Q*A));h[c++]=r[t]}}}return I.makeTensorInfo([i,n,s,a],C.dtype,h)}};function Dm(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dilations:Q,dimRoundingMode:o}=t;hF([C,e],"depthwiseConv2DNative");const E=KA(C.shape),n=KA(e.shape);let s=Q;null==s&&(s=[1,1]),CA(Ko(B,s),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${B} and dilations '${s}'`));const a=No(C.shape,e.shape,B,s,i,o,!0),{filterHeight:r,filterWidth:h,dilationHeight:c,dilationWidth:l,padInfo:D}=a,u=D.left,w=D.top,d=a.outChannels/a.inChannels,p=new Ae(a.outShape,C.dtype),y=I.data.get(C.dataId).values,G=I.data.get(e.dataId).values,f=p.values;for(let A=0;A<a.batchSize;++A){const g=A*E[0],I=A*p.strides[0];for(let A=0;A<a.outHeight;++A){const t=I+A*p.strides[1],C=A*a.strideHeight-w;for(let A=0;A<r;++A){const I=C+A*c;if(I<0||I>=a.inHeight)continue;const e=A*n[0],B=g+I*E[1];for(let A=0;A<a.outWidth;++A){const g=t+A*p.strides[2],I=A*a.strideWidth-u;for(let A=0;A<h;++A){const t=I+A*l;if(t<0||t>=a.inWidth)continue;const C=e+A*n[1],i=B+t*a.inChannels;let Q=g,o=C;for(let A=0;A<a.inChannels;++A){const g=y[i+A];for(let A=0;A<d;++A)f[Q+A]+=g*G[o+A];Q+=d,o+=d}}}}}}return I.makeTensorInfo(p.shape,p.dtype,p.values)}const um={kernelName:Hg,backendName:"cpu",kernelFunc:Dm};const wm={kernelName:qg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,dy:e}=g,{strides:B,dilations:i,pad:Q,dimRoundingMode:o,filterShape:E}=t;hF([C,e],"depthwiseConv2dNativeBackpropFilter");const n=No(C.shape,E,B,i,Q,o,!0),{strideHeight:s,strideWidth:a,filterHeight:r,filterWidth:h}=n,c=new Ae(n.filterShape,"float32"),l=n.padInfo.left,D=n.padInfo.top,u=n.outChannels/n.inChannels,w=I.data.get(C.dataId).values,d=new Ae(C.shape,C.dtype,w),p=I.data.get(e.dataId).values,y=new Ae(e.shape,e.dtype,p);for(let A=0;A<r;++A){const g=Math.max(0,Math.ceil((D-A)/s)),I=Math.min(n.outHeight,(n.inHeight+D-A)/s);for(let t=0;t<h;++t){const C=Math.max(0,Math.ceil((l-t)/a)),e=Math.min(n.outWidth,(n.inWidth+l-t)/a);for(let B=0;B<n.outChannels;++B){const i=Math.trunc(B/u),Q=B%u;let o=0;for(let Q=0;Q<n.batchSize;++Q)for(let E=g;E<I;++E){const g=A+E*s-D;for(let A=C;A<e;++A){const I=t+A*a-l;o+=d.get(Q,g,I,i)*y.get(Q,E,A,B)}}c.set(o,A,t,i,Q)}}}return I.makeTensorInfo(c.shape,c.dtype,c.values)}};const dm={kernelName:Tg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,filter:e}=g,{strides:B,dilations:i,pad:Q,dimRoundingMode:o,inputShape:E}=t;hF([C,e],"depthwiseConv2DNativeBackpropInput");const n=KA(C.shape),s=KA(e.shape),a=No(E,e.shape,B,i,Q,o,!0),r=new Ae(a.inShape,"float32"),h=r.values,[c,l,D]=r.strides,u=I.data.get(C.dataId).values,[w,d,p]=n,y=I.data.get(e.dataId).values,[G,f,N]=s,{batchSize:F,filterHeight:R,filterWidth:m,inChannels:k,inHeight:S,inWidth:M,outChannels:U,outHeight:K,outWidth:J,strideHeight:Y,strideWidth:L}=a,x=R-1-a.padInfo.top,b=m-1-a.padInfo.left,H=U/k;for(let A=0;A<F;++A)for(let g=0;g<k;++g)for(let I=0;I<S;++I){const t=I-x,C=Math.max(0,Math.ceil(t/Y)),e=Math.min(K,(R+t)/Y);for(let B=0;B<M;++B){const i=B-b,Q=Math.max(0,Math.ceil(i/L)),o=Math.min(J,(m+i)/L);let E=0;for(let I=C;I<e;++I){const C=I*Y-t;for(let t=Q;t<o;++t){const e=w*A+d*I+p*t,B=G*(R-1-C)+f*(m-1-(t*L-i))+N*g;for(let A=0;A<H;++A){E+=u[e+(g*H+A)]*y[B+A]}}}h[c*A+l*I+D*B+g]=E}}return I.makeTensorInfo(r.shape,r.dtype,r.values)}};const pm={kernelName:vg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t}=g,C=QA(t.shape),e=I.data.get(t.dataId).values,B=HB([C,C],t.dtype),i=B.values;for(let A=0;A<e.length;A++)i[A*C+A]=e[A];const Q=[...t.shape,...t.shape];return I.makeTensorInfo(Q,B.dtype,B.values)}},ym={kernelName:Vg,backendName:"cpu",kernelFunc:({inputs:A,backend:g,attrs:I})=>{const{x:t,filter:C}=A,{strides:e,pad:B,dilations:i}=I,Q=g,o=Q.data.get(t.dataId).values,E=t.shape.length,n=Q.data.get(C.dataId).values,s=C.shape.length,{batchSize:a,inHeight:r,inWidth:h,inChannels:c,outHeight:l,outWidth:D,padInfo:u,strideHeight:w,strideWidth:d,filterHeight:p,filterWidth:y,dilationHeight:G,dilationWidth:f,outShape:N}=yo(t.shape,C.shape,e,B,"NHWC",i),F=QA(N),R=N.length,m=dA(t.dtype,F);for(let A=0;A<a;++A)for(let g=0;g<l;++g){const I=g*w-u.top;for(let e=0;e<D;++e){const B=e*d-u.left;for(let i=0;i<c;++i){let Q=Number.MIN_SAFE_INTEGER;for(let g=0;g<p;++g){const e=I+g*G;if(e>=0&&e<r)for(let I=0;I<y;++I){const a=B+I*f;if(a>=0&&a<h){const B=qA([A,e,a,i],E,KA(t.shape)),r=qA([g,I,i],s,KA(C.shape)),h=o[B]+n[r];h>Q&&(Q=h)}}}m[qA([A,g,e,i],R,KA(N))]=Q}}}return{dataId:Q.write(xC(m,t.dtype),N,t.dtype),shape:N,dtype:t.dtype}}},Gm={kernelName:Og,backendName:"cpu",kernelFunc:({inputs:A,backend:g,attrs:I})=>{const{x:t,filter:C,dy:e}=A,{strides:B,pad:i,dilations:Q}=I,o=g,E=YA(t.shape,o.data.get(t.dataId).values),n=YA(C.shape,o.data.get(C.dataId).values),{batchSize:s,inHeight:a,inWidth:r,inChannels:h,outHeight:c,outWidth:l,padInfo:D,strideHeight:u,strideWidth:w,filterHeight:d,filterWidth:p,dilationHeight:y,dilationWidth:G,outShape:f}=yo(t.shape,C.shape,B,i,"NHWC",Q);CA(e.rank===f.length,(()=>`Error in ${Og}, dy must have the same rank as output ${f.length}, but got ${e.rank}`));const N=YA(f,o.data.get(e.dataId).values),F=bA(C.shape,C.dtype);for(let A=0;A<s;++A)for(let g=0;g<c;++g){const I=g*u-D.top;for(let t=0;t<l;++t){const C=t*w-D.left;for(let e=0;e<h;++e){let B=Number.MIN_SAFE_INTEGER,i=0,Q=0;for(let g=0;g<d;++g){const t=I+g*y;if(t>=0&&t<a)for(let I=0;I<p;++I){const o=C+I*G;if(o>=0&&o<r){const C=E[A][t][o][e]+n[g][I][e];C>B&&(B=C,i=g,Q=I)}}}F[i][Q][e]+=N[A][g][t][e]}}}return{dataId:o.write(xC(F,t.dtype),C.shape,C.dtype),shape:C.shape,dtype:C.dtype}}},fm={kernelName:Wg,backendName:"cpu",kernelFunc:({inputs:A,backend:g,attrs:I})=>{const{x:t,filter:C,dy:e}=A,{strides:B,pad:i,dilations:Q}=I,o=g,E=YA(t.shape,o.data.get(t.dataId).values),n=YA(C.shape,o.data.get(C.dataId).values),{batchSize:s,inHeight:a,inWidth:r,inChannels:h,outHeight:c,outWidth:l,padInfo:D,strideHeight:u,strideWidth:w,filterHeight:d,filterWidth:p,dilationHeight:y,dilationWidth:G,outShape:f}=yo(t.shape,C.shape,B,i,"NHWC",Q);CA(e.rank===f.length,(()=>`Error in ${Wg}, dy must have the same rank as output ${f.length}, but got ${e.rank}`));const N=YA(f,o.data.get(e.dataId).values),F=bA(t.shape,t.dtype);for(let A=0;A<s;++A)for(let g=0;g<c;++g){const I=g*u-D.top;for(let t=0;t<l;++t){const C=t*w-D.left;for(let e=0;e<h;++e){let B=Number.MIN_SAFE_INTEGER,i=I<0?0:I,Q=C<0?0:C;for(let g=0;g<d;++g){const t=I+g*y;if(t>=0&&t<a)for(let I=0;I<p;++I){const o=C+I*G;if(o>=0&&o<r){const C=E[A][t][o][e]+n[g][I][e];C>B&&(B=C,i=t,Q=o)}}}F[A][i][Q][e]+=N[A][g][t][e]}}}return{dataId:o.write(xC(F,t.dtype),t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}},Nm=NF(((A,g)=>A*g)),Fm=PF(((A,g,I,t)=>({real:A*I-g*t,imag:A*t+g*I}))),Rm=ZF(WI,Nm,Fm),mm={kernelName:WI,backendName:"cpu",kernelFunc:Rm};function km(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t;let i;hF(C,"sum"),i="bool"===C.dtype?WF({inputs:{x:C},backend:I,attrs:{dtype:"int32"}}):pF({inputs:{x:C},backend:I});const Q=i.shape.length,o=DA(e,i.shape),E=UE(o,Q);let n=o,s=i;null!=E&&(s=sR({inputs:{x:i},backend:I,attrs:{perm:E}}),n=JE(n.length,Q)),ME("sum",n,s.shape.length);const[a,r]=kE(s.shape,n);let h=qF(I,a,ae(s.dtype,"int32"));const c=QA(r),l=I.data.get(h.dataId).values,D=I.data.get(s.dataId).values;for(let A=0;A<l.length;++A){const g=A*c;let I=0;for(let A=0;A<c;++A)I+=D[g+A];l[A]=I}if(B){const A=h;h=$F({inputs:{x:h},backend:I,attrs:{shape:SE(h.shape,o)}}),I.disposeIntermediateTensorInfo(A)}return I.disposeIntermediateTensorInfo(i),null!=E&&I.disposeIntermediateTensorInfo(s),h}const Sm={kernelName:St,backendName:"cpu",kernelFunc:km};const Mm={kernelName:Pg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{equation:C}=t,e=g,{allDims:B,summedDims:i,idDims:Q}=$r(C,e.length);gh(B.length,Q,e);const{path:o,steps:E}=Ih(i,Q),n=E.length;let s=null,a=B.length;const r=[];for(let A=0;A<n;++A){for(const g of E[A]){const{permutationIndices:A,expandDims:t}=Ah(a,Q[g]);let C;th(A)?C=e[g]:(C=sR({inputs:{x:e[g]},backend:I,attrs:{perm:A}}),r.push(C));const B=C.shape.slice();for(let A=0;A<t.length;++A)B.splice(t[A],0,1);EA(C.shape,B)||(C=$F({inputs:{x:C},backend:I,attrs:{shape:B}}),r.push(C)),null===s?s=C:(s=Rm({inputs:{a:C,b:s},backend:I}),r.push(s))}A<n-1&&(o[A]>=0&&(s=km({inputs:{x:s},backend:I,attrs:{axis:o[A]-(B.length-a),keepDims:!1}}),r.push(s)),a--)}for(const A of r)A!==s&&I.disposeIntermediateTensorInfo(A);return s}};const Um={kernelName:jg,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{dy:t,y:C}=g;hF([t,C],"eluGrad");const e=new Float32Array(QA(C.shape)),B=I.data.get(C.dataId).values,i=I.data.get(t.dataId).values;for(let A=0;A<B.length;++A){const g=B[A];e[A]=g>=1?i[A]:i[A]*(g+1)}return I.makeTensorInfo(C.shape,"float32",e)}},Km=NF(((A,g)=>A===g?1:0)),Jm=ZF(_g,Km,null,"bool"),Ym={kernelName:_g,backendName:"cpu",kernelFunc:Jm},Lm=Jr,xm=Yr,bm=Lr,Hm=xr,qm=br,Tm=Hr,vm=DF(zg,(A=>{const g=Math.sign(A),I=Math.abs(A),t=1/(1+Lm*I);return g*(1-((((Tm*t+qm)*t+Hm)*t+bm)*t+xm)*t*Math.exp(-I*I))})),Vm={kernelName:zg,backendName:"cpu",kernelFunc:vm},Wm=KF((A=>Math.exp(A))),Om=uF($g,Wm,"float32"),Zm={kernelName:$g,backendName:"cpu",kernelFunc:Om};function Pm(A){const{inputs:g,backend:I,attrs:t}=A,{input:C}=g,{dim:e}=t,B=C.shape.length,i=C.shape.slice();let Q=e;return e<0&&(CA(-(B+1)<=e,(()=>`Axis must be in the interval [${-(B+1)}, ${B}]`)),Q=B+e+1),i.splice(Q,0,1),$F({inputs:{x:C},backend:I,attrs:{shape:i}})}const Xm={kernelName:AI,backendName:"cpu",kernelFunc:Pm},jm=KF((A=>Math.expm1(A))),zm=uF(gI,jm),_m={kernelName:gI,backendName:"cpu",kernelFunc:zm},$m=NF(((A,g)=>A/g)),Ak=ZF(Zg,$m),gk={kernelName:Zg,backendName:"cpu",kernelFunc:Ak},Ik=NF(((A,g)=>A-g)),tk=PF(((A,g,I,t)=>({real:A-I,imag:g-t}))),Ck=ZF(Ot,Ik,tk),ek={kernelName:Ot,backendName:"cpu",kernelFunc:Ck};function Bk(A,g,I){const t=A.shape,C=t[0],e=t[1],B=I.data.get(A.dataId),i=B.complexTensorInfos.real,Q=B.complexTensorInfos.imag,o=[C,e],E=QA(o),n=wA("float32",E),s=wA("float32",E);for(let A=0;A<C;A++){const t=xR({inputs:{x:i},backend:I,attrs:{begin:[A,0],size:[1,e]}}),C=xR({inputs:{x:Q},backend:I,attrs:{begin:[A,0],size:[1,e]}}),B=bF({inputs:{real:t,imag:C},backend:I}),{real:o,imag:E}=ik(B,g,I),a=qr(o,E);for(let g=0;g<e;g++){const I=Wr(a,g);n[A*e+g]=I.real,s[A*e+g]=I.imag}I.disposeIntermediateTensorInfo(t),I.disposeIntermediateTensorInfo(C),I.disposeIntermediateTensorInfo(B)}const a=I.makeTensorInfo(o,"float32",n),r=I.makeTensorInfo(o,"float32",s),h=bF({inputs:{real:a,imag:r},backend:I});return I.disposeIntermediateTensorInfo(a),I.disposeIntermediateTensorInfo(r),h}function ik(A,g,I){const t=QA(A.shape),C=I.data.get(A.dataId),e=I.data.get(C.complexTensorInfos.real.dataId).values,B=I.data.get(C.complexTensorInfos.imag.dataId).values;if(0==((i=t)&i-1)){const C=Qk(e,B,t,g,I),i=[A.shape[0],A.shape[1]];if(g){const A=I.makeTensorInfo(i,"float32",C.real),g=I.makeTensorInfo(i,"float32",C.imag),e=I.makeTensorInfo([],"float32",LC(t,"float32")),B=pF({inputs:{x:e},backend:I}),Q=gk.kernelFunc({inputs:{a:A,b:e},backend:I}),o=gk.kernelFunc({inputs:{a:g,b:B},backend:I}),E=I.data.get(Q.dataId).values,n=I.data.get(o.dataId).values;return I.disposeIntermediateTensorInfo(A),I.disposeIntermediateTensorInfo(g),I.disposeIntermediateTensorInfo(e),I.disposeIntermediateTensorInfo(B),I.disposeIntermediateTensorInfo(Q),I.disposeIntermediateTensorInfo(o),{real:E,imag:n}}return C}{const A=function(A,g,I){const t=new Float32Array(2*g);for(let C=0;C<g;C++){let e=0,B=0;for(let t=0;t<g;t++){const i=Pr(C*t,g,I),Q=Wr(A,t);e+=Q.real*i.real-Q.imag*i.imag,B+=Q.real*i.imag+Q.imag*i.real}I&&(e/=g,B/=g),Or(t,e,B,C)}return t}(qr(e,B),t,g);return Tr(A)}var i}function Qk(A,g,I,t,C){if(1===I)return{real:A,imag:g};const e=qr(A,g),B=I/2,i=vr(e),Q=i.real,o=i.imag,E=[Q.length],n=C.makeTensorInfo(E,"float32",Q),s=C.makeTensorInfo(E,"float32",o),a=bF({inputs:{real:n,imag:s},backend:C}),r=Vr(e),h=r.real,c=r.imag,l=[h.length],D=C.makeTensorInfo(l,"float32",h),u=C.makeTensorInfo(l,"float32",c),w=bF({inputs:{real:D,imag:u},backend:C}),d=Qk(Q,o,B,t,C),p=d.real,y=d.imag,G=[p.length],f=C.makeTensorInfo(G,"float32",p),N=C.makeTensorInfo(G,"float32",y),F=bF({inputs:{real:f,imag:N},backend:C}),R=Qk(h,c,B,t,C),m=R.real,k=R.imag,S=[m.length],M=C.makeTensorInfo(S,"float32",m),U=C.makeTensorInfo(S,"float32",k),K=bF({inputs:{real:M,imag:U},backend:C}),J=Zr(I,t),Y=[J.real.length],L=C.makeTensorInfo(Y,"float32",J.real),x=C.makeTensorInfo(Y,"float32",J.imag),b=bF({inputs:{real:L,imag:x},backend:C}),H=Rm({inputs:{a:b,b:K},backend:C}),q=zF({inputs:{a:F,b:H},backend:C}),T=Ck({inputs:{a:F,b:H},backend:C}),v=TF({inputs:{input:q},backend:C}),V=TF({inputs:{input:T},backend:C}),W=_R({inputs:{input:q},backend:C}),O=_R({inputs:{input:T},backend:C}),Z=Am({inputs:[v,V],backend:C,attrs:{axis:0}}),P=Am({inputs:[W,O],backend:C,attrs:{axis:0}}),X=C.data.get(Z.dataId).values,j=C.data.get(P.dataId).values;return C.disposeIntermediateTensorInfo(n),C.disposeIntermediateTensorInfo(s),C.disposeIntermediateTensorInfo(a),C.disposeIntermediateTensorInfo(D),C.disposeIntermediateTensorInfo(u),C.disposeIntermediateTensorInfo(w),C.disposeIntermediateTensorInfo(f),C.disposeIntermediateTensorInfo(N),C.disposeIntermediateTensorInfo(F),C.disposeIntermediateTensorInfo(M),C.disposeIntermediateTensorInfo(U),C.disposeIntermediateTensorInfo(K),C.disposeIntermediateTensorInfo(L),C.disposeIntermediateTensorInfo(x),C.disposeIntermediateTensorInfo(b),C.disposeIntermediateTensorInfo(H),C.disposeIntermediateTensorInfo(q),C.disposeIntermediateTensorInfo(T),C.disposeIntermediateTensorInfo(v),C.disposeIntermediateTensorInfo(W),C.disposeIntermediateTensorInfo(V),C.disposeIntermediateTensorInfo(O),C.disposeIntermediateTensorInfo(Z),C.disposeIntermediateTensorInfo(P),{real:X,imag:j}}const ok={kernelName:II,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{input:t}=g,C=QA(t.shape),e=t.shape[t.shape.length-1],B=$F({inputs:{x:t},backend:I,attrs:{shape:[C/e,e]}}),i=Bk(B,!1,I),Q=$F({inputs:{x:i},backend:I,attrs:{shape:t.shape}});return I.disposeIntermediateTensorInfo(B),I.disposeIntermediateTensorInfo(i),Q}};function Ek(A){const{backend:g,attrs:I}=A,{shape:t,value:C,dtype:e}=I,B=e||SA(C),i=dA(B,QA(t));return function(A,g,I){A.fill(g)}(i,C),g.makeTensorInfo(t,B,i)}const nk={kernelName:tI,backendName:"cpu",kernelFunc:Ek};const sk={kernelName:CI,backendName:"cpu",kernelFunc:({inputs:A,attrs:g,backend:I})=>{const{image:t}=A,C=I,e=wA(t.dtype,QA(t.shape)),[B,i,Q,o]=t.shape,E=C.data.get(t.dataId).values;for(let A=0;A<B;A++){const g=A*Q*i*o;for(let A=0;A<i;A++){const I=A*(Q*o);for(let A=0;A<Q;A++){const t=A*o;for(let C=0;C<o;C++){const B=Math.round(Q-A-1),i=g+I+t+C;let n=E[i];if(B>=0&&B<Q){n=E[g+I+B*o+C]}e[i]=n}}}}return{dataId:C.write(e,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}},ak=KF((A=>Math.floor(A))),rk=uF(eI,ak),hk={kernelName:eI,backendName:"cpu",kernelFunc:rk},ck=NF(((A,g)=>Math.floor(A/g))),lk=ZF(BI,ck,null,"int32"),Dk={kernelName:BI,backendName:"cpu",kernelFunc:lk};const uk={kernelName:QC,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e,bias:B,preluActivationWeights:i}=g,{strides:Q,pad:o,dataFormat:E,dilations:n,dimRoundingMode:s,activation:a,leakyreluAlpha:r}=t;let h=Im({inputs:{x:C,filter:e},backend:I,attrs:{strides:Q,pad:o,dataFormat:E,dilations:n,dimRoundingMode:s}});if(B){const A=h;if("NCHW"===E&&1===B.shape.length&&1!==B.shape[0]){const A=$F({inputs:{x:B},backend:I,attrs:{shape:[B.shape[0],1,1]}});h=zF({inputs:{a:h,b:A},backend:I}),I.disposeIntermediateTensorInfo(A)}else h=zF({inputs:{a:h,b:B},backend:I});I.disposeIntermediateTensorInfo(A)}if(a){const A=h;if("NCHW"===E&&"prelu"===a&&1===i.shape.length&&1!==i.shape[0]){const A=$F({inputs:{x:i},backend:I,attrs:{shape:[i.shape[0],1,1]}});h=xF(I,h,a,A,r),I.disposeIntermediateTensorInfo(A)}else h=xF(I,h,a,i,r);I.disposeIntermediateTensorInfo(A)}return h}};const wk={kernelName:oC,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e,bias:B,preluActivationWeights:i}=g,{strides:Q,pad:o,dataFormat:E,dilations:n,dimRoundingMode:s,activation:a,leakyreluAlpha:r}=t;let h=Dm({inputs:{x:C,filter:e},backend:I,attrs:{strides:Q,pad:o,dataFormat:E,dilations:n,dimRoundingMode:s}});if(B){const A=h;h=zF({inputs:{a:h,b:B},backend:I}),I.disposeIntermediateTensorInfo(A)}if(a){const A=h;h=xF(I,h,a,i,r),I.disposeIntermediateTensorInfo(A)}return h}};function dk(A,g,I,t,C,e,B,i,Q){const o=HB([t,e],I);for(let I=0;I<t;I++){const t=[];let E=0;for(let g=0;g<C;g++){const e=A[I*C+g];E+=e*B[g],t.push(e)}if(E<0||E>=Q/e)throw new Error(`Invalid indices: ${t} does not index into ${i}`);for(let A=0;A<e;A++)o.values[I*e+A]=g.get(...g.indexToLoc(E*e+A))}return o}const pk={kernelName:oI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{params:t,indices:C}=g,e=QA(t.shape),B=C.shape,i=B[B.length-1],[Q,o,E,n]=Pi(t,C);if(0===o)return I.makeTensorInfo(Q,t.dtype,[]);const s=dk(I.data.get(C.dataId).values,I.bufferSync(t),t.dtype,o,i,E,n,t.shape,e);return I.makeTensorInfo(Q,t.dtype,s.values)}};function yk(A,g,I){const t=HB(I,A.dtype);for(let I=0;I<t.size;++I){const C=t.indexToLoc(I).slice(),e=C[0],B=C[2],i=g.locToIndex([e,B]);C[2]=g.values[i];const Q=A.locToIndex(C);0<=Q&&Q<A.values.length&&(t.values[I]=A.values[Q])}return t}const Gk={kernelName:QI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,indices:e}=g,{axis:B,batchDims:i}=t;hF([C,e],"gatherV2");const Q=DA(B,C.shape)[0],o=I.data.get(e.dataId).values,E=C.shape[Q];for(let A=0;A<o.length;++A){const g=o[A];CA(g<=E-1&&g>=0,(()=>`GatherV2: the index value ${g} is not in [0, ${E-1}]`))}let n=i;null==i&&(n=0);const s=QA(e.shape),a=wh(C,e,Q,n),r=$F({inputs:{x:C},backend:I,attrs:{shape:[a.batchSize,a.outerSize,a.dimSize,a.sliceSize]}}),h=$F({inputs:{x:e},backend:I,attrs:{shape:[a.batchSize,s/a.batchSize]}}),c=[a.batchSize,a.outerSize,s/a.batchSize,a.sliceSize],l=I.bufferSync(h),D=yk(I.bufferSync(r),l,c);return I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(h),I.makeTensorInfo(a.outputShape,D.dtype,D.values)}},fk=NF(((A,g)=>A>g?1:0)),Nk=ZF(EI,fk,null,"bool"),Fk={kernelName:EI,backendName:"cpu",kernelFunc:Nk},Rk=NF(((A,g)=>A>=g?1:0)),mk=ZF(nI,Rk,null,"bool"),kk={kernelName:nI,backendName:"cpu",kernelFunc:mk};const Sk={kernelName:aI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{input:t}=g,C=QA(t.shape),e=t.shape[t.shape.length-1],B=$F({inputs:{x:t},backend:I,attrs:{shape:[C/e,e]}}),i=Bk(B,!0,I),Q=$F({inputs:{x:i},backend:I,attrs:{shape:t.shape}});return I.disposeIntermediateTensorInfo(B),I.disposeIntermediateTensorInfo(i),Q}},Mk=DF(hI,(A=>Number.isFinite(A)?1:0),"bool"),Uk={kernelName:hI,backendName:"cpu",kernelFunc:Mk},Kk=DF(cI,(A=>Math.abs(A)===1/0?1:0),"bool"),Jk={kernelName:cI,backendName:"cpu",kernelFunc:Kk},Yk=DF(lI,(A=>Number.isNaN(A)?1:0),"bool"),Lk={kernelName:lI,backendName:"cpu",kernelFunc:Yk},xk=NF(((A,g)=>A<g?1:0)),bk=ZF(uI,xk,null,"bool"),Hk={kernelName:uI,backendName:"cpu",kernelFunc:bk},qk=NF(((A,g)=>A<=g?1:0)),Tk=ZF(wI,qk,null,"bool"),vk={kernelName:wI,backendName:"cpu",kernelFunc:Tk};function Vk(A,g,I){const t=(g-A)/(I-1),C=xA(I,"float32");C[0]=A;for(let A=1;A<C.length;A++)C[A]=C[A-1]+t;return C}const Wk={kernelName:dI,backendName:"cpu",kernelFunc:function(A){const{backend:g,attrs:I}=A,{start:t,stop:C,num:e}=I,B=Vk(t,C,e);return g.makeTensorInfo([B.length],"float32",B)}},Ok=KF((A=>Math.log(A))),Zk=uF(pI,Ok),Pk={kernelName:pI,backendName:"cpu",kernelFunc:Zk},Xk=DF(yI,(A=>Math.log1p(A))),jk={kernelName:yI,backendName:"cpu",kernelFunc:Xk},zk=NF(((A,g)=>A&&g)),_k=ZF(GI,zk,null,"bool"),$k={kernelName:GI,backendName:"cpu",kernelFunc:_k},AS=DF(fI,(A=>A?0:1),"bool"),gS={kernelName:fI,backendName:"cpu",kernelFunc:AS},IS=NF(((A,g)=>A||g)),tS=ZF(NI,IS,null,"bool"),CS={kernelName:NI,backendName:"cpu",kernelFunc:tS};const eS={kernelName:kI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{depthRadius:e,bias:B,alpha:i,beta:Q}=t;hF(C,"LRN");const o=C.shape[3],E=o-1,n=I.data.get(C.dataId).values,s=QA(C.shape),a=new Float32Array(s);function r(A){const g=A%o;let I=A-g+Math.max(0,g-e);const t=A-g+Math.min(g+e,E);let C=0;for(;I<=t;I++){const A=n[I];C+=A*A}return C}for(let A=0;A<s;A++){const g=r(A),I=n[A]*Math.pow(B+i*g,-Q);a[A]=I}return I.makeTensorInfo(C.shape,C.dtype,a)}};const BS={kernelName:SI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,y:e,dy:B}=g,{depthRadius:i,bias:Q,alpha:o,beta:E}=t;hF(B,"LRNGrad");const n=QA(B.shape),s=B.shape[3],a=I.data.get(B.dataId).values,r=I.data.get(C.dataId).values,h=I.data.get(e.dataId).values,c=new Float32Array(n),l=n;for(let A=0;A<l;A++){const g=A%s,I=A-g+Math.max(0,g-i),t=A-g+Math.min(s,g+i+1);let C=0;for(let A=I;A<t;A++)C+=Math.pow(r[A],2);C=o*C+Q;for(let g=I;g<t;g++){let I=-2*o*E*r[g]*h[A]/C;A===g&&(I+=Math.pow(C,-E)),I*=a[A],c[g]+=I}}return I.makeTensorInfo(B.shape,C.dtype,c)}};function iS(A,g,I,t){const C=wA(t,QA(I));for(let I=0;I<C.length;++I){const t=I*g;let e=A[t];for(let I=0;I<g;++I){const g=A[t+I];(Number.isNaN(g)||g>e)&&(e=g)}C[I]=e}return C}function QS(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{reductionIndices:e,keepDims:B}=t,i=I;let Q=C.shape;const o=Q.length,E=DA(e,Q);let n=E;const s=UE(n,o);let a=i.data.get(C.dataId).values;if(null!=s){const A=new Array(o);for(let g=0;g<A.length;g++)A[g]=Q[s[g]];a=nR(a,Q,C.dtype,s,A),n=JE(n.length,o),Q=A}hF(C,"max"),ME("max",n,o);const[r,h]=kE(Q,n),c=iS(a,QA(h),r,C.dtype),l=i.write(c,r,C.dtype);let D=r;if(B){D=SE(r,E)}return{dataId:l,shape:D,dtype:C.dtype}}const oS={kernelName:MI,backendName:"cpu",kernelFunc:QS},ES=NF(((A,g)=>Math.max(A,g))),nS=ZF(UI,ES),sS={kernelName:UI,backendName:"cpu",kernelFunc:nS};const aS={kernelName:KI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g;hF(C,"maxPool");const{filterSize:e,strides:B,pad:i,dimRoundingMode:Q}=t;CA(Ko(B,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${B} and dilations '1'`));const o=Go(C.shape,e,B,1,i,Q);let E;if(1===o.filterWidth&&1===o.filterHeight&&EA(o.inShape,o.outShape))E=pF({inputs:{x:C},backend:I});else{const A=I.data.get(C.dataId).values,g=KA(C.shape),t=mR(A,C.shape,C.dtype,g,o,"max");E=I.makeTensorInfo(o.outShape,C.dtype,t.values)}return E}};const rS={kernelName:YI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{filterSize:e,strides:B,pad:i,dimRoundingMode:Q,dataFormat:o}=t;hF(C,"maxPool3d");const E=fo(C.shape,e,B,1,i,Q,o),n=SR(I.data.get(C.dataId).values,C.shape,C.dtype,KA(C.shape),E,"max");return I.makeTensorInfo(n.shape,"float32",n.values)}};const hS={kernelName:LI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e}=g,{filterSize:B,strides:i,pad:Q,dimRoundingMode:o}=t;hF([C,e],"maxPool3DGrad");const E=fo(e.shape,B,i,1,Q,o),n=function(A,g){const I=HB(g.outShape,"int32"),t=g.strideDepth,C=g.strideHeight,e=g.strideWidth,B=g.dilationDepth,i=g.dilationHeight,Q=g.dilationWidth,o=g.effectiveFilterDepth,E=g.effectiveFilterHeight,n=g.effectiveFilterWidth,s=g.padInfo.front,a=g.padInfo.top,r=g.padInfo.left;for(let h=0;h<g.batchSize;++h)for(let c=0;c<g.inChannels;++c)for(let l=0;l<g.outDepth;++l){const D=l*t-s;let u=D;for(;u<0;)u+=B;const w=Math.min(g.inDepth,o+D);for(let t=0;t<g.outHeight;++t){const o=t*C-a;let s=o;for(;s<0;)s+=i;const d=Math.min(g.inHeight,E+o);for(let C=0;C<g.outWidth;++C){const a=C*e-r;let p=a;for(;p<0;)p+=Q;const y=Math.min(g.inWidth,n+a);let G=Number.NEGATIVE_INFINITY,f=-1;for(let g=u;g<w;g+=B){const I=g-D;for(let t=s;t<d;t+=i){const C=t-o;for(let e=p;e<y;e+=Q){const B=e-a,i=A.get(h,g,t,e,c);i>=G&&(G=i,f=I*E*n+C*E+B)}}}I.set(f,h,l,t,C,c)}}}return I}(I.bufferSync(e),E),s=E.strideDepth,a=E.strideHeight,r=E.strideWidth,h=E.dilationDepth,c=E.dilationHeight,l=E.dilationWidth,D=E.effectiveFilterDepth,u=E.effectiveFilterHeight,w=E.effectiveFilterWidth,d=D-1-E.padInfo.front,p=w-1-E.padInfo.left,y=u-1-E.padInfo.top,G=HB(e.shape,"float32"),f=I.bufferSync(C);for(let A=0;A<E.batchSize;++A)for(let g=0;g<E.inChannels;++g)for(let I=0;I<E.inDepth;++I)for(let t=0;t<E.inHeight;++t)for(let C=0;C<E.inWidth;++C){const e=I-d,B=t-y,i=C-p;let Q=0;for(let I=0;I<D;I+=h){const t=(e+I)/s;if(!(t<0||t>=E.outDepth||Math.floor(t)!==t))for(let C=0;C<u;C+=c){const e=(B+C)/a;if(!(e<0||e>=E.outHeight||Math.floor(e)!==e))for(let B=0;B<w;B+=l){const o=(i+B)/r;if(o<0||o>=E.outWidth||Math.floor(o)!==o)continue;const s=D*u*w-1-n.get(A,t,e,o,g)===I*u*w+C*w+B?1:0;if(0===s)continue;Q+=f.get(A,t,e,o,g)*s}}}G.set(Q,A,I,t,C,g)}return I.makeTensorInfo(G.shape,G.dtype,G.values)}};const cS={kernelName:JI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e,output:B}=g,i=e;hF([e,B],"maxPoolGrad");const{filterSize:Q,strides:o,pad:E,dimRoundingMode:n}=t,s=Go(i.shape,Q,o,1,E,n),a=I.data.get(i.dataId).values,r=HB(s.outShape,i.dtype,kR(a,i.shape,i.dtype,s).values),h=s.strideHeight,c=s.strideWidth,l=s.dilationHeight,D=s.dilationWidth,u=s.effectiveFilterHeight,w=s.effectiveFilterWidth,d=w-1-s.padInfo.left,p=u-1-s.padInfo.top,y=HB(i.shape,"float32"),G=I.data.get(C.dataId).values,f=HB(C.shape,"float32",G);for(let A=0;A<s.batchSize;++A)for(let g=0;g<s.inChannels;++g)for(let I=0;I<s.inHeight;++I)for(let t=0;t<s.inWidth;++t){const C=I-p,e=t-d;let B=0;for(let I=0;I<u;I+=l){const t=(C+I)/h;if(!(t<0||t>=s.outHeight||Math.floor(t)!==t))for(let C=0;C<w;C+=D){const i=(e+C)/c;if(i<0||i>=s.outWidth||Math.floor(i)!==i)continue;const Q=u*w-1-r.get(A,t,i,g)===I*w+C?1:0;if(0===Q)continue;B+=f.get(A,t,i,g)*Q}}y.set(B,A,I,t,g)}return I.makeTensorInfo(y.shape,y.dtype,y.values)}};const lS={kernelName:xI,backendName:"cpu",kernelFunc:({inputs:A,attrs:g,backend:I})=>{const{x:t}=A,{filterSize:C,strides:e,pad:B,includeBatchInIndex:i}=g,Q=I;hF(t,"MaxPoolWithArgmax");const o=Q.data.get(t.dataId).values,E=Go(t.shape,C,e,[1,1],B),[n,s]=function(A,g,I,t,C){const e=mR(A,0,I,KA(g),C,"max"),B=kR(A,g,I,C,!0,t);return[e.values,B.values]}(o,t.shape,t.dtype,i,E),a=Q.write(n,E.outShape,t.dtype),r=Q.write(s,E.outShape,t.dtype);return[{dataId:a,shape:E.outShape,dtype:t.dtype},{dataId:r,shape:E.outShape,dtype:"int32"}]}};const DS={kernelName:bI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t,i=DA(e,C.shape),Q=QA(kE(C.shape,i)[1]),o=[],E=I.makeTensorInfo([],"float32",new Float32Array([Q]));o.push(E);const n=WF({inputs:{x:C},backend:I,attrs:{dtype:"float32"}});o.push(n);const s=Ak({inputs:{a:n,b:E},backend:I});o.push(s);const a=km({inputs:{x:s},backend:I,attrs:{axis:e,keepDims:B}});return o.forEach((A=>I.disposeIntermediateTensorInfo(A))),a}};const uS={kernelName:HI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t;hF(C,"min");const i=DA(e,C.shape);let Q=i;const o=UE(Q,C.shape.length);let E=C;null!=o&&(E=sR({inputs:{x:C},backend:I,attrs:{perm:o}}),Q=JE(Q.length,C.shape.length)),ME("min",Q,E.shape.length);const[n,s]=kE(E.shape,Q),a=QA(s),r=xA(QA(n),E.dtype),h=I.data.get(E.dataId).values;for(let A=0;A<r.length;++A){const g=A*a;let I=h[g];for(let A=0;A<a;++A){const t=h[g+A];(Number.isNaN(t)||t<I)&&(I=t)}r[A]=I}null!=o&&I.disposeIntermediateTensorInfo(E);const c=I.makeTensorInfo(n,E.dtype,r);if(B){const A=$F({inputs:{x:c},backend:I,attrs:{shape:SE(n,i)}});return I.disposeIntermediateTensorInfo(c),A}return c}},wS=NF(((A,g)=>Math.min(A,g))),dS=ZF(qI,wS),pS={kernelName:qI,backendName:"cpu",kernelFunc:dS};const yS={kernelName:TI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{paddings:e,mode:B}=t;hF(C,"mirrorPad");const i=e.map(((A,g)=>A[0]+C.shape[g]+A[1])),Q=e.map((A=>A[0])),o=e.map(((A,g)=>A[0]+C.shape[g])),E="reflect"===B?0:1,n=I.data.get(C.dataId).values,s=C.shape.length,a=KA(C.shape),r=QA(i),h=i.length,c=KA(i),l=wA(C.dtype,r);for(let A=0;A<r;A++){let g=TA(A,h,c);for(let A=0;A<h;A++)g[A]<Q[A]?g[A]=2*Q[A]-g[A]-E:g[A]>=o[A]&&(g[A]=2*(o[A]-1)-g[A]+E);g=g.map(((A,g)=>A-Q[g]));const I=qA(g,s,a);l[A]=n[I]}return{dataId:I.write(l,i,C.dtype),shape:i,dtype:C.dtype}}},GS=NF(((A,g)=>{const I=A%g;return A<0&&g<0||A>=0&&g>=0?I:(I+g)%g})),fS=ZF(vI,GS),NS={kernelName:vI,backendName:"cpu",kernelFunc:fS};function FS(A){const{inputs:g,backend:I,attrs:t}=A,{logits:C}=g,{dim:e}=t,B=C.shape.length;let i=e;if(-1===i&&(i=B-1),i!==B-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${B} and dim was ${i}`);const Q=DA([i],C.shape),o=QS({inputs:{x:C},backend:I,attrs:{reductionIndices:Q,keepDims:!1}}),E=SE(o.shape,Q),n=$F({inputs:{x:o},backend:I,attrs:{shape:E}}),s=Ck({inputs:{a:C,b:n},backend:I}),a=Om({inputs:{x:s},backend:I}),r=km({inputs:{x:a},backend:I,attrs:{axis:Q,keepDims:!1}}),h=$F({inputs:{x:r},backend:I,attrs:{shape:E}}),c=Ak({inputs:{a,b:h},backend:I});return I.disposeIntermediateTensorInfo(o),I.disposeIntermediateTensorInfo(n),I.disposeIntermediateTensorInfo(s),I.disposeIntermediateTensorInfo(a),I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(h),c}const RS={kernelName:Kt,backendName:"cpu",kernelFunc:FS};const mS={kernelName:VI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{logits:C}=g,{numSamples:e,seed:B,normalized:i}=t;hF(C,"multinomial");const Q=i?C:FS({inputs:{logits:C},backend:I,attrs:{dim:-1}}),o=Q.shape[0],E=Q.shape[1],n=I.data.get(Q.dataId).values,s=[o,e],a=xA(QA(s),"int32");for(let A=0;A<o;++A){const g=A*E,I=new Float32Array(E-1);I[0]=n[g];for(let A=1;A<I.length;++A)I[A]=I[A-1]+n[g+A];const t=Zn.alea(B.toString()),C=A*e;for(let A=0;A<e;++A){const g=t();a[C+A]=I.length;for(let t=0;t<I.length;t++)if(g<I[t]){a[C+A]=t;break}}}return i||I.disposeIntermediateTensorInfo(Q),I.makeTensorInfo(s,"int32",a)}};function kS(A,g,I){const t=LC(-1,I);return Nm([],g,t,A,I)}const SS={kernelName:OI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t}=g;hF(t,"neg");const C=I.data.get(t.dataId).values,[e,B]=kS(C,t.shape,t.dtype);return I.makeTensorInfo(B,t.dtype,e)}},MS=fa;const US={kernelName:PI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{boxes:C,scores:e}=g,{maxOutputSize:B,iouThreshold:i,scoreThreshold:Q}=t;hF(C,"NonMaxSuppression");const o=I.data.get(C.dataId).values,E=I.data.get(e.dataId).values,{selectedIndices:n}=MS(o,E,B,i,Q);return I.makeTensorInfo([n.length],"int32",new Int32Array(n))}},KS=Na;const JS={kernelName:XI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{boxes:C,scores:e}=g,{maxOutputSize:B,iouThreshold:i,scoreThreshold:Q,padToMaxOutputSize:o}=t;hF(C,"NonMaxSuppressionPadded");const E=I.data.get(C.dataId).values,n=I.data.get(e.dataId).values,{selectedIndices:s,validOutputs:a}=KS(E,n,B,i,Q,o);return[I.makeTensorInfo([s.length],"int32",new Int32Array(s)),I.makeTensorInfo([],"int32",new Int32Array([a]))]}},YS=Fa;const LS={kernelName:jI,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{boxes:C,scores:e}=g,{maxOutputSize:B,iouThreshold:i,scoreThreshold:Q,softNmsSigma:o}=t;hF(C,"NonMaxSuppressionWithScore");const E=I.data.get(C.dataId).values,n=I.data.get(e.dataId).values,s=B,a=i,r=Q,h=o,{selectedIndices:c,selectedScores:l}=YS(E,n,s,a,r,h);return[I.makeTensorInfo([c.length],"int32",new Int32Array(c)),I.makeTensorInfo([l.length],"float32",new Float32Array(l))]}},xS=NF(((A,g)=>A!==g?1:0)),bS=ZF(ZI,xS,null,"bool"),HS={kernelName:ZI,backendName:"cpu",kernelFunc:bS};const qS={kernelName:_I,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{indices:C}=g,{dtype:e,depth:B,onValue:i,offValue:Q}=t;hF(C,"oneHot");const o=QA(C.shape),E=new Float32Array(o*B);E.fill(Q);const n=I.data.get(C.dataId).values;for(let A=0;A<o;++A)n[A]>=0&&n[A]<B&&(E[A*B+n[A]]=i);return I.makeTensorInfo([...C.shape,B],e,E)}};function TS(A){const{inputs:g,backend:I}=A,{x:t}=g;if("string"===t.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===t.dtype){const A=TF({inputs:{input:t},backend:I}),g=TS({inputs:{x:A},backend:I}),C=_R({inputs:{input:t},backend:I}),e=TS({inputs:{x:C},backend:I}),B=bF({inputs:{real:g,imag:e},backend:I});return I.disposeIntermediateTensorInfo(A),I.disposeIntermediateTensorInfo(g),I.disposeIntermediateTensorInfo(C),I.disposeIntermediateTensorInfo(e),B}return Ek({backend:I,attrs:{shape:t.shape,value:0,dtype:t.dtype}})}const vS={kernelName:tC,backendName:"cpu",kernelFunc:TS};const VS={kernelName:zI,backendName:"cpu",kernelFunc:function A(g){const{inputs:I,backend:t}=g,{x:C}=I;if("string"===C.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===C.dtype){const g=TF({inputs:{input:C},backend:t}),I=A({inputs:{x:g},backend:t}),e=_R({inputs:{input:C},backend:t}),B=TS({inputs:{x:e},backend:t}),i=bF({inputs:{real:I,imag:B},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(B),i}return Ek({backend:t,attrs:{shape:C.shape,value:1,dtype:C.dtype}})}};function WS(A){const{inputs:g,backend:I,attrs:t}=A,{axis:C}=t;if(1===g.length)return Pm({inputs:{input:g[0]},backend:I,attrs:{dim:C}});const e=g[0].shape,B=g[0].dtype;g.forEach((A=>{eA(e,A.shape,"All tensors passed to stack must have matching shapes"),CA(B===A.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],Q=Am({inputs:g.map((A=>{const g=Pm({inputs:{input:A},backend:I,attrs:{dim:C}});return i.push(g),g})),backend:I,attrs:{axis:C}});return i.forEach((A=>I.disposeIntermediateTensorInfo(A))),Q}const OS={kernelName:$I,backendName:"cpu",kernelFunc:WS};const ZS={kernelName:At,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{paddings:e,constantValue:B}=t;hF(C,"pad");const i=e.map(((A,g)=>A[0]+C.shape[g]+A[1])),Q=e.map((A=>A[0])),o=I.data.get(C.dataId).values,E=QA(C.shape),n=C.shape.length,s=KA(C.shape),a=QA(i),r=i.length,h=KA(i),c=wA(C.dtype,a);0!==B&&c.fill(B);for(let A=0;A<E;A++){c[qA(TA(A,n,s).map(((A,g)=>A+Q[g])),r,h)]=o[A]}return{dataId:I.write(c,i,C.dtype),shape:i,dtype:C.dtype}}},PS=NF(((A,g)=>Math.pow(A,g))),XS=ZF(It,PS),jS={kernelName:It,backendName:"cpu",kernelFunc:XS};function zS(A,g,I,t){const[C,e]=kE(A,t),B=ae(g,"int32"),i=xA(QA(C),B),Q=QA(e);for(let A=0;A<i.length;++A){const g=A*Q;let t=1;for(let A=0;A<Q;++A)t*=I[g+A];i[A]=t}return{outVals:i,outShape:C,outDtype:B}}const _S={kernelName:Ct,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t;hF(C,"prod");const i=C.shape.length,Q=DA(e,C.shape),o=UE(Q,i);let E=Q,n=C;const s=[];null!=o&&(n=sR({inputs:{x:C},backend:I,attrs:{perm:o}}),s.push(n),E=JE(E.length,i));const a=I.data.get(n.dataId).values,{outVals:r,outShape:h,outDtype:c}=zS(n.shape,n.dtype,a,E);let l=h;return B&&(l=SE(h,Q)),s.forEach((A=>I.disposeIntermediateTensorInfo(A))),I.makeTensorInfo(l,c,r)}};function $S(A,g,I,t){const C=[];let e=0;const B=g.length-1+I.length,i=new Array(B).fill(null).map((()=>[0]));!function(A,g){for(let I=0;I<A.length;++I){const t=A[I],C=I===A.length-1?g:A[I+1].length;if(0===t.length)throw new Error("Ragged splits may not be empty");if(t[0]<0)throw new Error("Ragged splits must be non-negative");if(t[t.length-1]>C)throw new Error("Ragged splits must not point past values");for(let A=1;A<t.length;++A)if(t[A-1]>t[A])throw new Error("Ragged splits must be sorted in ascending order")}}(I,t);let Q=1;for(let A=0;A<g.length-1;++A){Q*=g[A];const I=g[A+1];for(let g=1;g<Q+1;++g)i[A].push(g*I)}for(let t=0;t<A.length;++t){let B=A[t],Q=A[t]+1;for(let A=0;A<I.length;++A){const t=I[A],C=A+g.length-1;if(C>=0){const A=i[C],g=A[A.length-1]-t[B];for(let A=B;A<Q;++A)i[C].push(t[A+1]+g)}B=t[B],Q=t[Q]}Q!==B&&(C.push([B,Q]),e+=Q-B)}return{outSplits:i,valueSlices:C,numValues:e}}function AM(A,g){const I=A.slice(0,g);for(;I.length<g;)I.push(1);for(let t=g;t<A.length;t++)I[g-1]*=A[t];return I}function gM(A,g,I,t,C){const e=g.slice();e[0]=C;const B=dA(I,QA(e)),i=A.length;return function(A,g,I,t,C,e){const B=AM(g,2)[1],i=AM(e,2)[1];let Q=0;for(const g of I)for(let I=g[0];I<g[1];++I){for(let g=0;g<t;++g)C[Q*i+g]=A[I*B+g];++Q}}(A,g,t,0===i?0:i/g[0],B,e),[B,e]}function IM(A,g,I,t,C,e,B,i){if(0===A.length)throw new Error("paramsNestedSplits must be non empty");if(0===g[0].length)throw new Error("Split tensors must not be scalars");if(function(A,g,I){A.forEach(((A,t)=>{if(A<0||A>=I){const C=TA(t,g.length,KA(g)).join(",");throw new Error(`indices[${C}] = ${A} is not in [0, ${I})`)}}))}(e,B,g[0][0]-1),0===t.length)throw new Error("params.rank must be nonzero");const Q=t[0],{outSplits:o,valueSlices:E,numValues:n}=$S(e,B,A,Q),s=function(A){const g=[];for(let I=0;I<A.length;++I){const t=dA("int32",A[I].length);g.push(t),A[I].forEach(((A,g)=>t[g]=A))}return g}(o),a=gM(I,t,C,E,n);return[s,a[0],a[1]]}const tM={kernelName:et,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{paramsNestedSplits:C,paramsDenseValues:e,indices:B}=g,{outputRaggedRank:i}=t,Q=C.map((A=>I.data.get(A.dataId).values)),o=C.map((A=>A.shape)),E=I.data.get(e.dataId).values,n=I.data.get(B.dataId).values,[s,a,r]=IM(Q,o,E,e.shape,e.dtype,n,B.shape),h=s.map((A=>I.makeTensorInfo([A.length],"int32",A))),c=I.makeTensorInfo(r,e.dtype,a);return h.concat([c])}};var CM=wr;class eM{constructor(A,g,I,t,C,e,B,i,Q,o){this.shape=A,this.shapeShape=g,this.values=I,this.valuesShape=t,this.valuesDType=C,this.defaultValue=e,this.defaultValueShape=B,this.rowPartitionValues=i,this.rowPartitionValuesShapes=Q,this.rowPartitionTypes=pr(o),this.raggedRank=yr(this.rowPartitionTypes)}getRowPartitionTypeByDimension(A){return this.rowPartitionTypes[0]===CM.FIRST_DIM_SIZE?this.rowPartitionTypes[A+1]:this.rowPartitionTypes[A]}getRowPartitionTensor(A){return this.rowPartitionTypes[0]===CM.FIRST_DIM_SIZE?this.rowPartitionValues[A+1]:this.rowPartitionValues[A]}getMaxWidth(A){const g=this.getRowPartitionTensor(A-1);switch(this.getRowPartitionTypeByDimension(A-1)){case CM.VALUE_ROWIDS:return eM.getMaxWidthValueRowID(g);case CM.ROW_SPLITS:return eM.getMaxWidthRowSplit(g);default:throw new Error(`Cannot handle partition type ${CM[this.getRowPartitionTypeByDimension(A-1)]}`)}}static getMaxWidthRowSplit(A){const g=A.length;if(0===g||1===g)return 0;let I=0;for(let t=0;t<g-1;++t){const g=A[t+1]-A[t];g>I&&(I=g)}return I}static getMaxWidthValueRowID(A){const g=A.length;if(0===g)return 0;let I=0,t=A[0],C=0;for(let e=1;e<g;++e){const g=A[e];g!==t&&(t=g,C=Math.max(e-I,C),I=e)}return Math.max(g-I,C)}tensorShapeFromTensor(A,g,I=!0){if(0===g.length){if(-1===A[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return iM(A,I)}calculateOutputSize(A){const g=this.valuesShape;Gr(this.defaultValueShape,g);const I=this.tensorShapeFromTensor(this.shape,this.shapeShape),t=dr(this.raggedRank,I,g);t[0]<0&&(t[0]=A);for(let A=1;A<=this.raggedRank;++A)t[A]<0&&(t[A]=this.getMaxWidth(A));return t}calculateFirstParentOutputIndex(A,g,I){const t=Math.min(A,I),C=[];let e=0;for(let A=0;A<t;++A,e+=g)C.push(e);for(let g=t;g<A;++g)C.push(-1);return CA(C.length===A,(()=>"Final length of result must be equal to firstDimension.")),C}calculateOutputIndexRowSplit(A,g,I,t){const C=A.length,e=[];for(let B=0;B<C-1;++B){const C=A[B+1]-A[B];let i=Math.min(t,C),Q=g[B];-1===Q&&(i=0);for(let A=0;A<i;++A)e.push(Q),Q+=I;for(let A=0;A<C-i;++A)e.push(-1)}if(C>0&&e.length!==A[C-1])throw new Error("Invalid row split size.");return e}calculateOutputIndexValueRowID(A,g,I,t){const C=A.length,e=[];if(0===C)return[];let B=0,i=A[0];if(i>=g.length)throw new Error(`Got currentValueRowId=${i}, which is not less than ${g.length}`);let Q=g[i];e.push(Q);for(let o=1;o<C;++o){const C=A[o];if(C===i)Q>=0&&(++B,B<t?Q+=I:Q=-1);else{if(B=0,i=C,C>=g.length)throw new Error(`Got nextValueRowId=${C} which is not less than ${g.length}`);Q=g[C]}e.push(Q)}if(e.length!==A.length)throw new Error("Invalid row ids.");return e}calculateOutputIndex(A,g,I,t){const C=this.getRowPartitionTensor(A),e=this.getRowPartitionTypeByDimension(A);switch(e){case CM.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(C,g,I,t);case CM.ROW_SPLITS:if(C.length-1>g.length)throw new Error(`Row partition size is greater than output size: ${C.length-1} > ${g.length}`);return this.calculateOutputIndexRowSplit(C,g,I,t);default:throw new Error(`Unsupported partition type: ${CM[e]}`)}}getFirstDimensionSize(){const A=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const g=this.rowPartitionTypes[0];switch(g){case CM.FIRST_DIM_SIZE:return A[0];case CM.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case CM.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${CM[g]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const A=this.getFirstDimensionSize(),g=this.calculateOutputSize(A),I=new Array(this.raggedRank+1);I[I.length-1]=1;for(let A=I.length-2;A>=0;--A)I[A]=I[A+1]*g[A+1];const t=iM(g,!1),C=dA(this.valuesDType,QA(t));if(I[0]*g[0]>0){let e=this.calculateFirstParentOutputIndex(A,I[0],g[0]);for(let A=1;A<=this.raggedRank;++A){e=this.calculateOutputIndex(A-1,e,I[A],g[A])}this.setOutput(this.raggedRank,e,C,t)}return[t,C]}setOutput(A,g,I,t){if(0===I.length)return;const C=this.values,e=I;let B=t.slice();B=B.slice(A+1);const i=QA(B),Q=g.length;let o=this.defaultValue;if(o.length!==i&&1!==o.length){const A=this.defaultValueShape;wi((()=>{const g=Lo(o,A),I=_o(g,B);o=I.dataSync()}))}let E=0,n=0,s=0;for(let A=0;A<=Q;++A){let t=A<Q?g[A]:-1;if(t!==s){if(n<s){const A=C.subarray(E*i);BM(e.subarray(n*i),A,(s-n)*i)}if(A>=Q){const A=I.length;t=Math.floor(A/i)}if(t>s)if(1===this.defaultValue.length)e.subarray(s*i,t*i).fill(this.defaultValue[0]),s=t;else for(;t>s;){BM(e.slice(s*i),o,i),++s}t<0?(E=A+1,n=s):(E=A,n=s,s=n+1)}else++s}}}function BM(A,g,I){for(let t=0;t<I;t++)A[t]=g[t]}function iM(A,g){const I=[];for(let t of A){if(t<0){if(!g)throw new Error(`Dimension ${t} must be >= 0`);if(t<-1)throw new Error(`Dimension ${t} must be >= -1`);t=-1}I.push(t)}return I}function QM(A,g,I,t,C,e,B,i,Q,o){return new eM(A,g,I,t,C,e,B,i,Q,o).compute()}const oM={kernelName:Bt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{shape:C,values:e,defaultValue:B,rowPartitionTensors:i}=g,{rowPartitionTypes:Q}=t,o=I.data.get(C.dataId).values,E=I.data.get(e.dataId).values,n=I.data.get(B.dataId).values,s=i.map((A=>I.data.get(A.dataId).values)),a=i.map((A=>A.shape)),[r,h]=QM(o,C.shape,E,e.shape,e.dtype,n,B.shape,s,a,Q);return I.makeTensorInfo(r,e.dtype,h)}};function EM(A,g,I,t){if(A===g||A<g&&I<0||g<A&&I>1)return xA(0,t);const C=xA(Math.abs(Math.ceil((g-A)/I)),t);g<A&&1===I&&(I=-1),C[0]=A;for(let A=1;A<C.length;A++)C[A]=C[A-1]+I;return C}const nM={kernelName:it,backendName:"cpu",kernelFunc:function(A){const{backend:g,attrs:I}=A,{start:t,stop:C,dtype:e,step:B}=I,i=EM(t,C,B,e);return g.makeTensorInfo([i.length],e,i)}},sM=DF(ot,(A=>1/A)),aM={kernelName:ot,backendName:"cpu",kernelFunc:sM};const rM={kernelName:rt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C}=g,{alignCorners:e,halfPixelCenters:B,size:i}=t;hF(C,"resizeBilinear");const Q=KA(C.shape),[o,E]=i,[n,s,a,r]=C.shape,h=I.data.get(C.dataId).values,c=new Float32Array(QA([n,o,E,r])),l=[e&&o>1?s-1:s,e&&E>1?a-1:a],D=[e&&o>1?o-1:o,e&&E>1?E-1:E];let u=0;const w=l[0]/D[0],d=l[1]/D[1];for(let A=0;A<n;A++)for(let g=0;g<o;g++){let I;I=B?w*(g+.5)-.5:w*g;const t=Math.max(0,Math.floor(I)),C=I-t,e=Math.min(s-1,Math.ceil(I)),i=A*Q[0]+t*Q[1],o=A*Q[0]+e*Q[1];for(let A=0;A<E;A++){let g;g=B?d*(A+.5)-.5:d*A;const I=Math.max(0,Math.floor(g)),t=g-I,e=Math.min(a-1,Math.ceil(g)),E=i+I*Q[2],n=o+I*Q[2],s=i+e*Q[2],l=o+e*Q[2];for(let A=0;A<r;A++){const g=h[E+A],I=h[n+A],e=g+(h[s+A]-g)*t,B=e+(I+(h[l+A]-I)*t-e)*C;c[u++]=B}}}return I.makeTensorInfo([n,o,E,r],"float32",c)}};const hM={kernelName:ht,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C,dy:e}=g,{alignCorners:B}=t;hF([e,C],"resizeBilinearGrad");const i=KA(C.shape),[Q,o,E,n]=C.shape,[,s,a]=e.shape,r=new Float32Array(Q*o*E*n),h=[B&&s>1?o-1:o,B&&a>1?E-1:E],c=[B&&s>1?s-1:s,B&&a>1?a-1:a],l=h[0]/c[0],D=h[1]/c[1],u=I.data.get(e.dataId).values;let w=0;for(let A=0;A<Q;A++){const g=A*i[0];for(let A=0;A<s;A++){const I=A*l,t=Math.floor(I),C=Math.min(Math.ceil(I),o-1),e=g+t*i[1],B=g+C*i[1],Q=I-t,s=1-Q;for(let A=0;A<a;A++){const g=A*D,I=Math.floor(g),t=Math.min(Math.ceil(g),E-1),C=g-I,o=1-C,a=e+I*i[2],h=e+t*i[2],c=B+I*i[2],l=B+t*i[2],d=s*o,p=s*C,y=Q*o,G=Q*C;for(let A=0;A<n;A++){const g=u[w++];r[a+A]+=g*d,r[h+A]+=g*p,r[c+A]+=g*y,r[l+A]+=g*G}}}}return I.makeTensorInfo([Q,E,o,n],"float32",r)}};const cM={kernelName:st,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C}=g,{alignCorners:e,halfPixelCenters:B,size:i}=t;hF(C,"resizeNearestNeighbor");const Q=KA(C.shape),[o,E]=i,[n,s,a,r]=C.shape,h=I.data.get(C.dataId).values,c=new Float32Array(n*o*E*r),l=[e&&o>1?s-1:s,e&&E>1?a-1:a],D=[e&&o>1?o-1:o,e&&E>1?E-1:E],u=l[0]/D[0],w=l[1]/D[1];let d=0;for(let A=0;A<n;A++){const g=A*Q[0];for(let A=0;A<o;A++){const I=B?u*(A+.5):u*A;let t=Math.min(s-1,e?Math.round(I):Math.floor(I));B&&(t=Math.max(0,t));const C=g+t*Q[1];for(let A=0;A<E;A++){const g=B?w*(A+.5):w*A;let I=Math.min(a-1,e?Math.round(g):Math.floor(g));B&&(I=Math.max(0,I));const t=C+I*Q[2];for(let A=0;A<r;A++){const g=h[t+A];c[d++]=g}}}}return I.makeTensorInfo([n,o,E,r],C.dtype,c)}};const lM={kernelName:at,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C,dy:e}=g,{alignCorners:B}=t;hF([e,C],"resizeNearestNeighborGrad");const i=KA(C.shape),Q=KA(e.shape),[o,E,n,s]=C.shape,[,a,r]=e.shape,h=new Float32Array(o*E*n*s),c=I.data.get(e.dataId).values,l=[B&&a>1?E-1:E,B&&r>1?n-1:n],D=[B&&a>1?a-1:a,B&&r>1?r-1:r],u=l[0]/D[0],w=l[1]/D[1],d=1/u,p=1/w,y=2*Math.ceil(d)+2,G=2*Math.ceil(p)+2;for(let A=0;A<o;A++){const g=A*i[0];for(let A=0;A<E;A++){const I=g+A*i[1],t=Math.floor(A*d),C=Math.floor(t-y/2);for(let t=0;t<n;t++){const e=I+t*i[2],o=Math.floor(t*p),l=Math.floor(o-G/2);for(let I=0;I<s;I++){let i=0;for(let e=0;e<y;e++){const o=e+C;if(o<0||o>=a)continue;const s=g+o*Q[1],h=o*u;if(A===Math.min(E-1,B?Math.round(h):Math.floor(h)))for(let A=0;A<G;A++){const g=A+l;if(g<0||g>=r)continue;const C=s+g*Q[2],e=g*w;t===Math.min(n-1,B?Math.round(e):Math.floor(e))&&(i+=c[C+I])}}h[e+I]=i}}}}return I.makeTensorInfo(C.shape,C.dtype,h)}};const DM={kernelName:lt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{dims:e}=t;hF(C,"reverse");const B=C.shape.length,i=DA(e,C.shape);if(0===B)return pF({inputs:{x:C},backend:I});const Q=new Ae(C.shape,C.dtype),o=I.bufferSync(C);for(let A=0;A<Q.size;A++){const g=Q.indexToLoc(A),I=g.slice();i.forEach((A=>I[A]=C.shape[A]-1-I[A])),Q.set(o.get(...I),...g)}return I.makeTensorInfo(Q.shape,Q.dtype,Q.values)}},uM={kernelName:BC,backendName:"cpu",kernelFunc:({inputs:A,attrs:g,backend:I})=>{const{image:t}=A,{radians:C,fillValue:e,center:B}=g,i=I,Q=wA(t.dtype,QA(t.shape)),[o,E,n,s]=t.shape,[a,r]=Fr(B,E,n),h=Math.sin(C),c=Math.cos(C),l=i.data.get(t.dataId).values;for(let A=0;A<o;A++){const g=A*n*E*s;for(let A=0;A<E;A++){const I=A*(n*s);for(let t=0;t<n;t++){const C=t*s;for(let B=0;B<s;B++){const i=[o,A,t,B],D=i[2],u=i[1];let w=(D-a)*c-(u-r)*h,d=(D-a)*h+(u-r)*c;w=Math.round(w+a),d=Math.round(d+r);let p=e;if("number"!=typeof e&&(p=3===B?255:e[B]),w>=0&&w<n&&d>=0&&d<E){p=l[g+d*(n*s)+w*s+B]}Q[g+I+C+B]=p}}}}return{dataId:i.write(Q,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}},wM=DF(Dt,(A=>{const g=Math.floor(A);return A-g<.5?Math.floor(A):A-g>.5?Math.ceil(A):g%2==0?g:g+1})),dM={kernelName:Dt,backendName:"cpu",kernelFunc:wM},pM=KF((A=>1/Math.sqrt(A))),yM=uF(ut,pM),GM={kernelName:ut,backendName:"cpu",kernelFunc:yM};function fM(A,g,I,t,C,e,B,i,Q,o){const E=[t/C,C],n=A.values,s=g.values;if(0===t)return HB(I,g.dtype);const a=HB(E,g.dtype);"string"==typeof Q||"number"==typeof Q?a.values.fill(Q):"boolean"==typeof Q&&a.values.fill(+Q);for(let A=0;A<e;A++){const e=[];let Q=0;for(let g=0;g<B;g++){const I=n[A*B+g];e.push(I),Q+=I*i[g]}if(Q<0||Q>=t/C)throw new Error(`Invalid indices: ${e} does not index into ${I}`);for(let I=0;I<C;I++)o?a.values[Q*C+I]+=s[A*C+I]:a.values[Q*C+I]=0===g.rank?s[0]:s[A*C+I]}return a}const NM={kernelName:wt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{indices:C,updates:e}=g,{shape:B}=t,{sliceRank:i,numUpdates:Q,sliceSize:o,strides:E,outputSize:n}=zi(0,C,B),s=fM(I.bufferSync(C),I.bufferSync(e),B,n,o,Q,i,E,0,!0);return I.makeTensorInfo(B,s.dtype,s.values)}};function FM(A,g){let I=0,t=A.length,C=0;for(;I<t;)C=Math.floor((I+t)/2),A[C]<g?I=C+1:t=C;return t}function RM(A,g){let I=0,t=A.length,C=0;for(;I<t;)C=Math.floor((I+t)/2),A[C]<=g?I=C+1:t=C;return t}const mM={kernelName:dt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{sortedSequence:C,values:e}=g,{side:B}=t,i=function(A,g,I,t,C,e){const B=dA("int32",I*C);for(let i=0;i<I;++i){const I=A.slice(i*t,(i+1)*t),Q=i*C;for(let A=0;A<C;++A)B[Q+A]="left"===e?FM(I,g[A+Q]):RM(I,g[A+Q])}return B}(I.data.get(C.dataId).values,I.data.get(e.dataId).values,C.shape[0],C.shape[1],e.shape[1],B);return I.makeTensorInfo(e.shape,"int32",i)}};const kM={kernelName:pt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{condition:t,t:C,e}=g;hF([t,C,e],"select");const B=t.shape.length,i=I.data.get(t.dataId).values,Q=I.data.get(C.dataId).values,o=I.data.get(e.dataId).values,E=ae(C.dtype,e.dtype),n=xA(QA(C.shape),E);let s=0;const a=0===B||B>1||1===C.shape.length?1:QA(C.shape.slice(1));for(let A=0;A<i.length;A++)for(let g=0;g<a;g++)1===i[A]?n[s++]=Q[A]:n[s++]=o[A];return I.makeTensorInfo(C.shape,E,n)}},SM=Ur,MM=Kr,UM=DF(yt,(A=>A>=0?MM*A:SM*(Math.exp(A)-1))),KM={kernelName:yt,backendName:"cpu",kernelFunc:UM},JM=DF(Ft,(A=>A<0?-1:A>0?1:0)),YM={kernelName:Ft,backendName:"cpu",kernelFunc:JM},LM=DF(ft,(A=>Math.sin(A))),xM={kernelName:ft,backendName:"cpu",kernelFunc:LM},bM=DF(Nt,(A=>Math.sinh(A))),HM={kernelName:Nt,backendName:"cpu",kernelFunc:bM},qM=Math.log(1.1920928955078125e-7)+2,TM=DF(mt,(A=>{const g=A>-qM,I=A<qM,t=Math.exp(A);let C;return C=I?t:g?A:Math.log(1+t),C})),vM={kernelName:mt,backendName:"cpu",kernelFunc:TM};const VM={kernelName:Mt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{blockShape:e,paddings:B}=t;hF([C],"spaceToBatchND");const i=QA(e),Q=[[0,0]];Q.push(...B);for(let A=1+e.length;A<C.shape.length;++A)Q.push([0,0]);const o=ZS.kernelFunc({inputs:{x:C},backend:I,attrs:{paddings:Q,constantValue:0}}),E=Rr(o.shape,e,i,!1),n=mr(E.length,e.length,!1),s=kr(o.shape,e,i,!1),a=$F({inputs:{x:o},backend:I,attrs:{shape:E}}),r=sR({inputs:{x:a},backend:I,attrs:{perm:n}}),h=$F({inputs:{x:r},backend:I,attrs:{shape:s}});return I.disposeIntermediateTensorInfo(o),I.disposeIntermediateTensorInfo(a),I.disposeIntermediateTensorInfo(r),h}};function WM(A,g,I,t,C,e,B){const i=g[0],Q=e[0],o=new Array(Q),E=new Array(i),n=g[1];if(0===Q){if(0!==i)throw new Error(Bh(i));return[dA(I,0),[0,n],dA(C,0),o,E]}let s=!0,a=0;const r=new Array(Q).fill(0);for(let g=0;g<i;++g){const I=A[g*n];if(I<0)throw new Error(ih(g,I));if(I>=Q)throw new Error(Qh(g,I,Q));++r[I],s=s&&I>=a,a=I}let h=!0;for(let A=0;A<Q;++A){const g=0===r[A];o[A]=g,h=h&&!g,r[A]=Math.max(r[A],1),A>0&&(r[A]+=r[A-1])}if(h&&s){const g=A,I=t;for(let A=0;A<i;++A)E[A]=A;return[g,[i,n],I,o,E]}{const g=r[Q-1],e=dA(I,g*n),s=dA(C,g),a=new Array(Q).fill(0);for(let g=0;g<i;++g){const I=A[g*n],C=a[I],B=(0===I?0:r[I-1])+C;a[I]++;for(let I=0;I<n;++I)e[B*n+I]=A[g*n+I];s[B]=t[g],E[g]=B}for(let A=0;A<Q;++A){if(0===a[A]){const g=0===A?0:r[A-1];e[g*n+0]=A;for(let A=1;A<n;++A)e[g*n+A]=0;s[g]=B}}return[e,[g,n],s,o,E]}}const OM={kernelName:Jt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{indices:t,values:C,denseShape:e,defaultValue:B}=g;if(1!==e.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${e.shape}`);if(2!==t.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${t.shape}`);if(1!==C.shape.length)throw new Error(`Values must be a vector, saw:\n        ${C.shape}`);if(0!==B.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${B.shape}`);const i=I.data.get(t.dataId).values,Q=I.data.get(C.dataId).values,o=I.data.get(e.dataId).values,E=I.data.get(B.dataId).values[0],[n,s,a,r,h]=WM(i,t.shape,t.dtype,Q,C.dtype,o,E);return[I.makeTensorInfo(s,t.dtype,n),I.makeTensorInfo([s[0]],C.dtype,a),I.makeTensorInfo([r.length],"bool",new Uint8Array(r.map((A=>Number(A))))),I.makeTensorInfo([h.length],t.dtype,new Int32Array(h))]}};function ZM(A,g,I,t,C){const e=QA(t),B=g[0],i=C.length,Q=[];let o=1,E=-1;for(let A=0;A<i;++A){const g=C[A];if(-1===g){if(-1!==E)throw new Error(oh(E,A));E=A,Q.push(1)}else{if(g<0)throw new Error(Eh(A,g));o*=g,Q.push(g)}}if(-1!==E){if(o<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const A=Math.trunc(e/o);if(o*A!==e)throw new Error(sh(t,Q));Q[E]=A}if(QA(Q)!==e)throw new Error(ah(t,Q));const n=t.length,s=[];if(n>0){s[n-1]=1;for(let A=n-2;A>=0;--A)s[A]=s[A+1]*t[A+1]}const a=[];if(i>0){a[i-1]=1;for(let A=i-2;A>=0;--A)a[A]=a[A+1]*Q[A+1]}const r=dA(I,B*i);for(let g=0;g<B;++g){let I=0;for(let t=0;t<n;++t)I+=A[g*n+t]*s[t];for(let A=0;A<i;++A)r[g*i+A]=Math.trunc(I/a[A]),I%=a[A]}return[r,[B,i],Q]}const PM={kernelName:Yt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{inputIndices:t,inputShape:C,newShape:e}=g;if(2!==t.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${t.shape}`);if(1!==C.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${C.shape}`);if(1!==e.shape.length)throw new Error(`Target shape should be a vector but received shape ${e.shape}`);const B=Array.from(I.data.get(C.dataId).values),i=I.data.get(t.dataId).values,Q=Array.from(I.data.get(e.dataId).values),[o,E,n]=ZM(i,t.shape,t.dtype,B,Q);return[I.makeTensorInfo(E,t.dtype,o),I.makeTensorInfo([n.length],e.dtype,new Int32Array(n))]}};function XM(A,g,I,t,C,e=!1,B=0){const i=t.length,Q=[g[0],A.length/g[0]],o=Q[1],E=i>0?C[i-1]+1:0;if(E<0)throw new Error("segment ids must be >= 0");const n=g.slice();n[0]=E;const s=dA(I,n.reduce(((A,g)=>A*g),1));if(0===i)return E>0&&s.fill(B),[s,n];if(E<=0)throw new Error("segment ids must be >= 0");let a=0,r=1,h=0,c=C[a];for(;;){let g=0;if(r<i){if(g=C[r],c===g){++r;continue}if(c>=g)throw new Error("segment ids are not increasing")}if(c<0||c>=E)throw new Error(ch(c,E));c>h&&s.fill(B,h*o,c*o);for(let g=a;g<r;++g){const I=t[g];if(I<0||I>=Q[0])throw new Error(lh(g,t[g],Q[0]));for(let g=0;g<o;g++)s[c*o+g]+=A[I*o+g]}if(e)for(let A=0;A<o;A++)s[c*o+A]/=r-a;if(a=r,++r,h=c+1,c=g,r>i)break}return h<E&&s.fill(B,h*o,E*o),[s,n]}const jM={kernelName:Lt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{data:t,indices:C,segmentIds:e}=g;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==C.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${C.shape}`);if(1!==e.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${e.shape}`);if(C.shape[0]!==e.shape[0])throw new Error("segmentIds and indices should have same size.");const B=I.data.get(t.dataId).values,i=I.data.get(C.dataId).values,Q=I.data.get(e.dataId).values,[o,E]=XM(B,t.shape,t.dtype,i,Q,!0);return I.makeTensorInfo(E,t.dtype,o)}};const zM={kernelName:xt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I}=A,{data:t,indices:C,segmentIds:e}=g;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==C.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${C.shape}`);if(1!==e.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${e.shape}`);if(C.shape[0]!==e.shape[0])throw new Error("segmentIds and indices should have same size.");const B=I.data.get(t.dataId).values,i=I.data.get(C.dataId).values,Q=I.data.get(e.dataId).values,[o,E]=XM(B,t.shape,t.dtype,i,Q);return I.makeTensorInfo(E,t.dtype,o)}};const _M={kernelName:bt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{sparseIndices:C,sparseValues:e,defaultValue:B}=g,{outputShape:i}=t,{sliceRank:Q,numUpdates:o,sliceSize:E,strides:n,outputSize:s}=zi(0,C,i),a=!1,r=I.bufferSync(C);let h;switch(e.dtype){case"bool":h=fM(r,I.bufferSync(e),i,s,E,o,Q,n,Boolean(I.data.get(B.dataId).values[0]),a);break;case"float32":h=fM(r,I.bufferSync(e),i,s,E,o,Q,n,I.data.get(B.dataId).values[0],a);break;case"int32":h=fM(r,I.bufferSync(e),i,s,E,o,Q,n,I.data.get(B.dataId).values[0],a);break;case"string":h=fM(r,I.bufferSync(e),i,s,E,o,Q,n,TC(I.data.get(B.dataId).values[0]),a);break;default:throw new Error(`Unsupported type ${e.dtype}`)}return I.makeTensorInfo(i,h.dtype,h.values)}};const $M={kernelName:Ut,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{numOrSizeSplits:e,axis:B}=t,i=DA(B,C.shape)[0],Q=eh(C,e,i),o=new Array(C.shape.length).fill(0),E=C.shape.slice();return Q.map((A=>{const g=[...E];g[i]=A;const t=xR({inputs:{x:C},backend:I,attrs:{begin:o,size:g}});return o[i]+=A,t}))}},AU=KF((A=>Math.sqrt(A))),gU=DF(kt,(A=>Math.sqrt(A))),IU={kernelName:kt,backendName:"cpu",kernelFunc:gU},tU={kernelName:qt,backendName:"cpu",kernelFunc:({inputs:A,backend:g})=>{const{x:I}=A,t=g;hF(I,"square");const C=t.data.get(I.dataId).values,e=new Float32Array(C.length);for(let A=0;A<C.length;++A){const g=C[A];e[A]=g*g}return{dataId:t.write(e,I.shape,I.dtype),shape:I.shape,dtype:I.dtype}}},CU=NF(((A,g)=>{const I=A-g;return I*I})),eU=ZF(Ht,CU),BU={kernelName:Ht,backendName:"cpu",kernelFunc:eU},iU=DF(CC,((A,g)=>{const I=g;return isNaN(A)?NaN:A>0?1:I.alpha})),QU={kernelName:CC,backendName:"cpu",kernelFunc:iU};function oU(A,g,I,t){const C=HB(A,g.dtype);for(let A=0;A<C.size;A++){const e=C.indexToLoc(A),B=new Array(e.length);for(let A=0;A<B.length;A++)B[A]=e[A]*I[A]+t[A];C.set(g.get(...B),...e)}return C}const EU={kernelName:Tt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{begin:e,end:B,strides:i,beginMask:Q,endMask:o,ellipsisMask:E,newAxisMask:n,shrinkAxisMask:s}=t;hF(C,"stridedSlice");const{finalShapeSparse:a,finalShape:r,isIdentity:h,sliceDim0:c,isSimpleSlice:l,begin:D,end:u,strides:w}=hQ(C.shape,e,B,i,Q,o,E,n,s);let d;if(h)d=$F({inputs:{x:C},backend:I,attrs:{shape:r}});else if(c||l){CA(C.shape.length>=1,(()=>`Input must have rank at least 1, got: ${C.shape.length}`));const A=IQ(D,u,w),g=xR({inputs:{x:C},backend:I,attrs:{begin:D,size:A}});d=$F({inputs:{x:g},backend:I,attrs:{shape:r}}),I.disposeIntermediateTensorInfo(g)}else{const A=oU(a,I.bufferSync(C),w,D);d=I.makeTensorInfo(r,A.dtype,A.values)}return d}};class nU{constructor(A,g,I,t,C,e){this.separator=qC(A),this.nGramWidths=g,this.leftPad=qC(I),this.rightPad=qC(t),this.padWidth=C,this.preserveShort=e}getPadWidth(A){return Math.min(this.padWidth<0?A-1:this.padWidth,A-1)}getNumNGrams(A,g){const I=this.getPadWidth(g);return Math.max(0,A+2*I-g+1)}createNGrams(A,g,I,t,C,e){for(let B=0;B<C;++B){const i=this.getPadWidth(e),Q=Math.max(0,i-B),o=Math.max(0,i-(C-(B+1))),E=e-(Q+o),n=g+(Q>0?0:B-i);let s=0;s+=Q*this.leftPad.length;for(let g=0;g<E;++g)s+=A[n+g].length;s+=o*this.rightPad.length;s+=(Q+o+E-1)*this.separator.length,I[t+B]=new Uint8Array(s);const a=I[t+B];let r=0;const h=A=>A.forEach((A=>a[r++]=A));for(let A=0;A<Q;++A)h(this.leftPad),h(this.separator);for(let g=0;g<E-1;++g)h(A[n+g]),h(this.separator);if(E>0){h(A[n+E-1]);for(let A=0;A<o;++A)h(this.separator),h(this.rightPad)}else{for(let A=0;A<o-1;++A)h(this.rightPad),h(this.separator);h(this.rightPad)}}}compute(A,g){const I=A.length,t=g.length;if(t>0){let A=g[0];if(0!==A)throw new Error(`First split value must be 0, got ${A}`);for(let C=1;C<t;++C){let t=g[C]>=A;if(t=t&&g[C]<=I,!t)throw new Error(`Invalid split value ${g[C]}, must be in [${A}, ${I}]`);A=g[C]}if(A!==I)throw new Error(`Last split value must be data size. Expected ${I}, got ${A}`)}const C=t-1,e=dA("int32",t);if(0===I||0===t){const A=new Array(I);for(let A=0;A<=C;++A)e[A]=0;return[A,e]}e[0]=0;for(let A=1;A<=C;++A){const I=g[A]-g[A-1];let t=0;this.nGramWidths.forEach((A=>{t+=this.getNumNGrams(I,A)})),this.preserveShort&&I>0&&0===t&&(t=1),e[A]=e[A-1]+t}const B=new Array(e[C]);for(let I=0;I<C;++I){const t=g[I];let C=e[I];if(this.nGramWidths.forEach((e=>{const i=g[I+1]-g[I],Q=this.getNumNGrams(i,e);this.createNGrams(A,t,B,C,Q,e),C+=Q})),this.preserveShort&&C===e[I]){const e=g[I+1]-g[I];if(0===e)continue;const i=e+2*this.padWidth,Q=1;this.createNGrams(A,t,B,C,Q,i)}}return[B,e]}}function sU(A,g,I,t,C,e,B,i){return new nU(I,t,C,e,B,i).compute(A,g)}const aU={kernelName:vt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{separator:C,nGramWidths:e,leftPad:B,rightPad:i,padWidth:Q,preserveShortSequences:o}=t,{data:E,dataSplits:n}=g,s=I.data.get(E.dataId).values,a=I.data.get(n.dataId).values,[r,h]=sU(s,a,C,e,B,i,Q,o);return[I.makeTensorInfo([r.length],"string",r),I.makeTensorInfo(n.shape,"int32",h)]}};function rU(A,g,I,t){if(!A.length)return;if(0===g.length){for(let g=0;g<A.length;++g)t.push(A.subarray(g,g+1));return}if(1===g.length){const C=g[0];let e=A.indexOf(C);for(;-1!==e;){const g=A.subarray(0,e);I&&0===g.length||t.push(g),e=(A=A.subarray(e+1)).indexOf(C)}return void(I&&0===A.length||t.push(A))}let C=0;for(let e=0;e<A.length+1;e++)if(e===A.length||-1!==g.indexOf(A[e])){const g=A.subarray(C,e);I&&0===g.length||t.push(g),C=e+1}}function hU(A,g,I){const t=A.length,C=[];let e=0,B=0;const i=new Array(t);for(let Q=0;Q<t;++Q){const t=C.length;rU(A[Q],g,I,C);const o=C.length-t;i[Q]=o,e+=o,B=Math.max(B,o)}const Q=dA("int32",2*e),o=new Array(e),E=[t,B];let n=0;for(let A=0;A<t;++A)for(let g=0;g<i[A];++g)Q[2*n]=A,Q[2*n+1]=g,o[n]=C[n],++n;return[Q,o,E]}const cU={kernelName:Vt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{skipEmpty:C}=t,{input:e,delimiter:B}=g;if("string"!==e.dtype)throw new Error("Input must be of datatype string");if(1!==e.shape.length)throw new Error(`Input must be a vector, got shape: ${e.shape}`);if(0!==B.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${B.shape}`);const i=I.data.get(e.dataId).values,Q=I.data.get(B.dataId).values[0],[o,E,n]=hU(i,Q,C),s=E.length;return[I.makeTensorInfo([s,2],"int32",o),I.makeTensorInfo([s],"string",E),I.makeTensorInfo([2],"int32",new Int32Array(n))]}};function lU(A,g){const I=dA("int32",A.length);for(let t=0;t<A.length;++t)I[t]=YC(A[t]).modulo(g).getLowBitsUnsigned();return I}const DU={kernelName:Wt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{numBuckets:C}=t,{input:e}=g;if("string"!==e.dtype)throw new Error("Input must be of datatype string");if(C<=0)throw new Error("Number of buckets must be at least 1");const B=lU(I.data.get(e.dataId).values,C);return I.makeTensorInfo(e.shape,"int32",B)}},uU=DF(Zt,(A=>Math.tan(A))),wU={kernelName:Zt,backendName:"cpu",kernelFunc:uU},dU=DF(Pt,(A=>Math.tanh(A)));function pU(A,g){const I=new Array(A.rank);for(let t=0;t<I.length;t++)I[t]=A.shape[t]*g[t];const t=HB(I,A.dtype);for(let g=0;g<t.values.length;++g){const I=t.indexToLoc(g),C=new Array(A.rank);for(let g=0;g<C.length;g++)C[g]=I[g]%A.shape[g];const e=A.locToIndex(C);t.values[g]=A.values[e]}return t}const yU={kernelName:Xt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{reps:e}=t;hF(C,"tile");const B=pU(I.bufferSync(C),e);return I.makeTensorInfo(B.shape,B.dtype,B.values)}},GU=(A,g)=>{const I=g.value-A.value;return 0===I?A.index-g.index:I};function fU(A,g,I=0,t=A.length-1){for(;t>I;){if(t-I>600){const C=t-I+1,e=g-I+1,B=Math.log(C),i=.5*Math.exp(2*B/3),Q=.5*Math.sqrt(B*i*(C-i)/C)*Math.sign(e-C/2);fU(A,g,Math.max(I,Math.floor(g-e*i/C+Q)),Math.min(t,Math.floor(g+(C-e)*i/C+Q)))}const C=A[g];let e=I,B=t;for(AA(A,I,g),GU(A[t],C)>0&&AA(A,I,t);e<B;){for(AA(A,e,B),e++,B--;GU(A[e],C)<0;)e+=1;for(;GU(A[B],C)>0;)B-=1}0===GU(A[I],C)?AA(A,I,B):(B+=1,AA(A,B,t)),B<=g&&(I=B+1),g<=B&&(t=B-1)}}function NU(A,g,I,t,C){const e=g[g.length-1],[B,i]=[A.length/e,e],Q=wA(I,B*t),o=wA("int32",B*t);for(let g=0;g<B;g++){const I=g*i,e=A.subarray(I,I+i);let B=new Array(e.length);e.forEach(((A,g)=>B[g]={value:A,index:g})),t<B.length&&(fU(B,t),B=B.slice(0,t)),C&&B.sort(GU);const E=g*t,n=Q.subarray(E,E+t),s=o.subarray(E,E+t);for(let A=0;A<t;A++)n[A]=B[A].value,s[A]=B[A].index}const E=g.slice();return E[E.length-1]=t,[HB(E,I,Q),HB(E,"int32",o)]}const FU={kernelName:jt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{k:e,sorted:B}=t;hF(C,"topk");const i=I.data.get(C.dataId).values,[Q,o]=NU(i,C.shape,C.dtype,e,B);return[I.makeTensorInfo(Q.shape,Q.dtype,Q.values),I.makeTensorInfo(o.shape,o.dtype,o.values)]}};const RU={kernelName:zt,backendName:"cpu",kernelFunc:function(A){const{inputs:g,attrs:I,backend:t}=A,{image:C,transforms:e}=g,{interpolation:B,fillMode:i,fillValue:Q,outputShape:o}=I,[E,n,s,a]=C.shape,[r,h]=null!=o?o:[n,s],c=[E,r,h,a],l=KA(C.shape),D=l[0],u=l[1],w=l[2],d=KA(c),p=d[0],y=d[1],G=d[2],f=wA(C.dtype,QA(c));f.fill(Q);const N=t.data.get(C.dataId).values,F=t.data.get(e.dataId).values;for(let A=0;A<E;++A){const g=1===e.shape[0]?F:F.subarray(8*A,8*A+8);for(let I=0;I<r;++I)for(let t=0;t<h;++t)for(let C=0;C<a;++C){let e;const o=g[6]*t+g[7]*I+1;if(0===o)continue;const E=(g[0]*t+g[1]*I+g[2])/o,a=(g[3]*t+g[4]*I+g[5])/o,r=mU(E,s,i),h=mU(a,n,i);switch(B){case"nearest":e=SU(N,n,s,D,u,w,A,h,r,C,Q);break;case"bilinear":e=MU(N,n,s,D,u,w,A,h,r,C,Q);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${B}`)}f[A*p+I*y+t*G+C]=e}return t.makeTensorInfo(c,C.dtype,f)}return{dataId:t.write(f,c,C.dtype),shape:C.shape,dtype:C.dtype}}};function mU(A,g,I){switch(I){case"reflect":return function(A,g){let I=A;if(I<0)if(g<=1)I=0;else{const A=2*g;I<A&&(I=A*Math.trunc(-I/A)+I),I=I<-g?I+A:-I-1}else if(I>g-1)if(g<=1)I=0;else{const A=2*g;I-=A*Math.trunc(I/A),I>=g&&(I=A-I-1)}return _(0,I,g-1)}(A,g);case"wrap":return function(A,g){let I=A;if(I<0)if(g<=1)I=0;else{const A=g-1;I+=g*(Math.trunc(-I/A)+1)}else if(I>g-1)if(g<=1)I=0;else{const A=g-1;I-=g*Math.trunc(I/A)}return _(0,I,g-1)}(A,g);case"nearest":return function(A,g){return _(0,A,g-1)}(A,g);default:return function(A,g){return A}(A)}}function kU(A,g,I,t,C,e,B,i,Q,o,E){return 0<=i&&i<g&&0<=Q&&Q<I?A[B*t+i*C+Q*e+o]:E}function SU(A,g,I,t,C,e,B,i,Q,o,E){return kU(A,g,I,t,C,e,B,Math.round(i),Math.round(Q),o,E)}function MU(A,g,I,t,C,e,B,i,Q,o,E){const n=Math.floor(i),s=Math.floor(Q),a=n+1,r=s+1;return(a-i)*((r-Q)*kU(A,g,I,t,C,e,B,n,s,o,E)+(Q-s)*kU(A,g,I,t,C,e,B,n,r,o,E))+(i-n)*((r-Q)*kU(A,g,I,t,C,e,B,a,s,o,E)+(Q-s)*kU(A,g,I,t,C,e,B,a,r,o,E))}function UU(A,g,I,t){const C=DA(g,I)[0],e=[1,I[0],1];for(let A=0;A<C;A++)e[0]*=I[A];e[1]=I[C];for(let A=C+1;A<I.length;A++)e[2]*=I[A];const B={},i=new Int32Array(I[C]),Q=new Ae(e,t,A),o=[],E=1===e[0]&&1===e[2];for(let g=0;g<I[C];g++){let I;if(E)I=A[g].toString();else{const A=[];for(let I=0;I<e[0];I++)for(let t=0;t<e[2];t++)A.push(Q.get(I,g,t));I=A.join(",")}if(void 0!==B[I])i[g]=B[I];else{const A=Object.keys(B).length;B[I]=A,i[g]=A,o.push(g)}}const n=e.slice();n[1]=Object.keys(B).length;const s=new Ae(n,t);o.forEach(((A,g)=>{for(let I=0;I<e[0];I++)for(let t=0;t<e[2];t++)s.set(Q.get(I,A,t),I,g,t)}));const a=I.slice();return a[C]=n[1],{outputValues:s.values,outputShape:a,indices:i}}const KU={kernelName:$t,backendName:"cpu",kernelFunc:function(A){const{inputs:g,attrs:I,backend:t}=A,{axis:C}=I,{x:e}=g;hF(e,"unique");const B=t.data.get(e.dataId).values,{outputValues:i,outputShape:Q,indices:o}=UU(B,C,e.shape,e.dtype);return[t.makeTensorInfo(Q,e.dtype,i),t.makeTensorInfo([o.length],"int32",o)]}};const JU={kernelName:AC,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{value:C}=g;let{axis:e}=t;e<0&&(e+=C.shape.length);const B=C.shape.length,i=C.shape[e],Q=new Array(B-1);let o=0;for(let A=0;A<B;A++)A!==e&&(Q[o++]=C.shape[A]);const E=new Array(B).fill(0),n=C.shape.slice();n[e]=1;const s=new Array(i);for(let A=0;A<s.length;A++){E[e]=A;const g=xR({inputs:{x:C},backend:I,attrs:{begin:E,size:n}});s[A]=$F({inputs:{x:g},backend:I,attrs:{shape:Q}}),I.disposeIntermediateTensorInfo(g)}return s}};const YU={kernelName:gC,backendName:"cpu",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,segmentIds:e}=g,{numSegments:B}=t;hF(C,"unsortedSegmentSum");const i=[],Q=[],o=C.shape.length-e.shape.length;let E=e;for(let A=0;A<o;++A){const g=Pm({inputs:{input:E},backend:I,attrs:{dim:A+1}});E=g,Q.push(g)}for(let A=0;A<B;++A){const g=LC(A,"int32"),t=I.makeTensorInfo([],"int32",g),e=Jm({inputs:{a:t,b:E},backend:I}),B=WF({inputs:{x:e},backend:I,attrs:{dtype:"float32"}}),o=Rm({inputs:{a:B,b:C},backend:I}),n=km({inputs:{x:o},backend:I,attrs:{axis:0,keepDims:!1}});i.push(n),Q.push(t),Q.push(e),Q.push(B),Q.push(o),Q.push(n)}const n=WS({inputs:i,backend:I,attrs:{axis:0}});return Q.forEach((A=>I.disposeIntermediateTensorInfo(A))),n}},LU=[tR,eR,iR,oR,_F,ER,rR,hR,cR,lR,uR,dR,yR,NR,RR,MR,UR,KR,JR,IR,YR,HR,vR,VR,OF,ZR,XR,HF,jR,gm,tm,Cm,em,Bm,im,Qm,Em,sm,am,rm,hm,cm,lm,um,wm,dm,pm,ym,Gm,fm,Mm,dF,Um,Ym,Vm,Zm,Xm,_m,ok,nk,sk,hk,Dk,uk,wk,pk,Gk,Fk,kk,yF,Sk,$R,Uk,Jk,Lk,fF,Hk,vk,Wk,Pk,jk,$k,gS,CS,eS,BS,oS,sS,aS,rS,hS,cS,lS,DS,uS,pS,yS,NS,mS,mm,SS,US,JS,LS,HS,qS,VS,OS,ZS,jS,mF,_S,tM,oM,nM,vF,gk,aM,SF,UF,AR,rM,hM,cM,lM,DM,uM,dM,GM,NM,mM,kM,KM,LF,YM,xM,HM,bR,RS,vM,VM,OM,PM,jM,zM,_M,$M,IU,tU,BU,QU,EU,aU,cU,DU,ek,Sm,wU,{kernelName:Pt,backendName:"cpu",kernelFunc:dU},yU,FU,RU,aR,KU,JU,YU,vS];for(const A of LU)lC(A);const xU={},bU={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function HU(A,g){if(!(A in xU)||null!=g){const I=function(A,g){if(1!==A&&2!==A)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const I=null==g?function(A){if("undefined"!=typeof OffscreenCanvas&&2===A)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(A):g;I.addEventListener("webglcontextlost",(g=>{g.preventDefault(),delete xU[A]}),!1),ZA().getBool("SOFTWARE_WEBGL_ENABLED")&&(bU.failIfMajorPerformanceCaveat=!1);if(1===A)return I.getContext("webgl",bU)||I.getContext("experimental-webgl",bU);return I.getContext("webgl2",bU)}(A,g);if(null===I)return console.log("Could not get context for WebGL version",A),null;xU[A]=I}const I=xU[A];return null==I||I.isContextLost()?(delete xU[A],HU(A)):(I.disable(I.DEPTH_TEST),I.disable(I.STENCIL_TEST),I.disable(I.BLEND),I.disable(I.DITHER),I.disable(I.POLYGON_OFFSET_FILL),I.disable(I.SAMPLE_COVERAGE),I.enable(I.SCISSOR_TEST),I.enable(I.CULL_FACE),I.cullFace(I.BACK),xU[A])}var qU,TU,vU;function VU(A,g){return[g,A]}function WU(A){const g=QA(A);return aA(Math.ceil(g/4))}function OU(A,g){return[Math.max(1,Math.ceil(g/2)),Math.max(1,Math.ceil(A/2))]}function ZU(A,g){const I=A;let t,C,e,B,i,Q,o,E,n,s;return 2===ZA().getNumber("WEBGL_VERSION")?(t=I.R32F,C=I.R16F,e=I.RGBA16F,B=I.RGBA32F,i=I.RED,o=4,E=1,n=I.HALF_FLOAT,s=I.FLOAT,Q=I.RGBA8):(t=A.RGBA,C=A.RGBA,e=A.RGBA,B=I.RGBA,i=A.RGBA,o=4,E=4,n=null!=g?g.HALF_FLOAT_OES:null,s=A.FLOAT,Q=A.RGBA),{internalFormatFloat:t,internalFormatHalfFloat:C,internalFormatPackedHalfFloat:e,internalFormatPackedFloat:B,textureFormatFloat:i,downloadTextureFormat:Q,downloadUnpackNumChannels:o,defaultNumChannels:E,textureTypeHalfFloat:n,textureTypeFloat:s}}function PU(A,g){const I=g();return ZA().getBool("DEBUG")&&function(A){const g=A.getError();if(g!==A.NO_ERROR)throw new Error("WebGL Error: "+function(A,g){switch(g){case A.NO_ERROR:return"NO_ERROR";case A.INVALID_ENUM:return"INVALID_ENUM";case A.INVALID_VALUE:return"INVALID_VALUE";case A.INVALID_OPERATION:return"INVALID_OPERATION";case A.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case A.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case A.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${g}`}}(A,g))}(A),I}!function(A){A[A.DENSE=0]="DENSE",A[A.SHARED_BATCH=1]="SHARED_BATCH"}(qU||(qU={})),function(A){A[A.RENDER=0]="RENDER",A[A.UPLOAD=1]="UPLOAD",A[A.PIXELS=2]="PIXELS",A[A.DOWNLOAD=3]="DOWNLOAD"}(TU||(TU={})),function(A){A[A.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",A[A.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",A[A.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",A[A.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",A[A.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(vU||(vU={}));function XU(A){return!!(ZA().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===A||5.96e-8<Math.abs(A)&&Math.abs(A)<65504)}function jU(A,g){return eK(A,(()=>A.getExtension(g)),'Extension "'+g+'" not supported on this browser.')}const zU=/ERROR: [0-9]+:([0-9]+):/g;function _U(A,g){const I=zU.exec(g);if(null==I)return console.log(`Couldn't parse line number in error: ${g}`),void console.log(A);const t=+I[1],C=A.split("\n"),e=C.length.toString().length+2,B=C.map(((A,g)=>hA((g+1).toString(),e)+A));let i=0;for(let A=0;A<B.length;A++)i=Math.max(B[A].length,i);const Q=B.slice(0,t-1),o=B.slice(t-1,t),E=B.slice(t);console.log(Q.join("\n")),console.log(g.split("\n")[0]),console.log(`%c ${hA(o[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(E.join("\n"))}function $U(A,g){if(PU(A,(()=>A.validateProgram(g))),!1===A.getProgramParameter(g,A.VALIDATE_STATUS))throw console.log(A.getProgramInfoLog(g)),new Error("Shader program validation failed.")}function AK(A,g,I,t,C,e,B){const i=A.getAttribLocation(g,I);return-1!==i&&(PU(A,(()=>A.bindBuffer(A.ARRAY_BUFFER,t))),PU(A,(()=>A.vertexAttribPointer(i,C,A.FLOAT,!1,e,B))),PU(A,(()=>A.enableVertexAttribArray(i))),!0)}function gK(A,g,I,t){PU(A,(()=>function(A,g,I){BK(A,I),PU(A,(()=>A.activeTexture(A.TEXTURE0+I))),PU(A,(()=>A.bindTexture(A.TEXTURE_2D,g)))}(A,g,t))),PU(A,(()=>A.uniform1i(I,t)))}function IK(A,g,I){PU(A,(()=>A.bindFramebuffer(A.FRAMEBUFFER,I))),PU(A,(()=>A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,g,0)))}function tK(A,g){PU(A,(()=>A.bindFramebuffer(A.FRAMEBUFFER,g))),PU(A,(()=>A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,null,0)))}function CK(A){const g=A.checkFramebufferStatus(A.FRAMEBUFFER);if(g!==A.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(A,g){switch(g){case A.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case A.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case A.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case A.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${g}`}}(A,g))}function eK(A,g,I){const t=PU(A,(()=>g()));if(null==t)throw new Error(I);return t}function BK(A,g){const I=A.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,t=g+A.TEXTURE0;if(t<A.TEXTURE0||t>I){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${I}]`}.`)}}function iK(A,g=2){return QA(A.slice(0,A.length-g))}function QK(A){if(0===A.length)throw Error("Cannot get rows and columns of an empty shape array.");return[A.length>1?A[A.length-2]:1,A[A.length-1]]}function oK(A){let g=[1,1,1];return 0===A.length||1===A.length&&1===A[0]||(g=[iK(A),...QK(A)]),g}function EK(A){return A%2==0}function nK(A,g){if(EA(A=A.slice(-2),g=g.slice(-2)))return!0;if(!A.length||!g.length)return!0;if(0===A[0]||0===A[1]||0===g[0]||0===g[1])return!0;if(A.length!==g.length){const I=A.slice(-1)[0],t=g.slice(-1)[0];if(I===t)return!0;if(EK(I)&&EK(t)&&(1===A[0]||1===g[0]))return!0}return A[1]===g[1]&&EK(A[0])&&EK(g[0])}let sK,aK;function rK(A,g){return null!=A.getExtension(g)}function hK(A){try{if(null!=HU(A))return!0}catch(A){return console.log("Error when getting WebGL context: ",A),!1}return!1}function cK(A){if(0===A)return!1;const g=HU(A);if(1!==A){if(rK(g,"EXT_color_buffer_float"))return lK(g);const A="EXT_color_buffer_half_float";if(rK(g,A)){const I=g.getExtension(A);return function(A,g){const I=ZU(A,g),t=A.createTexture();A.bindTexture(A.TEXTURE_2D,t);const C=1,e=1;A.texImage2D(A.TEXTURE_2D,0,I.internalFormatHalfFloat,C,e,0,I.textureFormatFloat,I.textureTypeHalfFloat,null);const B=A.createFramebuffer();A.bindFramebuffer(A.FRAMEBUFFER,B),A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,t,0);const i=A.checkFramebufferStatus(A.FRAMEBUFFER)===A.FRAMEBUFFER_COMPLETE;return A.bindTexture(A.TEXTURE_2D,null),A.bindFramebuffer(A.FRAMEBUFFER,null),A.deleteTexture(t),A.deleteFramebuffer(B),i}(g,I)}return!1}if(!rK(g,"OES_texture_float"))return!1;if(!rK(g,"WEBGL_color_buffer_float"))return!1;return lK(g)}function lK(A){const g=ZU(A),I=A.createTexture();A.bindTexture(A.TEXTURE_2D,I);A.texImage2D(A.TEXTURE_2D,0,g.internalFormatFloat,1,1,0,g.textureFormatFloat,g.textureTypeFloat,null);const t=A.createFramebuffer();A.bindFramebuffer(A.FRAMEBUFFER,t),A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,I,0);const C=A.checkFramebufferStatus(A.FRAMEBUFFER)===A.FRAMEBUFFER_COMPLETE;return A.bindTexture(A.TEXTURE_2D,null),A.bindFramebuffer(A.FRAMEBUFFER,null),A.deleteTexture(I),A.deleteFramebuffer(t),C}function DK(A,g){Array.isArray(A)||(A=[A]),A.forEach((A=>{null!=A&&CA("complex64"!==A.dtype,(()=>`${g} does not support complex64 tensors in the WebGL backend.`))}))}const uK=ZA();function wK(){let A,g,I,t,C,e,B,i,Q,o;return 2===ZA().getNumber("WEBGL_VERSION")?(A="#version 300 es",g="in",I="out",t="in",C="texture",e="outputColor",B="out vec4 outputColor;",i=ZA().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",Q="",o="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(A="",g="attribute",I="varying",t="varying",C="texture2D",e="gl_FragColor",B="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",Q="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",o="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:A,attribute:g,varyingVs:I,varyingFs:t,texture2D:C,output:e,defineOutput:B,defineSpecialNaN:i,defineSpecialInf:Q,defineRound:o}}function dK(A,g,I="index"){const t=KA(g);return t.map(((g,C)=>`${`int ${A[C]} = ${I} / ${g}`}; ${C===t.length-1?`int ${A[C+1]} = ${I} - ${A[C]} * ${g}`:`index -= ${A[C]} * ${g}`};`)).join("")}function pK(A,g,I="index"){const t=KA(g);return t.map(((g,C)=>`${`int ${A[C]} = ${I} / outShapeStrides[${C}]`}; ${C===t.length-1?`int ${A[C+1]} = ${I} - ${A[C]} * outShapeStrides[${C}]`:`index -= ${A[C]} * outShapeStrides[${C}]`};`)).join("")}function yK(A,g,I="index"){const t=function(A,g){const I=A.length,t=A.map((A=>`${g}[${A}]`)),C=new Array(I-1);C[I-2]=t[I-1];for(let A=I-3;A>=0;--A)C[A]=`(${C[A+1]} * ${t[A+1]})`;return C}(A.map(((A,g)=>g)),g);return t.map(((g,C)=>`${`int ${A[C]} = ${I} / ${t[C]}`}; ${C===t.length-1?`int ${A[C+1]} = ${I} - ${A[C]} * ${t[C]}`:`index -= ${A[C]} * ${t[C]}`};`)).join("")}function GK(A){const g=KA(A).map((A=>A.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${g[0]} + coords.y * ${g[1]} + coords.z;\n  }\n`}uK.registerFlag("HAS_WEBGL",(()=>uK.getNumber("WEBGL_VERSION")>0)),uK.registerFlag("WEBGL_VERSION",(()=>hK(2)?2:hK(1)?1:0)),uK.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),uK.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===uK.get("WEBGL_VERSION"))),uK.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),uK.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),uK.registerFlag("WEBGL_PACK",(()=>uK.getBool("HAS_WEBGL"))),uK.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_CLIP",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_PACK_REDUCE",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_LAZILY_UNPACK",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_CONV_IM2COL",(()=>uK.getBool("WEBGL_PACK"))),uK.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(A){if(null==sK){const g=HU(A);sK=g.getParameter(g.MAX_TEXTURE_SIZE)}return sK}(uK.getNumber("WEBGL_VERSION")))),uK.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(A){if(null==aK){const g=HU(A);aK=g.getParameter(g.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,aK)}(uK.getNumber("WEBGL_VERSION")))),uK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const A=uK.getNumber("WEBGL_VERSION");return 0===A?0:function(A){if(0===A)return 0;let g;const I=HU(A);return g=rK(I,"EXT_disjoint_timer_query_webgl2")&&2===A?2:rK(I,"EXT_disjoint_timer_query")?1:0,g}(A)})),uK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>uK.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Re())),uK.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(A){if(0===A)return!1;const g=HU(A);if(1===A){if(!rK(g,"OES_texture_float"))return!1}else if(!rK(g,"EXT_color_buffer_float"))return!1;return lK(g)}(uK.getNumber("WEBGL_VERSION")))),uK.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!uK.getBool("WEBGL_FORCE_F16_TEXTURES")&&uK.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),uK.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>cK(uK.getNumber("WEBGL_VERSION")))),uK.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(A=uK.getNumber("WEBGL_VERSION"))&&null!=HU(A).fenceSync;var A})),uK.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>uK.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),uK.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(A=>{if(A<0&&-1!==A)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${A}.`)})),uK.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Re()?1:-1),(A=>{if(A<0&&-1!==A)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${A}.`)})),uK.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),uK.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),uK.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),uK.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),uK.registerFlag("WEBGL_EXP_CONV",(()=>!1)),uK.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>uK.getBool("IS_TEST"))),uK.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),uK.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),uK.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1));const fK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:NK}=l;function FK(A,g,I){const t=[];if(A.forEach((A=>{const g=QA(A.shapeInfo.logicalShape);if(A.shapeInfo.isUniform?t.push(`uniform float ${A.name}${g>1?`[${g}]`:""};`):(t.push(`uniform sampler2D ${A.name};`),t.push(`uniform int offset${A.name};`)),I.enableShapeUniforms){const{uniformShape:g}=xK(I.packedInputs,A.shapeInfo.logicalShape,A.shapeInfo.texShape);switch(g.length){case 1:t.push(`uniform int ${A.name}Shape;`);break;case 2:t.push(`uniform ivec2 ${A.name}Shape;`);break;case 3:t.push(`uniform ivec3 ${A.name}Shape;`);break;case 4:t.push(`uniform ivec4 ${A.name}Shape;`)}t.push(`uniform ivec2 ${A.name}TexShape;`)}})),I.enableShapeUniforms){switch(g.logicalShape.length){case 1:t.push("uniform int outShape;");break;case 2:t.push("uniform ivec2 outShape;"),t.push("uniform int outShapeStrides;");break;case 3:t.push("uniform ivec3 outShape;"),t.push("uniform ivec2 outShapeStrides;");break;case 4:t.push("uniform ivec4 outShape;"),t.push("uniform ivec3 outShapeStrides;")}t.push("uniform ivec2 outTexShape;")}I.customUniforms&&I.customUniforms.forEach((A=>{t.push(`uniform ${A.type} ${A.name}${A.arrayIndex?`[${A.arrayIndex}]`:""};`)}));const C=t.join("\n"),e=A.map((A=>function(A,g,I=!1,t){let C="";C+=I?mK(A,t):RK(A,t);const e=A.shapeInfo.logicalShape,B=g.logicalShape;e.length<=B.length&&(C+=I?function(A,g){const I=A.name,t=I.charAt(0).toUpperCase()+I.slice(1),C="get"+t+"AtOutCoords",e=A.shapeInfo.logicalShape.length,B=g.logicalShape.length,i=NK(A.shapeInfo.logicalShape,g.logicalShape),Q=LK(B),o=B-e;let E;const n=["x","y","z","w","u","v"];E=0===e?"":B<2&&i.length>=1?"coords = 0;":i.map((A=>`coords.${n[A+o]} = 0;`)).join("\n");let s="";s=B<2&&e>0?"coords":A.shapeInfo.logicalShape.map(((A,g)=>`coords.${n[g+o]}`)).join(", ");let a="return outputValue;";const r=1===QA(A.shapeInfo.logicalShape),h=QA(g.logicalShape),c=1===h;if(1!==e||r||c){if(r&&!c)a=1===B?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const A=e-2,g=e-1;i.indexOf(A)>-1&&i.indexOf(g)>-1?a="return vec4(outputValue.x);":i.indexOf(A)>-1?a="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(g)>-1&&(a="return vec4(outputValue.xx, outputValue.zz);")}}else a="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${C}() {\n      ${Q} coords = getOutputCoords();\n      ${E}\n      vec4 outputValue = get${t}(${s});\n      ${a}\n    }\n  `}(A,g):function(A,g){const I=A.name,t=I.charAt(0).toUpperCase()+I.slice(1),C="get"+t+"AtOutCoords",e=g.texShape,B=A.shapeInfo.texShape,i=A.shapeInfo.logicalShape.length,Q=g.logicalShape.length;if(!A.shapeInfo.isUniform&&i===Q&&null==A.shapeInfo.flatOffset&&EA(B,e))return`\n      float ${C}() {\n        return sampleTexture(${I}, resultUV);\n      }\n    `;const o=LK(Q),E=NK(A.shapeInfo.logicalShape,g.logicalShape),n=Q-i;let s;const a=["x","y","z","w","u","v"];s=0===i?"":Q<2&&E.length>=1?"coords = 0;":E.map((A=>`coords.${a[A+n]} = 0;`)).join("\n");let r="";r=Q<2&&i>0?"coords":A.shapeInfo.logicalShape.map(((A,g)=>`coords.${a[g+n]}`)).join(", ");return`\n    float ${C}() {\n      ${o} coords = getOutputCoords();\n      ${s}\n      return get${t}(${r});\n    }\n  `}(A,g));return C}(A,g,I.packedInputs,I.enableShapeUniforms))).join("\n"),B=g.texShape,i=wK(),Q=function(A){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${A.texture2D}(textureSampler, uv).r;\n    }\n  `}(i);let o,E,n=function(A){const g=`${A.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${A.varyingFs} vec2 resultUV;\n    ${A.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${A.defineSpecialNaN}\n    ${A.defineSpecialInf}\n    ${A.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${kK}\n    ${SK}\n    ${MK}\n  `;return g}(i);g.isPacked?(o=function(A,g,I){switch(A.length){case 0:return KK();case 1:return function(A,g,I){const t=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)];if(1===t[0])return I?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return I?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(I)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return 2 * (resTexRC.x * ${t[1]} + resTexRC.y);\n    }\n  `}(0,g,I);case 2:return function(A,g,I){const t=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)];if(EA(A,g))return I?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;const C=Math.ceil(A[1]/2);if(I)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = 2 * (index / ${C});\n      int c = imod(index, ${C}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(A,g,I);case 3:return function(A,g,I){if(I)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const t=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)],C=Math.ceil(A[2]/2),e=C*Math.ceil(A[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      int b = index / ${e};\n      index -= b * ${e};\n\n      int r = 2 * (index / ${C});\n      int c = imod(index, ${C}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(A,g,I);default:return function(A,g,I){if(I)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const t=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)],C=Math.ceil(A[A.length-1]/2),e=C*Math.ceil(A[A.length-2]/2);let B=e,i="",Q="b, r, c";for(let g=2;g<A.length-1;g++)B*=A[A.length-g-1],i=`\n      int b${g} = index / ${B};\n      index -= b${g} * ${B};\n    `+i,Q=`b${g}, `+Q;return`\n    ivec${A.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${e};\n      index -= b * ${e};\n\n      int r = 2 * (index / ${C});\n      int c = imod(index, ${C}) * 2;\n\n      return ivec${A.length}(${Q});\n    }\n  `}(A,g,I)}}(g.logicalShape,B,I.enableShapeUniforms),E=function(A){return`\n    void setOutput(vec4 val) {\n      ${A.output} = val;\n    }\n  `}(i)):(o=function(A,g,I){switch(A.length){case 0:return KK();case 1:return function(A,g,I){if(1===g[0])return I?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${g[1]}.0);\n      }\n    `;if(1===g[1])return I?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${g[0]}.0);\n      }\n    `;if(I)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${g[0]}, ${g[1]}));\n      return resTexRC.x * ${g[1]} + resTexRC.y;\n    }\n  `}(0,g,I);case 2:return function(A,g,I){if(EA(A,g))return I?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${g[0]}, ${g[1]}));\n      }\n    `;if(1===A[1])return I?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${g[0]}, ${g[1]}));\n        int index = resTexRC.x * ${g[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===A[0])return I?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${g[0]}, ${g[1]}));\n        int index = resTexRC.x * ${g[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(I)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${g[0]}, ${g[1]}));\n      int index = resTexRC.x * ${g[1]} + resTexRC.y;\n      int r = index / ${A[1]};\n      int c = index - r * ${A[1]};\n      return ivec2(r, c);\n    }\n  `}(A,g,I);case 3:return function(A,g,I){if(I){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${pK(["r","c","d"],A)}\n    return ivec3(r, c, d);\n  }\n`}const t=dK(["r","c","d"],A);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${g[0]}, ${g[1]}));\n      int index = resTexRC.x * ${g[1]} + resTexRC.y;\n      ${t}\n      return ivec3(r, c, d);\n    }\n  `}(A,g,I);case 4:return function(A,g,I){if(I){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${pK(["r","c","d","d2"],A)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const t=dK(["r","c","d","d2"],A);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${g[0]}, ${g[1]}));\n      int index = resTexRC.x * ${g[1]} + resTexRC.y;\n      ${t}\n      return ivec4(r, c, d, d2);\n    }\n  `}(A,g,I);case 5:return function(A,g){const I=dK(["r","c","d","d2","d3"],A);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${g[0]},\n                             ${g[1]}));\n\n      int index = resTexRC.x * ${g[1]} + resTexRC.y;\n\n      ${I}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(A,g);case 6:return function(A,g){const I=dK(["r","c","d","d2","d3","d4"],A);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${g[0]}, ${g[1]}));\n      int index = resTexRC.x * ${g[1]} + resTexRC.y;\n\n      ${I}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(A,g);default:throw new Error(`${A.length}-D output sampling is not yet supported`)}}(g.logicalShape,B,I.enableShapeUniforms),E=function(A){return`\n    void setOutput(float val) {\n      ${A.output} = vec4(val, 0, 0, 0);\n    }\n  `}(i)),I.packedInputs&&(n+=UK);return[n,Q,E,C,o,e,I.userCode].join("\n")}function RK(A,g=!1){const I=A.shapeInfo.logicalShape;switch(I.length){case 0:return function(A,g){const I=A.name,t="get"+I.charAt(0).toUpperCase()+I.slice(1);if(A.shapeInfo.isUniform)return`float ${t}() {return ${I};}`;const[C,e]=A.shapeInfo.texShape;if(1===C&&1===e)return`\n      float ${t}() {\n        return sampleTexture(${I}, halfCR);\n      }\n    `;const B=JK(I);if(g)return`\n    float ${t}() {\n      vec2 uv = uvFromFlat(${I}TexShape[0], ${I}TexShape[1], ${B});\n      return sampleTexture(${I}, uv);\n    }\n  `;const[i,Q]=A.shapeInfo.texShape;return`\n    float ${t}() {\n      vec2 uv = uvFromFlat(${i}, ${Q}, ${B});\n      return sampleTexture(${I}, uv);\n    }\n  `}(A,g);case 1:return function(A,g){const I=A.name,t="get"+I.charAt(0).toUpperCase()+I.slice(1);if(A.shapeInfo.isUniform)return`\n      float ${t}(int index) {\n        ${YK(A)}\n      }\n    `;const C=A.shapeInfo.texShape,e=C[0],B=C[1];if(1===B&&1===e)return`\n      float ${t}(int index) {\n        return sampleTexture(${I}, halfCR);\n      }\n    `;const i=JK(I);if(1===B)return g?`\n      float ${t}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${I}TexShape[0]));\n        return sampleTexture(${I}, uv);\n      }\n    `:`\n      float ${t}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${e}.0);\n        return sampleTexture(${I}, uv);\n      }\n    `;if(1===e)return g?`\n      float ${t}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${I}TexShape[1]), 0.5);\n        return sampleTexture(${I}, uv);\n      }\n    `:`\n      float ${t}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${B}.0, 0.5);\n        return sampleTexture(${I}, uv);\n      }\n    `;if(g)return`\n    float ${t}(int index) {\n      vec2 uv = uvFromFlat(${I}TexShape[0], ${I}TexShape[1], index + ${i});\n      return sampleTexture(${I}, uv);\n    }\n  `;return`\n    float ${t}(int index) {\n      vec2 uv = uvFromFlat(${e}, ${B}, index + ${i});\n      return sampleTexture(${I}, uv);\n    }\n  `}(A,g);case 2:return function(A,g){const I=A.shapeInfo.logicalShape,t=A.name,C="get"+t.charAt(0).toUpperCase()+t.slice(1),e=A.shapeInfo.texShape;if(null!=e&&EA(I,e)){if(g)return`\n      float ${C}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}TexShape[1], ${t}TexShape[0]);\n        return sampleTexture(${t}, uv);\n      }\n    `;const A=e[0];return`\n    float ${C}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${e[1]}.0, ${A}.0);\n      return sampleTexture(${t}, uv);\n    }\n  `}const{newShape:B,keptDims:i}=uA(I),Q=B;if(Q.length<I.length){const I=["row","col"];return`\n      ${RK(bK(A,Q),g)}\n      float ${C}(int row, int col) {\n        return ${C}(${HK(I,i)});\n      }\n    `}if(A.shapeInfo.isUniform)return`\n      float ${C}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${I[1]}, 1)));\n        ${YK(A)}\n      }\n    `;const o=e[0],E=e[1],n=JK(t);if(1===E)return g?`\n      float ${C}(int row, int col) {\n        float index = dot(vec3(row, col, ${n}), vec3(${t}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${C}(int row, int col) {\n      float index = dot(vec3(row, col, ${n}), vec3(${I[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${o}.0);\n      return sampleTexture(${t}, uv);\n    }\n  `;if(1===o)return g?`\n      float ${C}(int row, int col) {\n        float index = dot(vec3(row, col, ${n}), vec3(${t}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${C}(int row, int col) {\n      float index = dot(vec3(row, col, ${n}), vec3(${I[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${E}.0, 0.5);\n      return sampleTexture(${t}, uv);\n    }\n  `;if(g)return`\n      float ${C}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${t}Shape[1] + col + ${n};\n        vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n  float ${C}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${I[1]} + col + ${n};\n    vec2 uv = uvFromFlat(${o}, ${E}, index);\n    return sampleTexture(${t}, uv);\n  }\n`}(A,g);case 3:return function(A,g){const I=A.shapeInfo.logicalShape,t=A.name,C="get"+t.charAt(0).toUpperCase()+t.slice(1),e=I[1]*I[2],B=I[2],{newShape:i,keptDims:Q}=uA(I),o=i;if(o.length<I.length){const I=["row","col","depth"];return`\n        ${RK(bK(A,o),g)}\n        float ${C}(int row, int col, int depth) {\n          return ${C}(${HK(I,Q)});\n        }\n      `}if(A.shapeInfo.isUniform)return`\n      float ${C}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${e}, ${B}, 1)));\n        ${YK(A)}\n      }\n    `;const E=A.shapeInfo.texShape,n=E[0],s=E[1],a=A.shapeInfo.flatOffset;if(s===e&&null==a)return g?`\n      float ${C}(int row, int col, int depth) {\n        int stride1 = ${t}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${t}TexShape[1], ${t}TexShape[0]);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n        float ${C}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${B}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${s}.0, ${n}.0);\n          return sampleTexture(${t}, uv);\n        }\n      `;if(s===B&&null==a)return g?`\n      float ${C}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${t}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}TexShape[1], ${t}TexShape[0]);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${C}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${I[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n      return sampleTexture(${t}, uv);\n    }\n  `;const r=JK(t);if(g)return`\n    float ${C}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${t}Shape[1] * ${t}Shape[2];\n      int stride1 = ${t}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${r};\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index);\n      return sampleTexture(${t}, uv);\n    }\n    `;return`\n      float ${C}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${e} + col * ${B} + depth + ${r};\n        vec2 uv = uvFromFlat(${n}, ${s}, index);\n        return sampleTexture(${t}, uv);\n      }\n  `}(A,g);case 4:return function(A,g){const I=A.shapeInfo.logicalShape,t=A.name,C="get"+t.charAt(0).toUpperCase()+t.slice(1),e=I[3],B=I[2]*e,i=I[1]*B,{newShape:Q,keptDims:o}=uA(I);if(Q.length<I.length){const I=["row","col","depth","depth2"];return`\n      ${RK(bK(A,Q),g)}\n      float ${C}(int row, int col, int depth, int depth2) {\n        return ${C}(${HK(I,o)});\n      }\n    `}if(A.shapeInfo.isUniform)return`\n      float ${C}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${B}, ${e}, 1)));\n        ${YK(A)}\n      }\n    `;const E=A.shapeInfo.flatOffset,n=A.shapeInfo.texShape,s=n[0],a=n[1],r=`int stride2 = ${t}Shape[3];`,h=`int stride1 = ${t}Shape[2] * stride2;`,c=`int stride0 = ${t}Shape[1] * stride1;`;if(a===i&&null==E)return g?`\n      float ${C}(int row, int col, int depth, int depth2) {\n        ${r}\n        ${h}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${t}TexShape[1], ${t}TexShape[0]);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${C}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${B}, ${e}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}.0, ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(a===e&&null==E)return g?`\n      float ${C}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t}Shape[1] * ${t}Shape[2], ${t}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${t}TexShape[1], ${t}TexShape[0]);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${C}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${I[1]*I[2]}, ${I[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${a}.0, ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const l=JK(t);if(g)return`\n    float ${C}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${r}\n      ${h}\n      ${c}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${l});\n      return sampleTexture(${t}, uv);\n    }\n  `;return`\n    float ${C}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${B} +\n          depth * ${e} + depth2;\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${l});\n      return sampleTexture(${t}, uv);\n    }\n  `}(A,g);case 5:return function(A){const g=A.shapeInfo.logicalShape,I=A.name,t="get"+I.charAt(0).toUpperCase()+I.slice(1),C=g[4],e=g[3]*C,B=g[2]*e,i=g[1]*B,{newShape:Q,keptDims:o}=uA(g);if(Q.length<g.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${RK(bK(A,Q))}\n      float ${t}(int row, int col, int depth, int depth2, int depth3) {\n        return ${t}(${HK(g,o)});\n      }\n    `}if(A.shapeInfo.isUniform)return`\n      float ${t}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${B}, ${e}, ${C})) +\n          depth3;\n        ${YK(A)}\n      }\n    `;const E=A.shapeInfo.flatOffset,n=A.shapeInfo.texShape,s=n[0],a=n[1];if(a===i&&null==E)return`\n      float ${t}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${B}, ${e}, ${C}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}.0, ${s}.0);\n        return sampleTexture(${I}, uv);\n      }\n    `;if(a===C&&null==E)return`\n      float ${t}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${g[1]*g[2]*g[3]},\n               ${g[2]*g[3]}, ${g[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${a}.0, ${s}.0);\n        return sampleTexture(${I}, uv);\n      }\n    `;const r=JK(I);return`\n    float ${t}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${B} + depth * ${e} +\n          depth2 * ${C} + depth3 + ${r};\n      vec2 uv = uvFromFlat(${s}, ${a}, index);\n      return sampleTexture(${I}, uv);\n    }\n  `}(A);case 6:return function(A){const g=A.shapeInfo.logicalShape,I=A.name,t="get"+I.charAt(0).toUpperCase()+I.slice(1),{newShape:C,keptDims:e}=uA(g);if(C.length<g.length){const g=["row","col","depth","depth2","depth3","depth4"];return`\n      ${RK(bK(A,C))}\n      float ${t}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${t}(${HK(g,e)});\n      }\n    `}const B=g[5],i=g[4]*B,Q=g[3]*i,o=g[2]*Q,E=g[1]*o;if(A.shapeInfo.isUniform)return`\n      float ${t}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${E}, ${o}, ${Q}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${B}, 1)));\n        ${YK(A)}\n      }\n    `;const n=A.shapeInfo.flatOffset,s=A.shapeInfo.texShape,a=s[0],r=s[1];if(r===E&&null==n)return`\n      float ${t}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${o}, ${Q}, ${i}, ${B})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}.0, ${a}.0);\n        return sampleTexture(${I}, uv);\n      }\n    `;if(r===B&&null==n)return`\n      float ${t}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${g[1]*g[2]*g[3]*g[4]},\n               ${g[2]*g[3]*g[4]},\n               ${g[3]*g[4]},\n               ${g[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}.0, ${a}.0);\n        return sampleTexture(${I}, uv);\n      }\n    `;const h=JK(I);return`\n    float ${t}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${E} + col * ${o} + depth * ${Q} +\n          depth2 * ${i} + depth3 * ${B} + depth4 + ${h};\n      vec2 uv = uvFromFlat(${a}, ${r}, index);\n      return sampleTexture(${I}, uv);\n    }\n  `}(A);default:throw new Error(`${I.length}-D input sampling is not yet supported`)}}function mK(A,g){switch(A.shapeInfo.logicalShape.length){case 0:return function(A){const g=A.name,I="get"+g.charAt(0).toUpperCase()+g.slice(1),t=wK();return`\n    vec4 ${I}() {\n      return ${t.texture2D}(${g}, halfCR);\n    }\n  `}(A);case 1:return function(A,g){const I=A.name,t="get"+I.charAt(0).toUpperCase()+I.slice(1),C=A.shapeInfo.texShape,e=wK();if(g)return`\n    vec4 ${t}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${I}TexShape[0]) / 2.0), ceil(float(${I}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${e.texture2D}(${I}, uv);\n    }\n  `;const B=[Math.ceil(C[0]/2),Math.ceil(C[1]/2)];return`\n    vec4 ${t}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${B[0]}, ${B[1]}, index);\n      return ${e.texture2D}(${I}, uv);\n    }\n  `}(A,g);case 2:return function(A,g){const I=A.shapeInfo.logicalShape,t=A.name,C="get"+t.charAt(0).toUpperCase()+t.slice(1),e=A.shapeInfo.texShape,B=e[0],i=e[1],Q=wK();if(null!=e&&EA(I,e))return g?`\n      vec4 ${C}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}TexShape[1], ${t}TexShape[0]);\n\n        return ${Q.texture2D}(${t}, uv);\n      }\n    `:`\n      vec4 ${C}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${B}.0);\n\n        return ${Q.texture2D}(${t}, uv);\n      }\n    `;if(g)return`\n    vec4 ${C}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${t}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${Q.texture2D}(${t}, uv);\n    }\n  `;const o=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],E=Math.ceil(I[1]/2);return`\n    vec4 ${C}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${E}, ${o[0]}, ${o[1]}, row, col);\n      return ${Q.texture2D}(${t}, uv);\n    }\n  `}(A,g);case 3:return function(A,g){const I=A.shapeInfo.logicalShape,t=A.name,C="get"+t.charAt(0).toUpperCase()+t.slice(1),e=A.shapeInfo.texShape,B=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===I[0]){const t=[1,2],e=["b","row","col"];return`\n        ${mK(bK(A,I.slice(1)),g)}\n        vec4 ${C}(int b, int row, int col) {\n          return ${C}(${HK(e,t)});\n        }\n      `}const i=wK();if(g)return`\n    vec4 ${C}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${t}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${t}, uv);\n    }\n  `;const Q=B[0],o=B[1],E=Math.ceil(I[2]/2),n=E*Math.ceil(I[1]/2);return`\n    vec4 ${C}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${Q}, ${o}, ${n}, ${E}, b, row, col);\n      return ${i.texture2D}(${t}, uv);\n    }\n  `}(A,g);default:return function(A,g){const I=A.name,t="get"+I.charAt(0).toUpperCase()+I.slice(1),C=wK();if(g)return`\n    vec4 ${t}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${I}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${I}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${I}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${I}TexShape[0]) / 2.0), ceil(float(${I}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${C.texture2D}(${I}, uv);\n    }\n  `;const e=A.shapeInfo.logicalShape,B=e.length,i=A.shapeInfo.texShape,Q=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],o=Q[0],E=Q[1],n=Math.ceil(e[B-1]/2);let s=n*Math.ceil(e[B-2]/2),a="int b, int row, int col",r=`b * ${s} + (row / 2) * ${n} + (col / 2)`;for(let A=2;A<B-1;A++)a=`int b${A}, `+a,s*=e[B-A-1],r=`b${A} * ${s} + `+r;return`\n    vec4 ${t}(${a}) {\n      int index = ${r};\n      int texR = index / ${E};\n      int texC = index - texR * ${E};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${E}, ${o});\n      return ${C.texture2D}(${I}, uv);\n    }\n  `}(A,g)}}const kK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SK="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",MK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",UK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function KK(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function JK(A){return`offset${A}`}function YK(A){const g=A.name,I=QA(A.shapeInfo.logicalShape);return I<2?`return ${g};`:`\n    for (int i = 0; i < ${I}; i++) {\n      if (i == index) {\n        return ${g}[i];\n      }\n    }\n  `}function LK(A){if(A<=1)return"int";if(2===A)return"ivec2";if(3===A)return"ivec3";if(4===A)return"ivec4";if(5===A)return"ivec5";if(6===A)return"ivec6";throw Error(`GPU for rank ${A} is not yet supported`)}function xK(A,g,I){const{newShape:t,keptDims:C}=uA(g),e=g.length,B=A&&3===e&&1===g[0],i=B?g.slice(1):t,Q=!A&&e>1&&!EA(g,I)&&t.length<e||B;return{useSqueezeShape:Q,uniformShape:Q?i:g,keptDims:C}}function bK(A,g){const I=JSON.parse(JSON.stringify(A));return I.shapeInfo.logicalShape=g,I}function HK(A,g){return g.map((g=>A[g])).join(", ")}function qK(A,g,I,t){const C=I.map(((A,I)=>{const t={logicalShape:A.shape,texShape:A.isUniform?null:A.texData.texShape,isUniform:A.isUniform,isPacked:!A.isUniform&&A.texData.isPacked,flatOffset:null};return null!=A.texData&&null!=A.texData.slice&&A.texData.slice.flatOffset>0&&(t.flatOffset=A.texData.slice.flatOffset),{name:g.variableNames[I],shapeInfo:t}})),e=C.map((A=>A.shapeInfo)),B={logicalShape:t.shape,texShape:t.texData.texShape,isUniform:!1,isPacked:t.texData.isPacked,flatOffset:null},i=FK(C,B,g),Q=function(A,g){const I=eK(A,(()=>A.createShader(A.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(PU(A,(()=>A.shaderSource(I,g))),PU(A,(()=>A.compileShader(I))),ZA().get("ENGINE_COMPILE_ONLY"))return I;if(!1===A.getShaderParameter(I,A.COMPILE_STATUS))throw _U(g,A.getShaderInfoLog(I)),new Error("Failed to compile fragment shader.");return I}(A.gl,i),o=A.createProgram(Q);return ZA().get("ENGINE_COMPILE_ONLY")?{program:g,fragmentShader:Q,source:i,webGLProgram:o,inShapeInfos:e,outShapeInfo:B,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:g,fragmentShader:Q,source:i,webGLProgram:o,inShapeInfos:e,outShapeInfo:B},TK(A,g,o))}function TK(A,g,I){const t={},C={},e={},B=[];let i,Q,o,E=null,n=null;n=A.getUniformLocation(I,"NAN",!1),1===ZA().getNumber("WEBGL_VERSION")&&(E=A.getUniformLocation(I,"INFINITY",!1));const s=!1;for(let B=0;B<g.variableNames.length;B++){const i=g.variableNames[B];t[i]=A.getUniformLocation(I,i,s),t[`offset${i}`]=A.getUniformLocation(I,`offset${i}`,s),g.enableShapeUniforms&&(C[`${i}Shape`]=A.getUniformLocation(I,`${i}Shape`,s),e[`${i}TexShape`]=A.getUniformLocation(I,`${i}TexShape`,s))}return g.enableShapeUniforms&&(i=A.getUniformLocation(I,"outShape",s),o=A.getUniformLocation(I,"outShapeStrides",s),Q=A.getUniformLocation(I,"outTexShape",s)),g.customUniforms&&g.customUniforms.forEach(((g,t)=>{B[t]=A.getUniformLocation(I,g.name,s)})),{uniformLocations:t,customUniformLocations:B,infLoc:E,nanLoc:n,inShapesLocations:C,inTexShapesLocations:e,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:Q}}function vK(A,g){if(A.length!==g.length)throw Error(`Binary was compiled with ${A.length} inputs, but was executed with ${g.length} inputs`);A.forEach(((A,I)=>{const t=A.logicalShape,C=g[I],e=C.shape;if(!EA(t,e))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${t} and ${e} must match`);if(A.isUniform&&C.isUniform)return;const B=A.texShape,i=C.isUniform?null:C.texData.texShape;if(!EA(B,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${B} and ${i} must match`)}))}function VK(A){return ZA().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&A<=4}class WK{constructor(A){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=qU.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const g=wK();this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pK(["r","c","d"],A):dK(["r","c","d"],A)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${g.output} = result;\n      }\n    `}}class OK{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=qU.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const g=wK();this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pK(["r","c","d"],A):dK(["r","c","d"],A)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${g.output} = result;\n      }\n    `}}class ZK{constructor(A){this.variableNames=["A"],this.outTexUsage=TU.DOWNLOAD;const g=wK();this.outputShape=A,this.userCode=`\n      ${fK}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${g.output} = encode_float(x);\n      }\n    `}}class PK{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TU.DOWNLOAD;const g=wK();this.outputShape=A,this.userCode=`\n      ${fK}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${g.output} = encode_float(x);\n      }\n    `}}class XK{constructor(A,g=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const I=wK();this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length);let t="result";g&&(t="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":GK(A)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${I.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${I.output} = vec4(${t}, 0., 0., 0.);\n      }\n    `}}class jK{constructor(A,g=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const I=wK();this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length);let t="",C="result";g&&(C="floor(result * 255. + 0.5)");for(let g=0;g<=1;g++)for(let C=0;C<=1;C++){const e=2*g+C;t+=`\n          localCoords = coords;\n          if(localCoords[2] + ${C} < ${this.enableShapeUniforms?"outShape[2]":`${A[2]}`}) {\n          localCoords[2] += ${C};\n          if (localCoords[1] + ${g} < ${this.enableShapeUniforms?"outShape[1]":`${A[1]}`}) {\n            localCoords[1] += ${g};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${I.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${e}] = values[0];\n            } else if (offset == 1) {\n              result[${e}] = values[1];\n            } else if (offset == 2) {\n              result[${e}] = values[2];\n            } else {\n              result[${e}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":GK(A)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${t}\n\n          ${I.output} = ${C};\n        }\n    `}}function zK(A){const g=wK();return function(A,g){const I=eK(A,(()=>A.createShader(A.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(PU(A,(()=>A.shaderSource(I,g))),PU(A,(()=>A.compileShader(I))),!1===A.getShaderParameter(I,A.COMPILE_STATUS))throw console.log(A.getShaderInfoLog(I)),new Error("Failed to compile vertex shader.");return I}(A,`${g.version}\n    precision highp float;\n    ${g.attribute} vec3 clipSpacePos;\n    ${g.attribute} vec2 uv;\n    ${g.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function _K(A){return function(A,g){const I=eK(A,(()=>A.createBuffer()),"Unable to create WebGLBuffer");return PU(A,(()=>A.bindBuffer(A.ARRAY_BUFFER,I))),PU(A,(()=>A.bufferData(A.ARRAY_BUFFER,g,A.STATIC_DRAW))),I}(A,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function $K(A){return function(A,g){const I=eK(A,(()=>A.createBuffer()),"Unable to create WebGLBuffer");return PU(A,(()=>A.bindBuffer(A.ELEMENT_ARRAY_BUFFER,I))),PU(A,(()=>A.bufferData(A.ELEMENT_ARRAY_BUFFER,g,A.STATIC_DRAW))),I}(A,new Uint16Array([0,1,2,2,1,3]))}function AJ(A,g,I,t,C,e){!function(A,g){const I=ZA().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(A<=0||g<=0)throw new Error(`Requested texture size [${A}x${g}] is invalid.`);if(A>I||g>I)throw new Error(`Requested texture size [${A}x${g}] greater than WebGL maximum on this browser / GPU [${I}x${I}].`)}(g,I);const B=function(A){return eK(A,(()=>A.createTexture()),"Unable to create WebGLTexture.")}(A),i=A.TEXTURE_2D;return PU(A,(()=>A.bindTexture(i,B))),PU(A,(()=>A.texParameteri(i,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE))),PU(A,(()=>A.texParameteri(i,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE))),PU(A,(()=>A.texParameteri(i,A.TEXTURE_MIN_FILTER,A.NEAREST))),PU(A,(()=>A.texParameteri(i,A.TEXTURE_MAG_FILTER,A.NEAREST))),1===ZA().getNumber("WEBGL_VERSION")?PU(A,(()=>A.texImage2D(i,0,t,g,I,0,C,e,null))):PU(A,(()=>A.texStorage2D(i,1,t,g,I))),PU(A,(()=>A.bindTexture(A.TEXTURE_2D,null))),{texture:B,texShape:[I,g]}}function gJ(A){return A.internalFormatFloat}function IJ(A){return A.internalFormatHalfFloat}function tJ(A){return A.downloadTextureFormat}function CJ(A){return A.internalFormatPackedFloat}function eJ(A){return A.internalFormatPackedHalfFloat}function BJ(A,g,I,t,C,e,B,i){const Q=A,o=new Float32Array(function(A,g){const[I,t]=OU(A,g);return I*t*4}(e,B));return Q.bindBuffer(Q.PIXEL_PACK_BUFFER,g),Q.getBufferSubData(Q.PIXEL_PACK_BUFFER,0,o),Q.bindBuffer(Q.PIXEL_PACK_BUFFER,null),o}class iJ{constructor(A){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const g=ZA().getNumber("WEBGL_VERSION");null!=A?(this.gl=A,function(A,g){xU[A]=g}(g,A)):this.gl=HU(g);let I="WEBGL_color_buffer_float";const t="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===ZA().getNumber("WEBGL_VERSION")){const A="OES_texture_float",g="OES_texture_half_float";if(this.textureFloatExtension=jU(this.gl,A),rK(this.gl,g))this.textureHalfFloatExtension=jU(this.gl,g);else if(ZA().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(I),rK(this.gl,t))this.colorBufferHalfFloatExtension=jU(this.gl,t);else if(ZA().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(I="EXT_color_buffer_float",rK(this.gl,I))this.colorBufferFloatExtension=this.gl.getExtension(I);else{if(!rK(this.gl,t))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(t)}this.vertexBuffer=_K(this.gl),this.indexBuffer=$K(this.gl),this.framebuffer=function(A){return eK(A,(()=>A.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=ZU(this.gl,this.textureHalfFloatExtension)}get debug(){return ZA().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const A=this.gl;PU(A,(()=>A.finish())),PU(A,(()=>A.bindFramebuffer(A.FRAMEBUFFER,null))),PU(A,(()=>A.deleteFramebuffer(this.framebuffer))),PU(A,(()=>A.bindBuffer(A.ARRAY_BUFFER,null))),PU(A,(()=>A.bindBuffer(A.ELEMENT_ARRAY_BUFFER,null))),PU(A,(()=>A.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(A,g){return this.throwIfDisposed(),function(A,g,I,t){const[C,e]=VU(g,I);return AJ(A,C,e,gJ(t),t.textureFormatFloat,A.FLOAT)}(this.gl,A,g,this.textureConfig)}createFloat16MatrixTexture(A,g){return this.throwIfDisposed(),function(A,g,I,t){const[C,e]=VU(g,I);return AJ(A,C,e,IJ(t),t.textureFormatFloat,t.textureTypeHalfFloat)}(this.gl,A,g,this.textureConfig)}createUnsignedBytesMatrixTexture(A,g){return this.throwIfDisposed(),function(A,g,I,t){const[C,e]=VU(g,I);return AJ(A,C,e,tJ(t),A.RGBA,A.UNSIGNED_BYTE)}(this.gl,A,g,this.textureConfig)}uploadPixelDataToTexture(A,g){this.throwIfDisposed(),function(A,g,I){PU(A,(()=>A.bindTexture(A.TEXTURE_2D,g))),I.data instanceof Uint8Array?2===ZA().getNumber("WEBGL_VERSION")?PU(A,(()=>A.texSubImage2D(A.TEXTURE_2D,0,0,0,I.width,I.height,A.RGBA,A.UNSIGNED_BYTE,I.data))):PU(A,(()=>A.texImage2D(A.TEXTURE_2D,0,A.RGBA,I.width,I.height,0,A.RGBA,A.UNSIGNED_BYTE,I.data))):2===ZA().getNumber("WEBGL_VERSION")?PU(A,(()=>A.texSubImage2D(A.TEXTURE_2D,0,0,0,A.RGBA,A.UNSIGNED_BYTE,I))):PU(A,(()=>A.texImage2D(A.TEXTURE_2D,0,A.RGBA,A.RGBA,A.UNSIGNED_BYTE,I))),PU(A,(()=>A.bindTexture(A.TEXTURE_2D,null)))}(this.gl,A,g)}uploadDenseMatrixToTexture(A,g,I,t){this.throwIfDisposed(),function(A,g,I,t,C,e){let B,i,Q;PU(A,(()=>A.bindTexture(A.TEXTURE_2D,g))),C instanceof Uint8Array?(B=new Uint8Array(I*t*4),i=A.UNSIGNED_BYTE,Q=A.RGBA):(B=new Float32Array(I*t*4),i=A.FLOAT,Q=e.internalFormatPackedFloat),B.set(C),2===ZA().getNumber("WEBGL_VERSION")?PU(A,(()=>A.texSubImage2D(A.TEXTURE_2D,0,0,0,I,t,A.RGBA,i,B))):PU(A,(()=>A.texImage2D(A.TEXTURE_2D,0,Q,I,t,0,A.RGBA,i,B))),PU(A,(()=>A.bindTexture(A.TEXTURE_2D,null)))}(this.gl,A,g,I,t,this.textureConfig)}createFloat16PackedMatrixTexture(A,g){return this.throwIfDisposed(),function(A,g,I,t){const[C,e]=OU(g,I);return AJ(A,C,e,eJ(t),A.RGBA,t.textureTypeHalfFloat)}(this.gl,A,g,this.textureConfig)}createPackedMatrixTexture(A,g){return this.throwIfDisposed(),function(A,g,I,t){const[C,e]=OU(g,I);return AJ(A,C,e,CJ(t),A.RGBA,A.FLOAT)}(this.gl,A,g,this.textureConfig)}deleteMatrixTexture(A){this.throwIfDisposed(),this.outputTexture===A&&(tK(this.gl,this.framebuffer),this.outputTexture=null),PU(this.gl,(()=>this.gl.deleteTexture(A)))}downloadByteEncodedFloatMatrixFromOutputTexture(A,g,I){return this.downloadMatrixDriver(A,(()=>function(A,g,I,t){const[C,e]=VU(g,I),B=new Uint8Array(g*I*4);return PU(A,(()=>A.readPixels(0,0,C,e,t.downloadTextureFormat,A.UNSIGNED_BYTE,B))),new Float32Array(B.buffer)}(this.gl,g,I,this.textureConfig)))}downloadPackedMatrixFromBuffer(A,g,I,t,C,e){return BJ(this.gl,A,0,0,0,C,e,this.textureConfig)}downloadFloat32MatrixFromBuffer(A,g){return function(A,g,I){const t=A,C=new Float32Array(I);return t.bindBuffer(t.PIXEL_PACK_BUFFER,g),t.getBufferSubData(t.PIXEL_PACK_BUFFER,0,C),t.bindBuffer(t.PIXEL_PACK_BUFFER,null),C}(this.gl,A,g)}createBufferFromTexture(A,g,I){this.bindTextureToFrameBuffer(A);const t=function(A,g,I,t){const C=A.createBuffer();PU(A,(()=>A.bindBuffer(A.PIXEL_PACK_BUFFER,C)));const e=16*g*I;return PU(A,(()=>A.bufferData(A.PIXEL_PACK_BUFFER,e,A.STREAM_READ))),PU(A,(()=>A.readPixels(0,0,I,g,A.RGBA,A.FLOAT,0))),PU(A,(()=>A.bindBuffer(A.PIXEL_PACK_BUFFER,null))),C}(this.gl,g,I,this.textureConfig);return this.unbindTextureToFrameBuffer(),t}createAndWaitForFence(){const A=this.createFence(this.gl);return this.pollFence(A)}createFence(A){let g,I;if(ZA().getBool("WEBGL_FENCE_API_ENABLED")){const t=A,C=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);A.flush(),I=()=>{const A=t.clientWaitSync(C,0,0);return A===t.ALREADY_SIGNALED||A===t.CONDITION_SATISFIED},g=C}else ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(g=this.beginQuery(),this.endQuery(),I=()=>this.isQueryAvailable(g,ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):I=()=>!0;return{query:g,isFencePassed:I}}downloadMatrixFromPackedTexture(A,g,I){return this.downloadMatrixDriver(A,(()=>function(A,g,I){const t=new Float32Array(g*I*4);return PU(A,(()=>A.readPixels(0,0,I,g,A.RGBA,A.FLOAT,t))),t}(this.gl,g,I)))}createProgram(A){this.throwIfDisposed();const g=this.gl;null==this.vertexShader&&(this.vertexShader=zK(g));const I=function(A){return eK(A,(()=>A.createProgram()),"Unable to create WebGLProgram.")}(g);return PU(g,(()=>g.attachShader(I,this.vertexShader))),PU(g,(()=>g.attachShader(I,A))),function(A,g){if(PU(A,(()=>A.linkProgram(g))),!ZA().get("ENGINE_COMPILE_ONLY")&&!1===A.getProgramParameter(g,A.LINK_STATUS))throw console.log(A.getProgramInfoLog(g)),new Error("Failed to link vertex and fragment shaders.")}(g,I),this.debug&&$U(g,I),this.vertexAttrsAreBound||(this.setProgram(I),this.vertexAttrsAreBound=function(A,g,I){return PU(A,(()=>A.bindBuffer(A.ARRAY_BUFFER,I))),AK(A,g,"clipSpacePos",I,3,20,0)&&AK(A,g,"uv",I,2,20,12)}(g,this.program,this.vertexBuffer)),I}deleteProgram(A){this.throwIfDisposed(),A===this.program&&(this.program=null),null!=A&&PU(this.gl,(()=>this.gl.deleteProgram(A)))}setProgram(A){this.throwIfDisposed(),this.program=A,null!=this.program&&this.debug&&$U(this.gl,this.program),PU(this.gl,(()=>this.gl.useProgram(A)))}getUniformLocation(A,g,I=!0){return this.throwIfDisposed(),I?function(A,g,I){return eK(A,(()=>A.getUniformLocation(g,I)),'uniform "'+I+'" not present in program.')}(this.gl,A,g):function(A,g,I){return A.getUniformLocation(g,I)}(this.gl,A,g)}getAttributeLocation(A,g){return this.throwIfDisposed(),PU(this.gl,(()=>this.gl.getAttribLocation(A,g)))}getUniformLocationNoThrow(A,g){return this.throwIfDisposed(),this.gl.getUniformLocation(A,g)}setInputMatrixTexture(A,g,I){this.throwIfDisposed(),this.throwIfNoProgram(),gK(this.gl,A,g,I)}setOutputMatrixTexture(A,g,I){this.setOutputMatrixTextureDriver(A,I,g)}setOutputPackedMatrixTexture(A,g,I){this.throwIfDisposed();const[t,C]=OU(g,I);this.setOutputMatrixTextureDriver(A,t,C)}setOutputMatrixWriteRegion(A,g,I,t){this.setOutputMatrixWriteRegionDriver(I,A,t,g)}setOutputPackedMatrixWriteRegion(A,g,I,t){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&$U(this.gl,this.program),CK(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const A=this.gl;this.debug&&this.debugValidate(),PU(A,(()=>A.drawElements(A.TRIANGLES,6,A.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),PU(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=jU(this.gl,2===ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const A=this.gl,g=this.getQueryTimerExtensionWebGL2(),I=A.createQuery();return A.beginQuery(g.TIME_ELAPSED_EXT,I),I}const A=this.getQueryTimerExtensionWebGL1(),g=A.createQueryEXT();return A.beginQueryEXT(A.TIME_ELAPSED_EXT,g),g}endQuery(){if(2===ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const A=this.gl,g=this.getQueryTimerExtensionWebGL2();return void A.endQuery(g.TIME_ELAPSED_EXT)}const A=this.getQueryTimerExtensionWebGL1();A.endQueryEXT(A.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(A){return await cA((()=>this.disposed||this.isQueryAvailable(A,ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(A,ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(A,g){if(0===g)return null;if(2===g){const g=this.gl;return g.getQueryParameter(A,g.QUERY_RESULT)/1e6}{const g=this.getQueryTimerExtensionWebGL1();return g.getQueryObjectEXT(A,g.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(A,g){if(0===g)return!0;if(2===g){const g=this.gl,I=this.getQueryTimerExtensionWebGL2(),t=g.getQueryParameter(A,g.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(I.GPU_DISJOINT_EXT)),t&&!this.disjoint}{const g=this.getQueryTimerExtensionWebGL1(),I=g.getQueryObjectEXT(A,g.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(g.GPU_DISJOINT_EXT)),I&&!this.disjoint}}pollFence(A){return new Promise((g=>{this.addItemToPoll((()=>A.isFencePassed()),(()=>g()))}))}pollItems(){const A=function(A){let g=0;for(;g<A.length;++g){if(!A[g]())break}return g-1}(this.itemsToPoll.map((A=>A.isDoneFn)));for(let g=0;g<=A;++g){const{resolveFn:A}=this.itemsToPoll[g];A()}this.itemsToPoll=this.itemsToPoll.slice(A+1)}addItemToPoll(A,g){if(this.itemsToPoll.push({isDoneFn:A,resolveFn:g}),this.itemsToPoll.length>1)return;let I;"setTimeoutCustom"in ZA().platform&&(I=ZA().platform.setTimeoutCustom.bind(ZA().platform)),cA((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,I)}bindTextureToFrameBuffer(A){this.throwIfDisposed(),IK(this.gl,A,this.framebuffer),this.debug&&CK(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(IK(this.gl,this.outputTexture,this.framebuffer),this.debug&&CK(this.gl)):tK(this.gl,this.framebuffer)}downloadMatrixDriver(A,g){this.bindTextureToFrameBuffer(A);const I=g();return this.unbindTextureToFrameBuffer(),I}setOutputMatrixTextureDriver(A,g,I){this.throwIfDisposed();const t=this.gl;IK(t,A,this.framebuffer),this.debug&&CK(t),this.outputTexture=A,PU(t,(()=>t.viewport(0,0,g,I))),PU(t,(()=>t.scissor(0,0,g,I)))}setOutputMatrixWriteRegionDriver(A,g,I,t){this.throwIfDisposed(),PU(this.gl,(()=>this.gl.scissor(A,g,I,t)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:QJ,bincountImpl:oJ,bincountReduceImpl:EJ,castImpl:nJ,ceilImpl:sJ,concatImpl:aJ,equalImpl:rJ,expImpl:hJ,expm1Impl:cJ,floorImpl:lJ,gatherNdImpl:DJ,gatherV2Impl:uJ,greaterImpl:wJ,greaterEqualImpl:dJ,lessImpl:pJ,lessEqualImpl:yJ,linSpaceImpl:GJ,logImpl:fJ,maxImpl:NJ,maximumImpl:FJ,minimumImpl:RJ,multiplyImpl:mJ,negImpl:kJ,notEqualImpl:SJ,prodImpl:MJ,raggedGatherImpl:UJ,raggedTensorToTensorImpl:KJ,rangeImpl:JJ,rsqrtImpl:YJ,scatterImpl:LJ,sigmoidImpl:xJ,simpleAbsImpl:bJ,sliceImpl:HJ,sparseFillEmptyRowsImpl:qJ,sparseReshapeImpl:TJ,sparseSegmentReductionImpl:vJ,sqrtImpl:VJ,stridedSliceImpl:WJ,stringNGramsImpl:OJ,stringSplitImpl:ZJ,stringToHashBucketFastImpl:PJ,subImpl:XJ,tileImpl:jJ,topKImpl:zJ,transposeImpl:_J,uniqueImpl:$J}=O;function AY(A,g){return["x","y","z","w","u","v"].slice(0,g).map((g=>`${A}.${g}`))}function gY(A,g){return 1===g?[A]:AY(A,g)}class IY{constructor(A){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=A,this.rank=A.length,this.enableShapeUniforms=VK(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const A=gY("rc",this.rank),g=LK(this.rank),I=this.getOutOfBoundsCondition(A),t=this.getSetup(A),C=this.getOutput(A);this.userCode=`\n        void main() {\n          ${g} rc = getOutputCoords();\n\n          if(${I}) {\n            setOutput(vec4(0));\n          } else {\n            ${t}\n\n            setOutput(vec4(${C}));\n          }\n        }\n      `}}getSourceCoordsArr(A){const g=[];for(let I=0;I<=1;I++)for(let t=0;t<=1;t++){let C=`${0===I?"r":"rp1"}, ${0===t?"c":"cp1"}`;for(let g=2;g<this.rank;g++)C=`${A[A.length-1-g]},`+C;g.push(C)}return g}getOutOfBoundsCondition(A){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let g="";for(let I=this.rank-2;I<this.rank;I++)g+=`${A[I]} >= ${this.enableShapeUniforms?`outShape[${I}]`:this.outputShape[I]}`,I<this.rank-1&&(g+="||");return g}getSetup(A){if(1===this.rank)return"";const g=A.slice(-2),I=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],t=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${g[0]};\n      int c = ${g[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${I};\n      bool rEdge = rp1 >= ${t};\n    `}getOutput(A){const g=this.getSourceCoordsArr(A);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${g[0]}),\n            cEdge ? 0. : getA(${g[1]}),\n            rEdge ? 0. : getA(${g[2]}),\n            rEdge || cEdge ? 0. : getA(${g[3]})`}}class tY{constructor(A,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length);let I="";for(let A=0;A<4;A++){let g="thisRC = rc;";A%2==1&&(g+="thisRC.z += 1;"),A>1&&(g+="thisRC.y += 1;"),I+=`\n        ${g}\n        ${A>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${A}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${A>0?"}":""}\n      `}var t,C;this.userCode=`\n      ${t=g,C=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${C?yK(["r","c","d"],"inputShape"):dK(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":GK(A)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":A[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":A[2]};\n\n        ${I}\n\n        setOutput(result);\n      }\n    `}}class CY{constructor(A){this.gpgpu=A,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(A,g,I){const t=BY(g,I),C=iY(A,t,I);C in this.freeTextures||(this.freeTextures[C]=[]),C in this.usedTextures||(this.usedTextures[C]=[]);const e=eY(A,t,this.gpgpu.gl,this.gpgpu.textureConfig,I);if(this.freeTextures[C].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=e,this.log();const A=this.freeTextures[C].shift();return this.usedTextures[C].push(A),A}let B;return t===vU.PACKED_2X2_FLOAT32?B=this.gpgpu.createPackedMatrixTexture(A[0],A[1]):t===vU.PACKED_2X2_FLOAT16?B=this.gpgpu.createFloat16PackedMatrixTexture(A[0],A[1]):t===vU.UNPACKED_FLOAT32?B=this.gpgpu.createFloat32MatrixTexture(A[0],A[1]):t===vU.UNPACKED_FLOAT16?B=this.gpgpu.createFloat16MatrixTexture(A[0],A[1]):t===vU.PACKED_4X1_UNSIGNED_BYTE&&(B=this.gpgpu.createUnsignedBytesMatrixTexture(A[0],A[1])),this.usedTextures[C].push(B),this.numUsedTextures++,this._numBytesAllocated+=e,this.log(),B}releaseTexture(A,g,I,t){if(null==this.freeTextures)return;const C=BY(I,t),e=iY(g,C,t);e in this.freeTextures||(this.freeTextures[e]=[]);const B=eY(g,C,this.gpgpu.gl,this.gpgpu.textureConfig,t),i=ZA().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(A.texture),this._numBytesAllocated-=B):(this.freeTextures[e].push(A),this.numFreeTextures++,this._numBytesFree+=B),this.numUsedTextures--;const Q=this.usedTextures[e],o=Q.indexOf(A);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");Q.splice(o,1),this.log()}log(){if(!this.logEnabled)return;const A=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${A})`);const g=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*g)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const A in this.freeTextures)this.freeTextures[A].forEach((A=>{this.gpgpu.deleteMatrixTexture(A.texture)}));for(const A in this.usedTextures)this.usedTextures[A].forEach((A=>{this.gpgpu.deleteMatrixTexture(A.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function eY(A,g,I,t,C){const e=function(A,g){switch(A){case vU.PACKED_2X2_FLOAT32:return CJ(g);case vU.PACKED_2X2_FLOAT16:return eJ(g);case vU.UNPACKED_FLOAT32:return gJ(g);case vU.UNPACKED_FLOAT16:return IJ(g);case vU.PACKED_4X1_UNSIGNED_BYTE:return tJ(g);default:throw new Error(`Unknown physical texture type ${A}`)}}(g,t);let B;if(C){const[g,I]=OU(A[0],A[1]);B=g*I}else{const[g,I]=VU(A[0],A[1]);B=g*I}const i=function(A,g){const I=A;if(g===I.R32F)return 4;if(g===I.R16F)return 2;if(g===I.RGBA32F)return 16;if(g===A.RGBA)return 16;if(g===I.RGBA16F)return 8;if(g===I.RGBA8)return 4;throw new Error(`Unknown internal format ${g}`)}(I,e);return B*i}function BY(A,g){if(A===TU.UPLOAD)return vU.PACKED_2X2_FLOAT32;if(A===TU.RENDER||null==A)return function(A){return ZA().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?A?vU.PACKED_2X2_FLOAT32:vU.UNPACKED_FLOAT32:A?vU.PACKED_2X2_FLOAT16:vU.UNPACKED_FLOAT16}(g);if(A===TU.DOWNLOAD||A===TU.PIXELS)return vU.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${A}`)}function iY(A,g,I){return`${A[0]}_${A[1]}_${g}_${I}`}class QY{constructor(A,g){this.variableNames=["A"],this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${g}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const oY="if (isnan(x)) return x;",EY="return x;",nY="return abs(x);";const sY="return (x >= 0.0) ? x : (exp(x) - 1.0);",aY=oY+"\n  return (x < 0.0) ? 0.0 : x;\n",rY=oY+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",hY="return x;",cY="return 1.0 / (1.0 + exp(-1.0 * x));",lY="return x;",DY="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",uY="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",wY="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",dY="return 1.0 / (1.0 + exp(-1.0 * x));";class pY{constructor(A,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${g}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class yY{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length);const g=A.length,I=gY("rc",g),t=LK(g),C=function(A,g){if(1===A)return"rc";let I="";for(let t=0;t<A;t++)I+=g[t],t<A-1&&(I+=",");return I}(g,I),e=I.slice(-2),B=g<=1?"rc":`vec2(${e.join(",")})`;this.userCode=`\n      void main() {\n        ${t} rc = getOutputCoords();\n        vec4 packedInput = getA(${C});\n\n        setOutput(getChannel(packedInput, ${B}));\n      }\n    `}}const GY=Os,fY={};const NY=ZA().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class FY extends P{constructor(A){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ZA().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let g;if(null!=A){if(A instanceof iJ)g=A;else{const I=HU(ZA().getNumber("WEBGL_VERSION"),A);g=new iJ(I)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const A=HU(ZA().getNumber("WEBGL_VERSION"));g=new iJ(A),this.binaryCache=((I=ZA().getNumber("WEBGL_VERSION"))in fY||(fY[I]={}),fY[I]),this.gpgpuCreatedLocally=!0}var I;this.gpgpu=g,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new CY(this.gpgpu),this.numMBBeforeWarning=null==ZA().global.screen?1024:ZA().global.screen.height*ZA().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Z(this,li())}nextDataId(){return FY.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(A,g,I){if((ZA().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ZA().getBool("DEBUG"))&&this.checkNumericalProblems(A),"complex64"===I&&null!=A)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const t={id:this.nextDataId()};return this.texData.set(t,{shape:g,dtype:I,values:A,usage:TU.UPLOAD,refCount:1}),t}refCount(A){if(this.texData.has(A)){return this.texData.get(A).refCount}return 0}incRef(A){this.texData.get(A).refCount++}decRef(A){if(this.texData.has(A)){this.texData.get(A).refCount--}}move(A,g,I,t,C){if(ZA().getBool("DEBUG")&&this.checkNumericalProblems(g),"complex64"===t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(A,{shape:I,dtype:t,values:g,usage:TU.UPLOAD,refCount:C})}disposeIntermediateTensorInfo(A){this.disposeData(A.dataId)}readSync(A){const g=this.texData.get(A),{values:I,dtype:t,complexTensorInfos:C,slice:e,shape:B,isPacked:i}=g;if(null!=e){let g;g=i?new pY(B,hY):new QY(B,hY);const I=this.runWebGLProgram(g,[{dataId:A,shape:B,dtype:t}],t),C=this.readSync(I.dataId);return this.disposeIntermediateTensorInfo(I),C}if(null!=I)return this.convertAndCacheOnCPU(A);if("string"===t)return I;const Q=null!=this.activeTimers;let o,E;if(Q&&(o=bC()),"complex64"===t){E=qr(this.readSync(C.real.dataId),this.readSync(C.imag.dataId))}else E=this.getValuesFromTexture(A);return Q&&(this.downloadWaitMs+=bC()-o),this.convertAndCacheOnCPU(A,E)}async read(A){if(this.pendingRead.has(A)){const g=this.pendingRead.get(A);return new Promise((A=>g.push(A)))}const g=this.texData.get(A),{values:I,shape:t,slice:C,dtype:e,complexTensorInfos:B,isPacked:i}=g;if(null!=C){let g;g=i?new pY(t,hY):new QY(t,hY);const I=this.runWebGLProgram(g,[{dataId:A,shape:t,dtype:e}],e),C=this.read(I.dataId);return this.disposeIntermediateTensorInfo(I),C}if(null!=I)return this.convertAndCacheOnCPU(A);if(ZA().getBool("DEBUG")&&!ZA().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ZA().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let Q,o,E=null;if("complex64"!==e&&ZA().get("WEBGL_BUFFER_SUPPORTED")){Q=this.decode(A);const g=this.texData.get(Q.dataId);E=this.gpgpu.createBufferFromTexture(g.texture.texture,...WU(t))}if(this.pendingRead.set(A,[]),"complex64"!==e&&await this.gpgpu.createAndWaitForFence(),"complex64"===e){const A=await Promise.all([this.read(B.real.dataId),this.read(B.imag.dataId)]);o=qr(A[0],A[1])}else if(null==E)o=this.getValuesFromTexture(A);else{const A=QA(t);o=this.gpgpu.downloadFloat32MatrixFromBuffer(E,A)}if(null!=Q&&this.disposeIntermediateTensorInfo(Q),null!=E){const A=this.gpgpu.gl;PU(A,(()=>A.deleteBuffer(E)))}const n=this.convertAndCacheOnCPU(A,o),s=this.pendingRead.get(A);return this.pendingRead.delete(A),s.forEach((A=>A(n))),this.pendingDisposal.has(A)&&(this.pendingDisposal.delete(A),this.disposeData(A)&&li().removeDataId(A,this),this.pendingDeletes--),n}readToGPU(A,g={}){const I=this.texData.get(A),{values:t,shape:C,slice:e,dtype:B,isPacked:i,texture:Q}=I;if("complex64"===B)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=e){let I;I=i?new pY(C,hY):new QY(C,hY);const t=this.runWebGLProgram(I,[{dataId:A,shape:C,dtype:B}],B),e=this.readToGPU(t,g);return this.disposeIntermediateTensorInfo(t),e}if(null==Q)throw null!=t?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=this.decode(A,g.customTexShape),E=li().makeTensorFromTensorInfo(o),n=this.texData.get(o.dataId);return Object.assign({tensorRef:E},n.texture)}bufferSync(A){const g=this.readSync(A.dataId);if("string"===A.dtype)try{const I=g.map((A=>TC(A)));return HB(A.shape,A.dtype,I)}catch(A){throw new Error("Failed to decode encoded string bytes into utf-8")}return HB(A.shape,A.dtype,g)}checkNumericalProblems(A){if(null!=A)for(let g=0;g<A.length;g++){const I=A[g];if(!XU(I)){if(ZA().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${I} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${I} cannot be represented on this device.`)}}}getValuesFromTexture(A){const{shape:g,dtype:I,isPacked:t}=this.texData.get(A),C=QA(g);if(ZA().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const I=this.decode(A),t=this.texData.get(I.dataId),e=this.gpgpu.downloadMatrixFromPackedTexture(t.texture.texture,...WU(g)).subarray(0,C);return this.disposeIntermediateTensorInfo(I),e}const e=ZA().getBool("WEBGL_PACK")&&!0===t,B=e?oK(g):g,i=e?new PK(B):new ZK(B),Q=this.runWebGLProgram(i,[{shape:B,dtype:I,dataId:A}],"float32"),o=this.texData.get(Q.dataId),E=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(o.texture.texture,o.texShape[0],o.texShape[1]).subarray(0,C);return this.disposeIntermediateTensorInfo(Q),E}timerAvailable(){return ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(A){const g=this.activeTimers,I=[];let t=!1;null==this.programTimersStack?(this.programTimersStack=I,t=!0):this.activeTimers.push(I),this.activeTimers=I,A();const C=iA(this.activeTimers.map((A=>A.query))).filter((A=>null!=A)),e=iA(this.activeTimers.map((A=>A.name))).filter((A=>null!=A));this.activeTimers=g,t&&(this.programTimersStack=null);const B={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const A=await Promise.all(C);B.kernelMs=gA(A),B.getExtraProfileInfo=()=>A.map(((A,g)=>({name:e[g],ms:A}))).map((A=>`${A.name}: ${A.ms}`)).join(", ")}else B.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,B})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:bC(),endMs:null}}endTimer(A){return ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),A):(A.endMs=bC(),A)}async getQueryTime(A){if(ZA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(A);const g=A;return g.endMs-g.startMs}disposeData(A,g=!1){if(this.pendingDisposal.has(A))return!1;if(!this.texData.has(A))return!0;if(g?this.texData.get(A).refCount=0:this.texData.get(A).refCount--,!g&&this.texData.get(A).refCount>0)return!1;if(this.pendingRead.has(A))return this.pendingDisposal.add(A),this.pendingDeletes++,!1;this.releaseGPUData(A);const{complexTensorInfos:I}=this.texData.get(A);return null!=I&&(this.disposeData(I.real.dataId,g),this.disposeData(I.imag.dataId,g)),this.texData.delete(A),!0}releaseGPUData(A){const{texture:g,dtype:I,texShape:t,usage:C,isPacked:e,slice:B}=this.texData.get(A),i=B&&B.origDataId||A,Q=this.dataRefCount.get(i);Q>1?this.dataRefCount.set(i,Q-1):(this.dataRefCount.delete(i),null!=g&&(this.numBytesInGPU-=this.computeBytes(t,I),this.textureManager.releaseTexture(g,t,C,e)));const o=this.texData.get(A);o.texture=null,o.texShape=null,o.isPacked=!1,o.slice=null}getTexture(A){return this.uploadToGPU(A),this.texData.get(A).texture.texture}getDataInfo(A){return this.texData.get(A)}shouldExecuteOnCPU(A,g=NY){return ZA().getBool("WEBGL_CPU_FORWARD")&&A.every((A=>null==this.texData.get(A.dataId).texture&&QA(A.shape)<g))}getGPGPUContext(){return this.gpgpu}where(A){EC("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const g=A.dataSync();return GY(A.shape,g)}packedUnaryOp(A,g,I){const t=new pY(A.shape,g),C=this.compileAndRun(t,[A],I);return li().makeTensorFromTensorInfo(C)}abs(A){if(this.shouldExecuteOnCPU([A])&&"complex64"!==A.dtype){const g=bJ(this.texData.get(A.dataId).values);return this.makeOutput(A.shape,A.dtype,g)}if(ZA().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(A,nY,A.dtype);const g=new QY(A.shape,nY),I=this.compileAndRun(g,[A]);return li().makeTensorFromTensorInfo(I)}makeTensorInfo(A,g,I){let t;if("string"===g&&null!=I&&I.length>0&&RA(I[0])){const C=I.map((A=>qC(A)));t=this.write(C,A,g)}else t=this.write(I,A,g);return this.texData.get(t).usage=null,{dataId:t,shape:A,dtype:g}}makeOutput(A,g,I){return li().makeTensorFromTensorInfo(this.makeTensorInfo(A,g,I),this)}unpackTensor(A){const g=new yY(A.shape);return this.runWebGLProgram(g,[A],A.dtype)}packTensor(A){const g=new IY(A.shape);return this.runWebGLProgram(g,[A],A.dtype,null,!0)}packedReshape(A,g){const I=[iK(A.shape),...QK(A.shape)],t={dtype:A.dtype,shape:I,dataId:A.dataId},C=[iK(g),...QK(g)],e=new tY(C,I),B=[I],i=this.runWebGLProgram(e,[t],A.dtype,B,!0);return{dataId:i.dataId,shape:g,dtype:i.dtype}}decode(A,g){const I=this.texData.get(A),{isPacked:t,shape:C,dtype:e}=I;if(null!=g){CA(QA(C)<=g[0]*g[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const B=oK(C);let i;i=t?new OK(B):new WK(B);const Q=[null!=g?g:WU(B)];return{dtype:e,shape:C,dataId:this.runWebGLProgram(i,[{shape:B,dtype:e,dataId:A}],e,Q,!0,g).dataId}}runWebGLProgram(A,g,I,t,C=!1,e){const B=this.makeTensorInfo(A.outputShape,I),i=this.texData.get(B.dataId);if(A.packedOutput&&(i.isPacked=!0),A.outPackingScheme===qU.DENSE){const g=null!=e?e:WU(A.outputShape);i.texShape=g.map((A=>2*A))}if(null!=A.outTexUsage&&(i.usage=A.outTexUsage),0===QA(B.shape))return i.values=wA(B.dtype,0),B;const Q=[],o=g.map((g=>{if("complex64"===g.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let I=this.texData.get(g.dataId);if(null==I.texture){if(!A.packedInputs&&QA(g.shape)<=ZA().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:I.values};A.packedInputs&&(I.isPacked=!0,I.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!I.isPacked!=!!A.packedInputs)g=I.isPacked?this.unpackTensor(g):this.packTensor(g),Q.push(g),I=this.texData.get(g.dataId);else if(I.isPacked&&!nK(I.shape,g.shape)){const A=g,t=g.shape;g.shape=I.shape,g=this.packedReshape(g,t),Q.push(g),I=this.texData.get(g.dataId),A.shape=t}return{shape:g.shape,texData:I,isUniform:!1}}));this.uploadToGPU(B.dataId);const E={shape:B.shape,texData:i,isUniform:!1},n=function(A,g,I){let t="";g.concat(I).forEach((g=>{const C=null!=g.texData&&null!=g.texData.slice&&g.texData.slice.flatOffset>0;if(A.enableShapeUniforms&&!g.isUniform){const e=g.texData.texShape,{useSqueezeShape:B,uniformShape:i,keptDims:Q}=xK(A.packedInputs,g.shape,e);let o="",E="",n="";if(1===i.length&&A.packedInputs){const A=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];o=`${A[0]>1}_${A[1]>1}`}else if(2!==i.length||A.packedInputs){if(i.length>2&&!A.packedInputs){const A=KA(i);n=`${A[0]===e[1]}_${A[A.length-1]===e[1]}`}}else E=`${i[0]>1}_${i[1]>1}`;const s=g.shape.length,a=2===i.length&&EA(g.shape,e),r=1===QA(g.shape),h=xi(g.shape,I.shape),c=!A.packedInputs&&s===I.shape.length&&EA(e,I.texData.texShape),l=A.packedInputs||i.length>2?"":`${e[0]>1}_${e[1]>1}`;t+=`${s}_${c}_${B?Q:""}_${i.length}_${r}_${h}_${a}_${o}_${E}_${n}_${l}_${C}`}else{const A=g.isUniform?"uniform":g.texData.texShape;t+=`${g.shape}_${A}_${C}`}}));const C=A.userCode;let e=A.constructor.name;return e+="_"+t+"_"+C+`${ZA().getNumber("WEBGL_VERSION")}`,e}(A,o,E),s=this.getAndSaveBinary(n,(()=>qK(this.gpgpu,A,o,E))),a=null!=this.activeTimers;let r;a&&(r=this.startTimer()),ZA().get("ENGINE_COMPILE_ONLY")||function(A,g,I,t,C){g.program.enableShapeUniforms||(vK(g.inShapeInfos,I),vK([g.outShapeInfo],[t]));const e=t.texData.texture,B=t.texData.texShape;t.texData.isPacked?A.setOutputPackedMatrixTexture(e.texture,B[0],B[1]):A.setOutputMatrixTexture(e.texture,B[0],B[1]),A.setProgram(g.webGLProgram),1===ZA().getNumber("WEBGL_VERSION")&&null!==g.infLoc&&A.gl.uniform1f(g.infLoc,1/0),null!==g.nanLoc&&A.gl.uniform1f(g.nanLoc,NaN),I.forEach(((I,t)=>{const C=g.program.variableNames[t],e=g.uniformLocations[C],B=g.uniformLocations[`offset${C}`],i=g.inShapesLocations[`${C}Shape`],Q=g.inTexShapesLocations[`${C}TexShape`];if(i){const{uniformShape:t}=xK(g.program.packedInputs,I.shape,I.texData.texShape);switch(t.length){case 1:A.gl.uniform1iv(i,new Int32Array(t));break;case 2:A.gl.uniform2iv(i,new Int32Array(t));break;case 3:A.gl.uniform3iv(i,new Int32Array(t));break;case 4:A.gl.uniform4iv(i,new Int32Array(t))}}if(Q&&A.gl.uniform2i(Q,I.texData.texShape[0],I.texData.texShape[1]),null!=e)if(I.isUniform)if(QA(I.shape)<2)A.gl.uniform1f(e,I.uniformValues[0]);else{let g=I.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),A.gl.uniform1fv(e,g)}else null!=I.texData.slice&&null!=B&&A.gl.uniform1i(B,I.texData.slice.flatOffset),A.setInputMatrixTexture(I.texData.texture.texture,e,t)}));const i=g.outShapeLocation;if(i)switch(t.shape.length){case 1:A.gl.uniform1iv(i,new Int32Array(t.shape));break;case 2:A.gl.uniform2iv(i,new Int32Array(t.shape));break;case 3:A.gl.uniform3iv(i,new Int32Array(t.shape));break;case 4:A.gl.uniform4iv(i,new Int32Array(t.shape))}if(g.outShapeStridesLocation){const I=KA(t.shape);switch(t.shape.length){case 2:A.gl.uniform1iv(g.outShapeStridesLocation,new Int32Array(I));break;case 3:A.gl.uniform2iv(g.outShapeStridesLocation,new Int32Array(I));break;case 4:A.gl.uniform3iv(g.outShapeStridesLocation,new Int32Array(I))}}g.outTexShapeLocation&&A.gl.uniform2i(g.outTexShapeLocation,t.texData.texShape[0],t.texData.texShape[1]),g.program.customUniforms&&C&&g.program.customUniforms.forEach(((I,t)=>{const e=g.customUniformLocations[t],B=C[t];if("float"===I.type)A.gl.uniform1fv(e,B);else if("vec2"===I.type)A.gl.uniform2fv(e,B);else if("vec3"===I.type)A.gl.uniform3fv(e,B);else if("vec4"===I.type)A.gl.uniform4fv(e,B);else if("int"===I.type)A.gl.uniform1iv(e,B);else if("ivec2"===I.type)A.gl.uniform2iv(e,B);else if("ivec3"===I.type)A.gl.uniform3iv(e,B);else{if("ivec4"!==I.type)throw Error(`uniform type ${I.type} is not supported yet.`);A.gl.uniform4iv(e,B)}})),A.executeProgram()}(this.gpgpu,s,o,E,t),Q.forEach((A=>this.disposeIntermediateTensorInfo(A))),a&&(r=this.endTimer(r),this.activeTimers.push({name:A.constructor.name,query:this.getQueryTime(r)}));const h=ZA().get("WEBGL_FLUSH_THRESHOLD");if(h>0){const A=bC();A-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=A)}if(!ZA().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===C){const A=this.unpackTensor(B);return this.disposeIntermediateTensorInfo(B),A}return B}compileAndRun(A,g,I,t,C=!1){I=I||g[0].dtype;return this.runWebGLProgram(A,g,I,t,C)}getAndSaveBinary(A,g){return A in this.binaryCache||(this.binaryCache[A]=g()),this.binaryCache[A]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!ZA().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((A=>{this.gpgpu.deleteProgram(this.binaryCache[A].webGLProgram),delete this.binaryCache[A]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=wi((()=>{if(!ZA().get("WEBGL_RENDER_FLOAT32_ENABLED")){const A=ZA().getBool("DEBUG");ZA().set("DEBUG",!1);const g=this.abs(XQ(1e-8)).dataSync()[0];if(ZA().set("DEBUG",A),g>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(A){const g=this.texData.get(A),{shape:I,dtype:t,values:C,texture:e,usage:B,isPacked:i}=g;if(null!=e)return;const Q=null!=this.activeTimers;let o;Q&&(o=bC());let E=g.texShape;if(null==E&&(E=function(A,g=!1){let I=ZA().getNumber("WEBGL_MAX_TEXTURE_SIZE"),t=ZA().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(t===1/0&&ZA().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(t=I/2),g&&(I*=2,t*=2,1===(A=A.map(((g,I)=>I>=A.length-2?$(A[I]):A[I]))).length&&(A=[2,A[0]])),2!==A.length){const g=uA(A);A=g.newShape}let C=QA(A),e=null;A.length<=1&&C<=I?e=[1,C]:2===A.length&&A[0]<=I&&A[1]<=I?e=A:3===A.length&&A[0]*A[1]<=I&&A[2]<=I?e=[A[0]*A[1],A[2]]:3===A.length&&A[0]<=I&&A[1]*A[2]<=I?e=[A[0],A[1]*A[2]]:4===A.length&&A[0]*A[1]*A[2]<=I&&A[3]<=I?e=[A[0]*A[1]*A[2],A[3]]:4===A.length&&A[0]<=I&&A[1]*A[2]*A[3]<=I&&(e=[A[0],A[1]*A[2]*A[3]]);const B=null!=e&&Math.max(...e)>t&&Math.min(...e)<=(g?2:1)&&Math.min(...e)>0;if(null==e||B)if(g){const g=iK(A);let I=2,t=2;A.length&&([I,t]=QK(A)),C=g*(I/2)*(t/2),e=aA(C).map((A=>2*A))}else e=aA(C);return e}(I,i),g.texShape=E),null!=C){const A=oK(I);let e,B=E[1],n=E[0];const s=C instanceof Uint8Array||C instanceof Uint8ClampedArray;!i&&s||([B,n]=OU(E[0],E[1])),e=i?new jK(A,s):new XK(A,s);const a=s?[n,B]:E,r=this.makeTensorInfo(a,t),h=this.texData.get(r.dataId);h.usage=s?TU.PIXELS:TU.UPLOAD,h.texShape=a,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(r.dataId),B,n,C);const c=[[n,B]],l=!0,D=this.runWebGLProgram(e,[r],t,c,l),u=this.texData.get(D.dataId);g.texShape=u.texShape,g.isPacked=u.isPacked,g.usage=u.usage,ZA().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(g.texture=u.texture,g.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo(r),Q&&(this.uploadWaitMs+=bC()-o)}else{const A=this.acquireTexture(E,B,t,i);g.texture=A}}convertAndCacheOnCPU(A,g){const I=this.texData.get(A),{dtype:t}=I;return this.releaseGPUData(A),null!=g&&(I.values=function(A,g){if("float32"===g||"complex64"===g)return A;if("int32"===g||"bool"===g){const I="int32"===g?new Int32Array(A.length):new Uint8Array(A.length);for(let g=0;g<I.length;++g)I[g]=Math.round(A[g]);return I}throw new Error(`Unknown dtype ${g}`)}(g,t)),I.values}acquireTexture(A,g,I,t){if(this.numBytesInGPU+=this.computeBytes(A,I),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const A=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${A} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(A,g,t)}computeBytes(A,g){return A[0]*A[1]*NA(g)}checkCompileCompletion(){for(const[,A]of Object.entries(this.binaryCache))this.checkCompletion_(A)}async checkCompileCompletionAsync(){const A=[];if(this.gpgpu.parallelCompilationExtension){for(const[,g]of Object.entries(this.binaryCache))A.push(this.checkCompletionAsync_(g));return Promise.all(A)}for(const[,g]of Object.entries(this.binaryCache)){const I=new Promise((A=>{try{this.checkCompletion_(g),A(!0)}catch(A){throw A}}));A.push(I)}return Promise.all(A)}async checkCompletionAsync_(A){return this.gpgpu.gl.getProgramParameter(A.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(A):(await lr(),this.checkCompletionAsync_(A))}checkCompletion_(A){if(!1===this.gpgpu.gl.getProgramParameter(A.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(A.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(A.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw _U(A.source,this.gpgpu.gl.getShaderInfoLog(A.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,A]of Object.entries(this.binaryCache)){const{uniformLocations:g,customUniformLocations:I,infLoc:t,nanLoc:C,inShapesLocations:e,inTexShapesLocations:B,outShapeLocation:i,outShapeStridesLocation:Q,outTexShapeLocation:o}=TK(this.gpgpu,A.program,A.webGLProgram);A.uniformLocations=g,A.customUniformLocations=I,A.infLoc=t,A.nanLoc=C,A.inShapesLocations=e,A.inTexShapesLocations=B,A.outShapeLocation=i,A.outShapeStridesLocation=Q,A.outTexShapeLocation=o}}}FY.nextDataId=0;me()&&ki("webgl",(()=>new FY),2);const RY="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class mY{constructor(A,g,I){this.variableNames=["A","B"],this.outputShape=Hi(g,I),this.enableShapeUniforms=VK(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${A}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const kY="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class SY{constructor(A,g,I,t=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Hi(g,I);const C=this.outputShape.length;this.enableShapeUniforms=VK(C);let e="";if(t)if(0===C||1===QA(this.outputShape))e="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(e=`\n          ${LK(C)} coords = getOutputCoords();\n        `,1===C)this.enableShapeUniforms?e+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":e+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const A=gY("coords",C);this.enableShapeUniforms?e+=`\n            bool nextRowOutOfBounds =\n              (${A[C-2]} + 1) >= outShape[${C} - 2];\n            bool nextColOutOfBounds =\n              (${A[C-1]} + 1) >= outShape[${C} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:e+=`\n            bool nextRowOutOfBounds =\n              (${A[C-2]} + 1) >= ${this.outputShape[C-2]};\n            bool nextColOutOfBounds =\n              (${A[C-1]} + 1) >= ${this.outputShape[C-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${A}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${e}\n\n        setOutput(result);\n      }\n    `}}function MY(A){const{inputs:g,backend:I}=A,{x:t}=g;return I.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const UY={kernelName:sI,backendName:"webgl",kernelFunc:MY};function KY(A){const{inputs:g,backend:I}=A,{real:t,imag:C}=g,e=I.makeTensorInfo(t.shape,"complex64"),B=I.texData.get(e.dataId),i=MY({inputs:{x:t},backend:I}),Q=MY({inputs:{x:C},backend:I});return B.complexTensorInfos={real:i,imag:Q},e}const JY={kernelName:Gg,backendName:"webgl",kernelFunc:KY},YY="return (a < 0.) ? b * a : a;",LY="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const xY={kernelName:DI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{alpha:e}=t,B=I.makeTensorInfo([],"float32",LC(e,"float32")),i=ZA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SY(LY,C.shape,B.shape):new mY(YY,C.shape,B.shape),Q=I.runWebGLProgram(i,[C,B],"float32");return I.disposeIntermediateTensorInfo(B),Q}},bY="return (a < 0.) ? b * a : a;",HY="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const qY={kernelName:tt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t,alpha:C}=g,e=ZA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SY(HY,t.shape,C.shape):new mY(bY,t.shape,C.shape);return I.runWebGLProgram(e,[t,C],"float32")}},TY="if (isnan(x)) return x;";function vY({opSnippet:A,packedOpSnippet:g,cpuKernelImpl:I,dtype:t}){return({inputs:C,backend:e})=>{const{x:B}=C,i=e,Q=t||B.dtype;if(i.shouldExecuteOnCPU([B])&&null!=I){const A=i.texData.get(B.dataId),g=I(A.values,Q);return i.makeTensorInfo(B.shape,Q,g)}let o;return o=ZA().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=g?new pY(B.shape,g):new QY(B.shape,A),i.runWebGLProgram(o,[B],Q)}}function VY({opSnippet:A,packedOpSnippet:g,checkOutOfBounds:I=!1,supportsComplex:t=!1,cpuKernelImpl:C,dtype:e}){return({inputs:B,backend:i})=>{const{a:Q,b:o}=B,E=i;if(t&&"complex64"===Q.dtype){const g=E.texData.get(Q.dataId),I=E.texData.get(o.dataId),[t,C]=[[g.complexTensorInfos.real,I.complexTensorInfos.real],[g.complexTensorInfos.imag,I.complexTensorInfos.imag]].map((g=>{const[I,t]=g,C={dataId:I.dataId,dtype:I.dtype,shape:Q.shape},e={dataId:t.dataId,dtype:t.dtype,shape:o.shape},B=new mY(A,Q.shape,o.shape);return E.runWebGLProgram(B,[C,e],ae(I.dtype,t.dtype))})),e=KY({inputs:{real:t,imag:C},backend:E});return E.disposeIntermediateTensorInfo(t),E.disposeIntermediateTensorInfo(C),e}const n=e||ae(Q.dtype,o.dtype);if(("string"===Q.dtype||"string"===o.dtype||E.shouldExecuteOnCPU([Q,o]))&&null!=C){const A=E.texData.get(Q.dataId).values,g=E.texData.get(o.dataId).values,I="string"===Q.dtype?dh(A):A,t="string"===Q.dtype?dh(g):g,[e,B]=C(Q.shape,o.shape,I,t,n),i=E.makeTensorInfo(B,n);return E.texData.get(i.dataId).values=e,i}let s;return s=ZA().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=g?new SY(g,Q.shape,o.shape,I):new mY(A,Q.shape,o.shape),E.runWebGLProgram(s,[Q,o],n)}}function WY(A,g=!1){if("linear"===A)return g?lY:EY;if("relu"===A)return g?uY:aY;if("elu"===A)return g?DY:sY;if("relu6"===A)return g?wY:rY;if("prelu"===A)return g?HY:bY;if("leakyrelu"===A)return g?LY:YY;if("sigmoid"===A)return g?dY:cY;throw new Error(`Activation ${A} has not been implemented for the WebGL backend.`)}class OY{constructor(A,g,I,t=!1,C=!1,e=!1,B=null,i=!1,Q=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=I,this.enableShapeUniforms=VK(this.outputShape.length);const o=t?A[1]:A[2],E=Math.ceil(o/2),n=t?"i * 2, rc.y":"rc.y, i * 2",s=C?"rc.z, i * 2":"i * 2, rc.z",a=t?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],r=C?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let h="",c="";B&&(h=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${B}\n        }`:Q?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${B}\n        }`:`vec4 activation(vec4 x) {\n          ${B}\n        }`,c="result = activation(result);");const l=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),Q&&this.variableNames.push("leakyreluAlpha");let D="rc.x",u="rc.x";A[0]<g[0]?D=`int(min(float(rc.x), ${A[0]-1}.))`:g[0]<A[0]&&(u=`int(min(float(rc.x), ${g[0]-1}.))`),this.userCode=`\n      ${h}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${E}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${E}; i++) {\n          int batchA = ${D};\n          int batchB = ${u};\n          vec4 a = getMatrixA(batchA, ${n});\n          vec4 b = getMatrixB(batchB, ${s});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${a[0]} * ${r[0]});\n          result += (${a[1]} * ${r[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${l}\n\n        ${c}\n\n        setOutput(result);\n      }\n    `}}const ZY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class PY{constructor(A,g,I){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Hi(g,I),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${A}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const XY="return a * b;";function jY(A){const{inputs:g,backend:I}=A,{a:t,b:C}=g,e=ae(t.dtype,C.dtype);if("complex64"===t.dtype){const A=I.texData.get(t.dataId),g=I.texData.get(C.dataId),e=new PY(ZY.REAL,t.shape,C.shape),B=new PY(ZY.IMAG,t.shape,C.shape),i=[{dataId:A.complexTensorInfos.real.dataId,dtype:A.complexTensorInfos.real.dtype,shape:t.shape},{dataId:A.complexTensorInfos.imag.dataId,dtype:A.complexTensorInfos.imag.dtype,shape:t.shape},{dataId:g.complexTensorInfos.real.dataId,dtype:g.complexTensorInfos.real.dtype,shape:C.shape},{dataId:g.complexTensorInfos.imag.dataId,dtype:g.complexTensorInfos.imag.dtype,shape:C.shape}],Q=I.runWebGLProgram(e,i,"float32"),o=I.runWebGLProgram(B,i,"float32"),E=KY({inputs:{real:Q,imag:o},backend:I});return I.disposeIntermediateTensorInfo(Q),I.disposeIntermediateTensorInfo(o),E}if(I.shouldExecuteOnCPU([t,C])){const A=I.texData.get(t.dataId),g=I.texData.get(C.dataId),[B,i]=mJ(t.shape,C.shape,A.values,g.values,e),Q=I.makeTensorInfo(i,e);return I.texData.get(Q.dataId).values=B,Q}let B;return B=ZA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SY(XY,t.shape,C.shape):new mY(XY,t.shape,C.shape),I.runWebGLProgram(B,[t,C],e)}const zY={kernelName:WI,backendName:"webgl",kernelFunc:jY};function _Y(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{shape:e}=t,B=I,i=QA(C.shape),Q=lA(e,i),o=QA(Q);CA(i===o,(()=>`The new shape (${Q}) has ${o} elements and the old shape (${C.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`));const E=B.texData.get(C.dataId);return!E.isPacked||nK(C.shape,Q)||null!==E.texture&&nK(E.shape,Q)?(B.incRef(C.dataId),{dataId:C.dataId,shape:Q,dtype:C.dtype}):function(A,g,I){const t=[iK(A.shape),...QK(A.shape)],C={dtype:A.dtype,shape:t,dataId:A.dataId},e=[iK(g),...QK(g)],B=new tY(e,t),i=[t],Q=I.runWebGLProgram(B,[C],A.dtype,i,!0);return{dataId:Q.dataId,shape:g,dtype:Q.dtype}}(C,Q,B)}const $Y={kernelName:nt,backendName:"webgl",kernelFunc:_Y};class AL{constructor(A,g){this.variableNames=["x"];const{windowSize:I,batchSize:t,inSize:C,outSize:e}=A;this.outputShape=[t,e];const B=4*Math.floor(I/4),i=I%4;let Q="sumValue += dot(values, ones);";if(null!=g){const A=1/g;Q=`sumValue += dot(values * ${nA(A)?A.toPrecision(2):A}, ones);`}let o="";C%I>0&&(o=`\n        if (inIdx < 0 || inIdx >= ${C}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${o}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${I};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${B}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${Q}\n        }\n\n        int inIdx = inOffset + ${B};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${Q}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${Q}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${Q}\n        }\n        setOutput(sumValue);\n      }\n    `}}class gL{constructor(A,g){this.variableNames=["x"];const{windowSize:I,batchSize:t,inSize:C,outSize:e}=A;this.outputShape=[t,e];let B="0.0",i="";"prod"===g?B="1.0":"min"===g?(B="1.0 / 1e-20",i="min"):"max"===g&&(B="-1.0 / 1e-20",i="max");let Q=`${g}(${g}(${g}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===g?Q="sumValue":"prod"===g?Q="prodValue":"all"===g?Q="allValue":"any"===g&&(Q="anyValue");const o=4*Math.floor(I/4),E=I%4;let n=`\n      if (${"sum"===g}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===g}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${"min"===g} || ${"max"===g}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,s="vec4";"all"===g?(B="1.0",n="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",s="bvec4"):"any"===g&&(B="0.0",n="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",s="bvec4");let a="";C%I>0&&(a=`\n        if (inIdx < 0 || inIdx >= ${C}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${B};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${a}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${I};\n\n        vec4 minMaxValue = vec4(${B});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          ${s} values = ${s}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${n}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===E}) {\n          ${s} values = ${s}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${n}\n        } else if (${2===E}) {\n          ${s} values = ${s}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${n}\n        } else if (${3===E}) {\n          ${s} values = ${s}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${n}\n        }\n        setOutput(${Q});\n      }\n    `}}function IL(A,g,I,t){const C=function(A){const g=[];for(;0===g.length||1!==g[g.length-1].outSize;){const I=g.length?g[g.length-1].outSize:A[1],t=Nr(I);g.push({inSize:I,windowSize:t,outSize:Math.ceil(I/t)})}return g}(A.shape);let e=A;for(let B=0;B<C.length;B++){const{inSize:i,windowSize:Q,outSize:o}=C[B];let E,n;E="mean"===I?0===B?new AL({windowSize:Q,inSize:i,batchSize:A.shape[0],outSize:o},i):new AL({windowSize:Q,inSize:i,batchSize:A.shape[0],outSize:o}):new gL({windowSize:Q,inSize:i,batchSize:A.shape[0],outSize:o},I),n=e,e=t.runWebGLProgram(E,[e],g),n.dataId!==A.dataId&&t.disposeIntermediateTensorInfo(n)}return e}class tL{constructor(A,g){this.variableNames=["A"];const I=new Array(A.length);for(let t=0;t<I.length;t++)I[t]=A[g[t]];this.outputShape=I,this.rank=I.length;const t=LK(this.rank),C=function(A){const g=A.length;if(g>6)throw Error(`Transpose for rank ${g} is not yet supported`);const I=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],t=new Array(g);for(let g=0;g<A.length;g++)t[A[g]]=I[g];return t.join()}(g);this.userCode=`\n    void main() {\n      ${t} resRC = getOutputCoords();\n      setOutput(getA(${C}));\n    }\n    `}}class CL{constructor(A,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const I=new Array(A.length);for(let t=0;t<I.length;t++)I[t]=A[g[t]];if(this.outputShape=I,this.rank=I.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const t=LK(this.rank),C=AY("rc",this.rank),e=new Array(this.rank);for(let A=0;A<g.length;A++)e[g[A]]=C[A];const B=`vec2(${e.slice(-2).join()})`,i=`++${C[this.rank-1]} < ${I[this.rank-1]}`,Q=`getChannel(getA(${e.join()}), ${B})`;this.userCode=`\n    void main() {\n      ${t} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${Q};\n      if(${i}) {\n        result[1] = ${Q};\n      }\n      --${C[this.rank-1]};\n      if(++${C[this.rank-2]} < ${I[this.rank-2]}) {\n        result[2] = ${Q};\n        if(${i}) {\n          result[3] = ${Q};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function eL(A,g,I){const t=ZA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CL(A.shape,g):new tL(A.shape,g);return I.runWebGLProgram(t,[A],A.dtype)}function BL(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t;return function(A,g,I,t){const C=g,e=A.shape.length,B=DA(C,A.shape);let i=B;const Q=UE(i,e),o=null!=Q;let E=A;o&&(E=eL(A,Q,t),i=JE(i.length,e)),ME("sum",i,e);const[n,s]=kE(E.shape,i);let a=n;I&&(a=SE(n,B));const r=QA(s),h=_Y({inputs:{x:E},attrs:{shape:[QA(A.shape)/r,r]},backend:t}),c=IL(h,re(A.dtype),"sum",t),l=_Y({inputs:{x:c},attrs:{shape:a},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(c),o&&t.disposeIntermediateTensorInfo(E),l}(C,e,B,I)}const iL={kernelName:St,backendName:"webgl",kernelFunc:BL};function QL(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{perm:e}=t,B=I,i=C.shape.length,Q=new Array(i);for(let A=0;A<Q.length;A++)Q[A]=C.shape[e[A]];let o;if(B.shouldExecuteOnCPU([C])){const A=B.texData.get(C.dataId).values,g=_J(A,C.shape,C.dtype,e,Q);o=B.makeTensorInfo(Q,C.dtype);B.texData.get(o.dataId).values=g}else o=eL(C,e,B);return o}const oL={kernelName:_t,backendName:"webgl",kernelFunc:QL},EL=1e3;function nL({a:A,b:g,transposeA:I,transposeB:t,backend:C,bias:e=null,preluActivationWeights:B=null,leakyreluAlpha:i=0,activation:Q=null}){const o=A.shape.length,E=g.shape.length,n=I?A.shape[o-2]:A.shape[o-1],s=t?g.shape[E-1]:g.shape[E-2],a=I?A.shape[o-1]:A.shape[o-2],r=t?g.shape[E-2]:g.shape[E-1],h=A.shape.slice(0,-2),c=g.shape.slice(0,-2),l=QA(h),D=QA(c),u=Hi(A.shape.slice(0,-2),g.shape.slice(0,-2)).concat([a,r]);CA(n===s,(()=>`Error in matMul: inner shapes (${n}) and (${s}) of Tensors with shapes ${A.shape} and ${g.shape} and transposeA=${I} and transposeB=${t} must match.`));const w=I?[l,n,a]:[l,a,n],d=t?[D,r,s]:[D,s,r],p=_Y({inputs:{x:A},backend:C,attrs:{shape:w}}),y=_Y({inputs:{x:g},backend:C,attrs:{shape:d}}),G=[p,y],f=Math.max(l,D),N=I?p.shape[1]:p.shape[2],F=null!=e,R=null!=B,m="leakyrelu"===Q,k=null!=Q?WY(Q,!0):null;let S;if((1===a||1===r)&&N>EL&&!1===(F||R||m||null!=k)){let A=p,g=y;I&&(A=QL({inputs:{x:p},backend:C,attrs:{perm:[0,2,1]}}),G.push(A)),t&&(g=QL({inputs:{x:y},backend:C,attrs:{perm:[0,2,1]}}),G.push(g));const e=1===r;let B=A;1!==r&&(B=_Y({inputs:{x:A},backend:C,attrs:{shape:[f,N,1]}}),G.push(B));const i=1===r?2:1;let Q=g;e&&(Q=_Y({inputs:{x:g},backend:C,attrs:{shape:[f,1,N]}}),G.push(Q));const o=jY({inputs:{a:B,b:Q},backend:C});S=BL({inputs:{x:o},backend:C,attrs:{axis:i,keepDims:!0}}),G.push(o)}else{const Q=ae(A.dtype,g.dtype),o=new OY(w,d,[f,a,r],I,t,F,k,R,m),E=[p,y];if(null!=e&&E.push(e),R&&E.push(B),m){const A=C.makeTensorInfo([],"float32",LC(i,"float32"));E.push(A),G.push(A)}S=C.runWebGLProgram(o,E,Q)}const M=_Y({inputs:{x:S},backend:C,attrs:{shape:u}});G.push(S);for(const A of G)C.disposeIntermediateTensorInfo(A);return M}const sL={kernelName:iC,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{a:C,b:e,bias:B,preluActivationWeights:i}=g,{transposeA:Q,transposeB:o,activation:E,leakyreluAlpha:n}=t;return nL({a:C,b:e,transposeA:Q,transposeB:o,backend:I,bias:B,preluActivationWeights:i,leakyreluAlpha:n,activation:E})}},aL="return abs(x);";const rL={kernelName:_A,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t}=g;if(I.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const A=I.texData.get(t.dataId),g=bJ(A.values);return I.makeTensorInfo(t.shape,t.dtype,g)}let C;return C=ZA().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new pY(t.shape,aL):new QY(t.shape,aL),I.runWebGLProgram(C,[t],t.dtype)}},hL=vY({opSnippet:oY+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),cL={kernelName:$A,backendName:"webgl",kernelFunc:hL},lL=vY({opSnippet:oY+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),DL={kernelName:Ag,backendName:"webgl",kernelFunc:lL},uL="return a + b;",wL=VY({opSnippet:uL,packedOpSnippet:uL,supportsComplex:!0,cpuKernelImpl:QJ}),dL={kernelName:gg,backendName:"webgl",kernelFunc:wL};class pL{constructor(A,g){this.outputShape=[],this.outputShape=A,this.variableNames=g.map(((A,g)=>`T${g}`));const I=[];this.variableNames.forEach((A=>{I.push(`float v${A} = get${A}AtOutCoords();`)}));const t=this.variableNames.map((A=>`v${A}`)).join(" + ");this.userCode=`\n      void main() {\n        ${I.join("\n        ")}\n\n        float result = ${t};\n        setOutput(result);\n      }\n    `}}class yL{constructor(A,g){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=A,this.variableNames=g.map(((A,g)=>`T${g}`));const I=[];this.variableNames.forEach((A=>{I.push(`vec4 v${A} = get${A}AtOutCoords();`)}));const t=this.variableNames.map((A=>`v${A}`)).join(" + ");this.userCode=`\n      void main() {\n        ${I.join("\n        ")}\n\n        vec4 result = ${t};\n        setOutput(result);\n      }\n    `}}const GL={kernelName:Ig,backendName:"webgl",kernelFunc:function A(g){const{inputs:I,backend:t}=g,C=I;if(1===C.length)return MY({inputs:{x:C[0]},backend:t});if(C.length>ZA().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const g=Math.floor(C.length/2),I=A({inputs:C.slice(0,g),backend:t}),e=A({inputs:C.slice(g),backend:t});return A({inputs:[I,e],backend:t})}const e=C.map((A=>A.dtype)).reduce(((A,g)=>ae(A,g))),B=C.map((A=>A.shape)),i=ZA().getBool("WEBGL_PACK")?new yL(C[0].shape,B):new pL(C[0].shape,B);return t.runWebGLProgram(i,C,e)}};const fL={kernelName:tg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t,i=C.shape.length,Q=DA(e,C.shape);let o=Q;const E=UE(o,i);let n=C;null!=E&&(n=QL({inputs:{x:C},backend:I,attrs:{perm:E}}),o=JE(o.length,i)),ME("all",o,i);const[s,a]=kE(n.shape,o),r=_Y({inputs:{x:n},backend:I,attrs:{shape:[-1,QA(a)]}}),h=IL(r,r.dtype,"all",I);let c;if(B){c=_Y({inputs:{x:h},backend:I,attrs:{shape:SE(s,Q)}})}else c=_Y({inputs:{x:h},backend:I,attrs:{shape:s}});return I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(h),null!=E&&I.disposeIntermediateTensorInfo(n),c}};const NL={kernelName:Cg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t,i=C.shape.length,Q=DA(e,C.shape);let o=Q;const E=UE(o,i);let n=C;null!=E&&(n=QL({inputs:{x:C},backend:I,attrs:{perm:E}}),o=JE(o.length,i)),ME("any",o,i);const[s,a]=kE(n.shape,o),r=_Y({inputs:{x:n},backend:I,attrs:{shape:[-1,QA(a)]}}),h=IL(r,r.dtype,"any",I);let c;if(B){c=_Y({inputs:{x:h},backend:I,attrs:{shape:SE(s,Q)}})}else c=_Y({inputs:{x:h},backend:I,attrs:{shape:s}});return I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(h),null!=E&&I.disposeIntermediateTensorInfo(n),c}};class FL{constructor(A,g,I){this.variableNames=["A"];const{windowSize:t,batchSize:C,outSize:e}=A;I||this.variableNames.push("bestIndicesA"),this.outputShape=[C,e];const B="max"===g?">":"<",i=I?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${t};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${t}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${B} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class RL{constructor(A,g,I,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,CA(A.length>2,(()=>`Packed arg${I.charAt(0).toUpperCase()+I.slice(1)} supports only inputs with rank above 2.`));const C=A[A.length-1],e=Math.ceil(C/g);this.outputShape=A.slice(0,-1),e>1&&this.outputShape.push(e),t||this.variableNames.push("bestIndicesA");const B=this.outputShape,i=B.length,Q=LK(i),o=gY("coords",i);let E,n;if(1===e){n=i+1;const A=LK(n);E=`\n        ${A} sourceLocR = ${A}(${o.join()}, 0);\n        ++${o[i-1]};\n        ${A} sourceLocG = ${A}(${o.join()}, 0);\n        ++${o[i-2]};\n        ${A} sourceLocA = ${A}(${o.join()}, 0);\n        --${o[i-1]};\n        ${A} sourceLocB = ${A}(${o.join()}, 0);\n        --${o[i-2]};`}else n=i,E=`\n        ${Q} sourceLocR = coords;\n        ++${o[i-1]};\n        ${Q} sourceLocG = coords;\n        ++${o[i-2]};\n        ${Q} sourceLocA = coords;\n        --${o[i-1]};\n        ${Q} sourceLocB = coords;\n        --${o[i-2]};`;const s=["x","y","z","w","u","v"].slice(0,n),a="."+s[n-1],r=s.map((A=>"int "+A)),h=gY("sourceLocR",n-1).concat("inIdx.r"),c=gY("sourceLocG",n-1).concat("inIdx.g"),l=gY("sourceLocB",n-1).concat("inIdx.b"),D=gY("sourceLocA",n-1).concat("inIdx.a"),u="max"===I?"greaterThan":"lessThan",w=t?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${h.join()}),\n                             getBestIndicesAChannel(${c.join()}),\n                             getBestIndicesAChannel(${l.join()}),\n                             getBestIndicesAChannel(${D.join()})));`,d=`vec4(\n            getAChannel(${h.join()}),\n            hasNextCol ? getAChannel(${c.join()}) : 0.,\n            hasNextRow ? getAChannel(${l.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${D.join()}) : 0.)`,p=t?"":`\n      float getBestIndicesAChannel(${r.join()}) {\n        return getChannel(getBestIndicesA(${s.join()}),\n                                          vec2(${s.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${r.join()}) {\n        return getChannel(getA(${s.join()}),\n                               vec2(${s.slice(-2).join()}));\n      }\n      ${p}\n      void main() {\n        ${Q} coords = getOutputCoords();\n        bool hasNextCol = ${o[i-1]} < ${B[i-1]-1};\n        bool hasNextRow = ${o[i-2]} < ${B[i-2]-1};\n        ${E}\n        ivec4 srcIdx = ivec4(sourceLocR${a}, sourceLocG${a},\n          sourceLocB${a}, sourceLocA${a}) * ${g};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${d};\n\n        for (int i = 0; i < ${g}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${d};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${u}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function mL(A,g,I,t=null){let C=g.shape[0],e=g.shape[1];null!=t&&(C=t.shape[0],e=t.shape[1]);const B=Nr(e),i={windowSize:B,inSize:e,batchSize:C,outSize:Math.ceil(e/B)},Q=new FL(i,I,null==t),o=[g];null!=t&&o.push(t);const E=A.runWebGLProgram(Q,o,"int32");if(1===E.shape[1])return E;const n=mL(A,g,I,E);return A.disposeIntermediateTensorInfo(E),n}function kL(A,g,I,t=null){const C=null!=t?t.shape:g.shape,e=Nr(C[C.length-1]),B=new RL(C,e,I,null==t),i=null==t?[g]:[g,t],Q=A.runWebGLProgram(B,i,"int32");if(Q.shape.length===g.shape.length){const t=kL(A,g,I,Q);return A.disposeIntermediateTensorInfo(Q),t}return Q}function SL(A,g,I,t){const C=[I];if(ME("arg"+t.charAt(0).toUpperCase()+t.slice(1),C,g.shape.length),!ZA().getBool("WEBGL_PACK_REDUCE")||g.shape.length<=2){const I=[],e=A.texData.get(g.dataId);let B=g;null!==e&&e.isPacked&&(B=A.unpackTensor(g),I.push(B));const[i,Q]=kE(B.shape,C),o=QA(Q),E=_Y({inputs:{x:B},backend:A,attrs:{shape:[-1,o]}});I.push(E);const n=mL(A,E,t);I.push(n);const s=_Y({inputs:{x:n},backend:A,attrs:{shape:i}});return I.forEach((g=>A.disposeIntermediateTensorInfo(g))),s}return kL(A,g,t)}const ML={kernelName:eg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e}=t;let B=DA(e,C.shape);const i=UE(B,C.shape.length);let Q=C;const o=[];null!=i&&(Q=QL({inputs:{x:C},backend:I,attrs:{perm:i}}),o.push(Q),B=JE(B.length,Q.shape.length)),ME("argMax",[B[0]],Q.shape.length);const E=SL(I,Q,B[0],"max");return o.forEach((A=>I.disposeIntermediateTensorInfo(A))),E}};const UL={kernelName:Bg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e}=t;let B=DA(e,C.shape);const i=UE(B,C.shape.length);let Q=C;const o=[];null!=i&&(Q=QL({inputs:{x:C},backend:I,attrs:{perm:i}}),o.push(Q),B=JE(B.length,Q.shape.length)),ME("argMin",[B[0]],Q.shape.length);const E=SL(I,Q,B[0],"min");return o.forEach((A=>I.disposeIntermediateTensorInfo(A))),E}},KL=vY({opSnippet:oY+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),JL={kernelName:ig,backendName:"webgl",kernelFunc:KL},YL=vY({opSnippet:oY+"return log(x + sqrt(x * x + 1.0));"}),LL={kernelName:Qg,backendName:"webgl",kernelFunc:YL},xL=vY({opSnippet:oY+"\n  return atan(x);\n"}),bL={kernelName:og,backendName:"webgl",kernelFunc:xL},HL=VY({opSnippet:RY+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+kY+"\n  return result;\n"}),qL={kernelName:ng,backendName:"webgl",kernelFunc:HL},TL=vY({opSnippet:oY+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),vL={kernelName:Eg,backendName:"webgl",kernelFunc:TL};class VL{constructor(A,g,I,t=!1,C=!1){if(this.variableNames=["x"],"avg"===g&&I)throw new Error("Cannot compute positions for average pool.");const e=A.filterWidth,B=A.strideHeight,i=A.strideWidth,Q=A.dilationHeight,o=A.dilationWidth,E=A.effectiveFilterHeight,n=A.effectiveFilterWidth,s=A.padInfo.top,a=A.padInfo.left;this.outputShape=A.outShape;const r="avg"===g,h=`((batch  * ${A.inHeight} + xR) * ${A.inWidth} + xC) * ${A.inChannels} + d`,c=`(xR * ${A.inWidth} + xC) * ${A.inChannels} + d`;let l="0.0";if(r||(l="-1.0 / 1e-20"),I){const g=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${B}, ${i});\n        const ivec2 pads = ivec2(${s}, ${a});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${E};\n              wR += ${Q}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${A.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${n};\n                wC += ${o}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${A.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${g} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${t?C?h:c:`wR * ${n} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let D=`${g}(${g}(${g}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===g&&(D="avgValue / count");const u=4*Math.floor(e/4),w=e%4,d=`\n      if (${r}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${B}, ${i});\n      const ivec2 pads = ivec2(${s}, ${a});\n      const float initializationValue = ${l};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${A.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${l});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${E};\n            wR += ${Q}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${A.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${u}; wC += 4) {\n            int xC = xCCorner + wC * ${o};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${o}, d),\n              getValue(batch, xR, xC + 2 * ${o}, d),\n              getValue(batch, xR, xC + 3 * ${o}, d)\n            );\n\n            ${d}\n          }\n\n          int xC = xCCorner + ${u};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${d}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${o}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${d}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${o}, d),\n              getValue(batch, xR, xC + 2 * ${o}, d),\n              initializationValue\n            );\n\n            ${d}\n          }\n        }\n        setOutput(${D});\n      }\n    `}}class WL{constructor(A,g,I,t=!1,C=!1){if(this.variableNames=["x"],"avg"===g&&I)throw new Error("Cannot compute positions for average pool.");const e=A.filterWidth,B=A.strideDepth,i=A.strideHeight,Q=A.strideWidth,o=A.dilationDepth,E=A.dilationHeight,n=A.dilationWidth,s=A.effectiveFilterDepth,a=A.effectiveFilterHeight,r=A.effectiveFilterWidth,h=A.padInfo.front,c=A.padInfo.top,l=A.padInfo.left;this.outputShape=A.outShape;const D="avg"===g;let u="0.0";if(D||(u="-1.0 / 1e-20"),I){const g=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${B}, ${i}, ${Q});\n        const ivec3 pads = ivec3(${h}, ${c}, ${l});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${s};\n              wD += ${o}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${A.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${a};\n                wR += ${E}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${A.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${r};\n                  wC += ${n}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${A.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${g} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${t?C?`(((batch * ${A.inDepth} + xD) * ${A.inHeight} + xR) * ${A.inWidth} + xC) * ${A.inChannels} + ch`:`((xD * ${A.inHeight} + xR) * ${A.inWidth} + xC) * ${A.inChannels} + ch`:`wD * ${a} * ${r} +\n                      wR * ${r} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${g}(${g}(${g}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===g&&(w="avgValue / count");const d=4*Math.floor(e/4),p=e%4,y=`\n      if (${D}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${B}, ${i}, ${Q});\n      const ivec3 pads = ivec3(${h}, ${c}, ${l});\n      const float initializationValue = ${u};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${A.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${u});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${s};\n            wD += ${o}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${A.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${a};\n            wR += ${E}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${A.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC += 4) {\n              int xC = xCCorner + wC * ${n};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${n}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${n}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${n}, ch)\n              );\n\n              ${y}\n            }\n\n            int xC = xCCorner + ${d};\n            if (${1===p}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${y}\n            } else if (${2===p}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${n}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${y}\n            } else if (${3===p}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${n}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${n}, ch),\n                initializationValue\n              );\n\n              ${y}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `}}const OL={kernelName:sg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g;DK(C,"avgPool");const{filterSize:e,strides:B,pad:i,dimRoundingMode:Q}=t;CA(Ko(B,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${B} and dilations '1'`));const o=Go(C.shape,e,B,1,i,Q);if(1===o.filterWidth&&1===o.filterHeight&&EA(o.inShape,o.outShape))return MY({inputs:{x:C},backend:I});const E=new VL(o,"avg",!1);return I.runWebGLProgram(E,[C],"float32")}};const ZL={kernelName:rg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{filterSize:e,strides:B,pad:i,dimRoundingMode:Q,dataFormat:o}=t,E=fo(C.shape,e,B,[1,1,1],i,Q,o),n=new WL(E,"avg",!1);return I.runWebGLProgram(n,[C],"float32")}};class PL{constructor(A){this.variableNames=["dy"],this.outputShape=A.inShape;const g=A.filterHeight,I=A.filterWidth,t=A.strideHeight,C=A.strideWidth,e=A.dilationHeight,B=A.dilationWidth,i=A.effectiveFilterHeight,Q=A.effectiveFilterWidth,o=i-1-A.padInfo.top,E=Q-1-A.padInfo.left,n=1/(g*I);this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${E});\n      const float avgMultiplier = float(${n});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${e}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${A.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${Q};\n            wC+= ${B}) {\n            float dyC = float(dyCCorner + wC) / ${C}.0;\n\n            if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class XL{constructor(A){this.variableNames=["dy"],this.outputShape=A.inShape;const g=A.filterDepth,I=A.filterHeight,t=A.filterWidth,C=A.strideDepth,e=A.strideHeight,B=A.strideWidth,i=A.dilationDepth,Q=A.dilationHeight,o=A.dilationWidth,E=A.effectiveFilterDepth,n=A.effectiveFilterHeight,s=A.effectiveFilterWidth,a=E-1-A.padInfo.front,r=n-1-A.padInfo.top,h=s-1-A.padInfo.left,c=1/(g*I*t);this.userCode=`\n      const ivec3 pads = ivec3(${a}, ${r}, ${h});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${E};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${C}.0;\n\n          if (dyD < 0.0 || dyD >= ${A.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${Q}) {\n            float dyR = float(dyRCorner + wR) / ${e}.0;\n\n            if (dyR < 0.0 || dyR >= ${A.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${B}.0;\n\n              if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const jL={kernelName:hg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e}=g,B=e,{filterSize:i,strides:Q,pad:o,dimRoundingMode:E}=t,n=fo(B.shape,i,Q,[1,1,1],o,E),s=new XL(n);return I.runWebGLProgram(s,[C],B.dtype)}};const zL={kernelName:ag,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e}=g,B=e;DK([C,e],"avgPoolGrad");const{filterSize:i,strides:Q,pad:o}=t,E=Go(B.shape,i,Q,1,o),n=new PL(E);return I.runWebGLProgram(n,[C],B.dtype)}};const _L={kernelName:cg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{a:C,b:e}=g,{transposeA:B,transposeB:i}=t;return nL({a:C,b:e,transposeA:B,transposeB:i,backend:I})}};class $L{constructor(A,g,I,t,C,e){this.outputShape=[],this.variableNames=["x","mean","variance"],Hi(A,g),Hi(A,I);let B="0.0";null!=t&&(Hi(A,t),this.variableNames.push("offset"),B="getOffsetAtOutCoords()");let i="1.0";null!=C&&(Hi(A,C),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=A,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${B};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${e}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Ax{constructor(A,g,I,t,C,e){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Hi(A,g),Hi(A,I);let B="vec4(0.0)";null!=t&&(Hi(A,t),this.variableNames.push("offset"),B="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=C&&(Hi(A,C),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=A,this.userCode=`\n      void main() {\n        vec4 offset = ${B};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${e}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const gx={kernelName:iI,backendName:"webgl",kernelFunc:({inputs:A,backend:g,attrs:I})=>{const{x:t,mean:C,variance:e,offset:B,scale:i}=A;CA(C.shape.length===e.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),CA(null==B||C.shape.length===B.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),CA(null==i||C.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:Q}=I;null==Q&&(Q=.001);const o=[t,C,e];let E=null;null!=B&&(E=B.shape,o.push(B));let n=null;null!=i&&(n=i.shape,o.push(i));const s=ZA().getBool("WEBGL_PACK_NORMALIZATION")?new Ax(t.shape,C.shape,e.shape,E,n,Q):new $L(t.shape,C.shape,e.shape,E,n,Q);return g.runWebGLProgram(s,o,o[0].dtype)}};class Ix{constructor(A){this.variableNames=["source"],this.outputShape=A,this.rank=A.length;const g=LK(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const I=function(A){if(1===A)return"sourceLoc";if(A<=6)return tx.slice(0,A).map((A=>"sourceLoc."+A)).join(",");throw Error(`Slicing for rank ${A} is not yet supported`)}(this.rank);let t;t=`\n        ${g} sourceLoc;\n        ${g} coords = getOutputCoords();\n        ${A.map(((A,g)=>`sourceLoc.${tx[g]} = start[${g}] + coords.${tx[g]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${t}\n        setOutput(getSource(${I}));\n      }\n    `}}const tx=["x","y","z","w","u","v"];class Cx{constructor(A){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=A,this.rank=A.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const g=LK(this.rank),I=gY("coords",this.rank),t=gY("sourceLoc",this.rank),C=1===this.rank?"sourceLoc":`vec2(${t.slice(-2).join()})`,e=`getChannel(getSource(${t.join()}), ${C})`,B=`\n      result.x = ${e};\n      if (++${I[this.rank-1]} < ${A[this.rank-1]}) {\n        ++${t[this.rank-1]};\n        result.y = ${e};\n        --${t[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${I[this.rank-1]};\n      if (++${I[this.rank-2]} < ${A[this.rank-2]}) {\n        ++${t[this.rank-2]};\n        result.z = ${e};\n        if (++${I[this.rank-1]} < ${A[this.rank-1]}) {\n          ++${t[this.rank-1]};\n          result.w = ${e};\n        }\n      }\n    `,Q=this.rank<=4?`sourceLoc = coords +\n            ${g}(${A.map(((A,g)=>`start[${g}]`)).join()});`:A.map(((A,g)=>`${t[g]} = ${I[g]} + start[${g}];`)).join("\n");this.userCode=`\n      void main() {\n        ${g} coords = getOutputCoords();\n        ${g} sourceLoc;\n        ${Q}\n        vec4 result = vec4(0.);\n        ${B}\n        ${i}\n        setOutput(result);\n      }\n    `}}function ex(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{begin:e,size:B}=t,[i,Q]=rQ(C,e,B);if(AQ(C,i,Q),0===QA(Q))return I.makeTensorInfo(Q,C.dtype,[]);if(I.shouldExecuteOnCPU([C])||"string"===C.dtype){const A=I.texData.get(C.dataId),g=HJ(A.values,i,Q,C.shape,C.dtype);return I.makeTensorInfo(Q,C.dtype,g)}const{isPacked:o}=I.texData.get(C.dataId),E=sQ(C.shape,i,Q);if(o||!E){const A=ZA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Cx(Q):new Ix(Q),g=[i];return I.runWebGLProgram(A,[C],C.dtype,g)}return I.uploadToGPU(C.dataId),function(A,g,I,t){const C=t.texData.get(A.dataId),e=t.makeTensorInfo(I,A.dtype),B=t.texData.get(e.dataId);Object.assign(B,C),B.refCount=1,B.shape=I,B.dtype=A.dtype;let i=aQ(g,KA(A.shape));C.slice&&(i+=C.slice.flatOffset),B.slice={flatOffset:i,origDataId:C.slice&&C.slice.origDataId||A.dataId};const Q=t.dataRefCount.get(B.slice.origDataId)||1;return t.dataRefCount.set(B.slice.origDataId,Q+1),e}(C,i,Q,I)}const Bx={kernelName:Gt,backendName:"webgl",kernelFunc:ex},ix={kernelName:lg,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{blockShape:e,crops:B}=t;CA(C.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=e.reduce(((A,g)=>A*g)),Q=Rr(C.shape,e,i),o=mr(Q.length,e.length),E=kr(C.shape,e,i),n=Sr(B,e.length),s=Mr(E,B,e.length),a=[],r=_Y({inputs:{x:C},backend:I,attrs:{shape:Q}}),h=QL({inputs:{x:r},backend:I,attrs:{perm:o}}),c=_Y({inputs:{x:h},backend:I,attrs:{shape:E}}),l=ex({inputs:{x:c},backend:I,attrs:{begin:n,size:s}});return a.push(r),a.push(h),a.push(c),a.forEach((A=>I.disposeIntermediateTensorInfo(A))),l}};const Qx={kernelName:Dg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,weights:e}=g,{size:B}=t,i=I.readSync(C.dataId),Q=I.readSync(e.dataId),o=oJ(i,Q,e.dtype,e.shape,B);return I.makeTensorInfo([B],e.dtype,o)}};const ox={kernelName:wg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{s0:t,s1:C}=g,e=I.readSync(t.dataId),B=I.readSync(C.dataId),i=Hi(Array.from(e),Array.from(B));return I.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},Ex=VY({opSnippet:"return float(a != b);",cpuKernelImpl:SJ,dtype:"bool"}),nx={kernelName:ZI,backendName:"webgl",kernelFunc:Ex};function sx(A){const{inputs:g,backend:I}=A,{input:t}=g;return MY({inputs:{x:I.texData.get(t.dataId).complexTensorInfos.real},backend:I})}const ax={kernelName:Qt,backendName:"webgl",kernelFunc:sx},rx="return float(int(x));";const hx={kernelName:dg,backendName:"webgl",kernelFunc:function A(g){const{inputs:I,backend:t,attrs:C}=g,{x:e}=I,{dtype:B}=C;if("complex64"===B){if("complex64"===e.dtype)return MY({inputs:{x:e},backend:t});const g=yn(e.shape),I=A({inputs:{x:e},backend:t,attrs:{dtype:"float32"}}),C=KY({inputs:{real:I,imag:g},backend:t});return g.dispose(),t.disposeIntermediateTensorInfo(I),C}if("complex64"===e.dtype){const g=sx({inputs:{input:e},backend:t}),I=A({inputs:{x:g},backend:t,attrs:{dtype:B}});return t.disposeIntermediateTensorInfo(g),I}if(!GA(e.dtype,B)){const A=MY({inputs:{x:e},backend:t});return{dataId:A.dataId,shape:A.shape,dtype:B}}if(t.shouldExecuteOnCPU([e])){const A=t.texData.get(e.dataId).values,[g,I,C]=nJ(A,e.shape,e.dtype,B);return t.makeTensorInfo(g,I,C)}if("int32"===B)return function(A,g){const I=new QY(A.shape,rx),t=g.runWebGLProgram(I,[A],"int32");return{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}(e,t);if("bool"===B){const A=t.makeTensorInfo([],"bool",wA("bool",1)),g=Ex({inputs:{a:e,b:A},backend:t});return t.disposeIntermediateTensorInfo(A),g}throw new Error(`Error in Cast: failed to cast ${e.dtype} to ${B}`)}},cx="return ceil(x);",lx=vY({opSnippet:cx,packedOpSnippet:cx,cpuKernelImpl:sJ}),Dx={kernelName:pg,backendName:"webgl",kernelFunc:lx};class ux{constructor(A){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=A,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class wx{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=A,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const dx={kernelName:yg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{clipValueMin:e,clipValueMax:B}=t;let i;i=ZA().getBool("WEBGL_PACK_CLIP")?new wx(C.shape):new ux(C.shape);const Q=[[e],[B]];return I.runWebGLProgram(i,[C],C.dtype,Q)}};class px{constructor(A){this.variableNames=["real","imag"],this.outputShape=A,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function yx(A,g){return{dataId:g.dataId,dtype:g.dtype,shape:A.shape}}const Gx={kernelName:fg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t}=g,C=I.texData.get(t.dataId),e=new px(t.shape),B=[yx(t,C.complexTensorInfos.real),yx(t,C.complexTensorInfos.imag)];return I.runWebGLProgram(e,B,B[0].dtype)}};class fx{constructor(A){this.outputShape=[],this.outputShape=ur(A,1),this.variableNames=A.map(((A,g)=>`T${g}`));const g=new Array(A.length-1);g[0]=A[0][1];for(let I=1;I<g.length;I++)g[I]=g[I-1]+A[I][1];const I=[`if (yC < ${g[0]}) setOutput(getT0(yR, yC));`];for(let A=1;A<g.length;A++){const t=g[A-1];I.push(`else if (yC < ${g[A]}) setOutput(getT${A}(yR, yC-${t}));`)}const t=g.length,C=g[g.length-1];I.push(`else setOutput(getT${t}(yR, yC-${C}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${I.join("\n        ")}\n      }\n    `}}class Nx{constructor(A,g){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ur(A,g);const I=this.outputShape,t=I.length,C=LK(t),e=gY("coords",t),B=["x","y","z","w","u","v"].slice(0,t);this.variableNames=A.map(((A,g)=>`T${g}`));const i=new Array(A.length-1);i[0]=A[0][g];for(let I=1;I<i.length;I++)i[I]=i[I-1]+A[I][g];const Q=B[g],o=B.slice(-2),E=B.join();let n=`if (${Q} < ${i[0]}) {\n        return getChannel(\n            getT0(${E}), vec2(${o.join()}));\n        }`;for(let A=1;A<i.length;A++){const g=i[A-1];n+=`\n        if (${Q} < ${i[A]}  && ${Q} >= ${i[A-1]}) {\n          return getChannel(\n            getT${A}(${Fx(B,Q,g)}),\n            vec2(${Fx(o,Q,g)}));\n        }`}const s=i.length,a=i[i.length-1];n+=`\n        return getChannel(\n          getT${s}(${Fx(B,Q,a)}),\n          vec2(${Fx(o,Q,a)}));`,this.userCode=`\n      float getValue(${B.map((A=>"int "+A))}) {\n        ${n}\n      }\n\n      void main() {\n        ${C} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${e}), 0., 0., 0.);\n\n        ${e[t-1]} = ${e[t-1]} + 1;\n        if (${e[t-1]} < ${I[t-1]}) {\n          result.g = getValue(${e});\n        }\n\n        ${e[t-2]} = ${e[t-2]} + 1;\n        if (${e[t-2]} < ${I[t-2]}) {\n          result.a = getValue(${e});\n        }\n\n        ${e[t-1]} = ${e[t-1]} - 1;\n        if (${e[t-2]} < ${I[t-2]} &&\n            ${e[t-1]} < ${I[t-1]}) {\n          result.b = getValue(${e});\n        }\n        setOutput(result);\n      }\n    `}}function Fx(A,g,I){const t=A.indexOf(g);return A.map(((A,g)=>g===t?`${A} - ${I}`:A)).join()}function Rx(A){const{inputs:g,backend:I}=A,{input:t}=g;return MY({inputs:{x:I.texData.get(t.dataId).complexTensorInfos.imag},backend:I})}const mx={kernelName:rI,backendName:"webgl",kernelFunc:Rx};function kx(A,g,I){const t=A[0].dtype;if("complex64"===t){const t=A.map((A=>sx({inputs:{input:A},backend:I}))),C=A.map((A=>Rx({inputs:{input:A},backend:I}))),e=kx(t,g,I),B=kx(C,g,I),i=KY({inputs:{real:e,imag:B},backend:I});return t.forEach((A=>I.disposeIntermediateTensorInfo(A))),C.forEach((A=>I.disposeIntermediateTensorInfo(A))),I.disposeIntermediateTensorInfo(e),I.disposeIntermediateTensorInfo(B),i}let C=I.shouldExecuteOnCPU(A);if("string"===t&&(C=!0),C){const C=A.map((A=>{const t=QA(A.shape.slice(g));return _Y({inputs:{x:A},backend:I,attrs:{shape:[-1,t]}})})),e=C.map((A=>({vals:I.readSync(A.dataId),shape:A.shape}))),B=ur(C.map((A=>A.shape)),1),i=1===C[0].shape[0],Q=aJ(e,B,t,i),o=ur(A.map((A=>A.shape)),g),E=I.makeTensorInfo(o,t,Q);return C.forEach((A=>I.disposeIntermediateTensorInfo(A))),E}const e=ZA().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(A.length>e){const t=[];for(let C=0;C<A.length;C+=e){const B=A.slice(C,C+e);t.push(kx(B,g,I))}const C=kx(t,g,I);for(const A of t)I.disposeIntermediateTensorInfo(A);return C}if(ZA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&A[0].shape.length>1){const C=new Nx(A.map((A=>A.shape)),g);return I.runWebGLProgram(C,A,t)}const{tensors2D:B,outShape:i}=function(A,g,I){const t=ur(A.map((A=>A.shape)),g),C=A.map((A=>_Y({inputs:{x:A},attrs:{shape:[-1,QA(A.shape.slice(g))]},backend:I})));return{tensors2D:C,outShape:t}}(A,g,I),Q=new fx(B.map((A=>A.shape))),o=I.runWebGLProgram(Q,B,t);B.forEach((A=>I.disposeIntermediateTensorInfo(A)));const E=_Y({inputs:{x:o},attrs:{shape:i},backend:I});return I.disposeIntermediateTensorInfo(o),E}function Sx(A){const{inputs:g,backend:I,attrs:t}=A,{axis:C}=t,e=DA(C,g[0].shape)[0];Dr(g.map((A=>A.shape)),e);const B=ur(g.map((A=>A.shape)),e);if(0===QA(B))return I.makeTensorInfo(B,g[0].dtype,[]);const i=g.filter((A=>QA(A.shape)>0));return 1===i.length?MY({inputs:{x:i[0]},backend:I}):kx(i,e,I)}const Mx={kernelName:Ng,backendName:"webgl",kernelFunc:Sx};class Ux{constructor(A,g=!1,I=null,t=!1,C=!1){this.variableNames=["x","W"],this.outputShape=A.outShape;const e=A.padInfo.top,B=A.padInfo.left,i=A.strideHeight,Q=A.strideWidth,o=A.dilationHeight,E=A.dilationWidth,n=A.filterHeight,s=A.filterWidth,a=4*Math.floor(A.inChannels/4),r=A.inChannels%4,h="channelsLast"===A.dataFormat,c=h?1:2,l=h?2:3,D=h?3:1;let u="",w="";I&&(u=t?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${I}\n        }`:C?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${I}\n        }`:`\n          float activation(float x) {\n            ${I}\n          }\n        `,w="result = activation(result);");const d=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),t&&this.variableNames.push("preluActivationWeights"),C&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      const ivec2 strides = ivec2(${i}, ${Q});\n      const ivec2 pads = ivec2(${e}, ${B});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${D}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${c}], coords[${l}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${n}; wR++) {\n          int xR = xRCorner + wR * ${o};\n\n          if (xR < 0 || xR >= ${A.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int xC = xCCorner + wC * ${E};\n\n            if (xC < 0 || xC >= ${A.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${a}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${h}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===r}) {\n\n              if (${h}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${a}) *\n                    getW(wR, wC, ${a}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${a}, xR, xC) *\n                    getW(wR, wC, ${a}, d2);\n              }\n\n            } else if (${2===r}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${a}, d2),\n                getW(wR, wC, ${a} + 1, d2)\n              );\n\n              if (${h}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${a}),\n                  getX(batch, xR, xC, ${a} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${a}, xR, xC),\n                  getX(batch, ${a} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===r}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${a}, d2),\n                getW(wR, wC, ${a} + 1, d2),\n                getW(wR, wC, ${a} + 2, d2)\n              );\n\n              if (${h}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${a}),\n                  getX(batch, xR, xC, ${a} + 1),\n                  getX(batch, xR, xC, ${a} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${a}, xR, xC),\n                  getX(batch, ${a} + 1, xR, xC),\n                  getX(batch, ${a} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${w}\n        setOutput(result);\n      }\n    `}}class Kx{constructor(A){this.variableNames=["x","W"],this.outputShape=A.outShape;const g=A.padInfo.front,I=A.padInfo.top,t=A.padInfo.left,C=A.strideDepth,e=A.strideHeight,B=A.strideWidth,i=A.dilationDepth,Q=A.dilationHeight,o=A.dilationWidth,E=A.filterDepth,n=A.filterHeight,s=A.filterWidth,a=4*Math.floor(A.inChannels/4),r=A.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${C}, ${e}, ${B});\n      const ivec3 pads = ivec3(${g}, ${I}, ${t});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${E}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${A.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            int xR = xRCorner + wR * ${Q};\n\n            if (xR < 0 || xR >= ${A.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              int xC = xCCorner + wC * ${o};\n\n              if (xC < 0 || xC >= ${A.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${a}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===r}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${a}) *\n                  getW(wF, wR, wC, ${a}, d2);\n              } else if (${2===r}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${a}),\n                  getX(batch, xF, xR, xC, ${a} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${a}, d2),\n                  getW(wF, wR, wC, ${a} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===r}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${a}),\n                  getX(batch, xF, xR, xC, ${a} + 1),\n                  getX(batch, xF, xR, xC, ${a} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${a}, d2),\n                  getW(wF, wR, wC, ${a} + 1, d2),\n                  getW(wF, wR, wC, ${a} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Jx{constructor(A,g=!1,I=null,t=!1,C=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=A.outShape,this.enableShapeUniforms=VK(this.outputShape.length);const e=A.padInfo.left,B=A.strideWidth,i=A.dilationWidth,Q=A.filterHeight,o=A.filterWidth,E=o;let n="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let A=0;A<o;A++)n+=`\n           vec4 xTexelC${2*A};\n           int xTexelC${2*A}Ready;\n           vec4 xTexelC${2*A+1};\n           int xTexelC${2*A+1}Ready;\n           vec4 xC${A};`;n+=`\n     for (int r = 0; r < ${Q}; r++) {\n      for (int d1 = 0; d1 < ${A.inChannels}; d1 += 2) {\n       `;for(let A=0;A<o;A++)n+=`\n           xTexelC${2*A} = vec4(0.0);\n           xTexelC${2*A}Ready = 0;\n           xTexelC${2*A+1} = vec4(0.0);\n           xTexelC${2*A+1}Ready = 0;\n           xC${A} = vec4(0.0);`;n+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(E+1)/2;g++){const I=2*g;if(n+=`\n           xC = xCCorner + ${I*i};\n           `,1===B){if(I<o&&(e%2==1?(n+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I}Ready == 0) {\n                   xTexelC${I} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${I}.zw = vec2(0.0);\n                   }\n                   xTexelC${I}Ready = 1;\n                 }\n               `,n+=1===i&&I>0?`\n                 xC${I} = vec4(xTexelC${I-2}.zw, xTexelC${I}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${I} = vec4(previous.zw, xTexelC${I}.xy);\n                   } else {\n                     xC${I} = vec4(0.0, 0.0, xTexelC${I}.xy);\n                   }\n                   `):n+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${I}Ready == 0) {\n                   xTexelC${I} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${I}.zw = vec2(0.0);\n                   }\n                   xTexelC${I}Ready = 1;\n                 }\n\n                 xC${I} = xTexelC${I};\n                 `,I+1<o)){const A=e%2==0?$(i):i;i%2==0&&e%2==1||i%2!=0&&e%2!=1?(n+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${A};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I+1}Ready == 0) {\n                     xTexelC${I+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${I+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${I+1}Ready = 1;\n                   }\n                   `,n+=i>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${I+1} = vec4(previous.zw, xTexelC${I+1}.xy);\n                     } else {\n                      xC${I+1} = vec4(0.0, 0.0, xTexelC${I+1}.xy);\n                     }\n                     `:`\n                     xC${I+1} = vec4(xTexelC${I}.zw, xTexelC${I+1}.xy);\n                     `):n+=1===A?`\n                     xC${I+1} = xTexelC${I};\n                     `:`\n                     xCOffset = xC + ${A};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I+1}Ready == 0) {\n                       xTexelC${I+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${I+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${I+1}Ready = 1;\n                     }\n\n                     xC${I+1} = xTexelC${I+1};\n                     `}}else I<o&&(e%2==1?(n+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I}Ready == 0) {\n                   xTexelC${I} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${I}.zw = vec2(0.0);\n                   }\n                   xTexelC${I}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${I+1}Ready == 0) {\n                   xTexelC${I+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${I+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${I+1}Ready = 1;\n                 }\n\n                 xC${I} = vec4(xTexelC${I}.zw, xTexelC${I+1}.zw);\n               `,I+1<o&&(n+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${I+1} = vec4(xTexelC${I+1}.xy, final.xy);\n                 `)):(n+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${I}Ready == 0) {\n                   xTexelC${I} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${I}.zw = vec2(0.0);\n                   }\n                   xTexelC${I}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I+1}Ready == 0) {\n                   xTexelC${I+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${I+1}.zw = vec2(0.);\n                   }\n                   xTexelC${I+1}Ready = 1;\n                 }\n\n                 xC${I} = vec4(\n                   xTexelC${I}.xy, xTexelC${I+1}.xy);\n               `,I+1<o&&(n+=`\n                   xC${I+1} = vec4(xTexelC${I}.zw, xTexelC${I+1}.zw);\n                 `)));I<o&&(n+=`\n             wTexel = getW(r, ${I}, d1, d2);\n             dotProd += xC${I}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${A.inChannels}) {\n               dotProd += xC${I}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,I+1<o&&(n+=`\n               wTexel = getW(r, ${I+1}, d1, d2);\n               dotProd += xC${I+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${A.inChannels}) {\n                 dotProd += xC${I+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}n+="\n     }\n   ",n+="\n     }\n   ",n+="\n     }\n   ";let s="",a="";I&&(s=t?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${I}\n         }`:C?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${I}\n         }`:`vec4 activation(vec4 x) {\n           ${I}\n         }`,a="result = activation(result);");const r=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),t&&this.variableNames.push("preluActivationWeights"),C&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${s}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${n}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${r}\n         ${a}\n         setOutput(result);\n       }\n     `}}class Yx{constructor(A,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=A,this.enableShapeUniforms=VK(this.outputShape.length);const{dataFormat:I}=g,t=wK(),C="channelsLast"===I,e=C?1:2,B=C?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${A[2]} && pos < ${A[1]}) {`;let Q="";for(let A=0;A<=1;A++)for(let g=0;g<=1;g++)Q+=`\n          blockIndex = rc.z + ${g};\n          pos = rc.y + ${A};\n\n          ${i}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${e}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${B}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${C}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*A+g}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*A+g}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${Q}\n\n        ${t.output} = result;\n      }\n    `}}function Lx(A,g){const I=A.length;return I>=3?g?[...A.slice(0,-3),A[I-3]*A[I-2],A[I-1]]:[...A.slice(0,-3),A[I-3],A[I-2]*A[I-1]]:!g&&1===I&&A[0]>1?[A[0],1]:null}function xx({x:A,filter:g,convInfo:I,backend:t,bias:C=null,preluActivationWeights:e=null,leakyreluAlpha:B=0,activation:i=null}){const Q=A.shape,o=t.texData.get(A.dataId),E=I.inChannels,n=Q[0]*Q[1]*Q[2],s=I.outChannels,a="channelsLast"===I.dataFormat;let r;const h=[];if(null!=e){const A=Lx(e.shape,a);null!=A&&(e=_Y({inputs:{x:e},backend:t,attrs:{shape:A}}),h.push(e))}if(null!=C){const A=Lx(C.shape,a);null!=A&&(C=_Y({inputs:{x:C},backend:t,attrs:{shape:A}}),h.push(C))}if(!((1===n||1===s)&&E>EL)&&o.isPacked&&a&&null!=o.texture&&Q[2]%2!=0&&EA(o.shape.slice(-3),Q.slice(-3))){const E=Q[0]*Q[1]*(Q[2]+1),n={dataId:A.dataId,shape:[1,E,I.inChannels],dtype:A.dtype},s=o.shape;o.shape=o.shape.slice(),o.shape[o.shape.length-2]++,CA(nK(o.shape,n.shape),(()=>`packed reshape ${o.shape} to ${n.shape} isn't free`));const a=_Y({inputs:{x:g},backend:t,attrs:{shape:[1,I.inChannels,I.outChannels]}});h.push(a);const c=nL({a:n,b:a,backend:t,transposeA:false,transposeB:false,bias:C,activation:i,preluActivationWeights:e,leakyreluAlpha:B}),l=t.texData.get(c.dataId);CA(l.isPacked,(()=>"batchMatMul result is expected to be packed")),o.shape=s,l.shape=I.outShape,r=MY({inputs:{x:c},backend:t}),r.shape=I.outShape,h.push(c)}else{const Q=I.outHeight*I.outWidth,o=_Y({inputs:{x:A},backend:t,attrs:{shape:a?[I.batchSize,Q,I.inChannels]:[I.batchSize,I.inChannels,Q]}}),E=_Y({inputs:{x:g},backend:t,attrs:{shape:[1,I.inChannels,I.outChannels]}}),n=nL({a:a?o:E,b:a?E:o,transposeA:!a,transposeB:false,backend:t,bias:C,activation:i,preluActivationWeights:e,leakyreluAlpha:B});r=_Y({inputs:{x:n},backend:t,attrs:{shape:I.outShape}}),h.push(o),h.push(E),h.push(n)}for(const A of h)t.disposeIntermediateTensorInfo(A);return r}function bx({x:A,filter:g,convInfo:I,backend:t,bias:C=null,preluActivationWeights:e=null,leakyreluAlpha:B=0,activation:i=null}){const{filterWidth:Q,filterHeight:o,inChannels:E,outWidth:n,outHeight:s,dataFormat:a}=I,r="channelsLast"===a,h=Q*o*E,c=s*n,l=[I.batchSize,h,c],D=[];if(null!=e){const A=Lx(e.shape,r);null!=A&&(e=_Y({inputs:{x:e},backend:t,attrs:{shape:A}}),D.push(e))}if(null!=C){const A=Lx(C.shape,r);null!=A&&(C=_Y({inputs:{x:C},backend:t,attrs:{shape:A}}),D.push(C))}const u=_Y({inputs:{x:g},backend:t,attrs:{shape:[1,h,QA(g.shape)/h]}});D.push(u);const w=new Yx(l,I),d=[A.shape,[I.padInfo.top,I.padInfo.left],[I.strideHeight,I.strideWidth],[I.dilationHeight,I.dilationWidth],[I.inChannels],[I.filterWidth*I.inChannels],[I.outWidth]],p=t.runWebGLProgram(w,[A],"float32",d),y=_Y({inputs:{x:p},backend:t,attrs:{shape:l}});D.push(p),D.push(y);const G=null!=C,f=null!=e,N="leakyrelu"===i,F=i?WY(i,!0):null,R=new OY(r?y.shape:u.shape,r?u.shape:y.shape,r?[I.batchSize,c,I.outChannels]:[I.batchSize,I.outChannels,c],!0,!1,G,F,f,N),m=r?[y,u]:[u,y];if(C&&m.push(C),f&&m.push(e),N){const A=t.makeTensorInfo([],"float32",LC(B,"float32"));m.push(A),D.push(A)}const k=t.runWebGLProgram(R,m,"float32"),S=_Y({inputs:{x:k},backend:t,attrs:{shape:I.outShape}});D.push(k);for(const A of D)t.disposeIntermediateTensorInfo(A);return S}const Hx={kernelName:Fg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dataFormat:Q,dilations:o,dimRoundingMode:E}=t,n=Jo(Q),s=No(C.shape,e.shape,B,o,i,E,!1,n);let a;if(1!==s.filterHeight||1!==s.filterWidth||1!==s.dilationHeight||1!==s.dilationWidth||1!==s.strideHeight||1!==s.strideWidth||"SAME"!==s.padInfo.type&&"VALID"!==s.padInfo.type)if(s.strideWidth<=2&&"channelsLast"===n&&ZA().getBool("WEBGL_EXP_CONV")){const A=new Jx(s),g=[[s.padInfo.top,s.padInfo.left],[s.strideHeight,s.strideWidth],[s.dilationHeight,s.dilationWidth],[s.inHeight,s.inWidth]];a=I.runWebGLProgram(A,[C,e],"float32",g)}else if(ZA().getBool("WEBGL_CONV_IM2COL"))a=bx({x:C,filter:e,convInfo:s,backend:I});else{const A=new Ux(s);a=I.runWebGLProgram(A,[C,e],"float32")}else a=xx({x:C,filter:e,convInfo:s,backend:I});const r=_Y({inputs:{x:a},backend:I,attrs:{shape:s.outShape}});return I.disposeIntermediateTensorInfo(a),r}};class qx{constructor(A){this.variableNames=["x","dy"],this.outputShape=A.filterShape;const g=A.strideHeight,I=A.strideWidth,t=A.padInfo.top,C=A.padInfo.left,e="channelsLast"===A.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${A.batchSize}; b++) {\n          for (int yR = 0; yR < ${A.outHeight}; yR++) {\n            int xR = wR + yR * ${g} - ${t};\n\n            if (xR < 0 || xR >= ${A.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${A.outWidth}; yC++) {\n              int xC = wC + yC * ${I} - ${C};\n\n              if (xC < 0 || xC >= ${A.inWidth}) {\n                continue;\n              }\n\n              if (${e}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Tx{constructor(A){this.variableNames=["dy","W"],this.outputShape=A.inShape;const g=A.filterHeight,I=A.filterWidth,t=A.strideHeight,C=A.strideWidth,e="channelsLast"===A.dataFormat,B=g-1-A.padInfo.top,i=I-1-A.padInfo.left,Q=e?1:2,o=e?2:3,E=e?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${B}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${E}];\n\n        ivec2 dyCorner = ivec2(coords[${Q}], coords[${o}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${g}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${A.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${g} - 1 - wR;\n\n          for (int wC = 0; wC < ${I}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${C}.0;\n\n            if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${I} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${A.outChannels}; d2++) {\n\n              if (${e}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vx{constructor(A){this.variableNames=["x","dy"],this.outputShape=A.filterShape;const g=A.strideDepth,I=A.strideHeight,t=A.strideWidth,C=A.padInfo.front,e=A.padInfo.top,B=A.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${A.batchSize}; b++) {\n          for (int yF = 0; yF < ${A.outDepth}; yF++) {\n            int xF = wF + yF * ${g} - ${C};\n\n            if (xF < 0 || xF >= ${A.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${A.outHeight}; yR++) {\n              int xR = wR + yR * ${I} - ${e};\n\n              if (xR < 0 || xR >= ${A.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${A.outWidth}; yC++) {\n                int xC = wC + yC * ${t} - ${B};\n\n                if (xC < 0 || xC >= ${A.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Vx{constructor(A){this.variableNames=["dy","W"],this.outputShape=A.inShape;const g=A.filterDepth,I=A.filterHeight,t=A.filterWidth,C=A.strideDepth,e=A.strideHeight,B=A.strideWidth,i=g-1-A.padInfo.front,Q=I-1-A.padInfo.top,o=t-1-A.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${Q}, ${o});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${g}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${C}.0;\n\n          if (dyF < 0.0 || dyF >= ${A.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${g} - 1 - wF;\n\n          for (int wR = 0; wR < ${I}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e}.0;\n\n            if (dyR < 0.0 || dyR >= ${A.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${I} - 1 - wR;\n\n            for (int wC = 0; wC < ${t}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${B}.0;\n\n              if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${t} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${A.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Wx={kernelName:Rg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,dy:e}=g,{strides:B,pad:i,dataFormat:Q,dimRoundingMode:o,filterShape:E}=t,n=Jo(Q),s=No(C.shape,E,B,1,i,o,!1,n),a=new qx(s);return I.runWebGLProgram(a,[C,e],"float32")}};const Ox={kernelName:mg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,filter:e}=g,{inputShape:B,strides:i,pad:Q,dataFormat:o,dimRoundingMode:E}=t,n=Jo(o),s=No(B,e.shape,i,1,Q,E,!1,n),a=new Tx(s);return I.runWebGLProgram(a,[C,e],"float32")}};const Zx={kernelName:kg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dilations:Q}=t,o=Fo(C.shape,e.shape,B,Q,i),E=new Kx(o);return I.runWebGLProgram(E,[C,e],"float32")}};const Px={kernelName:Sg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,dy:e}=g,{strides:B,pad:i,filterShape:Q}=t,o=Fo(C.shape,Q,B,1,i),E=new vx(o);return I.runWebGLProgram(E,[C,e],"float32")}};const Xx={kernelName:Mg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,filter:e}=g,{pad:B,strides:i,inputShape:Q}=t,o=Fo(Q,e.shape,i,1,B),E=new Vx(o);return I.runWebGLProgram(E,[C,e],"float32")}},jx=vY({opSnippet:TY+"\n  return cos(x);\n"}),zx={kernelName:Ug,backendName:"webgl",kernelFunc:jx},_x=vY({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),$x={kernelName:Kg,backendName:"webgl",kernelFunc:_x};class Ab{constructor(A,g,I,t,C){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[e,B,i,Q]=A,[o]=g,[E,n]=I;this.outputShape=[o,E,n,Q];const s="bilinear"===t?1:0,[a,r]=[B-1+".0",i-1+".0"],[h,c,l]=E>1?[""+(B-1)/(E-1),"(y2-y1) * height_ratio",`y1*${a} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${a}`],[D,u,w]=n>1?[""+(i-1)/(n-1),"(x2-x1) * width_ratio",`x1*${r} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${r}`];this.userCode=`\n      const float height_ratio = float(${h});\n      const float width_ratio = float(${D});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${e}) {\n          return;\n        }\n\n        float height_scale = ${c};\n        float width_scale = ${u};\n\n        float in_y = ${l};\n        if( in_y < 0.0 || in_y > ${a} ) {\n          setOutput(float(${C}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${r} ) {\n          setOutput(float(${C}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${s} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const gb={kernelName:Lg,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I,attrs:t}=A,{image:C,boxes:e,boxInd:B}=g,{cropSize:i,method:Q,extrapolationValue:o}=t,E=new Ab(C.shape,e.shape,i,Q,o);return I.runWebGLProgram(E,[C,e,B],"float32")}};var Ib;!function(A){A.Prod="*",A.Sum="+"}(Ib||(Ib={}));class tb{constructor(A,g,I,t){this.op=A,this.outputShape=g,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const C=this.outputShape.length,e=this.op===Ib.Prod?"1.0":"0.0",B=I?e:`getX(${Cb(C,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let Q="",o="";I?(Q=t?"end != "+(i-1):"end != 0",o=t?"end + 1":"end - 1"):(Q=t?`end + pow2 < ${i}`:"end >= pow2",o=t?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${LK(C)} coords = getOutputCoords();\n        int end = ${eb(C,"coords",this.op)};\n        float val = ${B};\n        int pow2 = int(pow(2.0, index));\n        if (${Q}) {\n          int idx = ${o};\n          ${eb(C,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Cb(C,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Cb(A,g,I){if(1===A)return`${g}`;if(2===A)return`${g}.x, ${g}.y`;if(3===A)return`${g}.x, ${g}.y, ${g}.z`;if(4===A)return`${g}.x, ${g}.y, ${g}.z, ${g}.w`;throw new Error(`Cumulative ${I} for rank ${A} is not yet supported`)}function eb(A,g,I){if(1===A)return`${g}`;if(2===A)return`${g}.y`;if(3===A)return`${g}.z`;if(4===A)return`${g}.w`;throw new Error(`Cumulative ${I} for rank ${A} is not yet supported`)}function Bb(A,g,I,t,C,e){const B=g.shape.length,i=UE([t],B);let Q=g;null!=i&&(Q=QL({inputs:{x:g},backend:I,attrs:{perm:i}}));const o=JE(1,B)[0];if(o!==B-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${g.shape.length-1} but got axis=${t}`);const E=Q.shape[o];let n=MY({inputs:{x:Q},backend:I});for(let g=0;g<=Math.ceil(Math.log2(E))-1;g++){const t=new tb(A,Q.shape,!1,e),C=[[g]],B=n;n=I.runWebGLProgram(t,[n],n.dtype,C),I.disposeIntermediateTensorInfo(B)}if(C){const g=new tb(A,Q.shape,C,e),t=n;n=I.runWebGLProgram(g,[n],n.dtype),I.disposeIntermediateTensorInfo(t)}if(null!=i){const A=QL({inputs:{x:n},backend:I,attrs:{perm:KE(i)}});return I.disposeIntermediateTensorInfo(n),I.disposeIntermediateTensorInfo(Q),A}return n}const ib={kernelName:Jg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,exclusive:B,reverse:i}=t;return Bb(Ib.Prod,C,I,e,B,i)}};const Qb={kernelName:Yg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,exclusive:B,reverse:i}=t;return Bb(Ib.Sum,C,I,e,B,i)}};const ob={kernelName:xg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,weights:e}=g,{size:B,binaryOutput:i}=t;if(1===C.shape.length){const A=I.readSync(C.dataId),g=I.readSync(e.dataId),t=oJ(A,g,e.dtype,e.shape,B);return I.makeTensorInfo([B],e.dtype,t)}if(2===C.shape.length){const A=I.bufferSync(C),g=I.bufferSync(e),t=EJ(A,g,B,i);return I.makeTensorInfo(t.shape,e.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${C.shape.length}.`)}};class Eb{constructor(A,g,I){this.variableNames=["x"],this.outputShape=[],this.outputShape=A,this.blockSize=g,this.dataFormat=I,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${g};\n      int offset_h = imod(h, ${g});\n      int in_w = w / ${g};\n      int offset_w = imod(w, ${g});\n      int offset_d = (offset_h * ${g} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const nb={kernelName:bg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{blockSize:e,dataFormat:B}=t,i=C.shape[0],Q=("NHWC"===B?C.shape[1]:C.shape[2])*e,o=("NHWC"===B?C.shape[2]:C.shape[3])*e,E=("NHWC"===B?C.shape[3]:C.shape[1])/(e*e),n=new Eb("NHWC"===B?[i,Q,o,E]:[i,E,Q,o],e,B);return I.runWebGLProgram(n,[C],C.dtype)}};class sb{constructor(A,g=!1,I=null,t=!1,C=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=A.outShape,this.enableShapeUniforms=VK(this.outputShape.length);const e=A.filterHeight,B=A.filterWidth,i=A.outChannels/A.inChannels;let Q="",o="";I&&(Q=t?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${I}\n        }`:C?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${I}\n        }`:`\n          float activation(float x) {\n            ${I}\n          }\n        `,o="result = activation(result);");const E=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),t&&this.variableNames.push("preluActivationWeights"),C&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${Q}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${e}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${B}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${E}\n        ${o}\n        setOutput(result);\n      }\n    `}}class ab{constructor(A,g=!1,I=null,t=!1,C=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=A.outShape,this.enableShapeUniforms=VK(this.outputShape.length);const e=A.outChannels/A.inChannels,B=A.padInfo.left,i=A.strideWidth,Q=A.dilationWidth,o=A.filterHeight,E=A.filterWidth,n=E;let s="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let A=0;A<E;A++)s+=`\n          vec4 xTexelC${2*A};\n          int xTexelC${2*A}Ready;\n          vec4 xTexelC${2*A+1};\n          int xTexelC${2*A+1}Ready;\n          vec4 xC${A};`;s+=`\n    for (int r = 0; r < ${o}; r++) {\n      `;for(let A=0;A<E;A++)s+=`\n          xTexelC${2*A} = vec4(0.0);\n          xTexelC${2*A}Ready = 0;\n          xTexelC${2*A+1} = vec4(0.0);\n          xTexelC${2*A+1}Ready = 0;\n          xC${A} = vec4(0.0);`;s+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let A=0;A<(n+1)/2;A++){const g=2*A;if(s+=`\n          xC = xCCorner + ${g*Q};\n          `,1===i){if(g<E&&(B%2==1?(s+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                  xTexelC${g} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${g}.zw = vec2(0.0);\n                  }\n                  xTexelC${g}Ready = 1;\n                }\n              `,s+=1===Q&&g>0?`\n                xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${g} = vec4(previous.zw, xTexelC${g}.xy);\n                  } else {\n                    xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);\n                  }\n                  `):s+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                  xTexelC${g} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${g}.zw = vec2(0.0);\n                  }\n                  xTexelC${g}Ready = 1;\n                }\n\n                xC${g} = xTexelC${g};\n                `,g+1<E)){const A=B%2==0?$(Q):Q;Q%2==0&&B%2==1||Q%2!=0&&B%2!=1?(s+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${A};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                    xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${g+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${g+1}Ready = 1;\n                  }\n                  `,s+=Q>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);\n                    } else {\n                     xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);\n                    }\n                    `:`\n                    xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);\n                    `):s+=1===A?`\n                    xC${g+1} = xTexelC${g};\n                    `:`\n                    xCOffset = xC + ${A};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                      xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${g+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${g+1}Ready = 1;\n                    }\n\n                    xC${g+1} = xTexelC${g+1};\n                    `}}else g<E&&(B%2==1?(s+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                  xTexelC${g} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${g}.zw = vec2(0.0);\n                  }\n                  xTexelC${g}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {\n                  xTexelC${g+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${g+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${g+1}Ready = 1;\n                }\n\n                xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n              `,g+1<E&&(s+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);\n                `)):(s+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                  xTexelC${g} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${g}.zw = vec2(0.0);\n                  }\n                  xTexelC${g}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                  xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${g+1}.zw = vec2(0.);\n                  }\n                  xTexelC${g+1}Ready = 1;\n                }\n\n                xC${g} = vec4(\n                  xTexelC${g}.xy, xTexelC${g+1}.xy);\n              `,g+1<E&&(s+=`\n                  xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n                `)));g<E&&(s+=`\n            wTexel = getW(r, ${g}, d1, q);\n            dotProd += xC${g} * vec4(wTexel.xz, wTexel.xz);\n          `,g+1<E&&(s+=`\n              wTexel = getW(r, ${g+1}, d1, q);\n              dotProd += xC${g+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}s+="\n    }\n  ",s+="\n      }\n    ";let a="",r="";I&&(a=t?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${I}\n        }`:C?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${I}\n        }`:`vec4 activation(vec4 x) {\n          ${I}\n        }`,r="result = activation(result);");const h=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),t&&this.variableNames.push("preluActivationWeights"),C&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${a}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${e};\n        int q = d2 - d1 * ${e};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${s}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${h}\n        ${r}\n        setOutput(result);\n      }\n    `}}const rb={kernelName:Hg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dilations:Q,dimRoundingMode:o}=t;let E=Q;null==E&&(E=[1,1]),CA(Ko(B,E),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${B} and dilations '${E}'`));const n=No(C.shape,e.shape,B,E,i,o,!0);let s;s=ZA().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?new ab(n):new sb(n);const a=[[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inHeight,n.inWidth]];return I.runWebGLProgram(s,[C,e],"float32",a)}};class hb{constructor(A){this.variableNames=["x","dy"],this.outputShape=A.filterShape;const g=A.strideHeight,I=A.strideWidth,t=A.padInfo.top,C=A.padInfo.left,e=A.outChannels/A.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${A.batchSize}; b++) {\n          for (int yR = 0; yR < ${A.outHeight}; yR++) {\n            int xR = wR + yR * ${g} - ${t};\n\n            if (xR < 0 || xR >= ${A.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${A.outWidth}; yC++) {\n              int xC = wC + yC * ${I} - ${C};\n\n              if (xC < 0 || xC >= ${A.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class cb{constructor(A){this.variableNames=["dy","W"],this.outputShape=A.inShape;const g=A.filterHeight,I=A.filterWidth,t=A.strideHeight,C=A.strideWidth,e=g-1-A.padInfo.top,B=I-1-A.padInfo.left,i=A.outChannels/A.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e}, ${B});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${g}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${A.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${g} - 1 - wR;\n\n          for (int wC = 0; wC < ${I}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${C}.0;\n\n            if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${I} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const lb={kernelName:qg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,dy:e}=g,{strides:B,dilations:i,pad:Q,dimRoundingMode:o,filterShape:E}=t,n=No(C.shape,E,B,i,Q,o,!0),s=new hb(n);return I.runWebGLProgram(s,[C,e],"float32")}};const Db={kernelName:Tg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,filter:e}=g,{strides:B,dilations:i,pad:Q,dimRoundingMode:o,inputShape:E}=t,n=No(E,e.shape,B,i,Q,o,!0),s=new cb(n);return I.runWebGLProgram(s,[C,e],"float32")}};class ub{constructor(A){this.variableNames=["X"],this.outputShape=[A,A],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const wb={kernelName:vg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t}=g,C=[...t.shape,...t.shape],e=QA(t.shape),B=_Y({inputs:{x:t},backend:I,attrs:{shape:[e]}}),i=new ub(e),Q=I.runWebGLProgram(i,[B],B.dtype),o=_Y({inputs:{x:Q},backend:I,attrs:{shape:C}});return I.disposeIntermediateTensorInfo(B),I.disposeIntermediateTensorInfo(Q),o}};class db{constructor(A){this.variableNames=["x","W"],this.outputShape=A.outShape;const{inHeight:g,inWidth:I,padInfo:t,strideHeight:C,strideWidth:e,filterHeight:B,filterWidth:i,dilationHeight:Q,dilationWidth:o}=A,{top:E,left:n}=t;this.userCode=`\n      const ivec2 strides = ivec2(${C}, ${e});\n      const ivec2 pads = ivec2(${E}, ${n});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${B}; h++) {\n          int hIn = hBeg + h * ${Q};\n\n          if (hIn >= 0 && hIn < ${g}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${o};\n\n              if (wIn >= 0 && wIn < ${I}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const pb={kernelName:Vg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e}=g,{strides:B,pad:i,dilations:Q}=t,o=yo(C.shape,e.shape,B,i,"NHWC",Q);let E;const n=new db(o);E=I.runWebGLProgram(n,[C,e],"float32");const s=_Y({inputs:{x:E},backend:I,attrs:{shape:o.outShape}});return I.disposeIntermediateTensorInfo(E),s}};const yb={kernelName:Pg,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{equation:C}=t,e=g,{allDims:B,summedDims:i,idDims:Q}=$r(C,e.length);gh(B.length,Q,e);const{path:o,steps:E}=Ih(i,Q),n=E.length;let s=null,a=B.length;const r=[];for(let A=0;A<n;++A){for(const g of E[A]){const{permutationIndices:A,expandDims:t}=Ah(a,Q[g]);let C;th(A)?C=e[g]:(C=QL({inputs:{x:e[g]},backend:I,attrs:{perm:A}}),r.push(C));const B=C.shape.slice();for(let A=0;A<t.length;++A)B.splice(t[A],0,1);EA(C.shape,B)||(C=_Y({inputs:{x:C},backend:I,attrs:{shape:B}}),r.push(C)),null===s?s=C:(s=jY({inputs:{a:C,b:s},backend:I}),r.push(s))}A<n-1&&(o[A]>=0&&(s=BL({inputs:{x:s},backend:I,attrs:{axis:o[A]-(B.length-a),keepDims:!1}}),r.push(s)),a--)}for(const A of r)A!==s&&I.disposeIntermediateTensorInfo(A);return s}},Gb=vY({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),fb={kernelName:Xg,backendName:"webgl",kernelFunc:Gb},Nb={kernelName:jg,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I}=A,{dy:t,y:C}=g,e=ZA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SY("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,C.shape):new mY("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,C.shape);return I.runWebGLProgram(e,[t,C],t.dtype)}},Fb=VY({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:rJ}),Rb={kernelName:_g,backendName:"webgl",kernelFunc:Fb},mb=vY({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Jr};\n  float a1 = ${Yr};\n  float a2 = ${Lr};\n  float a3 = ${xr};\n  float a4 = ${br};\n  float a5 = ${Hr};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),kb={kernelName:zg,backendName:"webgl",kernelFunc:mb},Sb=vY({opSnippet:TY+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:hJ,dtype:"float32"}),Mb={kernelName:$g,backendName:"webgl",kernelFunc:Sb};function Ub(A){const{inputs:g,attrs:I,backend:t}=A,{dim:C}=I,{input:e}=g,B=e.shape.length,i=e.shape.slice();let Q=C;return C<0&&(CA(-(B+1)<=C,(()=>`Axis must be in the interval [${-(B+1)}, ${B}]`)),Q=B+C+1),i.splice(Q,0,1),_Y({inputs:{x:e},backend:t,attrs:{shape:i}})}const Kb={kernelName:AI,backendName:"webgl",kernelFunc:Ub},Jb="return exp(x) - 1.0;",Yb=vY({opSnippet:Jb,packedOpSnippet:Jb,cpuKernelImpl:cJ}),Lb={kernelName:gI,backendName:"webgl",kernelFunc:Yb};class xb{constructor(A,g,I){this.variableNames=["real","imag"];const t=g[1];this.outputShape=g;const C=I?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,e=I?`${t}.0`:"1.0";let B;if("real"===A)B="return real * expR - imag * expI;";else{if("imag"!==A)throw new Error(`FFT component must be either "real" or "imag", got ${A}.`);B="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${C};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${B}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${t});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${t}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${e};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function bb(A,g,I){const t=I.texData.get(A.dataId),C=QA(A.shape),e=A.shape[A.shape.length-1],B=_Y({inputs:{x:A},backend:I,attrs:{shape:[C/e,e]}}),i=B.shape,Q=new xb("real",i,g),o=new xb("imag",i,g),E=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i}],n=I.runWebGLProgram(Q,E,"float32"),s=I.runWebGLProgram(o,E,"float32"),a=KY({inputs:{real:n,imag:s},backend:I});I.disposeIntermediateTensorInfo(n),I.disposeIntermediateTensorInfo(s);const r=_Y({inputs:{x:a},backend:I,attrs:{shape:A.shape}});return I.disposeIntermediateTensorInfo(B),I.disposeIntermediateTensorInfo(a),r}const Hb={kernelName:II,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{input:t}=g;return bb(t,!1,I)}};class qb{constructor(A,g){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=A,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Tb(A){const{backend:g,attrs:I}=A,{shape:t,value:C}=I;let{dtype:e}=I;if(e=e||SA(C),"string"===e){const A=dA(e,QA(t));return A.fill(C),g.makeTensorInfo(t,e,A)}{const A=new qb(t,C),I=[[C]];return g.runWebGLProgram(A,[],e,I)}}const vb={kernelName:tI,backendName:"webgl",kernelFunc:Tb};class Vb{constructor(A){this.variableNames=["Image"],this.outputShape=[];const g=A[2];this.outputShape=A,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${g} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${g}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Wb={kernelName:CI,backendName:"webgl",kernelFunc:({inputs:A,backend:g})=>{const{image:I}=A,t=g,C=new Vb(I.shape);return t.runWebGLProgram(C,[I],I.dtype)}},Ob="return floor(x);",Zb=vY({opSnippet:Ob,packedOpSnippet:Ob,cpuKernelImpl:lJ}),Pb={kernelName:eI,backendName:"webgl",kernelFunc:Zb},Xb=VY({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),jb={kernelName:BI,backendName:"webgl",kernelFunc:Xb};class zb{constructor(A){this.variableNames=["A"];const g=wK(),[I,t]=A;this.outputShape=A,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}.0, ${I}.0);\n\n        vec4 values = ${g.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class _b{constructor(A){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const g=wK(),[I,t]=A;this.outputShape=A,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${t}.0, ${I}.0);\n            vec4 values = ${g.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${g.output} = result;\n      }\n    `}}const $b={kernelName:eC,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A;let{pixels:C}=g;const{numChannels:e}=t,B="undefined"!=typeof HTMLVideoElement&&C instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&C instanceof HTMLImageElement,[Q,o]=B?[C.videoWidth,C.videoHeight]:[C.width,C.height],E=[o,Q],n=[o,Q,e];if(i||B){const A=ZA().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=AH&&A===gH||(gH=A,AH=document.createElement("canvas").getContext("2d",{willReadFrequently:gH})),AH.canvas.width=Q,AH.canvas.height=o,AH.drawImage(C,0,0,Q,o),C=AH.canvas}const s=I.makeTensorInfo(E,"int32");I.texData.get(s.dataId).usage=TU.PIXELS,I.gpgpu.uploadPixelDataToTexture(I.getTexture(s.dataId),C);const a=ZA().getBool("WEBGL_PACK")?new _b(n):new zb(n),r=I.runWebGLProgram(a,[s],"int32");return I.disposeData(s.dataId),r}};let AH,gH=ZA().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const IH={kernelName:QC,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e,bias:B,preluActivationWeights:i}=g,{strides:Q,pad:o,dataFormat:E,dilations:n,dimRoundingMode:s,activation:a,leakyreluAlpha:r}=t,h=Jo(E),c=No(C.shape,e.shape,Q,n,o,s,!1,h);let l;const D=[],u=null!=B,w=null!=i,d="leakyrelu"===a,p=()=>{const A=[C,e],g=(A,g)=>{if("NCHW"===g&&1===A.shape.length&&1!==A.shape[0]){const g=_Y({inputs:{x:A},backend:I,attrs:{shape:[A.shape[0],1,1]}});return D.push(g),g}return A};if(u&&A.push(g(B,E)),w&&A.push(g(i,E)),d){const g=I.makeTensorInfo([],"float32",LC(r,"float32"));A.push(g),D.push(g)}return A};if(1!==c.filterHeight||1!==c.filterWidth||1!==c.dilationHeight||1!==c.dilationWidth||1!==c.strideHeight||1!==c.strideWidth||"SAME"!==c.padInfo.type&&"VALID"!==c.padInfo.type)if(c.strideWidth<=2&&"channelsLast"===h&&ZA().getBool("WEBGL_EXP_CONV")){const A=a?WY(a,!0):null,g=new Jx(c,u,A,w,d),t=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]],C=p();l=I.runWebGLProgram(g,C,"float32",t)}else if(ZA().getBool("WEBGL_CONV_IM2COL"))l=bx({x:C,filter:e,convInfo:c,backend:I,bias:B,activation:a,preluActivationWeights:i,leakyreluAlpha:r});else{const A=a?WY(a,!1):null,g=new Ux(c,u,A,w,d),t=p();l=I.runWebGLProgram(g,t,"float32")}else l=xx({x:C,filter:e,convInfo:c,backend:I,bias:B,activation:a,preluActivationWeights:i,leakyreluAlpha:r});const y=_Y({inputs:{x:l},backend:I,attrs:{shape:c.outShape}});return D.push(l),D.forEach((A=>I.disposeIntermediateTensorInfo(A))),y}};const tH={kernelName:oC,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,filter:e,bias:B,preluActivationWeights:i}=g,{strides:Q,pad:o,dilations:E,dimRoundingMode:n,activation:s,leakyreluAlpha:a}=t,r=[];let h=E;null==h&&(h=[1,1]),CA(Ko(Q,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${Q} and dilations '${h}'`));const c=No(C.shape,e.shape,Q,h,o,n,!0),l=ZA().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels==1,D=s?WY(s,l):null,u=[C,e],w=null!=B,d=null!=i,p="leakyrelu"===s;if(w&&u.push(B),d&&u.push(i),p){const A=I.makeTensorInfo([],"float32",LC(a,"float32"));u.push(A),r.push(A)}let y;y=l?new ab(c,w,D,d,p):new sb(c,w,D,d,p);const G=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]],f=I.runWebGLProgram(y,u,"float32",G);return r.forEach((A=>I.disposeIntermediateTensorInfo(A))),f}};class CH{constructor(A,g,I,t){this.sliceDim=A,this.strides=g,this.paramsShape=t,this.variableNames=["x","indices"],this.outputShape=I;const C=LK(I.length);let e="\n    int index;";for(let A=0;A<this.sliceDim;A++)e+=`\n          index = round(getIndices(coords[0], ${A}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[A]};\n          flattenIndex += index * ${this.strides[A]};`;this.userCode=`\n         void main() {\n          ${C} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${e}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const eH={kernelName:oI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{params:t,indices:C}=g,e=C.shape,B=e[e.length-1],i=QA(t.shape),[Q,o,E,n]=Pi(t,C),s=_Y({inputs:{x:C},backend:I,attrs:{shape:[o,B]}}),a=_Y({inputs:{x:t},backend:I,attrs:{shape:[QA(t.shape)/E,E]}});if(I.shouldExecuteOnCPU([t,C])||"string"===t.dtype){const A=I.readSync(C.dataId),g=I.bufferSync(t),e=DJ(A,g,t.dtype,o,B,E,n,t.shape,i);return I.makeTensorInfo(Q,t.dtype,e.values)}const r=new CH(B,n,[o,E],t.shape),h=I.runWebGLProgram(r,[a,s],a.dtype),c=_Y({inputs:{x:h},backend:I,attrs:{shape:Q}});return I.disposeIntermediateTensorInfo(s),I.disposeIntermediateTensorInfo(a),I.disposeIntermediateTensorInfo(h),c}};class BH{constructor(A,g){this.variableNames=["A","indices"],this.outputShape=g,this.rank=g.length;const I=LK(this.rank),t=function(A,g){const I=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let g=0;g<A.length;g++)2===g?t.push("index"):t.push(`${I[g]}`);return t.join()}(A);this.userCode=`\n      void main() {\n        ${I} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${A[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${t}));\n      }\n    `}}function iH(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,indices:e}=g,{axis:B,batchDims:i}=t,Q=DA(B,C.shape)[0];if(ZA().get("DEBUG")){const A=I.readSync(e.dataId),g=C.shape[Q];for(let I=0;I<A.length;++I){const t=A[I];CA(t<=g-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${g-1}]`))}}const o=wh(C,e,Q,i),E=QA(e.shape),n=[],s=_Y({inputs:{x:C},backend:I,attrs:{shape:[o.batchSize,o.outerSize,o.dimSize,o.sliceSize]}}),a=_Y({inputs:{x:e},backend:I,attrs:{shape:[o.batchSize,E/o.batchSize]}});n.push(s),n.push(a);const r=[o.batchSize,o.outerSize,E/o.batchSize,o.sliceSize];if(I.shouldExecuteOnCPU([C,e])||"string"===C.dtype){const A=I.bufferSync(a),g=I.bufferSync(s),t=uJ(g,A,r);return n.forEach((A=>I.disposeIntermediateTensorInfo(A))),I.makeTensorInfo(o.outputShape,t.dtype,t.values)}const h=new BH(s.shape,r),c=I.runWebGLProgram(h,[s,a],s.dtype);n.push(c);const l=_Y({inputs:{x:c},backend:I,attrs:{shape:o.outputShape}});return n.forEach((A=>I.disposeIntermediateTensorInfo(A))),l}const QH={kernelName:QI,backendName:"webgl",kernelFunc:iH},oH=VY({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:wJ,dtype:"bool"}),EH={kernelName:EI,backendName:"webgl",kernelFunc:oH},nH=VY({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:dJ}),sH={kernelName:nI,backendName:"webgl",kernelFunc:nH};const aH={kernelName:aI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{input:t}=g;return bb(t,!0,I)}},rH=vY({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),hH={kernelName:hI,backendName:"webgl",kernelFunc:rH},cH=vY({opSnippet:"return float(isinf(x));",dtype:"bool"}),lH={kernelName:cI,backendName:"webgl",kernelFunc:cH},DH=vY({opSnippet:"return float(isnan(x));",dtype:"bool"}),uH={kernelName:lI,backendName:"webgl",kernelFunc:DH},wH=VY({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:pJ,dtype:"bool"}),dH={kernelName:uI,backendName:"webgl",kernelFunc:wH},pH=VY({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:yJ,dtype:"bool"}),yH={kernelName:wI,backendName:"webgl",kernelFunc:pH};const GH={kernelName:dI,backendName:"webgl",kernelFunc:function(A){const{backend:g,attrs:I}=A,{start:t,stop:C,num:e}=I,B=GJ(t,C,e);return g.makeTensorInfo([B.length],"float32",B)}},fH=vY({opSnippet:TY+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:fJ}),NH={kernelName:pI,backendName:"webgl",kernelFunc:fH},FH=vY({opSnippet:TY+"\n  return log(1.0 + x);\n"}),RH={kernelName:yI,backendName:"webgl",kernelFunc:FH},mH=VY({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),kH={kernelName:GI,backendName:"webgl",kernelFunc:mH},SH=vY({opSnippet:"return float(!(x >= 1.0));"}),MH={kernelName:fI,backendName:"webgl",kernelFunc:SH},UH=VY({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),KH={kernelName:NI,backendName:"webgl",kernelFunc:UH};class JH{constructor(A,g,I,t,C){this.variableNames=["x"],this.outputShape=[];const e=g,B=A[3]-1;let i;this.outputShape=A;const Q=`float(${I}) + float(${t}) * sum`;i=.5===C?`inversesqrt(${Q})`:1===C?`1.0/(${Q})`:`exp(log(${Q}) * float(-${C}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${e}; j <= ${e}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${B}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class YH{constructor(A,g,I,t,C){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const e=g,B=A[3]-1;let i;this.outputShape=A;const Q=`float(${I}) + float(${t}) * sum`;i=.5===C?`inversesqrt(${Q})`:1===C?`1.0/(${Q})`:`exp(log(${Q}) * float(-${C}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${e};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${e}; j <= ${e}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${B}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}const LH={kernelName:kI,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{depthRadius:e,bias:B,alpha:i,beta:Q}=t,o=ZA().getBool("WEBGL_PACK_NORMALIZATION")?new YH(C.shape,e,B,i,Q):new JH(C.shape,e,B,i,Q);return I.runWebGLProgram(o,[C],C.dtype)}};class xH{constructor(A,g,I,t,C){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=A,this.depth=A[3],this.depthRadius=g,this.bias=I,this.alpha=t,this.beta=C,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${g})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${g} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${t}) * norm + float(${I});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${t})\n                * float(${C})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${C});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const bH={kernelName:SI,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I,attrs:t}=A,{x:C,y:e,dy:B}=g,{depthRadius:i,bias:Q,alpha:o,beta:E}=t,n=new xH(C.shape,i,Q,o,E);return I.runWebGLProgram(n,[C,e,B],C.dtype)}};function HH(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{reductionIndices:e,keepDims:B}=t,i=C.shape.length,Q=DA(e,C.shape);let o=Q;const E=UE(o,i),n=null!=E,s=I.shouldExecuteOnCPU([C]);let a=C;if(n){if(s){const A=I.texData.get(a.dataId).values,g=new Array(i);for(let A=0;A<g.length;A++)g[A]=C.shape[E[A]];const t=_J(A,C.shape,C.dtype,E,g);a=I.makeTensorInfo(g,C.dtype);I.texData.get(a.dataId).values=t}else a=eL(C,E,I);o=JE(o.length,i)}ME("max",o,i);const[r,h]=kE(a.shape,o);let c,l=r;if(B&&(l=SE(r,Q)),s){const A=I.texData.get(a.dataId).values,g=NJ(A,QA(h),l,C.dtype);c=I.makeTensorInfo(l,C.dtype);I.texData.get(c.dataId).values=g}else c=function(A,g,I,t){const C=QA(g),e=_Y({inputs:{x:A},attrs:{shape:[QA(A.shape)/C,C]},backend:t}),B=IL(e,A.dtype,"max",t),i=_Y({inputs:{x:B},attrs:{shape:I},backend:t});return t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(B),i}(a,h,l,I);return n&&I.disposeIntermediateTensorInfo(a),c}const qH={kernelName:MI,backendName:"webgl",kernelFunc:HH},TH=VY({opSnippet:RY+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+kY+"\n  return result;\n",cpuKernelImpl:FJ}),vH={kernelName:UI,backendName:"webgl",kernelFunc:TH};const VH={kernelName:KI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g;DK(C,"maxPool");const{filterSize:e,strides:B,pad:i,dimRoundingMode:Q}=t;CA(Ko(B,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${B} and dilations '1'`));const o=Go(C.shape,e,B,1,i,Q);if(1===o.filterWidth&&1===o.filterHeight&&EA(o.inShape,o.outShape))return MY({inputs:{x:C},backend:I});const E=new VL(o,"max",!1);return I.runWebGLProgram(E,[C],C.dtype)}};const WH={kernelName:YI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{filterSize:e,strides:B,pad:i,dataFormat:Q,dimRoundingMode:o}=t,E=fo(C.shape,e,B,[1,1,1],i,o,Q),n=new WL(E,"max",!1);return I.runWebGLProgram(n,[C],C.dtype)}};class OH{constructor(A){this.variableNames=["dy","maxPos"],this.outputShape=A.inShape;const g=A.strideHeight,I=A.strideWidth,t=A.dilationHeight,C=A.effectiveFilterHeight,e=A.effectiveFilterWidth,B=C-1-A.padInfo.top,i=e-1-A.padInfo.left,Q=C*e-1;this.userCode=`\n      const ivec2 pads = ivec2(${B}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${C};\n          wR += ${t}) {\n          float dyR = float(dyRCorner + wR) / ${g}.0;\n\n          if (dyR < 0.0 || dyR >= ${A.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${I}.0;\n\n            if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${Q} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${e} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZH{constructor(A){this.variableNames=["dy","maxPos"],this.outputShape=A.inShape;const g=A.strideDepth,I=A.strideHeight,t=A.strideWidth,C=A.dilationDepth,e=A.dilationHeight,B=A.dilationWidth,i=A.effectiveFilterDepth,Q=A.effectiveFilterHeight,o=A.effectiveFilterWidth,E=i-1-A.padInfo.front,n=Q-1-A.padInfo.top,s=o-1-A.padInfo.left,a=i*Q*o-1;this.userCode=`\n      const ivec3 pads = ivec3(${E}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${C}) {\n          float dyD = float(dyDCorner + wD) / ${g}.0;\n\n          if (dyD < 0.0 || dyD >= ${A.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${Q};\n              wR += ${e}) {\n            float dyR = float(dyRCorner + wR) / ${I}.0;\n\n            if (dyR < 0.0 || dyR >= ${A.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${o};\n                wC += ${B}) {\n              float dyC = float(dyCCorner + wC) / ${t}.0;\n\n              if (dyC < 0.0 || dyC >= ${A.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${a} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${Q} * ${o} +\n                  wR * ${o} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const PH={kernelName:LI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e}=g,B=e,{filterSize:i,strides:Q,pad:o,dimRoundingMode:E}=t,n=fo(B.shape,i,Q,[1,1,1],o,E),s=new WL(n,"max",!0),a=I.runWebGLProgram(s,[B],B.dtype),r=new ZH(n),h=I.runWebGLProgram(r,[C,a],B.dtype);return I.disposeIntermediateTensorInfo(a),h}};const XH={kernelName:JI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{dy:C,input:e,output:B}=g,i=e;DK([e,B],"maxPoolGrad");const{filterSize:Q,strides:o,pad:E,dimRoundingMode:n}=t,s=Go(i.shape,Q,o,1,E,n),a=new VL(s,"max",!0),r=I.runWebGLProgram(a,[i],i.dtype),h=new OH(s),c=I.runWebGLProgram(h,[C,r],i.dtype);return I.disposeIntermediateTensorInfo(r),c}};const jH={kernelName:xI,backendName:"webgl",kernelFunc:({inputs:A,attrs:g,backend:I})=>{const{x:t}=A,{filterSize:C,strides:e,pad:B,includeBatchInIndex:i}=g,Q=I;CA(4===t.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${t.shape.length}.`));const o=[1,1];CA(Ko(e,o),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`));const E=Go(t.shape,C,e,o,B),[n,s]=function(A,g,I,t){let C=new VL(I,"max",!1);const e=t.runWebGLProgram(C,[A],"float32");return C=new VL(I,"max",!0,!0,g),[e,t.runWebGLProgram(C,[A],"float32")]}(t,i,E,Q);return[n,s]}};const zH={kernelName:bI,backendName:"webgl",kernelFunc:({inputs:A,attrs:g,backend:I})=>{const{x:t}=A,{keepDims:C,axis:e}=g,B=I,i=t.shape.length,Q=DA(e,t.shape);let o=Q;const E=UE(o,i),n=null!=E,s=B.shouldExecuteOnCPU([t]),a=[];let r=t;if(n){if(s){const A=B.texData.get(r.dataId).values,g=new Array(i);for(let A=0;A<g.length;A++)g[A]=t.shape[E[A]];const I=_J(A,t.shape,t.dtype,E,g);r=B.makeTensorInfo(g,t.dtype);B.texData.get(r.dataId).values=I}else r=eL(t,E,B);a.push(r),o=JE(o.length,i)}ME("sum",o,i);const[h,c]=kE(r.shape,o);let l=h;C&&(l=SE(h,Q));const D=function(A,g,I,t){const C=QA(g),e=_Y({inputs:{x:A},attrs:{shape:[QA(A.shape)/C,C]},backend:t}),B=IL(e,"float32","mean",t),i=_Y({inputs:{x:B},attrs:{shape:I},backend:t});return t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(B),i}(r,c,l,B);for(const A of a)B.disposeIntermediateTensorInfo(A);return D}};const _H={kernelName:HI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t,i=C.shape.length,Q=DA(e,C.shape);let o=Q;const E=UE(o,i);let n=C;null!=E&&(n=QL({inputs:{x:C},backend:I,attrs:{perm:E}}),o=JE(o.length,C.shape.length)),ME("min",o,i);const[s,a]=kE(n.shape,o),r=_Y({inputs:{x:n},backend:I,attrs:{shape:[-1,QA(a)]}}),h=IL(r,r.dtype,"min",I);let c;if(B){c=_Y({inputs:{x:h},backend:I,attrs:{shape:SE(s,Q)}})}else c=_Y({inputs:{x:h},backend:I,attrs:{shape:s}});return I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(h),null!=E&&I.disposeIntermediateTensorInfo(n),c}},$H=VY({opSnippet:RY+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+kY+"\n  return result;\n",cpuKernelImpl:RJ}),Aq={kernelName:qI,backendName:"webgl",kernelFunc:$H};class gq{constructor(A,g,I){this.variableNames=["x"],this.outputShape=g.map(((g,I)=>g[0]+A[I]+g[1]));const t=A.length,C=LK(t),e=g.map((A=>A[0])).join(","),B=g.map(((g,I)=>g[0]+A[I])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t),Q="reflect"===I?0:1;this.userCode=1!==t?`\n      ${C} start = ${C}(${e});\n      ${C} end = ${C}(${B});\n\n      void main() {\n        ${C} outC = getOutputCoords();\n        for (int i = 0; i < ${t}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${Q};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${Q};\n          }\n        }\n        ${C} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${e};\n        int end = ${B};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${Q};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${Q};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Iq{constructor(A,g,I){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g.map(((g,I)=>g[0]+A[I]+g[1]));const t=A.length,C=LK(t),e=g.map((A=>A[0])).join(","),B=g.map(((g,I)=>g[0]+A[I])).join(","),i=gY("rc",t),Q=gY("source",t),o=`${i[t-1]} < ${this.outputShape[t-1]}`,E=1===t?"source":`vec2(${Q.slice(-2).join()})`,n="reflect"===I?0:1;let s="";if(1===t){const A=`\n        ${C} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${n};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${n};\n        }\n        source -= start;\n      `;s=`\n        ${C} rc = outputLoc;\n        ${A}\n        result[0] = getChannel(getX(${Q.join()}), ${E});\n        ${i[t-1]} += 1;\n        if(${o}) {\n          ${A}\n          result[1] = getChannel(getX(${Q.join()}), ${E});\n        }\n      `}else{const A=`\n        ${C} source = rc;\n        ${C} lt = ${C}(lessThan(source, start));\n        ${C} gte = ${C}(greaterThanEqual(source, end));\n        ${C} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${n}) +\n                gte * ((end - 1) * 2 - source + ${n});\n        source -= start;\n      `;s=`\n        ${C} rc = outputLoc;\n        ${A}\n        result[0] = getChannel(getX(${Q.join()}), ${E});\n        ${i[t-1]} += 1;\n        if(${o}) {\n          ${A}\n          result[1] = getChannel(getX(${Q.join()}), ${E});\n        }\n        rc = outputLoc;\n        ${i[t-2]} += 1;\n        if(${i[t-2]} < ${this.outputShape[t-2]}) {\n          ${A}\n          result[2] = getChannel(getX(${Q.join()}), ${E});\n          ${i[t-1]} += 1;\n          if(${o}) {\n            ${A}\n            result[3] = getChannel(getX(${Q.join()}), ${E});\n          }\n        }\n      `}this.userCode=`\n      const ${C} start = ${C}(${e});\n      const ${C} end = ${C}(${B});\n\n      void main() {\n        ${C} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${s}\n        setOutput(result);\n      }\n    `}}const tq={kernelName:TI,backendName:"webgl",kernelFunc:({inputs:A,backend:g,attrs:I})=>{const{x:t}=A,{paddings:C,mode:e}=I,B=ZA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Iq(t.shape,C,e):new gq(t.shape,C,e);return g.runWebGLProgram(B,[t],t.dtype)}},Cq=VY({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+kY+"\n  return result;\n"}),eq={kernelName:vI,backendName:"webgl",kernelFunc:Cq};class Bq{constructor(A,g,I){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[A,I],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${g-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${g-1}));\n      }\n    `}}const iq=VY({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Qq={kernelName:Zg,backendName:"webgl",kernelFunc:iq},oq="return a - b;",Eq=VY({opSnippet:oq,packedOpSnippet:oq,supportsComplex:!0,cpuKernelImpl:XJ}),nq={kernelName:Ot,backendName:"webgl",kernelFunc:Eq};function sq(A){const{inputs:g,backend:I,attrs:t}=A,{logits:C}=g,{dim:e}=t,B=DA([e],C.shape),i=HH({inputs:{x:C},backend:I,attrs:{reductionIndices:B,keepDims:!1}}),Q=SE(i.shape,B),o=_Y({inputs:{x:i},backend:I,attrs:{shape:Q}}),E=Eq({inputs:{a:C,b:o},backend:I}),n=Sb({inputs:{x:E},backend:I}),s=BL({inputs:{x:n},backend:I,attrs:{axis:B,keepDims:!1}}),a=_Y({inputs:{x:s},backend:I,attrs:{shape:Q}}),r=iq({inputs:{a:n,b:a},backend:I});return I.disposeIntermediateTensorInfo(i),I.disposeIntermediateTensorInfo(o),I.disposeIntermediateTensorInfo(E),I.disposeIntermediateTensorInfo(n),I.disposeIntermediateTensorInfo(s),I.disposeIntermediateTensorInfo(a),r}const aq={kernelName:Kt,backendName:"webgl",kernelFunc:sq};const rq={kernelName:VI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{logits:C}=g,{numSamples:e,seed:B,normalized:i}=t,Q=i?C:sq({inputs:{logits:C},backend:I,attrs:{dim:C.shape.length-1}}),o=Q.shape[0],E=Q.shape[1],n=new Bq(o,E,e),s=[[B]],a=I.runWebGLProgram(n,[Q],"int32",s);return i||I.disposeIntermediateTensorInfo(Q),a}},hq=oY+"\n  return -x;\n";const cq={kernelName:OI,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{x:t}=g;if(I.shouldExecuteOnCPU([t])){const A=I.texData.get(t.dataId),[g,C]=kJ(A.values,t.shape,t.dtype);return I.makeTensorInfo(C,t.dtype,g)}let C;return C=ZA().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new pY(t.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new QY(t.shape,hq),I.runWebGLProgram(C,[t],t.dtype)}},lq=fa;const Dq={kernelName:PI,backendName:"webgl",kernelFunc:function(A){EC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:g,backend:I,attrs:t}=A,{boxes:C,scores:e}=g,{maxOutputSize:B,iouThreshold:i,scoreThreshold:Q}=t,o=I.readSync(C.dataId),E=I.readSync(e.dataId),{selectedIndices:n}=lq(o,E,B,i,Q);return I.makeTensorInfo([n.length],"int32",new Int32Array(n))}},uq=Na;const wq={kernelName:XI,backendName:"webgl",kernelFunc:function(A){EC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:g,backend:I,attrs:t}=A,{boxes:C,scores:e}=g,{maxOutputSize:B,iouThreshold:i,scoreThreshold:Q,padToMaxOutputSize:o}=t,E=I.readSync(C.dataId),n=I.readSync(e.dataId),{selectedIndices:s,validOutputs:a}=uq(E,n,B,i,Q,o);return[I.makeTensorInfo([s.length],"int32",new Int32Array(s)),I.makeTensorInfo([],"int32",new Int32Array([a]))]}},dq=Fa;const pq={kernelName:jI,backendName:"webgl",kernelFunc:function(A){EC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:g,backend:I,attrs:t}=A,{boxes:C,scores:e}=g,{maxOutputSize:B,iouThreshold:i,scoreThreshold:Q,softNmsSigma:o}=t,E=I.readSync(C.dataId),n=I.readSync(e.dataId),s=B,a=i,r=Q,h=o,{selectedIndices:c,selectedScores:l}=dq(E,n,s,a,r,h);return[I.makeTensorInfo([c.length],"int32",new Int32Array(c)),I.makeTensorInfo([l.length],"float32",new Float32Array(l))]}};class yq{constructor(A,g,I,t){this.variableNames=["indices"],this.outputShape=[A,g],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${t}), float(${I}),\n                      float(index == coords.y)));\n      }\n    `}}const Gq={kernelName:_I,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I,attrs:t}=A,{indices:C}=g,{dtype:e,depth:B,onValue:i,offValue:Q}=t,o=QA(C.shape),E=new yq(o,B,i,Q),n=_Y({inputs:{x:C},backend:I,attrs:{shape:[o]}}),s=I.runWebGLProgram(E,[n],e);I.disposeIntermediateTensorInfo(n);const a=_Y({inputs:{x:s},backend:I,attrs:{shape:[...C.shape,B]}});return I.disposeIntermediateTensorInfo(s),a}};function fq(A){const{inputs:g,backend:I}=A,{x:t}=g;if("complex64"===t.dtype){const A=sx({inputs:{input:t},backend:I}),g=fq({inputs:{x:A},backend:I}),C=Rx({inputs:{input:t},backend:I}),e=fq({inputs:{x:C},backend:I}),B=KY({inputs:{real:g,imag:e},backend:I});return I.disposeIntermediateTensorInfo(A),I.disposeIntermediateTensorInfo(g),I.disposeIntermediateTensorInfo(C),I.disposeIntermediateTensorInfo(e),B}return Tb({attrs:{shape:t.shape,dtype:t.dtype,value:"string"===t.dtype?"":0},backend:I})}const Nq={kernelName:tC,backendName:"webgl",kernelFunc:fq};const Fq={kernelName:zI,backendName:"webgl",kernelFunc:function A(g){const{inputs:I,backend:t}=g,{x:C}=I;if("string"===C.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===C.dtype){const g=sx({inputs:{input:C},backend:t}),I=A({inputs:{x:g},backend:t}),e=Rx({inputs:{input:C},backend:t}),B=fq({inputs:{x:e},backend:t}),i=KY({inputs:{real:I,imag:B},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(B),i}return Tb({attrs:{shape:C.shape,dtype:C.dtype,value:1},backend:t})}};const Rq={kernelName:$I,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{axis:C}=t;if(1===g.length)return Ub({inputs:{input:g[0]},backend:I,attrs:{dim:C}});const e=g[0].shape,B=g[0].dtype;g.forEach((A=>{eA(e,A.shape,"All tensors passed to stack must have matching shapes"),CA(B===A.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],Q=Sx({inputs:g.map((A=>{const g=Ub({inputs:{input:A},backend:I,attrs:{dim:C}});return i.push(g),g})),backend:I,attrs:{axis:C}});return i.forEach((A=>I.disposeIntermediateTensorInfo(A))),Q}};class mq{constructor(A,g,I){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=g.map(((g,I)=>g[0]+A[I]+g[1]));const t=A.length,C=LK(t),e=g.map((A=>A[0])).join(","),B=g.map(((g,I)=>g[0]+A[I])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t);this.userCode=1!==t?`\n      ${C} start = ${C}(${e});\n      ${C} end = ${C}(${B});\n\n      void main() {\n        ${C} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${C} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${e};\n        int end = ${B};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class kq{constructor(A,g,I){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=g.map(((g,I)=>g[0]+A[I]+g[1]));const t=A.length,C=LK(t),e=g.map((A=>A[0])).join(","),B=g.map(((g,I)=>g[0]+A[I])).join(","),i=gY("rc",t),Q=gY("source",t),o=`${i[t-1]} < ${this.outputShape[t-1]}`,E=1===t?"source":`vec2(${Q.slice(-2).join()})`,n=[`${C} rc = outputLoc;`,`${i[t-1]} += 1;\n       if(${o}) {\n      `,1===t?"":`}\n       rc = outputLoc;\n       ${i[t-2]} += 1;\n       if(${i[t-2]} < ${this.outputShape[t-2]}) {`,1===t?"":`  ${i[t-1]} += 1;\n         if(${o}) {`],s=1===t?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let a="";for(let A=0,g=1===t?2:4;A<g;A++)a+=`\n        ${n[A]}\n        if (${s}) {\n          result[${A}] = float(value);\n        } else {\n          ${C} source = rc - start;\n          result[${A}] = getChannel(getX(${Q.join()}), ${E});\n        }\n      `;a+=1===t?"} ":"}}",this.userCode=`\n      const ${C} start = ${C}(${e});\n      const ${C} end = ${C}(${B});\n\n      void main() {\n        ${C} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${a}\n        setOutput(result);\n      }\n    `}}const Sq=A=>{const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{paddings:e,constantValue:B}=t;if(0===QA(C.shape)){const A=e.map(((A,g)=>A[0]+C.shape[g]+A[1]));return Tb({backend:I,attrs:{shape:A,value:B,dtype:C.dtype}})}const i=ZA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kq(C.shape,e,B):new mq(C.shape,e,B),Q=[[B]];return I.runWebGLProgram(i,[C],C.dtype,Q)},Mq={kernelName:At,backendName:"webgl",kernelFunc:Sq},Uq=VY({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+kY+"\n  return result;\n"}),Kq={kernelName:It,backendName:"webgl",kernelFunc:Uq};const Jq={kernelName:Ct,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{axis:e,keepDims:B}=t,i=C.shape.length,Q=[],o=DA(e,C.shape);let E=o;const n=UE(E,i);let s,a=C;if(null!=n&&(a=QL({inputs:{x:C},backend:I,attrs:{perm:n}}),E=JE(E.length,i),Q.push(a)),ME("prod",E,i),I.shouldExecuteOnCPU([a])){const A=I.texData.get(a.dataId).values,{outVals:g,outShape:t,outDtype:C}=MJ(a.shape,a.dtype,A,E);s=I.makeTensorInfo(t,C,g)}else{const[A,g]=kE(a.shape,E),t=QA(g),e=_Y({inputs:{x:a},backend:I,attrs:{shape:[-1,t]}}),B=IL(e,re(C.dtype),"prod",I);s=_Y({inputs:{x:B},backend:I,attrs:{shape:A}}),Q.push(e),Q.push(B)}if(B){Q.push(s);const A=SE(s.shape,o);s=_Y({inputs:{x:s},backend:I,attrs:{shape:A}})}return Q.forEach((A=>I.disposeIntermediateTensorInfo(A))),s}};const Yq={kernelName:et,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{paramsNestedSplits:C,paramsDenseValues:e,indices:B}=g,{outputRaggedRank:i}=t,Q=C.map((A=>I.readSync(A.dataId))),o=C.map((A=>A.shape)),E=I.readSync(e.dataId),n=I.readSync(B.dataId),[s,a,r]=UJ(Q,o,E,e.shape,e.dtype,n,B.shape,i),h=s.map((A=>I.makeTensorInfo([A.length],"int32",A))),c=I.makeTensorInfo(r,e.dtype,a);return h.concat([c])}};const Lq={kernelName:Bt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{shape:C,values:e,defaultValue:B,rowPartitionTensors:i}=g,{rowPartitionTypes:Q}=t,o=I.readSync(C.dataId),E=I.readSync(e.dataId),n=I.readSync(B.dataId),s=i.map((A=>I.readSync(A.dataId))),a=i.map((A=>A.shape)),[r,h]=KJ(o,C.shape,E,e.shape,e.dtype,n,B.shape,s,a,Q);return I.makeTensorInfo(r,e.dtype,h)}},xq=A=>{const{backend:g,attrs:I}=A,{start:t,stop:C,step:e,dtype:B}=I,i=JJ(t,C,e,B);return g.makeTensorInfo([i.length],B,i)},bq={kernelName:it,backendName:"webgl",kernelFunc:xq},Hq=vY({opSnippet:"return 1.0 / x;"}),qq={kernelName:ot,backendName:"webgl",kernelFunc:Hq},Tq=vY({opSnippet:oY+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),vq={kernelName:Et,backendName:"webgl",kernelFunc:Tq},Vq=vY({opSnippet:oY+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Wq={kernelName:ct,backendName:"webgl",kernelFunc:Vq};class Oq{constructor(A,g,I,t,C){this.variableNames=["A"],this.outputShape=[];const[e,B,i,Q]=A;this.outputShape=[e,g,I,Q];const o=[t&&g>1?B-1:B,t&&I>1?i-1:i],E=[t&&g>1?g-1:g,t&&I>1?I-1:I];let n;n=C?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${o[0]/E[0]},\n          ${o[1]/E[1]});\n      const vec2 inputShapeRC = vec2(${B}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${n};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Zq{constructor(A,g,I,t,C){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[e,B,i,Q]=A;this.outputShape=[e,g,I,Q];const o=[t&&g>1?B-1:B,t&&I>1?i-1:i],E=[t&&g>1?g-1:g,t&&I>1?I-1:I];let n;n=C?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${o[0]/E[0]},\n          ${o[1]/E[1]},\n          ${o[1]/E[1]});\n      const vec3 inputShapeRC = vec3(${B}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${n};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${Q-1};\n        bool hasNextRow = coords.z < ${I-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Pq={kernelName:rt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C}=g,{alignCorners:e,halfPixelCenters:B,size:i}=t,[Q,o]=i,E=ZA().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Zq(C.shape,Q,o,e,B):new Oq(C.shape,Q,o,e,B);return I.runWebGLProgram(E,[C],"float32")}};class Xq{constructor(A,g,I){this.variableNames=["dy"],this.outputShape=[],this.outputShape=g;const[,t,C]=g,[,e,B]=A,i=[I&&e>1?t-1:t,I&&B>1?C-1:C],Q=[I&&e>1?e-1:e,I&&B>1?B-1:B],o=i[0]/Q[0],E=i[1]/Q[1],n=1/o,s=1/E,a=2*Math.ceil(n)+2,r=2*Math.ceil(s)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${o});\n        const float widthScale = float(${E});\n\n        const float invHeightScale = float(${n});\n        const float invWidthScale = float(${s});\n\n        const int winHeight = int(${a});\n        const int winWidth = int(${r});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${e}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${B}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${t-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${C-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const jq={kernelName:ht,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C,dy:e}=g,{alignCorners:B}=t,i=new Xq(e.shape,C.shape,B);return I.runWebGLProgram(i,[e],e.dtype)}};class zq{constructor(A,g,I,t,C){this.variableNames=["A"],this.outputShape=[];const[e,B,i,Q]=A;this.outputShape=[e,g,I,Q];const o=[t&&g>1?B-1:B,t&&I>1?i-1:i],E=[t&&g>1?g-1:g,t&&I>1?I-1:I],n=t?"0.5":"0.0";let s;s=C?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${o[0]/E[0]},\n          ${o[1]/E[1]});\n      const vec2 inputShapeRC = vec2(${B}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${s};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${n})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class _q{constructor(A,g,I,t,C){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[e,B,i,Q]=A;this.outputShape=[e,g,I,Q];const o=[t&&g>1?B-1:B,t&&I>1?i-1:i],E=[t&&g>1?g-1:g,t&&I>1?I-1:I],n=t?"0.5":"0.0";let s;s=C?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${o[0]/E[0]},\n          ${o[1]/E[1]},\n          ${o[1]/E[1]});\n      const vec3 inputShapeRC = vec3(${B}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${s};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${n})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${Q-1};\n        bool hasNextRow = coords.z < ${I-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const $q={kernelName:st,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C}=g,{alignCorners:e,halfPixelCenters:B,size:i}=t,[Q,o]=i,E=ZA().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new _q(C.shape,Q,o,e,B):new zq(C.shape,Q,o,e,B);return I.runWebGLProgram(E,[C],C.dtype)}};class AT{constructor(A,g,I){this.variableNames=["dy"],this.outputShape=[],this.outputShape=g;const[,t,C]=g,[,e,B]=A,i=[I&&e>1?t-1:t,I&&B>1?C-1:C],Q=[I&&e>1?e-1:e,I&&B>1?B-1:B],o=i[0]/Q[0],E=i[1]/Q[1],n=1/o,s=1/E,a=2*Math.ceil(n)+2,r=2*Math.ceil(s)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${o});\n        const float widthScale = float(${E});\n\n        const float invHeightScale = float(${n});\n        const float invWidthScale = float(${s});\n\n        const int winHeight = int(${a});\n        const int winWidth = int(${r});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${e}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${B}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${Q[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${Q[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${t}) - 1),\n                ${I} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${C}) - 1),\n                ${I} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const gT={kernelName:at,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{images:C,dy:e}=g,{alignCorners:B}=t,i=new AT(e.shape,C.shape,B);return I.runWebGLProgram(i,[e],e.dtype)}};class IT{constructor(A,g){this.variableNames=["x"];const I=A.length;if(I>4)throw new Error(`WebGL backend: Reverse of rank-${I} tensor is not yet supported`);if(this.outputShape=A,1===I)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${A[0]} - coord - 1));\n        }\n      `);const t=A.map(((I,t)=>(I=>-1!==g.indexOf(I)&&1!==A[I]?`${A[I]} - coords[${I}] - 1`:`coords[${I}]`)(t))).join(","),C=LK(I);this.userCode=`\n      void main() {\n        ${C} coords = getOutputCoords();\n        setOutput(getX(${t}));\n      }\n    `}}class tT{constructor(A,g){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const I=A.length;if(I>4)throw new Error(`WebGL backend: Reverse of rank-${I} tensor is not yet supported`);this.outputShape=A;const t=gY("rc",I),C=`${t[I-1]} + 1 < ${this.outputShape[I-1]}`,e=`${t[I-2]} + 1 < ${this.outputShape[I-2]}`,B=LK(I);function i(I){const t=A.map(((t,C)=>function(I,t){return-1!==g.indexOf(I)&&1!==A[I]?`${A[I]} - ${t[I]} - 1`:`${t[I]}`}(C,I)));return`getChannel(getX(${t.join(",")}), vec2(${t.slice(-2).join(",")}))`}this.userCode=1===I?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${A[0]} - rc - 1),\n            ${A[0]} - rc - 1);\n          if(${C}){\n              result.g = getChannel(getX(${A[0]} - (rc  + 1) - 1),\n                ${A[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${B} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(A){return i(A)}(t.slice())};\n          if(${C}){\n            result.g = ${function(A){return A[I-1]="("+A[I-1]+" + 1)",i(A)}(t.slice())};\n          }\n          if(${e}) {\n            result.b = ${function(A){return A[I-2]="("+A[I-2]+" + 1)",i(A)}(t.slice())};\n            if(${C}) {\n              result.a = ${function(A){return A[I-1]="("+A[I-1]+" + 1)",A[I-2]="("+A[I-2]+" + 1)",i(A)}(t.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const CT={kernelName:lt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{dims:e}=t,B=C.shape.length,i=DA(e,C.shape);if(0===B)return MY({inputs:{x:C},backend:I});const Q=ZA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tT(C.shape,i):new IT(C.shape,i);return I.runWebGLProgram(Q,[C],C.dtype)}};class eT{constructor(A,g){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const I=A[1],t=A[2];this.outputShape=A;let C="";C="number"==typeof g?`float outputValue = ${g.toFixed(2)};`:`\n        vec3 fill = vec3(${g.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${C}\n          if(coordX >= 0 && coordX < ${t} && coordY >= 0 && coordY < ${I}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const BT={kernelName:BC,backendName:"webgl",kernelFunc:({inputs:A,attrs:g,backend:I})=>{const{image:t}=A,{radians:C,fillValue:e,center:B}=g,i=I,Q=new eT(t.shape,e),[o,E]=Fr(B,t.shape[1],t.shape[2]),n=[[o,E,Math.sin(C),Math.cos(C)]];return i.runWebGLProgram(Q,[t],t.dtype,n)}},iT=vY({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),QT={kernelName:Dt,backendName:"webgl",kernelFunc:iT},oT=vY({opSnippet:"return inversesqrt(x);",cpuKernelImpl:YJ}),ET={kernelName:ut,backendName:"webgl",kernelFunc:oT};class nT{constructor(A,g,I,t,C,e,B=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=e;const i=LK(C.length),Q=LK(e.length);let o="";1===I?o="i":2===I&&(o="i, j");const E=`getIndices(${o})`;let n="";1===t?n="i":2===t&&(n="i, coords[1]");const s=`getUpdates(${n})`,a=g>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${C});\n\n        void main() {\n          ${Q} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${A}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${g}; j++) {\n              int index = round(${E});\n              flattenedIndex += index * ${a};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${s};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const sT={kernelName:wt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{indices:C,updates:e}=g,{shape:B}=t,{sliceRank:i,numUpdates:Q,sliceSize:o,strides:E,outputSize:n}=zi(0,C,B),s=[n/o,o];if(0===n)return I.makeTensorInfo(B,C.dtype);const a=_Y({inputs:{x:C},backend:I,attrs:{shape:[Q,i]}}),r=_Y({inputs:{x:e},backend:I,attrs:{shape:[Q,o]}}),h=I.makeTensorInfo([],"float32",new Float32Array([0])),c=new nT(Q,i,a.shape.length,r.shape.length,E,s),l=I.runWebGLProgram(c,[r,a,h],r.dtype),D=_Y({inputs:{x:l},backend:I,attrs:{shape:B}});return I.disposeIntermediateTensorInfo(a),I.disposeIntermediateTensorInfo(r),I.disposeIntermediateTensorInfo(l),I.disposeIntermediateTensorInfo(h),D}};class aT{constructor(A,g,I,t){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[A,I];const C=`for (int i = 0; i < ${Math.ceil(Math.log2(g+1))}; ++i) { if (left >= right) break;`,e=2===ZA().getNumber("WEBGL_VERSION")?"while (left < right) {":C,B="left"===t?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${e}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${B} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const rT={kernelName:dt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{sortedSequence:C,values:e}=g,{side:B}=t,i=new aT(C.shape[0],C.shape[1],e.shape[1],B),Q=[[C.shape[1]]];return I.runWebGLProgram(i,[C,e],"int32",Q)}};class hT{constructor(A,g,I){let t,C;if(this.variableNames=["c","a","b"],this.outputShape=g,I>4)throw Error(`Where for rank ${I} is not yet supported`);if(1===I)C="resRC",t="resRC";else{const I=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[],B=[];for(let t=0;t<g.length;t++)B.push(`${I[t]}`),t<A&&e.push(`${I[t]}`);t=e.join(),C=B.join()}const e=LK(I);this.userCode=`\n      void main() {\n        ${e} resRC = getOutputCoords();\n        float cVal = getC(${t});\n        if (cVal >= 1.0) {\n          setOutput(getA(${C}));\n        } else {\n          setOutput(getB(${C}));\n        }\n      }\n    `}}const cT={kernelName:pt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{condition:t,t:C,e}=g,B=new hT(t.shape.length,C.shape,C.shape.length);return I.runWebGLProgram(B,[t,C,e],ae(C.dtype,e.dtype))}},lT=vY({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Ur};\n  float scale = ${Kr};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),DT={kernelName:yt,backendName:"webgl",kernelFunc:lT},uT=vY({opSnippet:TY+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:xJ}),wT={kernelName:Rt,backendName:"webgl",kernelFunc:uT},dT=vY({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),pT={kernelName:Ft,backendName:"webgl",kernelFunc:dT},yT=vY({opSnippet:TY+"\n  return sin(x);\n"}),GT={kernelName:ft,backendName:"webgl",kernelFunc:yT},fT=vY({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),NT={kernelName:Nt,backendName:"webgl",kernelFunc:fT},FT=vY({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),RT={kernelName:mt,backendName:"webgl",kernelFunc:FT},mT={kernelName:Mt,backendName:"webgl",kernelFunc:A=>{const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{blockShape:e,paddings:B}=t;CA(C.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=e.reduce(((A,g)=>A*g)),Q=[[0,0]];Q.push(...B);for(let A=1+e.length;A<C.shape.length;++A)Q.push([0,0]);const o=[],E=Sq({inputs:{x:C},backend:I,attrs:{paddings:Q,constantValue:0}}),n=Rr(E.shape,e,i,!1),s=mr(n.length,e.length,!1),a=kr(E.shape,e,i,!1),r=_Y({inputs:{x:E},backend:I,attrs:{shape:n}}),h=QL({inputs:{x:r},backend:I,attrs:{perm:s}}),c=_Y({inputs:{x:h},backend:I,attrs:{shape:a}});return o.push(E),o.push(r),o.push(h),o.forEach((A=>I.disposeIntermediateTensorInfo(A))),c}};const kT={kernelName:Jt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{indices:t,values:C,denseShape:e,defaultValue:B}=g;if(1!==e.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${e.shape}`);if(2!==t.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${t.shape}`);if(1!==C.shape.length)throw new Error(`Values must be a vector, saw:\n         ${C.shape}`);if(0!==B.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${B.shape}`);const i=I.readSync(t.dataId),Q=I.readSync(C.dataId),o=I.readSync(e.dataId),E=I.readSync(B.dataId)[0],[n,s,a,r,h]=qJ(i,t.shape,t.dtype,Q,C.dtype,o,E);return[I.makeTensorInfo(s,t.dtype,n),I.makeTensorInfo([s[0]],C.dtype,a),I.makeTensorInfo([r.length],"bool",new Uint8Array(r.map((A=>Number(A))))),I.makeTensorInfo([h.length],t.dtype,new Int32Array(h))]}};const ST={kernelName:Yt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{inputIndices:t,inputShape:C,newShape:e}=g;if(2!==t.shape.length)throw new Error(`Input indices should be a matrix but received shape ${t.shape}`);if(1!==C.shape.length)throw new Error(`Input shape should be a vector but received shape ${C.shape}`);if(1!==e.shape.length)throw new Error(`Target shape should be a vector but received shape ${e.shape}`);const B=Array.from(I.readSync(C.dataId)),i=I.readSync(t.dataId),Q=Array.from(I.readSync(e.dataId)),[o,E,n]=TJ(i,t.shape,t.dtype,B,Q);return[I.makeTensorInfo(E,t.dtype,o),I.makeTensorInfo([n.length],e.dtype,new Int32Array(n))]}};const MT={kernelName:Lt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{data:t,indices:C,segmentIds:e}=g;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==C.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${C.shape}`);if(1!==e.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${e.shape}`);const B=I.readSync(t.dataId),i=I.readSync(C.dataId),Q=I.readSync(e.dataId),[o,E]=vJ(B,t.shape,t.dtype,i,Q,!0);return I.makeTensorInfo(E,t.dtype,o)}};const UT={kernelName:xt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I}=A,{data:t,indices:C,segmentIds:e}=g;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==C.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${C.shape}`);if(1!==e.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${e.shape}`);const B=I.readSync(t.dataId),i=I.readSync(C.dataId),Q=I.readSync(e.dataId),[o,E]=vJ(B,t.shape,t.dtype,i,Q);return I.makeTensorInfo(E,t.dtype,o)}};const KT={kernelName:bt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{sparseIndices:C,sparseValues:e,defaultValue:B}=g,{outputShape:i}=t,{sliceRank:Q,numUpdates:o,sliceSize:E,strides:n,outputSize:s}=zi(0,C,i);if("string"===e.dtype){const A=I.bufferSync(C),g=I.bufferSync(e),t=TC(I.readSync(B.dataId)[0]),a=LJ(A,g,i,s,E,o,Q,n,t,false);return I.makeTensorInfo(i,a.dtype,a.values)}const a=new nT(o,Q,C.shape.length,e.shape.length,n,[s,1],false),r=I.runWebGLProgram(a,[e,C,B],e.dtype),h=_Y({inputs:{x:r},backend:I,attrs:{shape:i}});return I.disposeIntermediateTensorInfo(r),h}};const JT={kernelName:Ut,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{numOrSizeSplits:e,axis:B}=t,i=DA(B,C.shape)[0],Q=eh(C,e,i),o=C.shape.length,E=new Array(o).fill(0),n=C.shape.slice();return Q.map((A=>{const g=[...n];g[i]=A;const t=ex({inputs:{x:C},backend:I,attrs:{begin:E,size:g}});return E[i]+=A,t}))}},YT="return sqrt(x);",LT=vY({opSnippet:YT,packedOpSnippet:YT,cpuKernelImpl:VJ}),xT={kernelName:kt,backendName:"webgl",kernelFunc:LT},bT=vY({opSnippet:"return x * x;"}),HT={kernelName:qt,backendName:"webgl",kernelFunc:bT},qT="return (a - b) * (a - b);",TT=VY({opSnippet:qT,packedOpSnippet:qT}),vT={kernelName:Ht,backendName:"webgl",kernelFunc:TT};const VT={kernelName:CC,backendName:"webgl",kernelFunc:function({inputs:A,attrs:g,backend:I}){const{x:t}=A,C=oY+`\n    return x > 0.0 ? 1.0 : float(${g.alpha});\n  `,e=new QY(t.shape,C);return I.runWebGLProgram(e,[t],t.dtype)}};class WT{constructor(A,g,I){this.variableNames=["x"],this.outputShape=I;const t=I.length,C=LK(I.length),e=LK(I.length);let B="";if(1===t)B="coords * strides + begin";else{let A=0;B=I.map(((g,t)=>(A++,1===I.length?`coords * strides[${t}] + begin[${t}]`:`coords[${A-1}] * strides[${t}] + begin[${t}]`))).join(",")}this.userCode=`\n      ${C} begin = ${C}(${A});\n      ${C} strides = ${C}(${g});\n\n      void main() {\n        ${e} coords = getOutputCoords();\n        setOutput(getX(${B}));\n      }\n    `}}const OT={kernelName:Tt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{begin:e,end:B,strides:i,beginMask:Q,endMask:o,ellipsisMask:E,newAxisMask:n,shrinkAxisMask:s}=t,{finalShapeSparse:a,finalShape:r,isIdentity:h,sliceDim0:c,isSimpleSlice:l,begin:D,end:u,strides:w}=hQ(C.shape,e,B,i,Q,o,E,n,s);let d;if(h)d=_Y({inputs:{x:C},backend:I,attrs:{shape:r}});else if(c||l){CA(C.shape.length>=1,(()=>`Input must have rank at least 1, got: ${C.shape.length}`));const A=IQ(D,u,w),g=ex({inputs:{x:C},backend:I,attrs:{begin:D,size:A}});d=_Y({inputs:{x:g},backend:I,attrs:{shape:r}}),I.disposeIntermediateTensorInfo(g)}else{if(I.shouldExecuteOnCPU([C])){const A=I.readSync(C.dataId),g=HB(C.shape,C.dtype,A),t=WJ(a,g,w,D);d=I.makeTensorInfo(r,C.dtype,t.values)}else{const A=new WT(D,w,a);d=I.runWebGLProgram(A,[C],C.dtype)}}const p=_Y({inputs:{x:d},backend:I,attrs:{shape:r}});return I.disposeIntermediateTensorInfo(d),p}};const ZT={kernelName:vt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{separator:C,nGramWidths:e,leftPad:B,rightPad:i,padWidth:Q,preserveShortSequences:o}=t,{data:E,dataSplits:n}=g,s=I.readSync(E.dataId),a=I.readSync(n.dataId),[r,h]=OJ(s,a,C,e,B,i,Q,o);return[I.makeTensorInfo([r.length],"string",r),I.makeTensorInfo(n.shape,"int32",h)]}};const PT={kernelName:Vt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{skipEmpty:C}=t,{input:e,delimiter:B}=g;if("string"!==e.dtype)throw new Error("Input must be of datatype string");if(1!==e.shape.length)throw new Error(`Input must be a vector, got shape: ${e.shape}`);if(0!==B.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${B.shape}`);const i=I.readSync(e.dataId),Q=I.readSync(B.dataId)[0],[o,E,n]=ZJ(i,Q,C),s=E.length;return[I.makeTensorInfo([s,2],"int32",o),I.makeTensorInfo([s],"string",E),I.makeTensorInfo([2],"int32",new Int32Array(n))]}};const XT={kernelName:Wt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{numBuckets:C}=t,{input:e}=g;if("string"!==e.dtype)throw new Error("Input must be of datatype string");if(C<=0)throw new Error("Number of buckets must be at least 1");const B=I.readSync(e.dataId),i=PJ(B,C);return I.makeTensorInfo(e.shape,"int32",i)}},jT=vY({opSnippet:"return tan(x);"}),zT={kernelName:Zt,backendName:"webgl",kernelFunc:jT},_T=vY({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),$T={kernelName:Pt,backendName:"webgl",kernelFunc:_T};class Av{constructor(A,g){this.variableNames=["A"];const I=new Array(A.length);for(let t=0;t<I.length;t++)I[t]=A[t]*g[t];this.outputShape=I,this.rank=I.length;const t=LK(this.rank),C=function(A){const g=A.length;if(g>5)throw Error(`Tile for rank ${g} is not yet supported`);if(1===g)return`imod(resRC, ${A[0]})`;const I=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],t=[];for(let g=0;g<A.length;g++)t.push(`imod(${I[g]}, ${A[g]})`);return t.join()}(A);this.userCode=`\n      void main() {\n        ${t} resRC = getOutputCoords();\n        setOutput(getA(${C}));\n      }\n    `}}function gv(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{reps:e}=t;if("string"===C.dtype||C.shape.length>5){const A=I.readSync(C.dataId),g="string"===C.dtype?A.map((A=>TC(A))):A,t=HB(C.shape,C.dtype,g),B=jJ(t,e);return I.makeTensorInfo(B.shape,B.dtype,B.values)}const B=new Av(C.shape,e);return I.runWebGLProgram(B,[C],C.dtype)}const Iv={kernelName:Xt,backendName:"webgl",kernelFunc:gv};class tv{constructor(A){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=A,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Cv{constructor(A){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=A,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function ev(A,g){null!==g&&A.disposeIntermediateTensorInfo(g)}function Bv(A){let g=1;for(;g<A;)g*=2;return g}const iv={kernelName:jt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C}=g,{k:e,sorted:B}=t,i=ZA().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),Q=ZA().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),o=C.shape,E=o[o.length-1];if(I.shouldExecuteOnCPU([C])||E<i||e>Q){const A=I.readSync(C.dataId),[g,t]=zJ(A,o,C.dtype,e,B);return[I.makeTensorInfo(g.shape,g.dtype,g.values),I.makeTensorInfo(t.shape,t.dtype,t.values)]}if(0===e)return o[o.length-1]=0,[I.makeTensorInfo(o,C.dtype,[]),I.makeTensorInfo(o,"int32",[])];if(1===E)return[C,Tb({attrs:{shape:o,dtype:"int32",value:0},backend:I})];const n=I.texData.get(C.dataId),s=null!==n&&n.isPacked,a=s?I.unpackTensor(C):C,r=QA(o)/E,h=_Y({inputs:{x:a},attrs:{shape:[r,E]},backend:I});s&&ev(I,a);const c=Bv(e),l=Bv(E);let D=null;const u=()=>null===D?[h,h]:[h,D],w=(A,g,t)=>{const C=u(),e=new tv(t),B=[[E],[null===D?1:0],[Number.NEGATIVE_INFINITY],[A],[g]],i=D;D=I.runWebGLProgram(e,C,"int32",B),ev(I,i)};for(let A=1;A<c;A*=2){const g=2*A;for(let I=A;I>=1;I/=2)w(g,I,[r,l])}for(let A=l;A>c;A/=2){const g=u(),t=new Cv([r,A/2]),C=[[E],[null===D?1:0],[c]],e=D;D=I.runWebGLProgram(t,g,"int32",C),ev(I,e);const B=c/2,i=2*B;for(let A=B;A>=1;A/=2)w(i,A,D.shape)}let d=D;D=ex({inputs:{x:D},backend:I,attrs:{begin:0,size:[r,e]}}),ev(I,d);let p=iH({inputs:{x:h,indices:D},backend:I,attrs:{axis:1,batchDims:1}});ev(I,h);const y=o.slice(0,-1);y.push(e),d=D,D=_Y({inputs:{x:D},attrs:{shape:y},backend:I}),ev(I,d);const G=p;return p=_Y({inputs:{x:p},attrs:{shape:y},backend:I}),ev(I,G),[p,D]}};class Qv{constructor(A,g,I,t,C,e){this.variableNames=["Image","Transforms"],this.outputShape=e;const B="nearest"===I?1:2;let i;switch(t){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${A} && 0 <= coordX && coordX < ${g}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${C});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${C});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${g}));\n                float mapY = mapCoord(inY, float(${A}));\n\n                if (${B} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const ov={kernelName:zt,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{image:C,transforms:e}=g,{interpolation:B,fillMode:i,fillValue:Q,outputShape:o}=t,[E,n,s,a]=C.shape,[r,h]=null!=o?o:[n,s],c=new Qv(n,s,B,i,Q,[E,r,h,a]);return I.runWebGLProgram(c,[C,e],"float32")}};const Ev={kernelName:$t,backendName:"webgl",kernelFunc:function(A){const{inputs:g,attrs:I,backend:t}=A,{axis:C}=I,{x:e}=g;DK(e,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const B=t.readSync(e.dataId),{outputValues:i,outputShape:Q,indices:o}=$J(B,C,e.shape,e.dtype);return[t.makeTensorInfo(Q,e.dtype,i),t.makeTensorInfo([o.length],"int32",o)]}};const nv={kernelName:AC,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{value:C}=g;let{axis:e}=t;e<0&&(e+=C.shape.length);const B=C,i=B.shape.length,Q=C.shape[e],o=new Array(i-1);let E=0;for(let A=0;A<i;A++)A!==e&&(o[E++]=B.shape[A]);const n=[],s=new Array(i).fill(0),a=B.shape.slice();a[e]=1;const r=new Array(Q);for(let A=0;A<r.length;A++){s[e]=A;const g=ex({inputs:{x:B},backend:I,attrs:{begin:s,size:a}}),t=_Y({inputs:{x:g},backend:I,attrs:{shape:o}});r[A]=t,n.push(g)}return n.forEach((A=>I.disposeIntermediateTensorInfo(A))),r}};class sv{constructor(A,g){this.variableNames=["x","segmentIds"];const I=A.windowSize,t=A.batchSize,C=A.inSize,e=A.numSegments,B=e*Math.ceil(C/I);this.outputShape=[t,B];const i=4*Math.floor(I/4),Q=I%4,o="\n        sumValue += dot(values, segFilter);\n    ";let E="";C%I>0&&(E=`\n        if (inIdx < 0 || inIdx >= ${C}) {\n          return initializationValue;\n        }\n      `);let n="";C%I>0&&(n=`\n        if (inIdx < 0 || inIdx >= ${C}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${E}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${n}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${e})) * float(${I}));\n        int currentSeg = int(mod(float(outIdx), float(${e})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${o}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===Q}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${o}\n        } else if (${2===Q}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${o}\n        } else if (${3===Q}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${o}\n        }\n        setOutput(sumValue);\n      }\n    `}}const av={kernelName:gC,backendName:"webgl",kernelFunc:function(A){const{inputs:g,backend:I,attrs:t}=A,{x:C,segmentIds:e}=g,{numSegments:B}=t,i=C.shape.length,Q=[];let o=0;const E=UE([o],i);let n=C;null!=E&&(n=QL({inputs:{x:C},backend:I,attrs:{perm:E}}),Q.push(n),o=JE(1,i)[0]);const s=uh(n.shape,o,B),a=QA([n.shape[o]]),r=_Y({inputs:{x:n},backend:I,attrs:{shape:[-1,a]}});Q.push(r);const h=re(C.dtype),c=(A,g,t,C,e)=>{const B=A.shape[0],i=A.shape[1],o=Dh(i,e),E=new sv({windowSize:o,inSize:i,batchSize:B,numSegments:e},g),n=I.compileAndRun(E,[A,t],C);if(Q.push(n),n.shape[1]===e)return n;const s=xq({backend:I,attrs:{start:0,stop:e,step:1,dtype:"float32"}}),a=gv({inputs:{x:s},backend:I,attrs:{reps:[i/o]}});Q.push(s),Q.push(a);return c(n,g,a,C,e)},l=_Y({inputs:{x:c(r,"unsortedSegmentSum",e,h,B)},backend:I,attrs:{shape:s}});let D=l;if(null!=E){Q.push(l);const A=KE(E);D=QL({inputs:{x:D},backend:I,attrs:{perm:A}})}return Q.forEach((A=>I.disposeIntermediateTensorInfo(A))),D}},rv=[sL,rL,cL,DL,dL,GL,fL,NL,ML,UL,JL,LL,bL,qL,vL,OL,ZL,jL,zL,_L,gx,ix,Qx,ox,hx,Dx,dx,JY,Gx,Mx,Hx,Wx,Ox,Zx,Px,Xx,zx,$x,gb,ib,Qb,ob,nb,rb,lb,Db,wb,pb,yb,fb,Nb,Rb,kb,Mb,Kb,Lb,Hb,vb,Wb,Pb,jb,$b,IH,tH,eH,QH,EH,sH,UY,aH,mx,hH,lH,uH,xY,dH,yH,GH,NH,RH,kH,MH,KH,LH,bH,qH,vH,VH,WH,PH,XH,jH,zH,_H,Aq,tq,eq,rq,zY,cq,Dq,wq,pq,nx,Gq,Fq,Rq,Mq,Kq,qY,Jq,Yq,Lq,bq,ax,Qq,qq,vq,Wq,$Y,Pq,jq,$q,gT,CT,BT,QT,ET,sT,rT,cT,DT,wT,pT,GT,NT,Bx,aq,RT,mT,kT,ST,MT,UT,KT,JT,xT,HT,vT,VT,OT,ZT,PT,XT,nq,iL,zT,$T,Iv,iv,ov,oL,Ev,nv,av,Nq];for(const A of rv)lC(A);const hv={"tfjs-core":KQ,"tfjs-backend-cpu":"3.21.0","tfjs-backend-webgl":"3.21.0","tfjs-data":rF,"tfjs-layers":sw,"tfjs-converter":CN,tfjs:"3.21.0"}},720:A=>{A.exports=I;var g=null;try{g=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(A){}function I(A,g,I){this.low=0|A,this.high=0|g,this.unsigned=!!I}function t(A){return!0===(A&&A.__isLong__)}I.prototype.__isLong__,Object.defineProperty(I.prototype,"__isLong__",{value:!0}),I.isLong=t;var C={},e={};function B(A,g){var I,t,B;return g?(B=0<=(A>>>=0)&&A<256)&&(t=e[A])?t:(I=Q(A,(0|A)<0?-1:0,!0),B&&(e[A]=I),I):(B=-128<=(A|=0)&&A<128)&&(t=C[A])?t:(I=Q(A,A<0?-1:0,!1),B&&(C[A]=I),I)}function i(A,g){if(isNaN(A))return g?l:c;if(g){if(A<0)return l;if(A>=a)return p}else{if(A<=-r)return y;if(A+1>=r)return d}return A<0?i(-A,g).neg():Q(A%s|0,A/s|0,g)}function Q(A,g,t){return new I(A,g,t)}I.fromInt=B,I.fromNumber=i,I.fromBits=Q;var o=Math.pow;function E(A,g,I){if(0===A.length)throw Error("empty string");if("NaN"===A||"Infinity"===A||"+Infinity"===A||"-Infinity"===A)return c;if("number"==typeof g?(I=g,g=!1):g=!!g,(I=I||10)<2||36<I)throw RangeError("radix");var t;if((t=A.indexOf("-"))>0)throw Error("interior hyphen");if(0===t)return E(A.substring(1),g,I).neg();for(var C=i(o(I,8)),e=c,B=0;B<A.length;B+=8){var Q=Math.min(8,A.length-B),n=parseInt(A.substring(B,B+Q),I);if(Q<8){var s=i(o(I,Q));e=e.mul(s).add(i(n))}else e=(e=e.mul(C)).add(i(n))}return e.unsigned=g,e}function n(A,g){return"number"==typeof A?i(A,g):"string"==typeof A?E(A,g):Q(A.low,A.high,"boolean"==typeof g?g:A.unsigned)}I.fromString=E,I.fromValue=n;var s=4294967296,a=s*s,r=a/2,h=B(1<<24),c=B(0);I.ZERO=c;var l=B(0,!0);I.UZERO=l;var D=B(1);I.ONE=D;var u=B(1,!0);I.UONE=u;var w=B(-1);I.NEG_ONE=w;var d=Q(-1,2147483647,!1);I.MAX_VALUE=d;var p=Q(-1,-1,!0);I.MAX_UNSIGNED_VALUE=p;var y=Q(0,-2147483648,!1);I.MIN_VALUE=y;var G=I.prototype;G.toInt=function(){return this.unsigned?this.low>>>0:this.low},G.toNumber=function(){return this.unsigned?(this.high>>>0)*s+(this.low>>>0):this.high*s+(this.low>>>0)},G.toString=function(A){if((A=A||10)<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(y)){var g=i(A),I=this.div(g),t=I.mul(g).sub(this);return I.toString(A)+t.toInt().toString(A)}return"-"+this.neg().toString(A)}for(var C=i(o(A,6),this.unsigned),e=this,B="";;){var Q=e.div(C),E=(e.sub(Q.mul(C)).toInt()>>>0).toString(A);if((e=Q).isZero())return E+B;for(;E.length<6;)E="0"+E;B=""+E+B}},G.getHighBits=function(){return this.high},G.getHighBitsUnsigned=function(){return this.high>>>0},G.getLowBits=function(){return this.low},G.getLowBitsUnsigned=function(){return this.low>>>0},G.getNumBitsAbs=function(){if(this.isNegative())return this.eq(y)?64:this.neg().getNumBitsAbs();for(var A=0!=this.high?this.high:this.low,g=31;g>0&&0==(A&1<<g);g--);return 0!=this.high?g+33:g+1},G.isZero=function(){return 0===this.high&&0===this.low},G.eqz=G.isZero,G.isNegative=function(){return!this.unsigned&&this.high<0},G.isPositive=function(){return this.unsigned||this.high>=0},G.isOdd=function(){return 1==(1&this.low)},G.isEven=function(){return 0==(1&this.low)},G.equals=function(A){return t(A)||(A=n(A)),(this.unsigned===A.unsigned||this.high>>>31!=1||A.high>>>31!=1)&&(this.high===A.high&&this.low===A.low)},G.eq=G.equals,G.notEquals=function(A){return!this.eq(A)},G.neq=G.notEquals,G.ne=G.notEquals,G.lessThan=function(A){return this.comp(A)<0},G.lt=G.lessThan,G.lessThanOrEqual=function(A){return this.comp(A)<=0},G.lte=G.lessThanOrEqual,G.le=G.lessThanOrEqual,G.greaterThan=function(A){return this.comp(A)>0},G.gt=G.greaterThan,G.greaterThanOrEqual=function(A){return this.comp(A)>=0},G.gte=G.greaterThanOrEqual,G.ge=G.greaterThanOrEqual,G.compare=function(A){if(t(A)||(A=n(A)),this.eq(A))return 0;var g=this.isNegative(),I=A.isNegative();return g&&!I?-1:!g&&I?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},G.comp=G.compare,G.negate=function(){return!this.unsigned&&this.eq(y)?y:this.not().add(D)},G.neg=G.negate,G.add=function(A){t(A)||(A=n(A));var g=this.high>>>16,I=65535&this.high,C=this.low>>>16,e=65535&this.low,B=A.high>>>16,i=65535&A.high,o=A.low>>>16,E=0,s=0,a=0,r=0;return a+=(r+=e+(65535&A.low))>>>16,s+=(a+=C+o)>>>16,E+=(s+=I+i)>>>16,E+=g+B,Q((a&=65535)<<16|(r&=65535),(E&=65535)<<16|(s&=65535),this.unsigned)},G.subtract=function(A){return t(A)||(A=n(A)),this.add(A.neg())},G.sub=G.subtract,G.multiply=function(A){if(this.isZero())return c;if(t(A)||(A=n(A)),g)return Q(g.mul(this.low,this.high,A.low,A.high),g.get_high(),this.unsigned);if(A.isZero())return c;if(this.eq(y))return A.isOdd()?y:c;if(A.eq(y))return this.isOdd()?y:c;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(h)&&A.lt(h))return i(this.toNumber()*A.toNumber(),this.unsigned);var I=this.high>>>16,C=65535&this.high,e=this.low>>>16,B=65535&this.low,o=A.high>>>16,E=65535&A.high,s=A.low>>>16,a=65535&A.low,r=0,l=0,D=0,u=0;return D+=(u+=B*a)>>>16,l+=(D+=e*a)>>>16,D&=65535,l+=(D+=B*s)>>>16,r+=(l+=C*a)>>>16,l&=65535,r+=(l+=e*s)>>>16,l&=65535,r+=(l+=B*E)>>>16,r+=I*a+C*s+e*E+B*o,Q((D&=65535)<<16|(u&=65535),(r&=65535)<<16|(l&=65535),this.unsigned)},G.mul=G.multiply,G.divide=function(A){if(t(A)||(A=n(A)),A.isZero())throw Error("division by zero");var I,C,e;if(g)return this.unsigned||-2147483648!==this.high||-1!==A.low||-1!==A.high?Q((this.unsigned?g.div_u:g.div_s)(this.low,this.high,A.low,A.high),g.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?l:c;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return l;if(A.gt(this.shru(1)))return u;e=l}else{if(this.eq(y))return A.eq(D)||A.eq(w)?y:A.eq(y)?D:(I=this.shr(1).div(A).shl(1)).eq(c)?A.isNegative()?D:w:(C=this.sub(A.mul(I)),e=I.add(C.div(A)));if(A.eq(y))return this.unsigned?l:c;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();e=c}for(C=this;C.gte(A);){I=Math.max(1,Math.floor(C.toNumber()/A.toNumber()));for(var B=Math.ceil(Math.log(I)/Math.LN2),E=B<=48?1:o(2,B-48),s=i(I),a=s.mul(A);a.isNegative()||a.gt(C);)a=(s=i(I-=E,this.unsigned)).mul(A);s.isZero()&&(s=D),e=e.add(s),C=C.sub(a)}return e},G.div=G.divide,G.modulo=function(A){return t(A)||(A=n(A)),g?Q((this.unsigned?g.rem_u:g.rem_s)(this.low,this.high,A.low,A.high),g.get_high(),this.unsigned):this.sub(this.div(A).mul(A))},G.mod=G.modulo,G.rem=G.modulo,G.not=function(){return Q(~this.low,~this.high,this.unsigned)},G.and=function(A){return t(A)||(A=n(A)),Q(this.low&A.low,this.high&A.high,this.unsigned)},G.or=function(A){return t(A)||(A=n(A)),Q(this.low|A.low,this.high|A.high,this.unsigned)},G.xor=function(A){return t(A)||(A=n(A)),Q(this.low^A.low,this.high^A.high,this.unsigned)},G.shiftLeft=function(A){return t(A)&&(A=A.toInt()),0==(A&=63)?this:A<32?Q(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):Q(0,this.low<<A-32,this.unsigned)},G.shl=G.shiftLeft,G.shiftRight=function(A){return t(A)&&(A=A.toInt()),0==(A&=63)?this:A<32?Q(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):Q(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},G.shr=G.shiftRight,G.shiftRightUnsigned=function(A){if(t(A)&&(A=A.toInt()),0===(A&=63))return this;var g=this.high;return A<32?Q(this.low>>>A|g<<32-A,g>>>A,this.unsigned):Q(32===A?g:g>>>A-32,0,this.unsigned)},G.shru=G.shiftRightUnsigned,G.shr_u=G.shiftRightUnsigned,G.toSigned=function(){return this.unsigned?Q(this.low,this.high,!1):this},G.toUnsigned=function(){return this.unsigned?this:Q(this.low,this.high,!0)},G.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},G.toBytesLE=function(){var A=this.high,g=this.low;return[255&g,g>>>8&255,g>>>16&255,g>>>24,255&A,A>>>8&255,A>>>16&255,A>>>24]},G.toBytesBE=function(){var A=this.high,g=this.low;return[A>>>24,A>>>16&255,A>>>8&255,255&A,g>>>24,g>>>16&255,g>>>8&255,255&g]},I.fromBytes=function(A,g,t){return t?I.fromBytesLE(A,g):I.fromBytesBE(A,g)},I.fromBytesLE=function(A,g){return new I(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,g)},I.fromBytesBE=function(A,g){return new I(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],g)}},377:(A,g,I)=>{var t=I(832),C=I(652),e=I(801),B=I(30),i=I(618),Q=I(49),o=I(971);o.alea=t,o.xor128=C,o.xorwow=e,o.xorshift7=B,o.xor4096=i,o.tychei=Q,A.exports=o},832:function(A,g,I){var t;!function(A,C,e){function B(A){var g=this,I=function(){var A=4022871197,g=function(g){g=String(g);for(var I=0;I<g.length;I++){var t=.02519603282416938*(A+=g.charCodeAt(I));t-=A=t>>>0,A=(t*=A)>>>0,A+=4294967296*(t-=A)}return 2.3283064365386963e-10*(A>>>0)};return g}();g.next=function(){var A=2091639*g.s0+2.3283064365386963e-10*g.c;return g.s0=g.s1,g.s1=g.s2,g.s2=A-(g.c=0|A)},g.c=1,g.s0=I(" "),g.s1=I(" "),g.s2=I(" "),g.s0-=I(A),g.s0<0&&(g.s0+=1),g.s1-=I(A),g.s1<0&&(g.s1+=1),g.s2-=I(A),g.s2<0&&(g.s2+=1),I=null}function i(A,g){return g.c=A.c,g.s0=A.s0,g.s1=A.s1,g.s2=A.s2,g}function Q(A,g){var I=new B(A),t=g&&g.state,C=I.next;return C.int32=function(){return 4294967296*I.next()|0},C.double=function(){return C()+11102230246251565e-32*(2097152*C()|0)},C.quick=C,t&&("object"==typeof t&&i(t,I),C.state=function(){return i(I,{})}),C}C&&C.exports?C.exports=Q:I.amdD&&I.amdO?void 0===(t=function(){return Q}.call(g,I,g,C))||(C.exports=t):this.alea=Q}(0,A=I.nmd(A),I.amdD)},49:function(A,g,I){var t;!function(A,C,e){function B(A){var g=this,I="";g.next=function(){var A=g.b,I=g.c,t=g.d,C=g.a;return A=A<<25^A>>>7^I,I=I-t|0,t=t<<24^t>>>8^C,C=C-A|0,g.b=A=A<<20^A>>>12^I,g.c=I=I-t|0,g.d=t<<16^I>>>16^C,g.a=C-A|0},g.a=0,g.b=0,g.c=-1640531527,g.d=1367130551,A===Math.floor(A)?(g.a=A/4294967296|0,g.b=0|A):I+=A;for(var t=0;t<I.length+20;t++)g.b^=0|I.charCodeAt(t),g.next()}function i(A,g){return g.a=A.a,g.b=A.b,g.c=A.c,g.d=A.d,g}function Q(A,g){var I=new B(A),t=g&&g.state,C=function(){return(I.next()>>>0)/4294967296};return C.double=function(){do{var A=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===A);return A},C.int32=I.next,C.quick=C,t&&("object"==typeof t&&i(t,I),C.state=function(){return i(I,{})}),C}C&&C.exports?C.exports=Q:I.amdD&&I.amdO?void 0===(t=function(){return Q}.call(g,I,g,C))||(C.exports=t):this.tychei=Q}(0,A=I.nmd(A),I.amdD)},652:function(A,g,I){var t;!function(A,C,e){function B(A){var g=this,I="";g.x=0,g.y=0,g.z=0,g.w=0,g.next=function(){var A=g.x^g.x<<11;return g.x=g.y,g.y=g.z,g.z=g.w,g.w^=g.w>>>19^A^A>>>8},A===(0|A)?g.x=A:I+=A;for(var t=0;t<I.length+64;t++)g.x^=0|I.charCodeAt(t),g.next()}function i(A,g){return g.x=A.x,g.y=A.y,g.z=A.z,g.w=A.w,g}function Q(A,g){var I=new B(A),t=g&&g.state,C=function(){return(I.next()>>>0)/4294967296};return C.double=function(){do{var A=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===A);return A},C.int32=I.next,C.quick=C,t&&("object"==typeof t&&i(t,I),C.state=function(){return i(I,{})}),C}C&&C.exports?C.exports=Q:I.amdD&&I.amdO?void 0===(t=function(){return Q}.call(g,I,g,C))||(C.exports=t):this.xor128=Q}(0,A=I.nmd(A),I.amdD)},618:function(A,g,I){var t;!function(A,C,e){function B(A){var g=this;g.next=function(){var A,I,t=g.w,C=g.X,e=g.i;return g.w=t=t+1640531527|0,I=C[e+34&127],A=C[e=e+1&127],I^=I<<13,A^=A<<17,I^=I>>>15,A^=A>>>12,I=C[e]=I^A,g.i=e,I+(t^t>>>16)|0},function(A,g){var I,t,C,e,B,i=[],Q=128;for(g===(0|g)?(t=g,g=null):(g+="\0",t=0,Q=Math.max(Q,g.length)),C=0,e=-32;e<Q;++e)g&&(t^=g.charCodeAt((e+32)%g.length)),0===e&&(B=t),t^=t<<10,t^=t>>>15,t^=t<<4,t^=t>>>13,e>=0&&(B=B+1640531527|0,C=0==(I=i[127&e]^=t+B)?C+1:0);for(C>=128&&(i[127&(g&&g.length||0)]=-1),C=127,e=512;e>0;--e)t=i[C+34&127],I=i[C=C+1&127],t^=t<<13,I^=I<<17,t^=t>>>15,I^=I>>>12,i[C]=t^I;A.w=B,A.X=i,A.i=C}(g,A)}function i(A,g){return g.i=A.i,g.w=A.w,g.X=A.X.slice(),g}function Q(A,g){null==A&&(A=+new Date);var I=new B(A),t=g&&g.state,C=function(){return(I.next()>>>0)/4294967296};return C.double=function(){do{var A=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===A);return A},C.int32=I.next,C.quick=C,t&&(t.X&&i(t,I),C.state=function(){return i(I,{})}),C}C&&C.exports?C.exports=Q:I.amdD&&I.amdO?void 0===(t=function(){return Q}.call(g,I,g,C))||(C.exports=t):this.xor4096=Q}(0,A=I.nmd(A),I.amdD)},30:function(A,g,I){var t;!function(A,C,e){function B(A){var g=this;g.next=function(){var A,I,t=g.x,C=g.i;return A=t[C],I=(A^=A>>>7)^A<<24,I^=(A=t[C+1&7])^A>>>10,I^=(A=t[C+3&7])^A>>>3,I^=(A=t[C+4&7])^A<<7,A=t[C+7&7],I^=(A^=A<<13)^A<<9,t[C]=I,g.i=C+1&7,I},function(A,g){var I,t=[];if(g===(0|g))t[0]=g;else for(g=""+g,I=0;I<g.length;++I)t[7&I]=t[7&I]<<15^g.charCodeAt(I)+t[I+1&7]<<13;for(;t.length<8;)t.push(0);for(I=0;I<8&&0===t[I];++I);for(8==I?t[7]=-1:t[I],A.x=t,A.i=0,I=256;I>0;--I)A.next()}(g,A)}function i(A,g){return g.x=A.x.slice(),g.i=A.i,g}function Q(A,g){null==A&&(A=+new Date);var I=new B(A),t=g&&g.state,C=function(){return(I.next()>>>0)/4294967296};return C.double=function(){do{var A=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===A);return A},C.int32=I.next,C.quick=C,t&&(t.x&&i(t,I),C.state=function(){return i(I,{})}),C}C&&C.exports?C.exports=Q:I.amdD&&I.amdO?void 0===(t=function(){return Q}.call(g,I,g,C))||(C.exports=t):this.xorshift7=Q}(0,A=I.nmd(A),I.amdD)},801:function(A,g,I){var t;!function(A,C,e){function B(A){var g=this,I="";g.next=function(){var A=g.x^g.x>>>2;return g.x=g.y,g.y=g.z,g.z=g.w,g.w=g.v,(g.d=g.d+362437|0)+(g.v=g.v^g.v<<4^A^A<<1)|0},g.x=0,g.y=0,g.z=0,g.w=0,g.v=0,A===(0|A)?g.x=A:I+=A;for(var t=0;t<I.length+64;t++)g.x^=0|I.charCodeAt(t),t==I.length&&(g.d=g.x<<10^g.x>>>4),g.next()}function i(A,g){return g.x=A.x,g.y=A.y,g.z=A.z,g.w=A.w,g.v=A.v,g.d=A.d,g}function Q(A,g){var I=new B(A),t=g&&g.state,C=function(){return(I.next()>>>0)/4294967296};return C.double=function(){do{var A=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===A);return A},C.int32=I.next,C.quick=C,t&&("object"==typeof t&&i(t,I),C.state=function(){return i(I,{})}),C}C&&C.exports?C.exports=Q:I.amdD&&I.amdO?void 0===(t=function(){return Q}.call(g,I,g,C))||(C.exports=t):this.xorwow=Q}(0,A=I.nmd(A),I.amdD)},971:function(A,g,I){var t;!function(C,e,B){var i,Q=256,o=B.pow(Q,6),E=B.pow(2,52),n=2*E,s=Q-1;function a(A,g,I){var t=[],s=l(c((g=1==g?{entropy:!0}:g||{}).entropy?[A,D(e)]:null==A?function(){try{var A;return i&&(A=i.randomBytes)?A=A(Q):(A=new Uint8Array(Q),(C.crypto||C.msCrypto).getRandomValues(A)),D(A)}catch(A){var g=C.navigator,I=g&&g.plugins;return[+new Date,C,I,C.screen,D(e)]}}():A,3),t),a=new r(t),u=function(){for(var A=a.g(6),g=o,I=0;A<E;)A=(A+I)*Q,g*=Q,I=a.g(1);for(;A>=n;)A/=2,g/=2,I>>>=1;return(A+I)/g};return u.int32=function(){return 0|a.g(4)},u.quick=function(){return a.g(4)/4294967296},u.double=u,l(D(a.S),e),(g.pass||I||function(A,g,I,t){return t&&(t.S&&h(t,a),A.state=function(){return h(a,{})}),I?(B.random=A,g):A})(u,s,"global"in g?g.global:this==B,g.state)}function r(A){var g,I=A.length,t=this,C=0,e=t.i=t.j=0,B=t.S=[];for(I||(A=[I++]);C<Q;)B[C]=C++;for(C=0;C<Q;C++)B[C]=B[e=s&e+A[C%I]+(g=B[C])],B[e]=g;(t.g=function(A){for(var g,I=0,C=t.i,e=t.j,B=t.S;A--;)g=B[C=s&C+1],I=I*Q+B[s&(B[C]=B[e=s&e+g])+(B[e]=g)];return t.i=C,t.j=e,I})(Q)}function h(A,g){return g.i=A.i,g.j=A.j,g.S=A.S.slice(),g}function c(A,g){var I,t=[],C=typeof A;if(g&&"object"==C)for(I in A)try{t.push(c(A[I],g-1))}catch(A){}return t.length?t:"string"==C?A:A+"\0"}function l(A,g){for(var I,t=A+"",C=0;C<t.length;)g[s&C]=s&(I^=19*g[s&C])+t.charCodeAt(C++);return D(g)}function D(A){return String.fromCharCode.apply(0,A)}if(l(B.random(),e),A.exports){A.exports=a;try{i=I(42)}catch(A){}}else void 0===(t=function(){return a}.call(g,I,g,A))||(A.exports=t)}("undefined"!=typeof self?self:this,[],Math)},477:A=>{"use strict";A.exports=function(A,g,I,t){var C=self||window;try{try{var e;try{e=new C.Blob([A])}catch(g){(e=new(C.BlobBuilder||C.WebKitBlobBuilder||C.MozBlobBuilder||C.MSBlobBuilder)).append(A),e=e.getBlob()}var B=C.URL||C.webkitURL,i=B.createObjectURL(e),Q=new C[g](i,I);return B.revokeObjectURL(i),Q}catch(t){return new C[g]("data:application/javascript,".concat(encodeURIComponent(A)),I)}}catch(A){if(!t)throw Error("Inline worker is not supported");return new C[g](t,I)}}},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},499:()=>{},903:()=>{},514:()=>{},42:()=>{},970:(A,g,I)=>{const{FaceMeshHelper:t}=I(478),{cv:C,waitCV:e}=I(150),{Estimator:B}=I(522),{createThreeFaceGeometry:i}=I(869),{positions:Q}=I(35),{OneEuroFilter:o}=I(489);A.exports={Controller:class{constructor({onUpdate:A=null,filterMinCF:g=null,filterBeta:I=null}){this.customFaceGeometries=[],this.estimator=null,this.lastEstimateResult=null,this.filterMinCF=null===g?.001:g,this.filterBeta=null===I?1:I,this.onUpdate=A,this.landmarkFilters=[];for(let A=0;A<Q.length;A++)this.landmarkFilters[A]=new o({minCutOff:this.filterMinCF,beta:this.filterBeta});this.faceMatrixFilter=new o({minCutOff:this.filterMinCF,beta:this.filterBeta}),this.faceScaleFilter=new o({minCutOff:this.filterMinCF,beta:this.filterBeta})}async setup(A){await e(),this.faceMeshHelper=new t,this.estimator=new B(A)}getCameraParams(){return{fov:180*this.estimator.fov/Math.PI,aspect:this.estimator.frameWidth/this.estimator.frameHeight,near:this.estimator.near,far:this.estimator.far}}async dummyRun(A){await this.faceMeshHelper.detect(A)}processVideo(A){if(this.processingVideo)return;this.processingVideo=!0;const g=async()=>{const I=await this.faceMeshHelper.detect(A);if(0===I.multiFaceLandmarks.length){this.lastEstimateResult=null,this.onUpdate({hasFace:!1});for(let A=0;A<this.landmarkFilters.length;A++)this.landmarkFilters[A].reset();this.faceMatrixFilter.reset(),this.faceScaleFilter.reset()}else{const A=I.multiFaceLandmarks[0].map((A=>[A.x,A.y,A.z])),g=this.estimator.estimate(A);if(null===this.lastEstimateResult)this.lastEstimateResult=g;else{const A=this.lastEstimateResult.metricLandmarks,I=(this.lastEstimateResult.faceMatrix,this.lastEstimateResult.faceScale,[]);for(let t=0;t<A.length;t++)I[t]=this.landmarkFilters[t].filter(Date.now(),g.metricLandmarks[t]);const t=this.faceMatrixFilter.filter(Date.now(),g.faceMatrix),C=this.faceScaleFilter.filter(Date.now(),[g.faceScale]);this.lastEstimateResult={metricLandmarks:I,faceMatrix:t,faceScale:C[0]}}this.onUpdate&&this.onUpdate({hasFace:!0,estimateResult:this.lastEstimateResult});for(let A=0;A<this.customFaceGeometries.length;A++)this.customFaceGeometries[A].updatePositions(g.metricLandmarks)}this.processingVideo&&window.requestAnimationFrame(g)};window.requestAnimationFrame(g)}stopProcessVideo(){this.processingVideo=!1}createThreeFaceGeometry(A){const g=i(A);return this.customFaceGeometries.push(g),g}getLandmarkMatrix(A){const{metricLandmarks:g,faceMatrix:I,faceScale:t}=this.lastEstimateResult,C=I,e=t,B=[g[A][0],g[A][1],g[A][2]];return[C[0]*e,C[1]*e,C[2]*e,C[0]*B[0]+C[1]*B[1]+C[2]*B[2]+C[3],C[4]*e,C[5]*e,C[6]*e,C[4]*B[0]+C[5]*B[1]+C[6]*B[2]+C[7],C[8]*e,C[9]*e,C[10]*e,C[8]*B[0]+C[9]*B[1]+C[10]*B[2]+C[11],C[12]*e,C[13]*e,C[14]*e,C[12]*B[0]+C[13]*B[1]+C[14]*B[2]+C[15]]}}}},522:(A,g,I)=>{const{positions:t,landmarkBasis:C}=I(35),{cv:e}=I(150),B=[];for(let A=0;A<t.length;A++)B[A]=0;C.forEach((([A,g])=>{B[A]=g}));const i=[];for(let A=0;A<B.length;A++)i[A]=Math.sqrt(B[A]);const Q=[33,263,61,291,199];C.forEach((([A,g])=>{Q.includes(A)||Q.push(A)})),Q.sort(((A,g)=>A-g));let o=0,E=0;for(let A=0;A<t.length;A++)t[A][0]<t[o][0]&&(o=A),t[A][0]>t[E][0]&&(E=A);A.exports={Estimator:class{constructor(A){const g=A.height,I=A.width,t=I,C=2*Math.atan(g/(2*t)),e=2*Math.tan(.5*C),B=I*e/g;this.near=1,this.far=1e4,this.frameHeight=g,this.frameWidth=I,this.focalLength=t,this.fov=C,this.left=-.5*B,this.right=.5*B,this.bottom=-.5*e,this.top=.5*e,this.focalLength=t,this.center=[I/2,g/2]}estimate(A){const g=this._projectToScreen(A);let I=this._cloneLandmarks(g);this._changeHandedness(I);const C=g.reduce(((A,g)=>A+g[2]),0)/g.length,B=this._estimateScale(I);I=this._cloneLandmarks(g),this._moveAndRescaleZ(C,B,I),this._unprojectScreen(I),this._changeHandedness(I);const n=this._estimateScale(I);let s=this._cloneLandmarks(g);const a=B*n;this._moveAndRescaleZ(C,a,s),this._unprojectScreen(s),this._changeHandedness(s);const r=this._solveWeightedOrthogonal(t,s,i),h=e.matFromArray(4,4,e.CV_64F,[r[0][0],r[0][1],r[0][2],r[0][3],r[1][0],r[1][1],r[1][2],r[1][3],r[2][0],r[2][1],r[2][2],r[2][3],r[3][0],r[3][1],r[3][2],r[3][3]]).inv(0).data64F,c=[[h[0],h[1],h[2],h[3]],[h[4],h[5],h[6],h[7]],[h[8],h[9],h[10],h[11]],[h[12],h[13],h[14],h[15]]],l=[];for(let A=0;A<s.length;A++){l[A]=[];for(let g=0;g<3;g++){l[A][g]=c[g][3];for(let I=0;I<3;I++)l[A][g]+=c[g][I]*s[A][I]}}const D=[],u=[];Q.forEach((g=>{D.push(l[g][0],l[g][1],l[g][2]),u.push(A[g][0]*this.frameWidth,A[g][1]*this.frameHeight)}));const w=e.matFromArray(D.length/3,3,e.CV_64F,D),d=e.matFromArray(u.length/2,2,e.CV_64F,u),p=e.matFromArray(3,3,e.CV_64F,[this.focalLength,0,this.center[0],0,this.focalLength,this.center[1],0,0,1]),y=e.Mat.zeros(4,1,e.CV_64F),G=new e.Mat(3,1,e.CV_64F),f=new e.Mat(3,1,e.CV_64F),N=new e.Mat(3,3,e.CV_64F);e.solvePnP(w,d,p,y,G,f,!1),e.Rodrigues(G,N);const F=[N.data64F[0],N.data64F[1],N.data64F[2],f.data64F[0],-N.data64F[3],-N.data64F[4],-N.data64F[5],-f.data64F[1],-N.data64F[6],-N.data64F[7],-N.data64F[8],-f.data64F[2],0,0,0,1],R=l[E][0]-l[o][0];return{metricLandmarks:l,faceMatrix:F,faceScale:R}}_estimateScale(A){const g=this._solveWeightedOrthogonal(t,A,i);return Math.sqrt(g[0][0]*g[0][0]+g[0][1]*g[0][1]+g[0][2]*g[0][2])}_solveWeightedOrthogonal(A,g,I){const t=[],C=[];for(let e=0;e<A.length;e++)t.push([A[e][0]*I[e],A[e][1]*I[e],A[e][2]*I[e]]),C.push([g[e][0]*I[e],g[e][1]*I[e],g[e][2]*I[e]]);const e=I.reduce(((A,g)=>A+g*g),0),B=[];for(let A=0;A<t.length;A++)B[A]=[t[A][0]*I[A],t[A][1]*I[A],t[A][2]*I[A]];const i=[0,0,0];for(let A=0;A<3;A++){for(let g=0;g<B.length;g++)i[A]+=B[g][A];i[A]/=e}const Q=[];for(let A=0;A<B.length;A++){Q[A]=[];for(let g=0;g<3;g++)Q[A][g]=t[A][g]-i[g]*I[A]}const o=[[0,0,0],[0,0,0],[0,0,0]];for(let A=0;A<3;A++)for(let g=0;g<3;g++)for(let I=0;I<C.length;I++)o[A][g]+=C[I][A]*Q[I][g];const E=this._computeOptimalRotation(o),n=this._computeOptimalScale(Q,t,C,E),s=[[],[],[]];for(let A=0;A<3;A++)for(let g=0;g<3;g++)s[A][g]=n*E[A][g];const a=[];for(let A=0;A<t.length;A++){a[A]=[];for(let g=0;g<3;g++){a[A][g]=C[A][g];for(let I=0;I<3;I++)a[A][g]-=s[g][I]*t[A][I]}}const r=[];for(let A=0;A<a.length;A++){r[A]=[];for(let g=0;g<3;g++)r[A][g]=a[A][g]*I[A]}const h=[0,0,0];for(let A=0;A<3;A++){for(let g=0;g<r.length;g++)h[A]+=r[g][A];h[A]/=e}return[[s[0][0],s[0][1],s[0][2],h[0]],[s[1][0],s[1][1],s[1][2],h[1]],[s[2][0],s[2][1],s[2][2],h[2]],[0,0,0,1]]}_computeOptimalRotation(A){const g=e.matFromArray(3,3,e.CV_64F,[A[0][0],A[0][1],A[0][2],A[1][0],A[1][1],A[1][2],A[2][0],A[2][1],A[2][2]]),I=new e.Mat(3,1,e.CV_64F),t=new e.Mat(3,3,e.CV_64F),C=new e.Mat(3,3,e.CV_64F);e.SVDecomp(g,I,t,C);const B=[[0,0,0],[0,0,0],[0,0,0]];for(let A=0;A<3;A++)for(let g=0;g<3;g++)for(let I=0;I<3;I++)B[A][g]+=t.data64F[3*A+I]*C.data64F[3*I+g];return B}_computeOptimalScale(A,g,I,t){const C=[];for(let g=0;g<A.length;g++){C[g]=[];for(let I=0;I<3;I++){C[g][I]=0;for(let e=0;e<3;e++)C[g][I]+=t[I][e]*A[g][e]}}let e=0;for(let A=0;A<C.length;A++)for(let g=0;g<3;g++)e+=C[A][g]*I[A][g];let B=0;for(let I=0;I<A.length;I++)for(let t=0;t<3;t++)B+=A[I][t]*g[I][t];return e/B}_projectToScreen(A){const g=[],I=this.right-this.left,t=this.top-this.bottom,C=this.left,e=this.bottom;for(let B=0;B<A.length;B++)g.push([A[B][0]*I+C,(1-A[B][1])*t+e,A[B][2]*I]);return g}_cloneLandmarks(A){const g=[];for(let I=0;I<A.length;I++)g[I]=[A[I][0],A[I][1],A[I][2]];return g}_changeHandedness(A){for(let g=0;g<A.length;g++)A[g][2]*=-1}_moveAndRescaleZ(A,g,I){for(let t=0;t<I.length;t++)I[t][2]=(I[t][2]-A+this.near)/g}_unprojectScreen(A){for(let g=0;g<A.length;g++)A[g][0]=A[g][0]*A[g][2]/this.near,A[g][1]=A[g][1]*A[g][2]/this.near}}}},35:A=>{A.exports={positions:[[0,-3.406404,5.979507],[0,-1.126865,7.475604],[0,-2.089024,6.058267],[-.463928,.955357,6.633583],[0,-.46317,7.58658],[0,.365669,7.24287],[0,2.473255,5.788627],[-4.253081,2.577646,3.279702],[0,4.019042,5.284764],[0,4.885979,5.385258],[0,8.261778,4.481535],[0,-3.706811,5.864924],[0,-3.918301,5.56943],[0,-3.994436,5.219482],[0,-4.5424,5.404754],[0,-4.745577,5.529457],[0,-5.019567,5.601448],[0,-5.365123,5.535441],[0,-6.149624,5.071372],[0,-1.501095,7.112196],[-.416106,-1.466449,6.447657],[-7.08796,5.434801,.09962],[-2.628639,2.035898,3.848121],[-3.198363,1.985815,3.796952],[-3.775151,2.039402,3.646194],[-4.465819,2.42295,3.155168],[-2.164289,2.189867,3.851822],[-3.208229,3.223926,4.115822],[-2.673803,3.205337,4.092203],[-3.745193,3.165286,3.972409],[-4.161018,3.059069,3.719554],[-5.062006,1.934418,2.776093],[-2.266659,-7.425768,4.389812],[-4.445859,2.663991,3.173422],[-7.21453,2.263009,.07315],[-5.799793,2.349546,2.204059],[-2.844939,-.720868,4.43313],[-.711452,-3.329355,5.877044],[-.606033,-3.924562,5.444923],[-1.431615,-3.500953,5.496189],[-1.91491,-3.803146,5.02893],[-1.131043,-3.973937,5.189648],[-1.563548,-4.082763,4.842263],[-2.650112,-5.003649,4.188483],[-.427049,-1.094134,7.360529],[-.496396,-.475659,7.440358],[-5.253307,3.881582,3.363159],[-1.718698,.974609,4.558359],[-1.608635,-.942516,5.814193],[-1.651267,-.610868,5.581319],[-4.765501,-.701554,3.534632],[-.478306,.295766,7.101013],[-3.734964,4.50823,4.550454],[-4.588603,4.302037,4.048484],[-6.279331,6.615427,1.42585],[-1.220941,4.142165,5.106035],[-2.193489,3.100317,4.000575],[-3.102642,-4.352984,4.095905],[-6.719682,-4.788645,-1.745401],[-1.193824,-1.306795,5.737747],[-.729766,-1.593712,5.833208],[-2.456206,-4.342621,4.283884],[-2.204823,-4.304508,4.162499],[-4.985894,4.802461,3.751977],[-1.592294,-1.257709,5.456949],[-2.644548,4.524654,4.921559],[-2.760292,5.100971,5.01599],[-3.523964,8.005976,3.729163],[-5.599763,5.71547,2.724259],[-3.063932,6.566144,4.529981],[-5.720968,4.254584,2.830852],[-6.374393,4.78559,1.591691],[-.672728,-3.688016,5.737804],[-1.26256,-3.787691,5.417779],[-1.732553,-3.952767,5.000579],[-1.043625,-1.464973,5.662455],[-2.321234,-4.329069,4.258156],[-2.056846,-4.477671,4.520883],[-2.153084,-4.276322,4.038093],[-.946874,-1.035249,6.512274],[-1.469132,-4.036351,4.604908],[-1.02434,-3.989851,4.926693],[-.533422,-3.993222,5.138202],[-.76972,-6.095394,4.985883],[-.699606,-5.29185,5.448304],[-.669687,-4.94977,5.509612],[-.630947,-4.695101,5.449371],[-.583218,-4.517982,5.339869],[-1.53717,-4.423206,4.74547],[-1.6156,-4.475942,4.813632],[-1.729053,-4.61868,4.854463],[-1.838624,-4.828746,4.823737],[-2.36825,-3.106237,4.868096],[-7.542244,-1.049282,-2.431321],[0,-1.724003,6.60139],[-1.826614,-4.399531,4.399021],[-1.929558,-4.411831,4.497052],[-.597442,-2.013686,5.866456],[-1.405627,-1.714196,5.241087],[-.662449,-1.819321,5.863759],[-2.34234,.572222,4.294303],[-3.327324,.104863,4.11386],[-1.726175,-.919165,5.273355],[-5.133204,7.485602,2.660442],[-4.538641,6.319907,3.683424],[-3.986562,5.109487,4.466315],[-2.169681,-5.440433,4.455874],[-1.395634,5.011963,5.316032],[-1.6195,6.599217,4.921106],[-1.891399,8.236377,4.274997],[-4.195832,2.235205,3.375099],[-5.733342,1.411738,2.431726],[-1.859887,2.355757,3.843181],[-4.988612,3.074654,3.083858],[-1.303263,1.416453,4.831091],[-1.305757,-.672779,6.415959],[-6.46517,.937119,1.689873],[-5.258659,.945811,2.974312],[-4.432338,.722096,3.522615],[-3.300681,.861641,3.872784],[-2.430178,1.131492,4.039035],[-1.820731,1.467954,4.224124],[-.563221,2.307693,5.566789],[-6.338145,-.529279,1.881175],[-5.587698,3.208071,2.687839],[-.242624,-1.462857,7.071491],[-1.611251,.339326,4.895421],[-7.743095,2.364999,-2.005167],[-1.391142,1.851048,4.448999],[-1.785794,-.978284,4.85047],[-4.670959,2.664461,3.084075],[-1.33397,-.283761,6.097047],[-7.270895,-2.890917,-2.252455],[-1.856432,2.585245,3.757904],[-.923388,.073076,6.671944],[-5.000589,-6.135128,1.892523],[-5.085276,-7.17859,.714711],[-7.159291,-.81182,-.072044],[-5.843051,-5.248023,.924091],[-6.847258,3.662916,.724695],[-2.412942,-8.258853,4.119213],[-.179909,-1.689864,6.573301],[-2.103655,-.163946,4.566119],[-6.407571,2.236021,1.560843],[-3.670075,2.360153,3.63523],[-3.177186,2.294265,3.775704],[-2.196121,-4.598322,4.479786],[-6.234883,-1.94443,1.663542],[-1.292924,-9.29592,4.094063],[-3.210651,-8.533278,2.802001],[-4.068926,-7.993109,1.925119],[0,6.54539,5.027311],[0,-9.403378,4.264492],[-2.724032,2.315802,3.777151],[-2.28846,2.398891,3.697603],[-1.998311,2.496547,3.689148],[-6.13004,3.399261,2.038516],[-2.28846,2.886504,3.775031],[-2.724032,2.96181,3.871767],[-3.177186,2.964136,3.876973],[-3.670075,2.927714,3.724325],[-4.018389,2.857357,3.482983],[-7.555811,4.106811,-.991917],[-4.018389,2.483695,3.440898],[0,-2.521945,5.932265],[-1.776217,-2.683946,5.213116],[-1.222237,-1.182444,5.952465],[-.731493,-2.536683,5.815343],[0,3.271027,5.236015],[-4.135272,-6.996638,2.67197],[-3.311811,-7.660815,3.382963],[-1.313701,-8.639995,4.702456],[-5.940524,-6.223629,-.631468],[-1.998311,2.743838,3.74403],[-.901447,1.236992,5.754256],[0,-8.765243,4.891441],[-2.308977,-8.974196,3.60907],[-6.954154,-2.439843,-.131163],[-1.098819,-4.458788,5.120727],[-1.181124,-4.579996,5.189564],[-1.255818,-4.787901,5.237051],[-1.325085,-5.106507,5.20501],[-1.546388,-5.819392,4.757893],[-1.953754,-4.183892,4.431713],[-2.117802,-4.137093,4.555096],[-2.285339,-4.051196,4.582438],[-2.85016,-3.66572,4.484994],[-5.278538,-2.238942,2.861224],[-.946709,1.907628,5.196779],[-1.314173,3.104912,4.231404],[-1.78,2.86,3.881555],[-1.84511,-4.09888,4.247264],[-5.436187,-4.030482,2.109852],[-.766444,3.182131,4.861453],[-1.938616,-6.61441,4.521085],[0,1.059413,6.774605],[-.516573,1.583572,6.148363],[0,1.728369,6.31675],[-1.246815,.230297,5.681036],[0,-7.942194,5.181173],[0,-6.991499,5.153478],[-.997827,-6.930921,4.979576],[-3.288807,-5.382514,3.795752],[-2.311631,-1.566237,4.590085],[-2.68025,-6.111567,4.096152],[-3.832928,-1.537326,4.137731],[-2.96186,-2.274215,4.440943],[-4.386901,-2.683286,3.643886],[-1.217295,-7.834465,4.969286],[-1.542374,-.136843,5.201008],[-3.878377,-6.041764,3.311079],[-3.084037,-6.809842,3.814195],[-3.747321,-4.503545,3.726453],[-6.094129,-3.205991,1.473482],[-4.588995,-4.728726,2.983221],[-6.583231,-3.941269,.070268],[-3.49258,-3.19582,4.130198],[-1.255543,.802341,5.307551],[-1.126122,-.933602,6.538785],[-1.443109,-1.142774,5.905127],[-.923043,-.529042,7.003423],[-1.755386,3.529117,4.327696],[-2.632589,3.713828,4.364629],[-3.388062,3.721976,4.309028],[-4.075766,3.675413,4.076063],[-4.62291,3.474691,3.646321],[-5.171755,2.535753,2.670867],[-7.297331,.763172,-.048769],[-4.706828,1.651,3.109532],[-4.071712,1.476821,3.476944],[-3.269817,1.470659,3.731945],[-2.527572,1.617311,3.865444],[-1.970894,1.858505,3.961782],[-1.579543,2.097941,4.084996],[-7.664182,.673132,-2.435867],[-1.397041,-1.340139,5.630378],[-.884838,.65874,6.233232],[-.767097,-.968035,7.077932],[-.460213,-1.334106,6.787447],[-.748618,-1.067994,6.798303],[-1.236408,-1.585568,5.48049],[-.387306,-1.40999,6.957705],[-.319925,-1.607931,6.508676],[-1.639633,2.556298,3.863736],[-1.255645,2.467144,4.2038],[-1.031362,2.382663,4.615849],[-4.253081,2.772296,3.315305],[-4.53,2.91,3.339685],[.463928,.955357,6.633583],[4.253081,2.577646,3.279702],[.416106,-1.466449,6.447657],[7.08796,5.434801,.09962],[2.628639,2.035898,3.848121],[3.198363,1.985815,3.796952],[3.775151,2.039402,3.646194],[4.465819,2.42295,3.155168],[2.164289,2.189867,3.851822],[3.208229,3.223926,4.115822],[2.673803,3.205337,4.092203],[3.745193,3.165286,3.972409],[4.161018,3.059069,3.719554],[5.062006,1.934418,2.776093],[2.266659,-7.425768,4.389812],[4.445859,2.663991,3.173422],[7.21453,2.263009,.07315],[5.799793,2.349546,2.204059],[2.844939,-.720868,4.43313],[.711452,-3.329355,5.877044],[.606033,-3.924562,5.444923],[1.431615,-3.500953,5.496189],[1.91491,-3.803146,5.02893],[1.131043,-3.973937,5.189648],[1.563548,-4.082763,4.842263],[2.650112,-5.003649,4.188483],[.427049,-1.094134,7.360529],[.496396,-.475659,7.440358],[5.253307,3.881582,3.363159],[1.718698,.974609,4.558359],[1.608635,-.942516,5.814193],[1.651267,-.610868,5.581319],[4.765501,-.701554,3.534632],[.478306,.295766,7.101013],[3.734964,4.50823,4.550454],[4.588603,4.302037,4.048484],[6.279331,6.615427,1.42585],[1.220941,4.142165,5.106035],[2.193489,3.100317,4.000575],[3.102642,-4.352984,4.095905],[6.719682,-4.788645,-1.745401],[1.193824,-1.306795,5.737747],[.729766,-1.593712,5.833208],[2.456206,-4.342621,4.283884],[2.204823,-4.304508,4.162499],[4.985894,4.802461,3.751977],[1.592294,-1.257709,5.456949],[2.644548,4.524654,4.921559],[2.760292,5.100971,5.01599],[3.523964,8.005976,3.729163],[5.599763,5.71547,2.724259],[3.063932,6.566144,4.529981],[5.720968,4.254584,2.830852],[6.374393,4.78559,1.591691],[.672728,-3.688016,5.737804],[1.26256,-3.787691,5.417779],[1.732553,-3.952767,5.000579],[1.043625,-1.464973,5.662455],[2.321234,-4.329069,4.258156],[2.056846,-4.477671,4.520883],[2.153084,-4.276322,4.038093],[.946874,-1.035249,6.512274],[1.469132,-4.036351,4.604908],[1.02434,-3.989851,4.926693],[.533422,-3.993222,5.138202],[.76972,-6.095394,4.985883],[.699606,-5.29185,5.448304],[.669687,-4.94977,5.509612],[.630947,-4.695101,5.449371],[.583218,-4.517982,5.339869],[1.53717,-4.423206,4.74547],[1.6156,-4.475942,4.813632],[1.729053,-4.61868,4.854463],[1.838624,-4.828746,4.823737],[2.36825,-3.106237,4.868096],[7.542244,-1.049282,-2.431321],[1.826614,-4.399531,4.399021],[1.929558,-4.411831,4.497052],[.597442,-2.013686,5.866456],[1.405627,-1.714196,5.241087],[.662449,-1.819321,5.863759],[2.34234,.572222,4.294303],[3.327324,.104863,4.11386],[1.726175,-.919165,5.273355],[5.133204,7.485602,2.660442],[4.538641,6.319907,3.683424],[3.986562,5.109487,4.466315],[2.169681,-5.440433,4.455874],[1.395634,5.011963,5.316032],[1.6195,6.599217,4.921106],[1.891399,8.236377,4.274997],[4.195832,2.235205,3.375099],[5.733342,1.411738,2.431726],[1.859887,2.355757,3.843181],[4.988612,3.074654,3.083858],[1.303263,1.416453,4.831091],[1.305757,-.672779,6.415959],[6.46517,.937119,1.689873],[5.258659,.945811,2.974312],[4.432338,.722096,3.522615],[3.300681,.861641,3.872784],[2.430178,1.131492,4.039035],[1.820731,1.467954,4.224124],[.563221,2.307693,5.566789],[6.338145,-.529279,1.881175],[5.587698,3.208071,2.687839],[.242624,-1.462857,7.071491],[1.611251,.339326,4.895421],[7.743095,2.364999,-2.005167],[1.391142,1.851048,4.448999],[1.785794,-.978284,4.85047],[4.670959,2.664461,3.084075],[1.33397,-.283761,6.097047],[7.270895,-2.890917,-2.252455],[1.856432,2.585245,3.757904],[.923388,.073076,6.671944],[5.000589,-6.135128,1.892523],[5.085276,-7.17859,.714711],[7.159291,-.81182,-.072044],[5.843051,-5.248023,.924091],[6.847258,3.662916,.724695],[2.412942,-8.258853,4.119213],[.179909,-1.689864,6.573301],[2.103655,-.163946,4.566119],[6.407571,2.236021,1.560843],[3.670075,2.360153,3.63523],[3.177186,2.294265,3.775704],[2.196121,-4.598322,4.479786],[6.234883,-1.94443,1.663542],[1.292924,-9.29592,4.094063],[3.210651,-8.533278,2.802001],[4.068926,-7.993109,1.925119],[2.724032,2.315802,3.777151],[2.28846,2.398891,3.697603],[1.998311,2.496547,3.689148],[6.13004,3.399261,2.038516],[2.28846,2.886504,3.775031],[2.724032,2.96181,3.871767],[3.177186,2.964136,3.876973],[3.670075,2.927714,3.724325],[4.018389,2.857357,3.482983],[7.555811,4.106811,-.991917],[4.018389,2.483695,3.440898],[1.776217,-2.683946,5.213116],[1.222237,-1.182444,5.952465],[.731493,-2.536683,5.815343],[4.135272,-6.996638,2.67197],[3.311811,-7.660815,3.382963],[1.313701,-8.639995,4.702456],[5.940524,-6.223629,-.631468],[1.998311,2.743838,3.74403],[.901447,1.236992,5.754256],[2.308977,-8.974196,3.60907],[6.954154,-2.439843,-.131163],[1.098819,-4.458788,5.120727],[1.181124,-4.579996,5.189564],[1.255818,-4.787901,5.237051],[1.325085,-5.106507,5.20501],[1.546388,-5.819392,4.757893],[1.953754,-4.183892,4.431713],[2.117802,-4.137093,4.555096],[2.285339,-4.051196,4.582438],[2.85016,-3.66572,4.484994],[5.278538,-2.238942,2.861224],[.946709,1.907628,5.196779],[1.314173,3.104912,4.231404],[1.78,2.86,3.881555],[1.84511,-4.09888,4.247264],[5.436187,-4.030482,2.109852],[.766444,3.182131,4.861453],[1.938616,-6.61441,4.521085],[.516573,1.583572,6.148363],[1.246815,.230297,5.681036],[.997827,-6.930921,4.979576],[3.288807,-5.382514,3.795752],[2.311631,-1.566237,4.590085],[2.68025,-6.111567,4.096152],[3.832928,-1.537326,4.137731],[2.96186,-2.274215,4.440943],[4.386901,-2.683286,3.643886],[1.217295,-7.834465,4.969286],[1.542374,-.136843,5.201008],[3.878377,-6.041764,3.311079],[3.084037,-6.809842,3.814195],[3.747321,-4.503545,3.726453],[6.094129,-3.205991,1.473482],[4.588995,-4.728726,2.983221],[6.583231,-3.941269,.070268],[3.49258,-3.19582,4.130198],[1.255543,.802341,5.307551],[1.126122,-.933602,6.538785],[1.443109,-1.142774,5.905127],[.923043,-.529042,7.003423],[1.755386,3.529117,4.327696],[2.632589,3.713828,4.364629],[3.388062,3.721976,4.309028],[4.075766,3.675413,4.076063],[4.62291,3.474691,3.646321],[5.171755,2.535753,2.670867],[7.297331,.763172,-.048769],[4.706828,1.651,3.109532],[4.071712,1.476821,3.476944],[3.269817,1.470659,3.731945],[2.527572,1.617311,3.865444],[1.970894,1.858505,3.961782],[1.579543,2.097941,4.084996],[7.664182,.673132,-2.435867],[1.397041,-1.340139,5.630378],[.884838,.65874,6.233232],[.767097,-.968035,7.077932],[.460213,-1.334106,6.787447],[.748618,-1.067994,6.798303],[1.236408,-1.585568,5.48049],[.387306,-1.40999,6.957705],[.319925,-1.607931,6.508676],[1.639633,2.556298,3.863736],[1.255645,2.467144,4.2038],[1.031362,2.382663,4.615849],[4.253081,2.772296,3.315305],[4.53,2.91,3.339685]],uvs:[[.499977,.347466],[.500026,.452513],[.499974,.397628],[.482113,.528021],[.500151,.472844],[.49991,.501747],[.499523,.598938],[.289712,.619236],[.499955,.687602],[.499987,.730081],[.500023,.89295],[.500023,.333766],[.500016,.320776],[.500023,.307652],[.499977,.304722],[.499977,.294066],[.499977,.280615],[.499977,.262981],[.499968,.218629],[.499816,.437019],[.473773,.42609],[.104907,.745859],[.36593,.590424],[.338758,.586975],[.31112,.59054],[.274658,.610869],[.393362,.596294],[.345234,.655989],[.370094,.653924],[.319322,.652735],[.297903,.646409],[.247792,.58919],[.396889,.157245],[.280098,.6244],[.10631,.600044],[.209925,.608647],[.355808,.465594],[.471751,.349596],[.474155,.319808],[.439785,.342771],[.414617,.333459],[.450374,.319139],[.428771,.317309],[.374971,.272195],[.486717,.452371],[.485301,.472605],[.257765,.68551],[.401223,.544828],[.429819,.451385],[.421352,.466259],[.276896,.467943],[.48337,.500413],[.337212,.717117],[.296392,.706757],[.169295,.806186],[.44758,.69739],[.39239,.646112],[.35449,.303216],[.067305,.269895],[.442739,.427174],[.457098,.415208],[.381974,.305289],[.392389,.305797],[.277076,.728068],[.422552,.436767],[.385919,.718636],[.383103,.74416],[.331431,.880286],[.229924,.767997],[.364501,.810886],[.229622,.700459],[.173287,.721252],[.472879,.333802],[.446828,.331473],[.422762,.32611],[.445308,.419934],[.388103,.306039],[.403039,.29346],[.403629,.306047],[.460042,.442861],[.431158,.307634],[.452182,.307634],[.475387,.307634],[.465828,.22081],[.472329,.263774],[.473087,.282143],[.473122,.295374],[.473033,.304722],[.427942,.304722],[.426479,.29646],[.423162,.288154],[.418309,.279937],[.390095,.360427],[.013954,.439966],[.499914,.419853],[.4132,.3046],[.409626,.298177],[.46808,.398465],[.422729,.414015],[.46308,.406216],[.37212,.526586],[.334562,.503927],[.411671,.453035],[.242176,.852324],[.290777,.798554],[.327338,.743473],[.39951,.251079],[.441728,.738324],[.429765,.812166],[.412198,.891099],[.288955,.601048],[.218937,.564589],[.412782,.60103],[.257135,.64456],[.427685,.562039],[.44834,.463064],[.17856,.542446],[.247308,.542806],[.286267,.532325],[.332828,.539288],[.368756,.552793],[.398964,.567345],[.47641,.594194],[.189241,.476076],[.228962,.651049],[.490726,.437599],[.40467,.514867],[.019469,.598436],[.426243,.579569],[.396993,.451203],[.26647,.623023],[.439121,.481042],[.032314,.355643],[.419054,.612845],[.462783,.494253],[.238979,.220255],[.198221,.168062],[.10755,.459245],[.18361,.259743],[.13441,.666317],[.385764,.116846],[.490967,.420622],[.382385,.491427],[.174399,.602329],[.318785,.603765],[.343364,.599403],[.3961,.289783],[.187885,.411462],[.430987,.055935],[.318993,.101715],[.266248,.130299],[.500023,.809424],[.499977,.045547],[.36617,.601178],[.393207,.604463],[.410373,.60892],[.194993,.657898],[.388665,.637716],[.365962,.644029],[.343364,.644643],[.318785,.64166],[.301415,.636844],[.058133,.680924],[.301415,.612551],[.499988,.381566],[.415838,.375804],[.445682,.433923],[.465844,.379359],[.499923,.648476],[.288719,.180054],[.335279,.14718],[.440512,.097581],[.128294,.208059],[.408772,.626106],[.455607,.548199],[.499877,.09101],[.375437,.075808],[.11421,.384978],[.448662,.304722],[.44802,.295368],[.447112,.284192],[.444832,.269206],[.430012,.233191],[.406787,.314327],[.400738,.318931],[.3924,.322297],[.367856,.336081],[.247923,.398667],[.45277,.57915],[.436392,.640113],[.416164,.631286],[.413386,.307634],[.228018,.316428],[.468268,.647329],[.411362,.195673],[.499989,.530175],[.479154,.557346],[.499974,.560363],[.432112,.506411],[.499886,.133083],[.499913,.178271],[.456549,.180799],[.344549,.254561],[.378909,.42599],[.374293,.219815],[.319688,.429262],[.357155,.39573],[.295284,.378419],[.44775,.137523],[.410986,.491277],[.313951,.224692],[.354128,.187447],[.324548,.296007],[.189096,.3537],[.279777,.285342],[.133823,.317299],[.336768,.355267],[.429884,.533478],[.455528,.451377],[.437114,.441104],[.467288,.470075],[.414712,.66478],[.377046,.677222],[.344108,.679849],[.312876,.677668],[.283526,.66681],[.241246,.617214],[.102986,.531237],[.267612,.57544],[.297879,.566824],[.333434,.566122],[.366427,.573884],[.396012,.583304],[.420121,.589772],[.007561,.519223],[.432949,.430482],[.458639,.520911],[.473466,.454256],[.476088,.43617],[.468472,.444943],[.433991,.417638],[.483518,.437016],[.482483,.422151],[.42645,.610201],[.438999,.603505],[.450067,.599566],[.289712,.631747],[.27667,.636627],[.517862,.528052],[.710288,.619236],[.526227,.42609],[.895093,.745859],[.63407,.590424],[.661242,.586975],[.68888,.59054],[.725342,.610869],[.60663,.596295],[.654766,.655989],[.629906,.653924],[.680678,.652735],[.702097,.646409],[.752212,.589195],[.602918,.157137],[.719902,.6244],[.893693,.60004],[.790082,.608646],[.643998,.465512],[.528249,.349596],[.52585,.319809],[.560215,.342771],[.585384,.333459],[.549626,.319139],[.571228,.317308],[.624852,.271901],[.51305,.452718],[.515097,.472748],[.742247,.685493],[.598631,.545021],[.570338,.451425],[.578632,.466377],[.723087,.467946],[.516446,.500361],[.662801,.717082],[.703624,.706729],[.830705,.806186],[.552386,.697432],[.60761,.646112],[.645429,.303293],[.932695,.269895],[.557261,.427174],[.542902,.415208],[.618026,.305289],[.607591,.305797],[.722943,.728037],[.577414,.436833],[.614083,.718613],[.616907,.744114],[.668509,.880086],[.770092,.767979],[.635536,.810751],[.770391,.700444],[.826722,.721245],[.527121,.333802],[.553172,.331473],[.577238,.32611],[.554692,.419934],[.611897,.306039],[.596961,.29346],[.596371,.306047],[.539958,.442861],[.568842,.307634],[.547818,.307634],[.524613,.307634],[.53409,.220859],[.527671,.263774],[.526913,.282143],[.526878,.295374],[.526967,.304722],[.572058,.304722],[.573521,.29646],[.576838,.288154],[.581691,.279937],[.609945,.36009],[.986046,.439966],[.5868,.3046],[.590372,.298177],[.531915,.398463],[.577268,.414065],[.536915,.406214],[.627543,.526648],[.665586,.504049],[.588354,.453138],[.757824,.852324],[.70925,.798492],[.672684,.743419],[.600409,.250995],[.558266,.738328],[.570304,.812129],[.588166,.890956],[.711045,.601048],[.78107,.564595],[.587247,.601068],[.74287,.644554],[.572156,.562348],[.551868,.46343],[.821442,.542444],[.752702,.542818],[.713757,.532373],[.667113,.539327],[.631101,.552846],[.600862,.567527],[.523481,.594373],[.810748,.476074],[.771046,.651041],[.509127,.437282],[.595293,.514976],[.980531,.598436],[.5735,.58],[.602995,.451312],[.73353,.623023],[.560611,.480983],[.967686,.355643],[.580985,.61284],[.537728,.494615],[.760966,.220247],[.801779,.168062],[.892441,.459239],[.816351,.25974],[.865595,.666313],[.614074,.116754],[.508953,.420562],[.617942,.491684],[.825608,.602325],[.681215,.603765],[.656636,.599403],[.6039,.289783],[.812086,.411461],[.568013,.055435],[.681008,.101715],[.733752,.130299],[.63383,.601178],[.606793,.604463],[.58966,.608938],[.805016,.657892],[.611335,.637716],[.634038,.644029],[.656636,.644643],[.681215,.64166],[.698585,.636844],[.941867,.680924],[.698585,.612551],[.584177,.375893],[.554318,.433923],[.534154,.37936],[.711218,.180025],[.66463,.147129],[.5591,.097368],[.871706,.208059],[.591234,.626106],[.544341,.548416],[.624563,.075808],[.88577,.384971],[.551338,.304722],[.55198,.295368],[.552888,.284192],[.555168,.269206],[.569944,.232965],[.593203,.314324],[.599262,.318931],[.6076,.322297],[.631938,.3365],[.752033,.398685],[.547226,.579605],[.563544,.640172],[.583841,.631286],[.586614,.307634],[.771915,.316422],[.531597,.647517],[.588371,.195559],[.520797,.557435],[.567985,.506521],[.543283,.180745],[.655317,.254485],[.621009,.425982],[.62556,.219688],[.680198,.429281],[.642764,.395662],[.704663,.37847],[.552012,.137408],[.589072,.491363],[.685945,.224643],[.645735,.18736],[.675343,.296022],[.810858,.353695],[.720122,.285333],[.866152,.317295],[.663187,.355403],[.570082,.533674],[.544562,.451624],[.562759,.441215],[.531987,.46986],[.585271,.664823],[.622953,.677221],[.655896,.679837],[.687132,.677654],[.716482,.666799],[.758757,.617213],[.897013,.531231],[.732392,.575453],[.702114,.566837],[.666525,.566134],[.633505,.573912],[.603876,.583413],[.579658,.590055],[.99244,.519223],[.567192,.43058],[.541366,.521101],[.526564,.453882],[.523913,.43617],[.531529,.444943],[.566036,.417671],[.516311,.436946],[.517472,.422123],[.573595,.610193],[.560698,.604668],[.549756,.600249],[.710288,.631747],[.72333,.636627]],faces:[173,155,133,246,33,7,382,398,362,263,466,249,308,415,324,78,95,191,356,389,264,127,34,162,368,264,389,139,162,34,267,0,302,37,72,0,11,302,0,11,0,72,349,451,350,120,121,231,452,350,451,232,231,121,267,302,269,37,39,72,303,269,302,73,72,39,357,343,350,128,121,114,277,350,343,47,114,121,350,452,357,121,128,232,453,357,452,233,232,128,299,333,297,69,67,104,332,297,333,103,104,67,175,152,396,175,171,152,377,396,152,148,152,171,381,384,382,154,155,157,398,382,384,173,157,155,280,347,330,50,101,118,348,330,347,119,118,101,269,303,270,39,40,73,304,270,303,74,73,40,9,336,151,9,151,107,337,151,336,108,107,151,344,278,360,115,131,48,279,360,278,49,48,131,262,431,418,32,194,211,424,418,431,204,211,194,304,408,270,74,40,184,409,270,408,185,184,40,272,310,407,42,183,80,415,407,310,191,80,183,322,270,410,92,186,40,409,410,270,185,40,186,347,449,348,118,119,229,450,348,449,230,229,119,434,432,430,214,210,212,422,430,432,202,212,210,313,314,18,83,18,84,17,18,314,17,84,18,307,375,306,77,76,146,291,306,375,61,146,76,259,387,260,29,30,160,388,260,387,161,160,30,286,414,384,56,157,190,398,384,414,173,190,157,418,424,406,194,182,204,335,406,424,106,204,182,367,416,364,138,135,192,434,364,416,214,192,135,391,423,327,165,98,203,358,327,423,129,203,98,298,301,284,68,54,71,251,284,301,21,71,54,4,275,5,4,5,45,281,5,275,51,45,5,254,373,253,24,23,144,374,253,373,145,144,23,320,321,307,90,77,91,375,307,321,146,91,77,280,425,411,50,187,205,427,411,425,207,205,187,421,313,200,201,200,83,18,200,313,18,83,200,335,321,406,106,182,91,405,406,321,181,91,182,405,321,404,181,180,91,320,404,321,90,91,180,17,314,16,17,16,84,315,16,314,85,84,16,425,266,426,205,206,36,423,426,266,203,36,206,369,396,400,140,176,171,377,400,396,148,171,176,391,269,322,165,92,39,270,322,269,40,39,92,417,465,413,193,189,245,464,413,465,244,245,189,257,258,386,27,159,28,385,386,258,158,28,159,260,388,467,30,247,161,466,467,388,246,161,247,248,456,419,3,196,236,399,419,456,174,236,196,333,298,332,104,103,68,284,332,298,54,68,103,285,8,417,55,193,8,168,417,8,168,8,193,340,261,346,111,117,31,448,346,261,228,31,117,285,417,441,55,221,193,413,441,417,189,193,221,327,460,326,98,97,240,328,326,460,99,240,97,277,355,329,47,100,126,371,329,355,142,126,100,309,392,438,79,218,166,439,438,392,219,166,218,381,382,256,154,26,155,341,256,382,112,155,26,360,279,420,131,198,49,429,420,279,209,49,198,365,364,379,136,150,135,394,379,364,169,135,150,355,277,437,126,217,47,343,437,277,114,47,217,443,444,282,223,52,224,283,282,444,53,224,52,281,275,363,51,134,45,440,363,275,220,45,134,431,262,395,211,170,32,369,395,262,140,32,170,337,299,338,108,109,69,297,338,299,67,69,109,335,273,321,106,91,43,375,321,273,146,43,91,348,450,349,119,120,230,451,349,450,231,230,120,467,359,342,247,113,130,446,342,359,226,130,113,282,283,334,52,105,53,293,334,283,63,53,105,250,458,462,20,242,238,461,462,458,241,238,242,276,353,300,46,70,124,383,300,353,156,124,70,325,292,324,96,95,62,308,324,292,78,62,95,283,276,293,53,63,46,300,293,276,70,46,63,447,264,345,227,116,34,372,345,264,143,34,116,352,345,346,123,117,116,340,346,345,111,116,117,1,19,274,1,44,19,354,274,19,125,19,44,248,281,456,3,236,51,363,456,281,134,51,236,425,426,427,205,207,206,436,427,426,216,206,207,380,381,252,153,22,154,256,252,381,26,154,22,391,393,269,165,39,167,267,269,393,37,167,39,199,428,200,199,200,208,421,200,428,201,208,200,330,329,266,101,36,100,371,266,329,142,100,36,422,432,273,202,43,212,287,273,432,57,212,43,290,250,328,60,99,20,462,328,250,242,20,99,258,286,385,28,158,56,384,385,286,157,56,158,342,446,353,113,124,226,265,353,446,35,226,124,257,386,259,27,29,159,387,259,386,160,159,29,430,422,431,210,211,202,424,431,422,204,202,211,445,342,276,225,46,113,353,276,342,124,113,46,424,422,335,204,106,202,273,335,422,43,202,106,306,292,307,76,77,62,325,307,292,96,62,77,366,447,352,137,123,227,345,352,447,116,227,123,302,268,303,72,73,38,271,303,268,41,38,73,371,358,266,142,36,129,423,266,358,203,129,36,327,294,460,98,240,64,455,460,294,235,64,240,294,331,278,64,48,102,279,278,331,49,102,48,303,271,304,73,74,41,272,304,271,42,41,74,427,436,434,207,214,216,432,434,436,212,216,214,304,272,408,74,184,42,407,408,272,183,42,184,394,430,395,169,170,210,431,395,430,211,210,170,395,369,378,170,149,140,400,378,369,176,140,149,296,334,299,66,69,105,333,299,334,104,105,69,417,168,351,193,122,168,6,351,168,6,168,122,280,411,352,50,123,187,376,352,411,147,187,123,319,320,325,89,96,90,307,325,320,77,90,96,285,295,336,55,107,65,296,336,295,66,65,107,404,320,403,180,179,90,319,403,320,89,90,179,330,348,329,101,100,119,349,329,348,120,119,100,334,293,333,105,104,63,298,333,293,68,63,104,323,454,366,93,137,234,447,366,454,227,234,137,16,315,15,16,15,85,316,15,315,86,85,15,429,279,358,209,129,49,331,358,279,102,49,129,15,316,14,15,14,86,317,14,316,87,86,14,8,285,9,8,9,55,336,9,285,107,55,9,329,349,277,100,47,120,350,277,349,121,120,47,252,253,380,22,153,23,374,380,253,145,23,153,402,403,318,178,88,179,319,318,403,89,179,88,351,6,419,122,196,6,197,419,6,197,6,196,324,318,325,95,96,88,319,325,318,89,88,96,397,367,365,172,136,138,364,365,367,135,138,136,288,435,397,58,172,215,367,397,435,138,215,172,438,439,344,218,115,219,278,344,439,48,219,115,271,311,272,41,42,81,310,272,311,80,81,42,5,281,195,5,195,51,248,195,281,3,51,195,273,287,375,43,146,57,291,375,287,61,57,146,396,428,175,171,175,208,199,175,428,199,208,175,268,312,271,38,41,82,311,271,312,81,82,41,444,445,283,224,53,225,276,283,445,46,225,53,254,339,373,24,144,110,390,373,339,163,110,144,295,282,296,65,66,52,334,296,282,105,52,66,346,448,347,117,118,228,449,347,448,229,228,118,454,356,447,234,227,127,264,447,356,34,127,227,336,296,337,107,108,66,299,337,296,69,66,108,151,337,10,151,10,108,338,10,337,109,108,10,278,439,294,48,64,219,455,294,439,235,219,64,407,415,292,183,62,191,308,292,415,78,191,62,358,371,429,129,209,142,355,429,371,126,142,209,345,372,340,116,111,143,265,340,372,35,143,111,388,390,466,161,246,163,249,466,390,7,163,246,352,346,280,123,50,117,347,280,346,118,117,50,295,442,282,65,52,222,443,282,442,223,222,52,19,94,354,19,125,94,370,354,94,141,94,125,295,285,442,65,222,55,441,442,285,221,55,222,419,197,248,196,3,197,195,248,197,195,197,3,359,263,255,130,25,33,249,255,263,7,33,25,275,274,440,45,220,44,457,440,274,237,44,220,300,383,301,70,71,156,368,301,383,139,156,71,417,351,465,193,245,122,412,465,351,188,122,245,466,263,467,246,247,33,359,467,263,130,33,247,389,251,368,162,139,21,301,368,251,71,21,139,374,386,380,145,153,159,385,380,386,158,159,153,379,394,378,150,149,169,395,378,394,170,169,149,351,419,412,122,188,196,399,412,419,174,196,188,426,322,436,206,216,92,410,436,322,186,92,216,387,373,388,160,161,144,390,388,373,163,144,161,393,326,164,167,164,97,2,164,326,2,97,164,354,370,461,125,241,141,462,461,370,242,141,241,0,267,164,0,164,37,393,164,267,167,37,164,11,12,302,11,72,12,268,302,12,38,12,72,386,374,387,159,160,145,373,387,374,144,145,160,12,13,268,12,38,13,312,268,13,82,13,38,293,300,298,63,68,70,301,298,300,71,70,68,340,265,261,111,31,35,446,261,265,226,35,31,380,385,381,153,154,158,384,381,385,157,158,154,280,330,425,50,205,101,266,425,330,36,101,205,423,391,426,203,206,165,322,426,391,92,165,206,429,355,420,209,198,126,437,420,355,217,126,198,391,327,393,165,167,98,326,393,327,97,98,167,457,438,440,237,220,218,344,440,438,115,218,220,382,362,341,155,112,133,463,341,362,243,133,112,457,461,459,237,239,241,458,459,461,238,241,239,434,430,364,214,135,210,394,364,430,169,210,135,414,463,398,190,173,243,362,398,463,133,243,173,262,428,369,32,140,208,396,369,428,171,208,140,457,274,461,237,241,44,354,461,274,125,44,241,316,403,317,86,87,179,402,317,403,178,179,87,315,404,316,85,86,180,403,316,404,179,180,86,314,405,315,84,85,181,404,315,405,180,181,85,313,406,314,83,84,182,405,314,406,181,182,84,418,406,421,194,201,182,313,421,406,83,182,201,366,401,323,137,93,177,361,323,401,132,177,93,408,407,306,184,76,183,292,306,407,62,183,76,408,306,409,184,185,76,291,409,306,61,76,185,410,409,287,186,57,185,291,287,409,61,185,57,436,410,432,216,212,186,287,432,410,57,186,212,434,416,427,214,207,192,411,427,416,187,192,207,264,368,372,34,143,139,383,372,368,156,139,143,457,459,438,237,218,239,309,438,459,79,239,218,352,376,366,123,137,147,401,366,376,177,147,137,4,1,275,4,45,1,274,275,1,44,1,45,428,262,421,208,201,32,418,421,262,194,32,201,327,358,294,98,64,129,331,294,358,102,129,64,367,435,416,138,192,215,433,416,435,213,215,192,455,439,289,235,59,219,392,289,439,166,219,59,328,462,326,99,97,242,370,326,462,141,242,97,326,370,2,97,2,141,94,2,370,94,141,2,460,455,305,240,75,235,289,305,455,59,235,75,448,339,449,228,229,110,254,449,339,24,110,229,261,446,255,31,25,226,359,255,446,130,226,25,449,254,450,229,230,24,253,450,254,23,24,230,450,253,451,230,231,23,252,451,253,22,23,231,451,252,452,231,232,22,256,452,252,26,22,232,256,341,452,26,232,112,453,452,341,233,112,232,413,464,414,189,190,244,463,414,464,243,244,190,441,413,286,221,56,189,414,286,413,190,189,56,441,286,442,221,222,56,258,442,286,28,56,222,442,258,443,222,223,28,257,443,258,27,28,223,444,443,259,224,29,223,257,259,443,27,223,29,259,260,444,29,224,30,445,444,260,225,30,224,260,467,445,30,225,247,342,445,467,113,247,225,250,309,458,20,238,79,459,458,309,239,79,238,290,305,392,60,166,75,289,392,305,59,75,166,460,305,328,240,99,75,290,328,305,60,75,99,376,433,401,147,177,213,435,401,433,215,213,177,250,290,309,20,79,60,392,309,290,166,60,79,411,416,376,187,147,192,433,376,416,213,192,147,341,463,453,112,233,243,464,453,463,244,243,233,453,464,357,233,128,244,465,357,464,245,244,128,412,343,465,188,245,114,357,465,343,128,114,245,437,343,399,217,174,114,412,399,343,188,114,174,363,440,360,134,131,220,344,360,440,115,220,131,456,420,399,236,174,198,437,399,420,217,198,174,456,363,420,236,198,134,360,420,363,131,134,198,361,401,288,132,58,177,435,288,401,215,177,58,353,265,383,124,156,35,372,383,265,143,35,156,255,249,339,25,110,7,390,339,249,163,7,110,261,255,448,31,228,25,339,448,255,110,25,228,14,317,13,14,13,87,312,13,317,82,87,13,317,402,312,87,82,178,311,312,402,81,178,82,402,318,311,178,81,88,310,311,318,80,88,81,318,324,310,88,80,95,415,310,324,191,95,80],landmarkBasis:[[4,.070909939706326],[6,.032100144773722],[10,.008446550928056],[33,.058724168688059],[54,.007667080033571],[67,.009078059345484],[117,.009791937656701],[119,.014565368182957],[121,.018591361120343],[127,.005197994410992],[129,.120625205338001],[132,.005560018587857],[133,.05328618362546],[136,.066890455782413],[143,.014816547743976],[147,.014262833632529],[198,.025462191551924],[205,.047252278774977],[263,.058724168688059],[284,.007667080033571],[297,.009078059345484],[346,.009791937656701],[348,.014565368182957],[350,.018591361120343],[356,.005197994410992],[358,.120625205338001],[361,.005560018587857],[362,.05328618362546],[365,.066890455782413],[372,.014816547743976],[376,.014262833632529],[420,.025462191551924],[425,.047252278774977]]}},869:(A,g,I)=>{const{uvs:t,faces:C}=I(35),e=t.length;A.exports={createThreeFaceGeometry:A=>{class g extends A.BufferGeometry{constructor(g={}){super(),this.positions=new Float32Array(3*e),this.uvs=new Float32Array(2*e),this.setAttribute("position",new A.BufferAttribute(this.positions,3)),this.setAttribute("uv",new A.BufferAttribute(this.uvs,2)),this.setUvs(),this.setIndex(C)}setUvs(){for(let A=0;A<e;A++)this.uvs[2*A]=t[A][0],this.uvs[2*A+1]=t[A][1];this.getAttribute("uv").needsUpdate=!0}updatePositions(A){for(let g=0;g<e;g++)this.positions[3*g+0]=A[g][0],this.positions[3*g+1]=A[g][1],this.positions[3*g+2]=A[g][2];this.attributes.position.needsUpdate=!0,this.computeVertexNormals()}}return new g}}},478:(A,g,I)=>{const{FaceMesh:t}=I(818);A.exports={FaceMeshHelper:class{constructor(){this.detectResolve=null,this.faceMesh=new t({locateFile:A=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${A}`}),this.faceMesh.setOptions({maxNumFaces:1,refineLandmarks:!1,minDetectionConfidence:.5,minTrackingConfidence:.5}),this.faceMesh.onResults((A=>{this.detectResolve&&this.detectResolve(A)}))}async detect(A){return await new Promise(((g,I)=>{this.detectResolve=g,this.faceMesh.send({image:A})}))}}}},709:(A,g,I)=>{const t=I(804),{Detector:C}=I(413),{buildImageList:e,buildTrackingImageList:B}=I(646),{build:i}=I(454),Q=I(113),o=I(512);const E=async(A,g)=>{const I=[];for(let t=0;t<A.length;t++){const e=A[t],B=new C(e.width,e.height);await o.nextFrame(),o.tidy((()=>{const A=o.tensor(e.data,[e.data.length],"float32").reshape([e.height,e.width]),{featurePoints:C}=B.detect(A),Q=C.filter((A=>A.maxima)),E=C.filter((A=>!A.maxima)),n=i({points:Q}),s=i({points:E});I.push({maximaPoints:Q,minimaPoints:E,maximaPointsCluster:n,minimaPointsCluster:s,width:e.width,height:e.height,scale:e.scale}),g(t)}))}return I};A.exports={Compiler:class{constructor(){this.data=null}compileImageTargets(A,g){return new Promise((async(I,C)=>{const i=[];for(let g=0;g<A.length;g++){const I=A[g],t=document.createElement("canvas");t.width=I.width,t.height=I.height;const C=t.getContext("2d");C.drawImage(I,0,0,I.width,I.height);const e=C.getImageData(0,0,I.width,I.height),B=new Uint8Array(I.width*I.height);for(let A=0;A<B.length;A++){const g=4*A;B[A]=Math.floor((e.data[g]+e.data[g+1]+e.data[g+2])/3)}const Q={data:B,height:I.height,width:I.width};i.push(Q)}const Q=50/i.length;let o=0;this.data=[];for(let A=0;A<i.length;A++){const I=i[A],t=e(I),C=Q/t.length,B=await E(t,(()=>{o+=C,g(o)}));this.data.push({targetImage:I,imageList:t,matchingData:B})}for(let A=0;A<i.length;A++){const g=B(i[A]);this.data[A].trackingImageList=g}const n=await new Promise(((A,I)=>{const C=new t;C.onmessage=I=>{"progress"===I.data.type?g(50+I.data.percent):"compileDone"===I.data.type&&A(I.data.list)},C.postMessage({type:"compile",targetImages:i})}));for(let A=0;A<i.length;A++)this.data[A].trackingData=n[A];I(this.data)}))}exportData(){const A=[];for(let g=0;g<this.data.length;g++)A.push({targetImage:{width:this.data[g].targetImage.width,height:this.data[g].targetImage.height},trackingData:this.data[g].trackingData,matchingData:this.data[g].matchingData});return Q.encode({v:2,dataList:A})}importData(A){const g=Q.decode(new Uint8Array(A));if(!g.v||2!==g.v)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:I}=g;this.data=[];for(let A=0;A<I.length;A++)this.data.push({targetImage:I[A].targetImage,trackingData:I[A].trackingData,matchingData:I[A].matchingData});return this.data}}}},557:(A,g,I)=>{const t=I(512),C=I(246),{Tracker:e}=I(380),{CropDetector:B}=I(708),{Compiler:i}=I(709),{InputLoader:Q}=I(704),{OneEuroFilter:o}=I(489);A.exports={Controller:class{constructor({inputWidth:A,inputHeight:g,onUpdate:I=null,debugMode:t=!1,maxTrack:e=1,warmupTolerance:i=null,missTolerance:o=null,filterMinCF:E=null,filterBeta:n=null}){this.inputWidth=A,this.inputHeight=g,this.maxTrack=e,this.filterMinCF=null===E?.001:E,this.filterBeta=null===n?1e3:n,this.warmupTolerance=null===i?5:i,this.missTolerance=null===o?5:o,this.cropDetector=new B(this.inputWidth,this.inputHeight,t),this.inputLoader=new Q(this.inputWidth,this.inputHeight),this.markerDimensions=null,this.onUpdate=I,this.debugMode=t,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const s=45*Math.PI/180,a=this.inputHeight/2/Math.tan(s/2);this.projectionTransform=[[a,0,this.inputWidth/2],[0,a,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:10,far:1e5}),this.worker=new C,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=A=>{"matchDone"===A.data.type&&null!==this.workerMatchDone&&this.workerMatchDone(A.data),"trackUpdateDone"===A.data.type&&null!==this.workerTrackDone&&this.workerTrackDone(A.data)}}showTFStats(){console.log(t.memory().numTensors),console.table(t.memory())}addImageTargets(A){return new Promise((async(g,I)=>{const t=await fetch(A),C=await t.arrayBuffer();g(this.addImageTargetsFromBuffer(C))}))}addImageTargetsFromBuffer(A){const g=(new i).importData(A),I=[],t=[],C=[];for(let A=0;A<g.length;A++)t.push(g[A].matchingData),I.push(g[A].trackingData),C.push([g[A].targetImage.width,g[A].targetImage.height]);return this.tracker=new e(C,I,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:t}),this.markerDimensions=C,{dimensions:C,matchingDataList:t,trackingDataList:I,dataList:g,buffer:A}}dummyRun(A){const g=this.inputLoader.loadInput(A);this.cropDetector.detect(g),this.tracker.dummyRun(g),g.dispose()}getProjectionMatrix(){return this.projectionMatrix}getWorldMatrix(A,g){return this._glModelViewMatrix(A,g)}async _detectAndMatch(A,g){const{featurePoints:I}=this.cropDetector.detectMoving(A),{targetIndex:t,modelViewTransform:C}=await this._workerMatch(I,g);return{targetIndex:t,modelViewTransform:C}}async _trackAndUpdate(A,g,I){const{worldCoords:t,screenCoords:C}=this.tracker.track(A,g,I);if(t.length<4)return null;return await this._workerTrackUpdate(g,{worldCoords:t,screenCoords:C})}processVideo(A){if(this.processingVideo)return;this.processingVideo=!0,this.trackingStates=[];for(let A=0;A<this.markerDimensions.length;A++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new o({minCutOff:this.filterMinCF,beta:this.filterBeta})});(async()=>{for(;this.processingVideo;){const g=this.inputLoader.loadInput(A);if(this.trackingStates.reduce(((A,g)=>A+(g.isTracking?1:0)),0)<this.maxTrack){const A=[];for(let g=0;g<this.trackingStates.length;g++){!0!==this.trackingStates[g].isTracking&&(-1!==this.interestedTargetIndex&&this.interestedTargetIndex!==g||A.push(g))}const{targetIndex:I,modelViewTransform:t}=await this._detectAndMatch(g,A);-1!==I&&(this.trackingStates[I].isTracking=!0,this.trackingStates[I].currentModelViewTransform=t)}for(let A=0;A<this.trackingStates.length;A++){const I=this.trackingStates[A];if(I.isTracking){let t=await this._trackAndUpdate(g,I.currentModelViewTransform,A);null===t?I.isTracking=!1:I.currentModelViewTransform=t}if(I.showing||I.isTracking&&(I.trackMiss=0,I.trackCount+=1,I.trackCount>this.warmupTolerance&&(I.showing=!0,I.trackingMatrix=null,I.filter.reset())),I.showing&&(I.isTracking?I.trackMiss=0:(I.trackCount=0,I.trackMiss+=1,I.trackMiss>this.missTolerance&&(I.showing=!1,I.trackingMatrix=null,this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:A,worldMatrix:null})))),I.showing){const g=this._glModelViewMatrix(I.currentModelViewTransform,A);I.trackingMatrix=I.filter.filter(Date.now(),g);const t=[];for(let A=0;A<I.trackingMatrix.length;A++)t[A]=I.trackingMatrix[A];this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:A,worldMatrix:t})}}g.dispose(),this.onUpdate&&this.onUpdate({type:"processDone"}),await t.nextFrame()}})()}stopProcessVideo(){this.processingVideo=!1}async detect(A){const g=this.inputLoader.loadInput(A),{featurePoints:I,debugExtra:t}=await this.cropDetector.detect(g);return g.dispose(),{featurePoints:I,debugExtra:t}}async match(A,g){const{modelViewTransform:I,debugExtra:t}=await this._workerMatch(A,[g]);return{modelViewTransform:I,debugExtra:t}}async track(A,g,I){const t=this.inputLoader.loadInput(A),C=this.tracker.track(t,g,I);return t.dispose(),C}async trackUpdate(A,g){if(g.worldCoords.length<4)return null;return await this._workerTrackUpdate(A,g)}_workerMatch(A,g){return new Promise((async(I,t)=>{this.workerMatchDone=A=>{I({targetIndex:A.targetIndex,modelViewTransform:A.modelViewTransform,debugExtra:A.debugExtra})},this.worker.postMessage({type:"match",featurePoints:A,targetIndexes:g})}))}_workerTrackUpdate(A,g){return new Promise((async(I,t)=>{this.workerTrackDone=A=>{I(A.modelViewTransform)};const{worldCoords:C,screenCoords:e}=g;this.worker.postMessage({type:"trackUpdate",modelViewTransform:A,worldCoords:C,screenCoords:e})}))}_glModelViewMatrix(A,g){const I=this.markerDimensions[g][1];return[A[0][0],-A[1][0],-A[2][0],0,-A[0][1],A[1][1],A[2][1],0,-A[0][2],A[1][2],A[2][2],0,A[0][1]*I+A[0][3],-(A[1][1]*I+A[1][3]),-(A[2][1]*I+A[2][3]),1]}_glProjectionMatrix({projectionTransform:A,width:g,height:I,near:t,far:C}){const e=[[2*A[0][0]/g,0,-(2*A[0][2]/g-1),0],[0,2*A[1][1]/I,-(2*A[1][2]/I-1),0],[0,0,-(C+t)/(C-t),-2*C*t/(C-t)],[0,0,-1,0]],B=[];for(let A=0;A<4;A++)for(let g=0;g<4;g++)B.push(e[g][A]);return B}}}},708:(A,g,I)=>{I(512);const{Detector:t}=I(413),{buildModelViewProjectionTransform:C,computeScreenCoordiate:e}=I(740);A.exports={CropDetector:class{constructor(A,g,I=!1){this.debugMode=I,this.width=A,this.height=g;let C=Math.min(A,g)/2,e=Math.pow(2,Math.round(Math.log(C)/Math.log(2)));this.cropSize=e,this.detector=new t(e,e,I),this.kernelCaches={},this.lastRandomIndex=4}detect(A){const g=Math.floor(this.height/2-this.cropSize/2),I=Math.floor(this.width/2-this.cropSize/2),t=this._detect(A,I,g);return this.debugMode&&(t.debugExtra.crop={startX:I,startY:g,cropSize:this.cropSize}),t}detectMoving(A){const g=this.lastRandomIndex%3,I=Math.floor(this.lastRandomIndex/3);let t=Math.floor(this.height/2-this.cropSize+I*this.cropSize/2),C=Math.floor(this.width/2-this.cropSize+g*this.cropSize/2);C<0&&(C=0),t<0&&(t=0),C>=this.width-this.cropSize&&(C=this.width-this.cropSize-1),t>=this.height-this.cropSize&&(t=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9;return this._detect(A,C,t)}_detect(A,g,I){const t=A.slice([I,g],[this.cropSize,this.cropSize]),{featurePoints:C,debugExtra:e}=this.detector.detect(t);return C.forEach((A=>{A.x+=g,A.y+=I})),this.debugMode&&(e.projectedImage=t.arraySync()),t.dispose(),{featurePoints:C,debugExtra:e}}}}},413:(A,g,I)=>{const t=I(512),{FREAKPOINTS:C}=I(134),e=10,B=36,i=(C.length-1)*C.length/2;A.exports={Detector:class{constructor(A,g,I=!1){this.debugMode=I,this.width=A,this.height=g;let t=0;for(;A>=8&&g>=8&&(A/=2,g/=2,t++,5!==t););this.numOctaves=t,this.tensorCaches={},this.kernelCaches={}}detectImageData(A){const g=new Uint8ClampedArray(4*A.length);for(let I=0;I<A.length;I++)g[4*I]=A[I],g[4*I+1]=A[I],g[4*I+2]=A[I],g[4*I+3]=255;const I=new ImageData(g,this.width,this.height);return this.detect(I)}detect(A){let g=null;const I=[];for(let g=0;g<this.numOctaves;g++){let t,C;t=0===g?this._applyFilter(A):this._downsampleBilinear(I[g-1][I[g-1].length-1]),C=this._applyFilter(t),I.push([t,C])}const t=[];for(let A=0;A<this.numOctaves;A++){let g=this._differenceImageBinomial(I[A][0],I[A][1]);t.push(g)}const C=[];for(let A=1;A<this.numOctaves-1;A++){const g=this._buildExtremas(t[A-1],t[A],t[A+1]);C.push(g)}const e=this._applyPrune(C),B=this._computeLocalization(e,t),i=this._computeOrientationHistograms(B,I),Q=this._smoothHistograms(i),o=this._computeExtremaAngles(Q),E=this._computeExtremaFreak(I,B,o),n=this._computeFreakDescriptors(E),s=B.arraySync(),a=o.arraySync(),r=n.arraySync();this.debugMode&&(g={pyramidImages:I.map((A=>A.map((A=>A.arraySync())))),dogPyramidImages:t.map((A=>A?A.arraySync():null)),extremasResults:C.map((A=>A.arraySync())),extremaAngles:o.arraySync(),prunedExtremas:e,localizedExtremas:B.arraySync()}),I.forEach((A=>A.forEach((A=>A.dispose())))),t.forEach((A=>A&&A.dispose())),C.forEach((A=>A.dispose())),B.dispose(),i.dispose(),Q.dispose(),o.dispose(),E.dispose(),n.dispose();const h=[];for(let A=0;A<s.length;A++){if(0==s[A][0])continue;const g=[];for(let I=0;I<r[A].length;I+=4){let t=16777216*r[A][I]+65536*r[A][I+1]+256*r[A][I+2]+r[A][I+3];g.push(t)}const I=s[A][1],t=s[A][2],C=s[A][3]*Math.pow(2,I)+Math.pow(2,I-1)-.5,e=t*Math.pow(2,I)+Math.pow(2,I-1)-.5,B=Math.pow(2,I);h.push({maxima:s[A][0]>0,x:C,y:e,scale:B,angle:a[A],descriptors:g})}return{featurePoints:h,debugExtra:g}}_computeFreakDescriptors(A){if(!this.tensorCaches.computeFreakDescriptors){const g=[],I=[];for(let t=0;t<A.shape[1];t++)for(let C=t+1;C<A.shape[1];C++)g.push(t),I.push(C);const C=t.tensor(g,[g.length]).cast("int32"),e=t.tensor(I,[I.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:t.keep(t.stack([C,e],1))}}const{positionT:g}=this.tensorCaches.computeFreakDescriptors,I=Math.ceil(i/8);if(!this.kernelCaches.computeFreakDescriptors){const g={variableNames:["freak","p"],outputShape:[A.shape[0],I],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int descIndex = coords[1] * 8;\n\n\t    int sum = 0;\n\t    for (int i = 0; i < 8; i++) {\n\t      if (descIndex + i >= ${i}) {\n\t\tcontinue;\n\t      }\n\n\t      int p1 = int(getP(descIndex + i, 0));\n\t      int p2 = int(getP(descIndex + i, 1));\n\n\t      float v1 = getFreak(featureIndex, p1);\n\t      float v2 = getFreak(featureIndex, p2);\n\n\t      if (v1 < v2 + 0.01) {\n\t        sum += int(pow(2.0, float(7 - i)));\n\t      }\n\t    }\n\t    setOutput(float(sum));\n\t  }\n\t`};this.kernelCaches.computeFreakDescriptors=[g]}return t.tidy((()=>{const[I]=this.kernelCaches.computeFreakDescriptors;return this._runWebGLProgram(I,[A,g],"int32")}))}_computeExtremaFreak(A,g,I){this.tensorCaches._computeExtremaFreak||t.tidy((()=>{const A=t.tensor(C);this.tensorCaches._computeExtremaFreak={freakPointsT:t.keep(A)}}));const{freakPointsT:e}=this.tensorCaches._computeExtremaFreak,B=[];for(let g=1;g<A.length;g++)B.push(A[g][1]);if(!this.kernelCaches._computeExtremaFreak){const I=[];for(let g=1;g<A.length;g++)I.push("image"+g);let t="float getPixel(int octave, int y, int x) {";for(let g=1;g<A.length;g++)t+=`\n\t  if (octave == ${g}) {\n\t    return getImage${g}(y, x);\n\t  }\n\t`;t+="}";const e={variableNames:[...I,"extrema","angles","freakPoints"],outputShape:[g.shape[0],C.length],userCode:`\n\t  ${t}\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int freakIndex = coords[1];\n\n\t    float freakSigma = getFreakPoints(freakIndex, 0);\n\t    float freakX = getFreakPoints(freakIndex, 1);\n\t    float freakY = getFreakPoints(freakIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    float inputY = getExtrema(featureIndex, 2);\n\t    float inputX = getExtrema(featureIndex, 3);\n\t    float inputAngle = getAngles(featureIndex);\n            float cos = 7. * cos(inputAngle);\n            float sin = 7. * sin(inputAngle);\n\n\t    float yp = inputY + freakX * sin + freakY * cos;\n\t    float xp = inputX + freakX * cos + freakY * -sin;\n\n\t    int x0 = int(floor(xp));\n\t    int x1 = x0 + 1;\n\t    int y0 = int(floor(yp));\n\t    int y1 = y0 + 1;\n\n\t    float f1 = getPixel(octave, y0, x0);\n\t    float f2 = getPixel(octave, y0, x1);\n\t    float f3 = getPixel(octave, y1, x0);\n\t    float f4 = getPixel(octave, y1, x1);\n\n\t    float x1f = float(x1);\n\t    float y1f = float(y1);\n\t    float x0f = float(x0);\n\t    float y0f = float(y0);\n\n\t    // ratio for interpolation between four neighbouring points\n\t    float value = (x1f - xp) * (y1f - yp) * f1\n\t\t\t+ (xp - x0f) * (y1f - yp) * f2\n\t\t\t+ (x1f - xp) * (yp - y0f) * f3\n\t\t\t+ (xp - x0f) * (yp - y0f) * f4;\n\n\t    setOutput(value);\n\t  }\n\t`};this.kernelCaches._computeExtremaFreak=[e]}return t.tidy((()=>{const[A]=this.kernelCaches._computeExtremaFreak;return this._compileAndRun(A,[...B,g,I,e])}))}_computeExtremaAngles(A){if(!this.kernelCaches.computeExtremaAngles){const g={variableNames:["histogram"],outputShape:[A.shape[0]],userCode:`\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\n\t    int maxIndex = 0;\n\t    for (int i = 1; i < 36; i++) {\n\t      if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {\n\t\tmaxIndex = i;\n\t      }\n\t    }\n\n\t    int prev = imod(maxIndex - 1 + 36, 36);\n\t    int next = imod(maxIndex + 1, 36);\n\n\t    /**\n\t     * Fit a quatratic to 3 points. The system of equations is:\n\t     *\n\t     * y0 = A*x0^2 + B*x0 + C\n\t     * y1 = A*x1^2 + B*x1 + C\n\t     * y2 = A*x2^2 + B*x2 + C\n\t     *\n\t     * This system of equations is solved for A,B,C.\n\t     */\n\t    float p10 = float(maxIndex - 1);\n\t    float p11 = getHistogram(featureIndex, prev); \n\t    float p20 = float(maxIndex);\n\t    float p21 = getHistogram(featureIndex, maxIndex); \n\t    float p30 = float(maxIndex + 1);\n\t    float p31 = getHistogram(featureIndex, next); \n\n\t    float d1 = (p30-p20)*(p30-p10);\n\t    float d2 = (p10-p20)*(p30-p10);\n\t    float d3 = p10-p20;\n\n\t    // If any of the denominators are zero then, just use maxIndex.\n            float fbin = float(maxIndex);\n\t    if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {\n\t      float a = p10*p10;\n\t      float b = p20*p20;\n\n\t      // Solve for the coefficients A,B,C\n\t      float A = ((p31-p21)/d1)-((p11-p21)/d2);\n\t      float B = ((p11-p21)+(A*(b-a)))/d3;\n\t      float C = p11-(A*a)-(B*p10);\n\t      fbin = -B / (2. * A);\n\t    }\n\n\t    float an = 2.0 *${Math.PI} * (fbin + 0.5) / 36. - ${Math.PI};\n\t    setOutput(an);\n\t  }\n\t`};this.kernelCaches.computeExtremaAngles=g}return t.tidy((()=>{const g=this.kernelCaches.computeExtremaAngles;return this._compileAndRun(g,[A])}))}_computeOrientationHistograms(A,g){const I=[];for(let A=1;A<g.length;A++)I.push(g[A][1]);this.tensorCaches.orientationHistograms||t.tidy((()=>{const A=Math.ceil(4.5),g=[];for(let I=-A;I<=A;I++)for(let t=-A;t<=A;t++){const A=t*t+I*I;if(A<=20.25){const C=-.05555555555555555*A;let e=.0013888888*(720+C*(720+C*(360+C*(120+C*(30+C*(6+C))))));g.push([I,t,e])}}this.tensorCaches.orientationHistograms={radialPropertiesT:t.keep(t.tensor(g,[g.length,3]))}}));const{radialPropertiesT:C}=this.tensorCaches.orientationHistograms;if(!this.kernelCaches.computeOrientationHistograms){const I=[];for(let A=1;A<g.length;A++)I.push("image"+A);let t="float getPixel(int octave, int y, int x) {";for(let A=1;A<g.length;A++)t+=`\n\t  if (octave == ${A}) {\n\t    return getImage${A}(y, x);\n\t  }\n\t`;t+="}";const e={variableNames:[...I,"extrema","radial"],outputShape:[A.shape[0],C.shape[0],2],userCode:`\n\t  ${t}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int radialIndex = coords[1];\n\t    int propertyIndex = coords[2];\n\n\t    int radialY = int(getRadial(radialIndex, 0));\n\t    int radialX = int(getRadial(radialIndex, 1));\n\t    float radialW = getRadial(radialIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\n\t    int xp = x + radialX;\n\t    int yp = y + radialY;\n\n\t    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);\n\t    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);\n\n\t    if (propertyIndex == 0) {\n\t      // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0\n\t      \n\t      float angle = atan(dy, dx) + ${Math.PI};\n\t      float fbin = angle * 36. * 0.159154943091895;\n\t      setOutput(fbin);\n\t      return;\n\t    }\n\n\t    if (propertyIndex == 1) {\n\t      float mag = sqrt(dx * dx + dy * dy);\n\t      float magnitude = radialW * mag;\n\t      setOutput(magnitude);\n\t      return;\n\t    }\n\t  }\n\n\t`},i={variableNames:["fbinMag"],outputShape:[A.shape[0],B],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    float sum = 0.;\n\t    for (int i = 0; i < ${C.shape[0]}; i++) {\n\t      float fbin = getFbinMag(featureIndex, i, 0);\n\t      int bin = int(floor(fbin - 0.5));\n\t      int b1 = imod(bin + 36, 36);\n\t      int b2 = imod(bin + 1 + 36, 36);\n\n\t      if (b1 == binIndex || b2 == binIndex) {\n\t\tfloat magnitude = getFbinMag(featureIndex, i, 1);\n\t\tfloat w2 = fbin - float(bin) - 0.5;\n\t\tfloat w1 = w2 * -1. + 1.;\n\n\t\tif (b1 == binIndex) {\n\t\t  sum += w1 * magnitude;\n\t\t}\n\t\tif (b2 == binIndex) {\n\t\t  sum += w2 * magnitude;\n\t\t}\n\t      }\n\t    }\n\t    setOutput(sum);\n\t  }\n\t`};this.kernelCaches.computeOrientationHistograms=[e,i]}return t.tidy((()=>{const[g,t]=this.kernelCaches.computeOrientationHistograms,e=this._compileAndRun(g,[...I,A,C]);return this._compileAndRun(t,[e])}))}_smoothHistograms(A){if(!this.kernelCaches.smoothHistograms){const g={variableNames:["histogram"],outputShape:[A.shape[0],B],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    int prevBin = imod(binIndex - 1 + 36, 36);\n\t    int nextBin = imod(binIndex + 1, 36);\n\n            float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);\n\n\t    setOutput(result);\n\t  }\n\t"};this.kernelCaches.smoothHistograms=g}return t.tidy((()=>{const g=this.kernelCaches.smoothHistograms;for(let I=0;I<5;I++)A=this._compileAndRun(g,[A]);return A}))}_computeLocalization(A,g){if(!this.kernelCaches.computeLocalization){const I=[];let t="float getPixel(int octave, int y, int x) {";for(let A=1;A<g.length;A++)I.push("image"+A),t+=`\n\t  if (octave == ${A}) {\n\t    return getImage${A}(y, x);\n\t  }\n \t`;t+="}";const C={variableNames:[...I,"extrema"],outputShape:[A.length,3,3],userCode:`\n\t  ${t}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    float score = getExtrema(featureIndex, 0);\n\t    if (score == 0.0) {\n\t      return;\n\t    }\n\n\t    int dy = coords[1]-1;\n\t    int dx = coords[2]-1;\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\t    setOutput(getPixel(octave, y+dy, x+dx));\n\t  }\n\t`};this.kernelCaches.computeLocalization=[C]}return t.tidy((()=>{const I=this.kernelCaches.computeLocalization[0],C=t.tensor(A,[A.length,A[0].length],"int32"),e=this._compileAndRun(I,[...g.slice(1),C]).arraySync(),B=[];for(let A=0;A<e.length;A++){B.push([]);for(let g=0;g<e[A].length;g++)B[A].push([])}const i=[];for(let g=0;g<A.length;g++)i[g]=[A[g][0],A[g][1],A[g][2],A[g][3]];for(let A=0;A<i.length;A++){if(0===i[A][0])continue;const g=e[A],I=.5*(g[1][2]-g[1][0]),t=.5*(g[2][1]-g[0][1]),C=g[1][2]+g[1][0]-2*g[1][1],B=g[2][1]+g[0][1]-2*g[1][1],Q=.25*(g[0][0]+g[2][2]-g[0][2]-g[2][0]),o=C*B-Q*Q,E=(B*-I+-Q*-t)/o,n=(-Q*-I+C*-t)/o,s=i[A][2]+n,a=i[A][3]+E;Math.abs(o)<1e-4||(i[A][2]=s,i[A][3]=a)}return t.tensor(i,[i.length,i[0].length],"float32")}))}_applyPrune(A){if(!this.kernelCaches.applyPrune){const g=[];for(let I=0;I<A.length;I++){const t=A[I].shape[0],C=A[I].shape[1],e={variableNames:["extrema"],outputShape:[Math.floor(t/2),Math.floor(C/2)],userCode:"\n\t    void main() {\n\t      ivec2 coords = getOutputCoords();\n\t      int y = coords[0] * 2;\n\t      int x = coords[1] * 2;\n\n\t      float location = 0.0;\n\t      float values = getExtrema(y, x);\n\n\t      if (getExtrema(y+1, x) != 0.0) {\n\t        location = 1.0;\n\t\tvalues = getExtrema(y+1, x);\n\t      }\n\t      else if (getExtrema(y, x+1) != 0.0) {\n\t        location = 2.0;\n\t\tvalues = getExtrema(y, x+1);\n\t      }\n\t      else if (getExtrema(y+1, x+1) != 0.0) {\n\t        location = 3.0;\n\t\tvalues = getExtrema(y+1, x+1);\n\t      }\n\n\t      if (values < 0.0) {\n\t        setOutput(location * -1000.0 + values);\n\t      } else {\n\t        setOutput(location * 1000.0 + values);\n\t      }\n\t    }\n\t  "};g.push(e)}this.kernelCaches.applyPrune={reductionKernels:g}}const g=[],I=[];for(let A=0;A<100;A++){I.push([]),g.push([]);for(let t=0;t<5;t++)I[A].push([0,0,0,0]),g[A].push(0)}t.tidy((()=>{const{reductionKernels:t}=this.kernelCaches.applyPrune;for(let C=0;C<A.length;C++){const B=t[C],i=this._compileAndRun(B,[A[C]]),Q=C+1,o=i.arraySync(),E=i.shape[0],n=i.shape[1],s=2*n/e,a=2*E/e;for(let A=0;A<E;A++)for(let t=0;t<n;t++){const C=o[A][t];if(0==C)continue;const B=C%1e3,i=Math.floor(Math.abs(C)/1e3),E=2*t+(2===i||3===i?1:0),n=2*A+(1===i||3===i?1:0),r=Math.floor(E/s),h=Math.floor(n/a)*e+r,c=Math.abs(B);let l=5;for(;l>=1&&c>g[h][l-1];)l-=1;if(l<5){for(let A=4;A>=l+1;A--)g[h][A]=g[h][A-1],I[h][A][0]=I[h][A-1][0],I[h][A][1]=I[h][A-1][1],I[h][A][2]=I[h][A-1][2],I[h][A][3]=I[h][A-1][3];g[h][l]=c,I[h][l][0]=B,I[h][l][1]=Q,I[h][l][2]=n,I[h][l][3]=E}}}}));const C=[];for(let A=0;A<100;A++)for(let g=0;g<5;g++)C.push(I[A][g]);return C}_buildExtremas(A,g,I){const C=g.shape[0],e=g.shape[1],B="w"+e;if(this.kernelCaches.buildExtremas||(this.kernelCaches.buildExtremas={}),!this.kernelCaches.buildExtremas[B]){const A={variableNames:["image0","image1","image2"],outputShape:[C,e],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int y = coords[0];\n\t    int x = coords[1];\n\n\t    float value = getImage1(y, x);\n\n\t    // Step 1: find local maxima/minima\n\t    if (value * value < 9.) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (y < 7 || y > ${C-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (x < 7 || x > ${e-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    bool isMax = true;\n\t    bool isMin = true;\n\t    for (int dy = -1; dy <= 1; dy++) {\n\t      for (int dx = -1; dx <= 1; dx++) {\n\t        float value0 = getImage0(y+dy, x+dx);\n\t        float value1 = getImage1(y+dy, x+dx);\n\t        float value2 = getImage2(y+dy, x+dx);\n\n\t\tif (value < value0 || value < value1 || value < value2) {\n\t\t  isMax = false;\n\t\t}\n\t\tif (value > value0 || value > value1 || value > value2) {\n\t\t  isMin = false;\n\t\t}\n\t      }\n\t    }\n\n\t    if (!isMax && !isMin) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    // compute edge score and reject based on threshold\n\t    float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);\n\t    float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);\n\t    float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));\n\n\t    float det = (dxx * dyy) - (dxy * dxy);\n\n\t    if (abs(det) < 0.0001) { // determinant undefined. no solution\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    float edgeScore = (dxx + dyy) * (dxx + dyy) / det;\n\n\t    if (abs(edgeScore) >= 6.25 ) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    setOutput(getImage1(y,x));\n\t  }\n\t`};this.kernelCaches.buildExtremas[B]=A}return t.tidy((()=>{const t=this.kernelCaches.buildExtremas[B];return A=this._downsampleBilinear(A),I=this._upsampleBilinear(I,g),this._compileAndRun(t,[A,g,I])}))}_differenceImageBinomial(A,g){return t.tidy((()=>A.sub(g)))}_applyFilter(A){const g=A.shape[0],I=A.shape[1],C="w"+I;if(this.kernelCaches.applyFilter||(this.kernelCaches.applyFilter={}),!this.kernelCaches.applyFilter[C]){const A={variableNames:["p"],outputShape:[g,I],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0], coords[1]-2);\n\t    sum += getP(coords[0], coords[1]-1) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0], coords[1]+1) * 4.;\n\t    sum += getP(coords[0], coords[1]+2);\n\t    setOutput(sum);\n\t  }\n\t"},t={variableNames:["p"],outputShape:[g,I],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0]-2, coords[1]);\n\t    sum += getP(coords[0]-1, coords[1]) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0]+1, coords[1]) * 4.;\n\t    sum += getP(coords[0]+2, coords[1]);\n\t    sum /= 256.;\n\t    setOutput(sum);\n\t  }\n\t"};this.kernelCaches.applyFilter[C]=[A,t]}return t.tidy((()=>{const[g,I]=this.kernelCaches.applyFilter[C],t=this._compileAndRun(g,[A]);return this._compileAndRun(I,[t])}))}_upsampleBilinear(A,g){A.shape[0];const I="w"+A.shape[1];if(this.kernelCaches.upsampleBilinear||(this.kernelCaches.upsampleBilinear={}),!this.kernelCaches.upsampleBilinear[I]){const A={variableNames:["p"],outputShape:[g.shape[0],g.shape[1]],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int j = coords[0];\n\t    int i = coords[1];\n\n\t    float sj = 0.5 * float(j) - 0.25; \n\t    float si = 0.5 * float(i) - 0.25;\n\n\t    float sj0 = floor(sj);\n\t    float sj1 = ceil(sj);\n\t    float si0 = floor(si);\n\t    float si1 = ceil(si);\n\n\t    int sj0I = int(sj0);\n\t    int sj1I = int(sj1);\n\t    int si0I = int(si0);\n\t    int si1I = int(si1);\n\n\t    float sum = 0.0;\n\t    sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);\n\t    sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);\n\t    sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);\n\t    sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);\n\t    setOutput(sum);\n\t  }\n\t"};this.kernelCaches.upsampleBilinear[I]=A}return t.tidy((()=>{const g=this.kernelCaches.upsampleBilinear[I];return this._compileAndRun(g,[A])}))}_downsampleBilinear(A){const g=A.shape[0],I=A.shape[1],C="w"+I;if(this.kernelCaches.downsampleBilinear||(this.kernelCaches.downsampleBilinear={}),!this.kernelCaches.downsampleBilinear[C]){const A={variableNames:["p"],outputShape:[Math.floor(g/2),Math.floor(I/2)],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int y = coords[0] * 2;\n\t    int x = coords[1] * 2;\n\n\t    float sum = getP(y, x) * 0.25;\n\t    sum += getP(y+1,x) * 0.25; \n\t    sum += getP(y, x+1) * 0.25; \n\t    sum += getP(y+1,x+1) * 0.25;\n\t    setOutput(sum);\n\t  }\n\t"};this.kernelCaches.downsampleBilinear[C]=A}return t.tidy((()=>{const g=this.kernelCaches.downsampleBilinear[C];return this._compileAndRun(g,[A])}))}_compileAndRun(A,g){const I=t.backend().compileAndRun(A,g);return t.engine().makeTensorFromDataId(I.dataId,I.shape,I.dtype)}_runWebGLProgram(A,g,I){const C=t.backend().runWebGLProgram(A,g,I);return t.engine().makeTensorFromDataId(C.dataId,C.shape,C.dtype)}}}},134:A=>{const g=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],I=[];for(let A=0;A<g.length;A++){const t=g[A].sigma;for(let C=0;C<g[A].points.length;C++){const e=g[A].points[C];I.push([t,e[0],e[1]])}}A.exports={FREAKPOINTS:I}},740:A=>{const g=(A,g,I,t)=>({x:A[0][0]*g+A[0][1]*I+A[0][3],y:A[1][0]*g+A[1][1]*I+A[1][3],z:A[2][0]*g+A[2][1]*I+A[2][3]});A.exports={buildModelViewProjectionTransform:(A,g)=>[[A[0][0]*g[0][0]+A[0][2]*g[2][0],A[0][0]*g[0][1]+A[0][2]*g[2][1],A[0][0]*g[0][2]+A[0][2]*g[2][2],A[0][0]*g[0][3]+A[0][2]*g[2][3]],[A[1][1]*g[1][0]+A[1][2]*g[2][0],A[1][1]*g[1][1]+A[1][2]*g[2][1],A[1][1]*g[1][2]+A[1][2]*g[2][2],A[1][1]*g[1][3]+A[1][2]*g[2][3]],[g[2][0],g[2][1],g[2][2],g[2][3]]],applyModelViewProjectionTransform:g,computeScreenCoordiate:(A,I,t,C)=>{const{x:e,y:B,z:i}=g(A,I,t);return{x:e/i,y:B/i}}}},646:(A,g,I)=>{const{resize:t}=I(45);A.exports={buildImageList:A=>{const g=[];let I=100/Math.min(A.width,A.height);for(;;)if(g.push(I),I*=Math.pow(2,1/3),I>=.95){I=1;break}g.push(I),g.reverse();const C=[];for(let I=0;I<g.length;I++){A.width,g[I],A.height,g[I];C.push(Object.assign(t({image:A,ratio:g[I]}),{scale:g[I]}))}return C},buildTrackingImageList:A=>{const g=Math.min(A.width,A.height),I=[],C=[];I.push(256/g),I.push(128/g);for(let g=0;g<I.length;g++)C.push(Object.assign(t({image:A,ratio:I[g]}),{scale:I[g]}));return C}}},704:(A,g,I)=>{const t=I(512);A.exports={InputLoader:class{constructor(A,g){this.width=A,this.height=g,this.texShape=[g,A];const I=document.createElement("canvas").getContext("2d");I.canvas.width=A,I.canvas.height=g,this.context=I,this.program=this.buildProgram(A,g);const C=t.backend();this.tempPixelHandle=C.makeTensorInfo(this.texShape,"float32"),C.texData.get(this.tempPixelHandle.dataId).usage=2}_loadInput(A){return t.tidy((()=>{let g=t.browser.fromPixels(A);return g=g.mean(2),g}))}loadInput(A){this.context.drawImage(A,0,0,this.width,this.height);const g=t.backend();g.gpgpu.uploadPixelDataToTexture(g.getTexture(this.tempPixelHandle.dataId),this.context.canvas);return this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(A,g){const I=2===t.env().getNumber("WEBGL_VERSION")?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`\n\tvoid main() {\n\t  ivec2 coords = getOutputCoords();\n\t  int texR = coords[0];\n\t  int texC = coords[1];\n\t  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${A}.0, ${g}.0);\n\n\t  vec4 values = ${I}(A, uv);\n\t  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);\n\t}\n      `}}_compileAndRun(A,g){const I=t.backend().compileAndRun(A,g);return t.engine().makeTensorFromDataId(I.dataId,I.shape,I.dtype)}_runWebGLProgram(A,g,I){const C=t.backend().runWebGLProgram(A,g,I);return t.engine().makeTensorFromDataId(C.dataId,C.shape,C.dtype)}}}},990:A=>{const g=A=>{var g=A-(A>>1&1431655765);return g=((g=((g=((g=(g>>2&858993459)+(858993459&g))>>4)+g&252645135)>>8)+g&16711935)>>16)+g&65535};A.exports={compute:A=>{const{v1:I,v2:t}=A;let C=0;for(let A=0;A<I.length;A++){let e=(I[A]^t[A])>>>0;C+=g(e)}return C}}},454:(A,g,I)=>{const{compute:t}=I(990),{createRandomizer:C}=I(262),e=A=>{const{points:g,pointIndexes:I,centerPointIndex:C,randomizer:B}=A;let i=!1;(I.length<=8||I.length<=16)&&(i=!0);const Q={};if(!i){const A=(A=>{const{points:g,pointIndexes:I,randomizer:C}=A,e=[];for(let A=0;A<I.length;A++)e.push(A);let B=Number.MAX_SAFE_INTEGER,i=-1;const Q=[];for(let A=0;A<128;A++){C.arrayShuffle({arr:e,sampleSize:8});let o=0;const E=[];for(let A=0;A<I.length;A++){let C=Number.MAX_SAFE_INTEGER;for(let B=0;B<8;B++){const i=I[e[B]],Q=t({v1:g[I[A]].descriptors,v2:g[i].descriptors});Q<C&&(E[A]=e[B],C=Q)}o+=C}Q.push(E),o<B&&(B=o,i=A)}return Q[i]})({points:g,pointIndexes:I,randomizer:B});for(let g=0;g<A.length;g++)void 0===Q[I[A[g]]]&&(Q[I[A[g]]]=[]),Q[I[A[g]]].push(I[g])}1===Object.keys(Q).length&&(i=!0);const o={centerPointIndex:C};if(i){o.leaf=!0,o.pointIndexes=[];for(let A=0;A<I.length;A++)o.pointIndexes.push(I[A]);return o}return o.leaf=!1,o.children=[],Object.keys(Q).forEach((A=>{o.children.push(e({points:g,pointIndexes:Q[A],centerPointIndex:A,randomizer:B}))})),o};A.exports={build:({points:A})=>{const g=[];for(let I=0;I<A.length;I++)g.push(I);const I=C();return{rootNode:e({points:A,pointIndexes:g,centerPointIndex:null,randomizer:I})}}}},380:(A,g,I)=>{const t=I(512),{buildModelViewProjectionTransform:C,computeScreenCoordiate:e}=I(740),B=1e3;A.exports={Tracker:class{constructor(A,g,I,t,C,e=!1){this.markerDimensions=A,this.trackingDataList=g,this.projectionTransform=I,this.debugMode=e,this.trackingKeyframeList=[];for(let A=0;A<g.length;A++)this.trackingKeyframeList.push(g[A][1]);let B=0;for(let A=0;A<this.trackingKeyframeList.length;A++)B=Math.max(B,this.trackingKeyframeList[A].points.length);this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(let A=0;A<this.trackingKeyframeList.length;A++){const{featurePoints:g,imagePixels:I,imageProperties:t}=this._prebuild(this.trackingKeyframeList[A],B);this.featurePointsListT[A]=g,this.imagePixelsListT[A]=I,this.imagePropertiesListT[A]=t}this.kernelCaches={}}dummyRun(A){let g=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let I=0;I<this.featurePointsListT.length;I++)this.track(A,g,I)}track(A,g,I){let t={};const B=C(this.projectionTransform,g),i=this._buildAdjustedModelViewTransform(B),Q=(this.markerDimensions[I][0],this.markerDimensions[I][1],this.trackingKeyframeList[I].width,this.trackingKeyframeList[I].height,this.featurePointsListT[I]),o=this.imagePixelsListT[I],E=this.imagePropertiesListT[I],n=this._computeProjection(i,A,I),{matchingPointsT:s,simT:a}=this._computeMatching(Q,o,E,n),r=s.arraySync(),h=a.arraySync(),c=this.trackingKeyframeList[I],l=[],D=[],u=[];for(let A=0;A<r.length;A++)if(h[A]>.8&&A<c.points.length){u.push(A);const g=e(B,r[A][0],r[A][1]);D.push(g),l.push({x:c.points[A].x/c.scale,y:c.points[A].y/c.scale,z:0})}return this.debugMode&&(t={projectedImage:n.arraySync(),matchingPoints:s.arraySync(),goodTrack:u,trackedPoints:D}),i.dispose(),n.dispose(),s.dispose(),a.dispose(),{worldCoords:l,screenCoords:D,debugExtra:t}}_computeMatching(A,g,I,C){const e=C.shape[0],B=C.shape[1],i=A.shape[0];if(!this.kernelCaches.computeMatching){const A={variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[i,441],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int searchOffsetIndex = coords[1];\n\n\t    int markerWidth = int(getMarkerProperties(0));\n\t    int markerHeight = int(getMarkerProperties(1));\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int searchOffsetX = imod(searchOffsetIndex, 21) * 1;\n\t    int searchOffsetY = searchOffsetIndex / 21 * 1;\n\n\t    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);\n\t    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);\n\n\t    int sx = sCenterX + searchOffsetX - 10;\n\t    int sy = sCenterY + searchOffsetY - 10;\n\n\t    if (sx < 6 || sx >= (${B} - 6) || sy < 6 || sy >= (${e} - 6)) {\n\t      setOutput(-2.);\n\t    } \n\t    else {\n\t      float sumPoint = 0.;\n\t      float sumPointSquare = 0.;\n\t      float sumTemplate = 0.;\n\t      float sumTemplateSquare = 0.;\n\t      float sumPointTemplate = 0.;\n\n\t      for (int templateOffsetY = 0; templateOffsetY < 13; templateOffsetY++) {\n\t\tfor (int templateOffsetX = 0; templateOffsetX < 13; templateOffsetX++) {\n\t\t  int fx2 = sCenterX + templateOffsetX - 6;\n\t\t  int fy2 = sCenterY + templateOffsetY - 6;\n\n\t\t  int sx2 = sx + templateOffsetX - 6;\n\t\t  int sy2 = sy + templateOffsetY - 6;\n\n\t\t  int markerPixelIndex = fy2 * markerWidth + fx2;\n\t\t  float markerPixel = getMarkerPixels(markerPixelIndex);\n\t\t  float targetPixel = getTargetPixels(sy2, sx2);\n\n\t\t  sumTemplate += markerPixel;\n\t\t  sumTemplateSquare += markerPixel * markerPixel;\n\t\t  sumPoint += targetPixel;\n\t\t  sumPointSquare += targetPixel * targetPixel;\n\t\t  sumPointTemplate += targetPixel * markerPixel;\n\t\t}\n\t      }\n\n\t      // Normalized cross-correlation\n\t      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)\n\t      float count = float(13 * 13);\n\t      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);\n\t      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);\n\n\t      if (pointVariance < 0.0000001) {\n\t\tsetOutput(-3.);\n\t      } else if (templateVariance < 0.0000001) {\n\t\t//setOutput(sumTemplate);\n\t\tsetOutput(-4.);\n\t      } else {\n\t\tsumPointTemplate -= sumPoint / count * sumTemplate;\n\t\tfloat sim = sumPointTemplate / pointVariance / templateVariance;  \n\t\tsetOutput(sim);\n\t      }\n\t    }\n\t  }\n\t`},g={variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[i,2],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int featureIndex = coords[0];\n\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    int searchLocationIndex = maxIndex / 441;\n\t    int searchOffsetIndex = imod(maxIndex, 441);\n\n\t    if (coords[1] == 0) {\n\t      int searchOffsetX = imod(searchOffsetIndex, 21) * 1;\n\t      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - 10) / markerScale);\n\t    }\n\t    else if (coords[1] == 1) {\n\t      int searchOffsetY = searchOffsetIndex / 21 * 1;\n\t      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - 10) / markerScale);\n\t    }\n\t  }\n\t"},I={variableNames:["sims","maxIndex"],outputShape:[i],userCode:"\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    setOutput(getSims(featureIndex, maxIndex));\n\t  }\n\t"};this.kernelCaches.computeMatching=[A,g,I]}return t.tidy((()=>{const t=this.kernelCaches.computeMatching,e=this._compileAndRun(t[0],[A,g,I,C]),B=e.argMax(1);return{matchingPointsT:this._compileAndRun(t[1],[A,I,B]),simT:this._compileAndRun(t[2],[e,B])}}))}_computeProjection(A,g,I){const C=this.trackingKeyframeList[I].width,e=this.trackingKeyframeList[I].height,B=this.trackingKeyframeList[I].scale,i=C+"-"+e+"-"+B;if(this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),!this.kernelCaches.computeProjection[i]){const A={variableNames:["M","pixel"],outputShape:[e,C],userCode:`\n\t  void main() {\n\t      ivec2 coords = getOutputCoords();\n\n\t      float m00 = getM(0, 0) * 1000.;\n\t      float m01 = getM(0, 1) * 1000.;\n\t      float m03 = getM(0, 3) * 1000.;\n\t      float m10 = getM(1, 0) * 1000.;\n\t      float m11 = getM(1, 1) * 1000.;\n\t      float m13 = getM(1, 3) * 1000.;\n\t      float m20 = getM(2, 0) * 1000.;\n\t      float m21 = getM(2, 1) * 1000.;\n\t      float m23 = getM(2, 3) * 1000.;\n\n\t      float y = float(coords[0]) / float(${B});\n\t      float x = float(coords[1]) / float(${B});\n\t      float uz = (x * m20) + (y * m21) + m23;\n\t      float oneOverUz = 1. / uz;\n\n\t      float ux = (x * m00) + (y * m01) + m03;\n\t      float uy = (x * m10) + (y * m11) + m13;\n\n\t      ux = floor(ux * oneOverUz + 0.5);\n\t      uy = floor(uy * oneOverUz + 0.5);\n\t      setOutput(getPixel(int(uy), int(ux)));\n\t    }\n\t`};this.kernelCaches.computeProjection[i]=A}return t.tidy((()=>{const I=this.kernelCaches.computeProjection[i];return this._compileAndRun(I,[A,g])}))}_buildAdjustedModelViewTransform(A){return t.tidy((()=>{let g=[];for(let I=0;I<A.length;I++){g.push([]);for(let t=0;t<A[I].length;t++)g[I].push(A[I][t]/B)}return t.tensor(g,[3,4])}))}_prebuild(A,g){return t.tidy((()=>{const I=A.scale,C=[];for(let t=0;t<g;t++)t<A.points.length?C.push([A.points[t].x/I,A.points[t].y/I]):C.push([-1,-1]);const e=t.tensor(A.data,[A.width*A.height]),B=t.tensor([A.width,A.height,A.scale],[3]);return{featurePoints:t.tensor(C,[C.length,2],"float32"),imagePixels:e,imageProperties:B}}))}_compileAndRun(A,g){const I=t.backend().compileAndRun(A,g);return t.engine().makeTensorFromDataId(I.dataId,I.shape,I.dtype)}}}},45:A=>{A.exports={downsampleBilinear:({image:A})=>{const{data:g,width:I,height:t}=A,C=Math.floor(I/2),e=Math.floor(t/2),B=new Float32Array(C*e),i=[0,1,I,I+1];for(let A=0;A<e;A++)for(let t=0;t<C;t++){let e=2*A*I+2*t,Q=0;for(let A=0;A<i.length;A++)Q+=g[e+i[A]];Q*=.25,B[A*C+t]=Q}return{data:B,width:C,height:e}},upsampleBilinear:({image:A,padOneWidth:g,padOneHeight:I})=>{const{width:t,height:C,data:e}=A,B=2*A.width+(g?1:0),i=2*A.height+(I?1:0),Q=new Float32Array(B*i);for(let A=0;A<B;A++){const g=.5*A-.25;let I=Math.floor(g),o=Math.ceil(g);I<0&&(I=0),o>=t&&(o=t-1);for(let E=0;E<i;E++){const i=.5*E-.25;let n=Math.floor(i),s=Math.ceil(i);n<0&&(n=0),s>=C&&(s=C-1);const a=(o-g)*(s-i)*e[n*t+I]+(o-g)*(i-n)*e[s*t+I]+(g-I)*(s-i)*e[n*t+o]+(g-I)*(i-n)*e[s*t+o];Q[E*B+A]=a}}return{data:Q,width:B,height:i}},resize:({image:A,ratio:g})=>{const I=Math.round(A.width*g),t=Math.round(A.height*g),C=new Uint8Array(I*t);for(let e=0;e<I;e++){let B=Math.round(1*e/g),i=Math.round(1*(e+1)/g)-1;i>=A.width&&(i=A.width-1);for(let Q=0;Q<t;Q++){let t=Math.round(1*Q/g),o=Math.round(1*(Q+1)/g)-1;o>=A.height&&(o=A.height-1);let E=0,n=0;for(let g=B;g<=i;g++)for(let I=t;I<=o;I++)E+=1*A.data[I*A.width+g],n+=1;C[Q*I+e]=Math.floor(E/n)}}return{data:C,width:I,height:t}}}},262:A=>{A.exports={createRandomizer:()=>({seed:1234,arrayShuffle(A){const{arr:g,sampleSize:I}=A;for(let A=0;A<I;A++){this.seed=(214013*this.seed+2531011)%(1<<31);let I=this.seed>>16&32767;I%=g.length;let t=g[A];g[A]=g[I],g[I]=t}},nextInt(A){this.seed=(214013*this.seed+2531011)%(1<<31);let g=this.seed>>16&32767;return g%=A,g}})}},489:A=>{const g=(A,g)=>{const I=2*Math.PI*g*A;return I/(I+1)},I=(A,g,I)=>A*g+(1-A)*I;A.exports={OneEuroFilter:class{constructor({minCutOff:A,beta:g}){this.minCutOff=A,this.beta=g,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(A,t){if(!this.initialized)return this.initialized=!0,this.xPrev=t,this.dxPrev=t.map((()=>0)),this.tPrev=A,t;const{xPrev:C,tPrev:e,dxPrev:B}=this,i=A-e,Q=g(i,this.dCutOff),o=[],E=[],n=[];for(let A=0;A<t.length;A++){o[A]=(t[A]-C[A])/i,E[A]=I(Q,o[A],B[A]);const e=this.minCutOff+this.beta*Math.abs(E[A]),s=g(i,e);n[A]=I(s,t[A],C[A])}return this.xPrev=n,this.dxPrev=E,this.tPrev=A,n}}}},150:(A,g,I)=>{const t=I(894);let C=!1;const e={},B=[];t.then((A=>{C=!0,Object.assign(e,A),B.forEach((A=>{A()}))})),A.exports={cv:e,waitCV:async()=>!!C||new Promise(((A,g)=>{B.push(A)}))}},894:function(A,g,I){var t,C,e="/index.js";C=this,t=function(){return C.cv=(g=(g="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||e,t=function(A){var t,C,e=void 0!==(A=A||{})?A:{};e.ready=new Promise((function(A,g){t=A,C=g}));var B,i={};for(B in e)e.hasOwnProperty(B)&&(i[B]=e[B]);var Q=[],o="./this.program",E=!1,n=!1,s=!1,a=!1;E="object"==typeof window,n="function"==typeof importScripts,s="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,a=!E&&!s&&!n;var r,h,c,l,D,u="";function w(A){return e.locateFile?e.locateFile(A,u):u+A}s?(u=n?I(514).dirname(u)+"/":"//",r=function(A,g){var t=Vt(A);return t?g?t:t.toString():(l||(l=I(903)),D||(D=I(514)),A=D.normalize(A),l.readFileSync(A,g?null:"utf8"))},c=function(A){var g=r(A,!0);return g.buffer||(g=new Uint8Array(g)),k(g.buffer),g},process.argv.length>1&&(o=process.argv[1].replace(/\\/g,"/")),Q=process.argv.slice(2),process.on("uncaughtException",(function(A){if(!(A instanceof _t))throw A})),process.on("unhandledRejection",wA),e.inspect=function(){return"[Emscripten Module object]"}):a?("undefined"!=typeof read&&(r=function(A){var g=Vt(A);return g?qt(g):read(A)}),c=function(A){var g;return(g=Vt(A))?g:"function"==typeof readbuffer?new Uint8Array(readbuffer(A)):(k("object"==typeof(g=read(A,"binary"))),g)},"undefined"!=typeof scriptArgs?Q=scriptArgs:void 0!==arguments&&(Q=arguments),"undefined"!=typeof print&&("undefined"==typeof console&&(console={}),console.log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(E||n)&&(n?u=self.location.href:"undefined"!=typeof document&&document.currentScript&&(u=document.currentScript.src),g&&(u=g),u=0!==u.indexOf("blob:")?u.substr(0,u.lastIndexOf("/")+1):"",r=function(A){try{var g=new XMLHttpRequest;return g.open("GET",A,!1),g.send(null),g.responseText}catch(g){var I=Vt(A);if(I)return qt(I);throw g}},n&&(c=function(A){try{var g=new XMLHttpRequest;return g.open("GET",A,!1),g.responseType="arraybuffer",g.send(null),new Uint8Array(g.response)}catch(g){var I=Vt(A);if(I)return I;throw g}}),h=function(A,g,I){var t=new XMLHttpRequest;t.open("GET",A,!0),t.responseType="arraybuffer",t.onload=function(){if(200==t.status||0==t.status&&t.response)g(t.response);else{var C=Vt(A);C?g(C.buffer):I()}},t.onerror=I,t.send(null)});var d=e.print||console.log.bind(console),p=e.printErr||console.warn.bind(console);for(B in i)i.hasOwnProperty(B)&&(e[B]=i[B]);i=null,e.arguments&&(Q=e.arguments),e.thisProgram&&(o=e.thisProgram),e.quit&&e.quit;var y=16;function G(A,g){return g||(g=y),Math.ceil(A/g)*g}function f(A){f.shown||(f.shown={}),f.shown[A]||(f.shown[A]=1,p(A))}var N,F,R=function(A){};e.wasmBinary&&(N=e.wasmBinary),e.noExitRuntime&&e.noExitRuntime,"object"!=typeof WebAssembly&&wA("no native wasm support detected");var m=!1;function k(A,g){A||wA("Assertion failed: "+g)}var S="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function M(A,g,I){for(var t=g+I,C=g;A[C]&&!(C>=t);)++C;if(C-g>16&&A.subarray&&S)return S.decode(A.subarray(g,C));for(var e="";g<C;){var B=A[g++];if(128&B){var i=63&A[g++];if(192!=(224&B)){var Q=63&A[g++];if((B=224==(240&B)?(15&B)<<12|i<<6|Q:(7&B)<<18|i<<12|Q<<6|63&A[g++])<65536)e+=String.fromCharCode(B);else{var o=B-65536;e+=String.fromCharCode(55296|o>>10,56320|1023&o)}}else e+=String.fromCharCode((31&B)<<6|i)}else e+=String.fromCharCode(B)}return e}function U(A,g){return A?M(b,A,g):""}function K(A,g,I,t){if(!(t>0))return 0;for(var C=I,e=I+t-1,B=0;B<A.length;++B){var i=A.charCodeAt(B);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&A.charCodeAt(++B)),i<=127){if(I>=e)break;g[I++]=i}else if(i<=2047){if(I+1>=e)break;g[I++]=192|i>>6,g[I++]=128|63&i}else if(i<=65535){if(I+2>=e)break;g[I++]=224|i>>12,g[I++]=128|i>>6&63,g[I++]=128|63&i}else{if(I+3>=e)break;g[I++]=240|i>>18,g[I++]=128|i>>12&63,g[I++]=128|i>>6&63,g[I++]=128|63&i}}return g[I]=0,I-C}function J(A,g,I){return K(A,b,g,I)}function Y(A){for(var g=0,I=0;I<A.length;++I){var t=A.charCodeAt(I);t>=55296&&t<=57343&&(t=65536+((1023&t)<<10)|1023&A.charCodeAt(++I)),t<=127?++g:g+=t<=2047?2:t<=65535?3:4}return g}var L,x,b,H,q,T,v,V,W,O="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0;function Z(A,g){for(var I=A,t=I>>1,C=t+g/2;!(t>=C)&&q[t];)++t;if((I=t<<1)-A>32&&O)return O.decode(b.subarray(A,I));for(var e="",B=0;!(B>=g/2);++B){var i=H[A+2*B>>1];if(0==i)break;e+=String.fromCharCode(i)}return e}function P(A,g,I){if(void 0===I&&(I=2147483647),I<2)return 0;for(var t=g,C=(I-=2)<2*A.length?I/2:A.length,e=0;e<C;++e){var B=A.charCodeAt(e);H[g>>1]=B,g+=2}return H[g>>1]=0,g-t}function X(A){return 2*A.length}function j(A,g){for(var I=0,t="";!(I>=g/4);){var C=T[A+4*I>>2];if(0==C)break;if(++I,C>=65536){var e=C-65536;t+=String.fromCharCode(55296|e>>10,56320|1023&e)}else t+=String.fromCharCode(C)}return t}function z(A,g,I){if(void 0===I&&(I=2147483647),I<4)return 0;for(var t=g,C=t+I-4,e=0;e<A.length;++e){var B=A.charCodeAt(e);if(B>=55296&&B<=57343&&(B=65536+((1023&B)<<10)|1023&A.charCodeAt(++e)),T[g>>2]=B,(g+=4)+4>C)break}return T[g>>2]=0,g-t}function _(A){for(var g=0,I=0;I<A.length;++I){var t=A.charCodeAt(I);t>=55296&&t<=57343&&++I,g+=4}return g}function $(A,g){x.set(A,g)}function AA(A,g,I){for(var t=0;t<A.length;++t)x[g++>>0]=A.charCodeAt(t);I||(x[g>>0]=0)}function gA(A,g){return A%g>0&&(A+=g-A%g),A}function IA(A){L=A,e.HEAP8=x=new Int8Array(A),e.HEAP16=H=new Int16Array(A),e.HEAP32=T=new Int32Array(A),e.HEAPU8=b=new Uint8Array(A),e.HEAPU16=q=new Uint16Array(A),e.HEAPU32=v=new Uint32Array(A),e.HEAPF32=V=new Float32Array(A),e.HEAPF64=W=new Float64Array(A)}e.INITIAL_MEMORY;var tA,CA=[],eA=[],BA=[],iA=[];function QA(){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)sA(e.preRun.shift());YA(CA)}function oA(){e.noFSInit||jA.init.initialized||jA.init(),ZA.init(),YA(eA)}function EA(){jA.ignorePermissions=!1,YA(BA)}function nA(){if(e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;)aA(e.postRun.shift());YA(iA)}function sA(A){CA.unshift(A)}function aA(A){iA.unshift(A)}var rA=0,hA=null,cA=null;function lA(A){return A}function DA(A){rA++,e.monitorRunDependencies&&e.monitorRunDependencies(rA)}function uA(A){if(rA--,e.monitorRunDependencies&&e.monitorRunDependencies(rA),0==rA&&(null!==hA&&(clearInterval(hA),hA=null),cA)){var g=cA;cA=null,g()}}function wA(A){e.onAbort&&e.onAbort(A),p(A+=""),m=!0,A="abort("+A+"). Build with -s ASSERTIONS=1 for more info.";var g=new WebAssembly.RuntimeError(A);throw C(g),g}function dA(A,g){return String.prototype.startsWith?A.startsWith(g):0===A.indexOf(g)}e.preloadedImages={},e.preloadedAudios={};var pA="data:application/octet-stream;base64,";function yA(A){return dA(A,pA)}var GA="file://";function fA(A){return dA(A,GA)}var NA,FA,RA,mA="data:application/octet-stream;base64,AGFzbQEAAAAB1Ah7YAF/AX9gAX8AYAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAR/f39/AGAIf39/f39/f38AYAV/f39/fwBgBX9/f39/AX9gCX9/f39/f39/fwBgBH9/f38Bf2AGf39/f39/AX9gBn9/f39/fwBgAABgAX8BfGAHf39/f39/fwBgAAF/YAh/f39/f39/fwF/YAR/f398AGADf398AGADf39/AXxgB39/f39/f38Bf2ABfwF9YAN/fX8AYAJ/fwF9YAp/f39/f39/f39/AGABfAF8YAJ/fABgAX8BfmADf35/AX5gDX9/f39/f39/f398fH8AYAV/fn5+fgBgBn9/f399fwF/YAJ/fwF8YAp/f39/f39/fHx/AGAFf39/f3wAYAR/f3x/AGACf34AYAV/f39/fgF/YAR/f398AX9gAnx8AXxgD39/f39/f39/f39/f39/fwBgBX9/f3x8AGAFf39+f38AYAN/f30AYAR/fH9/AGAFf39/f3wBf2AEf39/fwF+YAR/f399AGAHf398f3x/fwBgBH9+fn8AYAl/f39/f39/f38Bf2AKf39/f39/f39/fwF/YAt/f39/f39/f39/fwF/YAd/f39/f35+AX9gBn9/f39+fgF/YAV/f39/fwF9YAZ/f39/fX8AYAd/f39/fX9/AGALf39/f31/f31/f38AYAd/f39/fX99AGAGf39/f319AGAGf39/f3x8AGACf30AYAx/f39/f39/f39/f38Bf2AGf39/f3x/AX9gB39/f398f38Bf2ADf398AX9gBn98f39/fwF/YAJ+fwF/YAF8AX9gAAF+YAJ/fwF+YAR/f39+AX5gA39/fwF9YAh/f39/f39/fwF9YAh/f39/fX9/fwF9YAR/f39/AXxgAnx/AXxgC39/f39/f39/f39/AGANf39/f39/f39/f39/fwBgDH9/f39/f39/fHx8fABgCX9/f39/f3x8fwBgBn9/f39/fABgC39/f39/fH9/f398AGAPf39/f31/f31/f39/f39/AGAPf39/f3x/f3x/f39/f39/AGAKf39/f3x8fHx8fwBgBn9/f31/fwBgA39/fgBgA39+fgBgA398fwBgCn98f398f3x8fHwAYAd/fH98fH9/AGADf3x8AGAMf3x8fHx8fHx8fH9/AGADfH9/AGAFfHx/f38AYAh8fHx8fHx/fwBgB39/f39/f3wBf2AOf39/f399f398f3x/f38Bf2AEf39/fQF/YBh/f398fHx8fHx8fHx8fHx8fHx8fHx8fH8Bf2AEf398fAF/YAN/fn8Bf2AEf35/fwF/YAN/fH8Bf2ADfn9/AX9gAn5+AX9gA35+fgF/YAR+fn5+AX9gAX0Bf2ACfH8Bf2AHfHx8fH9/fwF/YAl8fHx8fH9/f38Bf2ADf39/AX5gBH9/f38BfWACfn4BfWAFf39/f38BfGADf3x8AXxgAn5+AXxgA3x8fwF8AtwKLgNlbnYQX2VtdmFsX25ld19hcnJheQARA2VudhhfZW12YWxfZ2V0X21ldGhvZF9jYWxsZXIAAwNlbnYXX2VtdmFsX2NhbGxfdm9pZF9tZXRob2QABgNlbnYRX2VtdmFsX3Rha2VfdmFsdWUAAwNlbnYSX2VtdmFsX25ld19jc3RyaW5nAAADZW52E19lbXZhbF9zZXRfcHJvcGVydHkABANlbnYNX2VtdmFsX2RlY3JlZgABA2Vudg1fZW12YWxfaW5jcmVmAAEDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAUQNlbnYiX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcgANA2VudiVfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX2Z1bmN0aW9uABADZW52H19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfcHJvcGVydHkAGgNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbgAHA2Vudh1fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdAANA2VudiNfZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZAAaA2Vudh1fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdAABA2VudhlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uAA0DZW52HF9lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfYXJyYXkADQNlbnYkX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9hcnJheV9lbGVtZW50AAoDZW52HF9lbWJpbmRfZmluYWxpemVfdmFsdWVfYXJyYXkAAQNlbnYZX2VtYmluZF9yZWdpc3Rlcl9jb25zdGFudAAUA2VudhhfX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24AAANlbnYLX19jeGFfdGhyb3cABANlbnYNY2xvY2tfZ2V0dGltZQADA2VudhVfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQAAgNlbnYVX2VtYmluZF9yZWdpc3Rlcl9ib29sAAgDZW52G19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwACA2VudhxfZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAQDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZW12YWwAAgNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAgDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABANlbnYcX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwAEA2VudgpfX3N5c19vcGVuAAUWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQALFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAALFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UAAANlbnYNX19zeXNfZmNudGw2NAAFA2VudgtfX3N5c19pb2N0bAAFFndhc2lfc25hcHNob3RfcHJldmlldzERZW52aXJvbl9zaXplc19nZXQAAxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxC2Vudmlyb25fZ2V0AAMDZW52BWFib3J0AA4DZW52CnN0cmZ0aW1lX2wACQNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAAAA2VudhVlbXNjcmlwdGVuX21lbWNweV9iaWcABQNlbnYLc2V0VGVtcFJldDAAARZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsACQP6HfgdDgkrBBMCBgQGBCITAgQCBAQCAgQCAgIABAICEhIWDAkLBgYEBAICAgEODg4ODg4ODg4OAAEAEQMABQMLBQkLDAUECwYDBAIDAgICAgICAgIAAwAAPwYkBAUIBgYLBAQABgQFAwAEFSgFAwQAAwQFBgsEBgQGBAYEBgQGBAYDBQULCwkFCwkDBQULCQULCQMFBQsJS3U5dwMVBU4RAREiFBktEREDBAMDERERIhQREREBAwQDAzQSFgwJBQMAAQsAAAABEQIEBAYA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BpwGnQahBqIGowbeBuEG4AbiBvUD7wOnB4QH5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb4BvkG+wb8Bu8DpweFB4YHhweIB4kHiweKB+8DpweMB40HjgfvA6gHkweUB5UHlgeXB6kH7wOoB5gHmQfvA6gHjweQB5EH7wOoB5oH7wOoB5sHkAe1B7YHtwe4B7kHuge7B7wHvQe+B78HwAfBB8IHwwfEB8UHxgfHB8gH/gf/B4AIgQiCCIMIhAiTCJQIlQiWCJcIjAiYCJkImgicCJ0InwiKCKEIowilCKcIqQirCIgIrQivCLAIsQiyCLMIkgi0CLUItwi5CLsIvQiQCL8IwQjDCMUIxwjJCI4IywjOCPUD7wPQCNgI3QjVCNII1wjrCPAIpQn8CP4I/wiACYEJggmDCY0JjgmPCZAJhAmTCZEJkgmWCZoJngmVCaMJpAmMCYsJoAmhCacJqAmpCaoJqwmuCb0Jvgm/CagH7wPCCcMJxAnvA/UD7wPECe8D9QPvA80JzgnPCdAJ0QnSCdMJ1An1A+8DxAnvA/UD7wPVCdkJ9QPvA8QJ7wPvA98J4QnPCeIJ4wnkCeUJ5gn1A+8DxAnvA+8D5wnrCfUD7wPECe8D7wPuCe8JzwniCfAJ8QnyCfMJ9QPvA8QJ7wPvA/QJ9wn6CfsJ/An9Cf4J/wmACoEKggqDCoYKhwqICokKigqLCowKvwqdCpUKoAq1CpYKlwqmCqcKgxu2CrcKuAq5CroKuwq8Cr0KyQbbCtwK3Qq9Cv0K/gr/Cu8DiAuJC4oLiwuMC5kLmgubC5wLnQueC58LoAv1A+8DyQbvA/UD7wOPC5ELkguTC5QLlQuWC5cL7wOhC6ILowukC/UD7wPJBu8D7wOlC/UD7wPJBu8D7wOmC/UD7wPJBu8D7wOoC/UD7wPJBu8D7wOpC/UD7wPJBu8D7wOrC6wLrQuuC68LsAu5C7oLuwu8C70L9QPvA8sLzAvvA/UD7wPJBu8D9QPvA9oL2wvcC90L3gvfC+8D4AvhC+IL4wvvA8kGyAbIBu0L5AvlC+gL6QvqC+8D6wvsC+4L7wvwC/ML9Av1C/EL9AvyC+8D+Qv6C+8D7wP5C/sL7wOCDIMMjwyRDJIMlAyVDIQM7wP5C5YM7wPoDOkMxAnvA+oM6wzsDO0M7gzvDPAM8QzyDPMM9AzECe8D9Qz2DPcM7QzuDO8M8AzxDPgM+Qz6DMQJ7wP7DPwM9wztDO4M7wzwDPEM/Qz+DP8MxAnvA4ANgQ2CDe0M7gzvDPAM8QyDDYQNhQ3ECe8Dhg2HDYIN7QzuDO8M8AzxDIgNiQ2KDcQJ7wOLDYwNjQ2ODY8NkA2RDZINxAnvA5MNlA2VDZYNlw2YDZkNmg3ECe8Dmw2cDZ0Nng2fDaANoQ2iDcQJ7wOjDaQNpQ2mDacNqA2pDaoNxAnvA6sNrA2tDa4Nrw2wDbENsg3ECe8Dsw20DbUNtg23DbgNuQ26DcQJ7wO7DbwNwA3DDcQNxQ3vA8YNxw3IDckNyg3LDcwNzQ3ODc8N0A3RDcUN7wPSDdMN1A3KDcsNzA3NDc4N1Q3WDdcNxQ3vA9gN2Q3aDdsN3A3LDd0N3g2+Dd8N4A3hDcUN7wPiDeMN5A3KDcsN5Q3NDc4N5g3nDegNxAnvA+kN6g2nB6gHyAbrDe0L7A3tDe4NxQ3vA/EN8g3zDfQN9Q32DfcN+A35DfsN/A3ECe8Duw39Df4N/w2ADoEOgg7ECe8Dgw6EDoUO/g3/DYYOhw6IDsQJ7wO7DYkOig7/DYsOjA6NDsQJ7wO7DY4Oig7/DY8Okg6TDsQJ7wO7DacHlA7GDpYOlw6YDsQJ7wO7DZkOgg+aDpsOnQ7FDe8DnA6fDqAOoQ6jDqQOpQ7ECe8Dpg6nDqgOqQ6qDqsOxAnvA7sNrA6tDooOrg6vDrAOxAnvA7sNsQ6yDv8Nsw60DrUOxAnvA7YOtw64DrIO/w25DroOuw7ECe8Duw28Dr0Ovg6/DsAOwQ7ECe8Duw3CDrIO/w3DDsQOxQ7ECe8Duw3GDooOxw7IDskOyg7ECe8Duw3LDswO/w3NDs4Ozw7ECe8Duw3QDswO/w3RDtIO0w7FDe8Duw3UDooO/g3XDtsO3Q7FDe8D3A7eDt8O4Q7mDugOxQ3vA+cO6Q7qDusO7A7uDsUN7wPtDu8O8A7xDvIO9A7ECe8D8w71DvYO9QP4DvkO+g71A+8D9w77DskG7wP8Dv4O/w6AD4EPxAnvA7sNgw+ED4UPxQ3vA4YPhw+ID4kPig+LD4wPjwmND44Pjw+QD+sNkQ+SD8UN7wOTD5QPlQ+WD5cPmA+ZD5oPjwmbD5wPnQ/wC54Pnw+gD6EPjgmiD6MPpA+lD6YPpw+oD6kPqg+r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QRBqJAALQAEBfyMAQRBrIgQkACAEIAE2AgQgBEGAgIQQNgIAIARCADcDCCAAIAQgAiADRAAAAAAAAAAAEIgDIARBEGokAAsSACAAIAEoAigpAgBCIIk3AgALXAEBfyMAQeABayIEJAAgBCABIAIgAxCfByAAEKcGIQAgBCgCACIBIAQgAEF/IAEoAgAoAgwRBgAgBEH4AGoQsQYaIARBQGsQsQYaIARBCGoQsQYaIARB4AFqJAALdgIBfwF+IwBB8AFrIgMkACADIAEpAgAiBDcDACADIAQ3AwggA0EQaiADIAIQoQcgABCnBiEAIAMoAhAiAiADQRBqIABBfyACKAIAKAIMEQYAIANBiAFqELEGGiADQdAAahCxBhogA0EYahCxBhogA0HwAWokAAtcAQF/IwBB4AFrIgQkACAEIAEgAiADEKIHIAAQpwYhACAEKAIAIgEgBCAAQX8gASgCACgCDBEGACAEQfgAahCxBhogBEFAaxCxBhogBEEIahCxBhogBEHgAWokAAt2AgF/AX4jAEHwAWsiAyQAIAMgASkCACIENwMAIAMgBDcDCCADQRBqIAMgAhCjByAAEKcGIQAgAygCECICIANBEGogAEF/IAIoAgAoAgwRBgAgA0GIAWoQsQYaIANB0ABqELEGGiADQRhqELEGGiADQfABaiQACzkCAX8BfCMAQRBrIgIkACACQgA3AwggAiABNgIEIAJBgICECDYCACAAIAIQhQYhAyACQRBqJAAgAwt7AQF/IwBB8AFrIgQkACAEQgA3AwggBCACNgIEIARBgICECDYCACAEQRBqIAEgBCADEJ4HIAAQpwYhACAEKAIQIgEgBEEQaiAAQX8gASgCACgCDBEGACAEQYgBahCxBhogBEHQAGoQsQYaIARBGGoQsQYaIARB8AFqJAALWAEBfyMAQeABayICJAAgAiABEJwHIAAQpwYhACACKAIAIgEgAiAAQX8gASgCACgCDBEGACACQfgAahCxBhogAkFAaxCxBhogAkEIahCxBhogAkHgAWokAAtaAQF/IwBB4AFrIgMkACADIAEgAhCdByAAEKcGIQAgAygCACIBIAMgAEF/IAEoAgAoAgwRBgAgA0H4AGoQsQYaIANBQGsQsQYaIANBCGoQsQYaIANB4AFqJAALMwEBfyMAQRBrIgIkACACIAE2AgQgAkGA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CCAAQYiyASACQQhqEAM2AgAgAkEQaiQAC2cBA38jAEEQayICJAAgARCvBiEEAn9BACABKAIEIgNBAUgNABogASgCLCADQQJ0akEEaygCAAshAyACIAEoAhA2AgwgAiADIARsQQF2NgIIIABBsLIBIAJBCGoQAzYCACACQRBqJAALZwEDfyMAQRBrIgIkACABEK8GIQQCf0EAIAEoAgQiA0EBSA0AGiABKAIsIANBAnRqQQRrKAIACyEDIAIgASgCEDYCDCACIAMgBGxBAXY2AgggAEHYsgEgAkEIahADNgIAIAJBEGokAAtnAQN/IwBBEGsiAiQAIAEQrwYhBAJ/QQAgASgCBCIDQQFIDQAaIAEoAiwgA0ECdGpBBGsoAgALIQMgAiABKAIQNgIMIAIgAyAEbEECdjYCCCAAQYCzASACQQhqEAM2AgAgAkEQaiQAC2cBA38jAEEQayICJAAgARCvBiEEAn9BACABKAIEIgNBAUgNABogASgCLCADQQJ0akEEaygCAAshAyACIAEoAhA2AgwgAiADIARsQQJ2NgIIIABBqLMBIAJBCGoQAzYCACACQRBqJAALZwEDfyMAQRBrIgIkACABEK8GIQQCf0EAIAEoAgQiA0EBSA0AGiABKAIsIANBAnRqQQRrKAIACyEDIAIgASgCEDYCDCACIAMgBGxBA3Y2AgggAEHQswEgAkEIahADNgIAIAJBEGokAAslAQF/IAAoAgQiAUEBSARAQQAPCyAAKAIsIAFBAnRqQQRrKAIACzUBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQAACxcAQZHEkMICIAAoAgBBAnRBHHF2QQ9xCxEAIAAoAgBBA3ZB/wNxQQFqCxQAIAEgAiADIAQgBSAAKAIAESsACxAAIAEgAiADIAAoAgARBAALEgAgASACIAMgBCAAKAIAERMAC0QBAX8jAEEQayIDJAAgAyACNgIIIAMgAkEBajYCDCADQoCAgID4/////wA3AwAgACABIANBCGogAxC6BhogA0EQaiQAC2YBAn8jAEFAaiIDJAAgASAAKAIEIgRBAXVqIQEgACgCACEAIANBCGogASACIARBAXEEfyABKAIAIABqKAIABSAACxEEAEE4ENUaIANBCGoQuAYhACADQQhqELEGGiADQUBrJAAgAAs7AQF/IAEgACgCBCIFQQF1aiEBIAAoAgAhACABIAIgAyAEIAVBAXEEfyABKAIAIABqKAIABSAACxEGAAtfAgJ/AX4jAEEQayIEJAAgASAAKAIEIgVBAXVqIQEgACgCACEAIAVBAXEEQCABKAIAIABqKAIAIQALIAQgAikCACIGNwMAIAQgBjcDCCABIAQgAyAAEQQAIARBEGokAAtBAQF/IwBBEGsiBCQAIAQgAzYCDCAEIAI2AgggBEKAgICA+P////8ANwMAIAAgASAEQQhqIAQQugYaIARBEGokAAtoAQJ/IwBBQGoiBCQAIAEgACgCBCIFQQF1aiEBIAAoAgAhACAEQQhqIAEgAiADIAVBAXEEfyABKAIAIABqKAIABSAACxEGAEE4ENUaIARBCGoQuAYhACAEQQhqELEGGiAEQUBrJAAgAAszAQF/IwBBEGsiAyQAIANCgICAgPj/////ADcDCCAAIAEgAiADQQhqELoGGiADQRBqJAALDgAgASACIAAoAgARAgALCwAgACgCAEH/H3ELQQEBfyMAQRBrIgQkACAEQoCAgID4/////wA3AwggBCADNgIEIAQgAjYCACAAIAEgBEEIaiAEELoGGiAEQRBqJAALMwEBfyMAQRBrIgMkACADQoCAgID4/////wA3AwggACABIANBCGogAhC6BhogA0EQaiQACzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRAwALZAECfyMAQUBqIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAkEIaiABIANBAXEEfyABKAIAIABqKAIABSAACxECAEE4ENUaIAJBCGoQuAYhACACQQhqELEGGiACQUBrJAAgAAsKACAAKAIAQQdxC0QBAX8jAEEQayIDJAAgA0KAgICA+P////8ANwMIIAMgAjYCACADIAJBAWo2AgQgACABIANBCGogAxC6BhogA0EQaiQACw4AIAEgAiAAKAIAESIAC0EBAX8jAEFAaiIEJAAgBEEIaiABIAIgAyAAKAIAERMAQTgQ1RogBEEIahC4BiEBIARBCGoQsQYaIARBQGskACABCz8BAX8jAEFAaiIDJAAgA0EIaiABIAIgACgCABEEAEE4ENUaIANBCGoQuAYhASADQQhqELEGGiADQUBrJAAgAQs9AQF/IwBBQGoiAiQAIAJBCGogASAAKAIAEQIAQTgQ1RogAkEIahC4BiEBIAJBCGoQsQYaIAJBQGskACABCwwAIAAgASACELwGGgsOACAALQABQcAAcUEGdgs0AQF/IwBBEGsiAiQAIAJBCGogASAAKAIAEQIAQQgQ1RoiASACKQMINwMAIAJBEGokACABC1IBA38jAEEQayIDJAAgAUEAELYGIQQgASgCECEFIAEoAiwoAgAhASADIAQ2AgggAyAFIAEgAmxqNgIMIABB4LEBIANBCGoQAzYCACADQRBqJAALNwEBfyMAQRBrIgMkACADQQhqIAEgAiAAKAIAEQQAIAMoAggQByADKAIIIgEQBiADQRBqJAAgAQthAQR/IwBBEGsiBCQAIAFBARC2BiEFIAEoAhAhBiABKAIsIgEoAgAhByABKAIEIQEgBCAFNgIIIAQgBiACIAdsaiABIANsajYCDCAAQeCxASAEQQhqEAM2AgAgBEEQaiQACzkBAX8jAEEQayIEJAAgBEEIaiABIAIgAyAAKAIAEQYAIAQoAggQByAEKAIIIgEQBiAEQRBqJAAgAQtSAQN/IwBBEGsiAyQAIAFBABC2BiEEIAEoAhAhBSABKAIsKAIAIQEgAyAENgIIIAMgBSABIAJsajYCDCAAQYiyASADQQhqEAM2AgAgA0EQaiQAC2EBBH8jAEEQayIEJAAgAUEBELYGIQUgASgCECEGIAEoAiwiASgCACEHIAEoAgQhASAEIAU2AgggBCAGIAIgB2xqIAEgA2xqNgIMIABBiLIBIARBCGoQAzYCACAEQRBqJAALUgEDfyMAQRBrIgMkACABQQAQtgYhBCABKAIQIQUgASgCLCgCACEBIAMgBDYCCCADIAUgASACbGo2AgwgAEHYsgEgA0EIahADNgIAIANBEGokAAthAQR/IwBBEGsiBCQAIAFBARC2BiEFIAEoAhAhBiABKAIsIgEoAgAhByABKAIEIQEgBCAFNgIIIAQgBiACIAdsaiABIANsajYCDCAAQdiyASAEQQhqEAM2AgAgBEEQaiQAC1IBA38jAEEQayIDJAAgAUEAELYGIQQgASgCECEFIAEoAiwoAgAhASADIAQ2AgggAyAFIAEgAmxqNgIMIABBsLIBIANBCGoQAzYCACADQRBqJAALYQEEfyMAQRBrIgQkACABQQEQtgYhBSABKAIQIQYgASgCLCIBKAIAIQcgASgCBCEBIAQgBTYCCCAEIAYgAiAHbGogASADbGo2AgwgAEGwsgEgBEEIahADNgIAIARBEGokAAtSAQN/IwBBEGsiAyQAIAFBABC2BiEEIAEoAhAhBSABKAIsKAIAIQEgAyAENgIIIAMgBSABIAJsajYCDCAAQYCzASADQQhqEAM2AgAgA0EQaiQAC2EBBH8jAEEQayIEJAAgAUEBELYGIQUgASgCECEGIAEoAiwiASgCACEHIAEoAgQhASAEIAU2AgggBCAGIAIgB2xqIAEgA2xqNgIMIABBgLMBIARBCGoQAzYCACAEQRBqJAALUgEDfyMAQRBrIgMkACABQQAQtgYhBCABKAIQIQUgASgCLCgCACEBIAMgBDYCCCADIAUgASACbGo2AgwgAEGoswEgA0EIahADNgIAIANBEGokAAthAQR/IwBBEGsiBCQAIAFBARC2BiEFIAEoAhAhBiABKAIsIgEoAgAhByABKAIEIQEgBCAFNgIIIAQgBiACIAdsaiABIANsajYCDCAAQaizASAEQQhqEAM2AgAgBEEQaiQAC1IBA38jAEEQayIDJAAgAUEAELYGIQQgASgCECEFIAEoAiwoAgAhASADIAQ2AgggAyAFIAEgAmxqNgIMIABB0LMBIANBCGoQAzYCACADQRBqJAALYQEEfyMAQRBrIgQkACABQQEQtgYhBSABKAIQIQYgASgCLCIBKAIAIQcgASgCBCEBIAQgBTYCCCAEIAYgAiAHbGogASADbGo2AgwgAEHQswEgBEEIahADNgIAIARBEGokAAttAQF/AkAgAC0AAUHAAHFFBEAgACgCKCICKAIAQQFHDQELIAAoAhAgAWoPCyACKAIEQQFGBEAgACgCECAAKAIsKAIAIAFsag8LIAAoAhAgACgCLCgCACABIAAoAgwiAG0iAmxqIAEgACACbGtqCzoBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRAwAsAAALFgAgACgCECAAKAIsKAIAIAFsaiACags8AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRBQAsAAALJwAgACgCECAAKAIsIgAoAgAgAWxqIAAoAgQgAmxqIAAoAgggA2xqCz4BAX8gASAAKAIEIgVBAXVqIQEgACgCACEAIAEgAiADIAQgBUEBcQR/IAEoAgAgAGooAgAFIAALEQsALAAACzoBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRAwAtAAALPAEBfyABIAAoAgQiBEEBdWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQUALQAACz4BAX8gASAAKAIEIgVBAXVqIQEgACgCACEAIAEgAiADIAQgBUEBcQR/IAEoAgAgAGooAgAFIAALEQsALQAAC3MBAX8CQCAALQABQcAAcUUEQCAAKAIoIgIoAgBBAUcNAQsgACgCECABQQF0ag8LIAIoAgRBAUYEQCAAKAIQIAAoAiwoAgAgAWxqDwsgACgCECAAKAIsKAIAIAEgACgCDCIAbSICbGogASAAIAJsa0EBdGoLOgEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEDAC4BAAsZACAAKAIQIAAoAiwoAgAgAWxqIAJBAXRqCzwBAX8gASAAKAIEIgRBAXVqIQEgACgCACEAIAEgAiADIARBAXEEfyABKAIAIABqKAIABSAACxEFAC4BAAs+AQF/IAEgACgCBCIFQQF1aiEBIAAoAgAhACABIAIgAyAEIAVBAXEEfyABKAIAIABqKAIABSAACxELAC4BAAs6AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALEQMALwEACzwBAX8gASAAKAIEIgRBAXVqIQEgACgCACEAIAEgAiADIARBAXEEfyABKAIAIABqKAIABSAACxEFAC8BAAs+AQF/IAEgACgCBCIFQQF1aiEBIAAoAgAhACABIAIgAyAEIAVBAXEEfyABKAIAIABqKAIABSAACxELAC8BAAtzAQF/AkAgAC0AAUHAAHFFBEAgACgCKCICKAIAQQFHDQELIAAoAhAgAUECdGoPCyACKAIEQQFGBEAgACgCECAAKAIsKAIAIAFsag8LIAAoAhAgACgCLCgCACABIAAoAgwiAG0iAmxqIAEgACACbGtBAnRqCzoBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRAwAoAgALGQAgACgCECAAKAIsKAIAIAFsaiACQQJ0ags8AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRBQAoAgALPgEBfyABIAAoAgQiBUEBdWohASAAKAIAIQAgASACIAMgBCAFQQFxBH8gASgCACAAaigCAAUgAAsRCwAoAgALOgEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEDACoCAAs8AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRBQAqAgALPgEBfyABIAAoAgQiBUEBdWohASAAKAIAIQAgASACIAMgBCAFQQFxBH8gASgCACAAaigCAAUgAAsRCwAqAgALPgEBfyABIAAoAgQiBUEBdWohASAAKAIAIQAgASACIAMgBCAFQQFxBH8gASgCACAAaigCAAUgAAsRCwArAwALcwEBfwJAIAAtAAFBwABxRQRAIAAoAigiAigCAEEBRw0BCyAAKAIQIAFBA3RqDwsgAigCBEEBRgRAIAAoAhAgACgCLCgCACABbGoPCyAAKAIQIAAoAiwoAgAgASAAKAIMIgBtIgJsaiABIAAgAmxrQQN0ags6AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALEQMAKwMACxkAIAAoAhAgACgCLCgCACABbGogAkEDdGoLPAEBfyABIAAoAgQiBEEBdWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQUAKwMACxIBAX9BCBDVGiIAQgA3AgAgAAsMACAABEAgABCiGwsLGQEBf0EQENUaIgBCADcDACAAQgA3AwggAAsNACABIAAoAgBqKwMACw8AIAEgACgCAGogAjkDAAsNACABIAAoAgBqKgIACw8AIAEgACgCAGogAjgCAAsZAQF/QRAQ1RoiAEIANwIAIABCADcCCCAACyABAX9BFBDVGiIAQgA3AgAgAEEANgIQIABCADcCCCAACx8BAX8gACgCACEAQQgQ1RoiAiAAIAFqKQIANwMAIAILEgAgASAAKAIAaiACKQIANwIACzIBAX8jAEEQayICJAAgAkEIaiABIAARAgAgAigCCBAHIAIoAggiABAGIAJBEGokACAACzgBAX8jAEEQayICJAAgAiABIAARAgBBEBDVGiIAIAIpAwg3AgggACACKQMANwIAIAJBEGokACAACzABAX9BHBDVGiIAQX82AhggAEIANwIQIABCgICAgICAgMC/fzcCCCAAQgA3AgAgAAsiAQF/QRAQ1RoiAEL/////////v/8ANwIIIABCfzcCACAACycBAX9BIBDVGiIAQgA3AwAgAEIANwMYIABCADcDECAAQgA3AwggAAsNACABIABBA3RqKwMACw8AIAEgAEEDdGogAjkDAAsZAQF/QQwQ1RoiAEIANwIAIABBADYCCCAACxAAQcABENUaQQBBwAEQrxsLCgBBPBDVGhCQCgsUACAABEAgACAAKAIAKAIEEQEACwuBAQECfyMAQRBrIgIkACACIAEgACgCABECAAJAIAIsAAsiAUEATgRAIAFB/wFxIgBBBGoQoRsiASAANgIAIAFBBGogAiAAEK4bGgwBCyACKAIEIgBBBGoQoRsiASAANgIAIAFBBGogAigCACIDIAAQrhsaIAMQohsLIAJBEGokACABC7EBAQR/IwBBEGsiAyQAIAIoAgAiBEFwSQRAIAAoAgAhBgJAAkAgBEELTwRAIARBEGpBcHEiBRDVGiEAIAMgBUGAgICAeHI2AgggAyAANgIAIAMgBDYCBCADIQUMAQsgAyAEOgALIAMiBSEAIARFDQELIAAgAkEEaiAEEK4bGgsgACAEakEAOgAAIAEgAyAGEQIAIAUsAAtBf0wEQCADKAIAEKIbCyADQRBqJAAPCxDZGgALfwEBfyMAQUBqIgIkACACIAEgABECAEE8ENUaIgBBrLQDNgIAIABBBGogAkEEchDbGhogACACKAIQNgIQIABBFGogAkEUahDbGhogAEEgaiACQSBqENsaGiAAQSxqIAJBLGoQ2xoaIAAgAigCODYCOCACEJUKGiACQUBrJAAgAAs4AQF/IwBBEGsiAiQAIAIgASAAEQIAQQwQ1RoiACACKAIINgIIIAAgAikDADcCACACQRBqJAAgAAvgAQIBfwF8IwBBgAFrIgkkACAJIAMpAgA3A3ggCSAEKwMAOQNYIAkgBCsDCDkDYCAJIAQrAxA5A2ggBCsDGCEKIAkgBTYCUCAJIAo5A3AgCSAGKwMAOQMwIAkgBisDCDkDOCAJIAYrAxA5A0AgCSAGKwMYOQNIIAkgBysDADkDECAJIAcrAwg5AxggCSAHKwMQOQMgIAkgBysDGDkDKCAJIAkpA3g3AwggASACIAlBCGogCUHYAGogCUHQAGogCUEwaiAJQRBqIAggABESACEHIAkoAlAQBiAJQYABaiQAIAcL3gECAX8BfCMAQYABayIIJAAgCCADKQIANwN4IAggBCsDADkDWCAIIAQrAwg5A2AgCCAEKwMQOQNoIAQrAxghCSAIIAU2AlAgCCAJOQNwIAggBisDADkDMCAIIAYrAwg5AzggCCAGKwMQOQNAIAggBisDGDkDSCAIIAcrAwA5AxAgCCAHKwMIOQMYIAggBysDEDkDICAIIAcrAxg5AyggCCAIKQN4NwMIIAEgAiAIQQhqIAhB2ABqIAhB0ABqIAhBMGogCEEQaiAAERYAIQcgCCgCUBAGIAhBgAFqJAAgBwuwAQMBfwF+AXwjAEHgAGsiByQAIAcgAykCACIINwNYIAcgBCsDADkDOCAHIAQrAwg5A0AgByAEKwMQOQNIIAQrAxghCSAHIAU2AjAgByAJOQNQIAcgBisDADkDECAHIAYrAwg5AxggByAGKwMQOQMgIAcgBisDGDkDKCAHIAg3AwggASACIAdBCGogB0E4aiAHQTBqIAdBEGogABEMACEGIAcoAjAQBiAHQeAAaiQAIAYLgQEDAX8BfgF8IwBBQGoiBiQAIAYgAykCACIHNwM4IAYgBCsDADkDGCAGIAQrAwg5AyAgBiAEKwMQOQMoIAQrAxghCCAGIAU2AhAgBiAIOQMwIAYgBzcDCCABIAIgBkEIaiAGQRhqIAZBEGogABEJACEEIAYoAhAQBiAGQUBrJAAgBAtlAgF/AX4jAEEwayIFJAAgBSADKQIAIgY3AyggBSAEKwMAOQMIIAUgBCsDCDkDECAFIAQrAxA5AxggBSAEKwMYOQMgIAUgBjcDACABIAIgBSAFQQhqIAARCwAhBCAFQTBqJAAgBAtOAQF/IwBBIGsiAyQAIAMgASACIAARBABBIBDVGiIAIAMpAxg3AxggACADKQMQNwMQIAAgAykDCDcDCCAAIAMpAwA3AwAgA0EgaiQAIAALTAEBfyMAQSBrIgIkACACIAEgABECAEEgENUaIgAgAikDGDcDGCAAIAIpAxA3AxAgACACKQMINwMIIAAgAikDADcDACACQSBqJAAgAAtKAQF/IwBBIGsiASQAIAEgABEBAEEgENUaIgAgASsDADkDACAAIAErAwg5AwggACABKwMQOQMQIAAgASsDGDkDGCABQSBqJAAgAAtCACAAQv/////////3/wA3AxggAEL/////////9/8ANwMQIABC//////////f/ADcDCCAAQv/////////3/wA3AwALTQEBfyMAQSBrIgQkACAEIAMpAwg3AxAgBCADKQMANwMIIARBGGogASACIARBCGogABEGACAEKAIYEAcgBCgCGCIDEAYgBEEgaiQAIAMLDQAgACgCAEEEaygCAAt8AQN/IwBBEGsiASQAIAEgABEBAAJAIAEsAAsiAEEATgRAIABB/wFxIgJBBGoQoRsiACACNgIAIABBBGogASACEK4bGgwBCyABKAIEIgJBBGoQoRsiACACNgIAIABBBGogASgCACIDIAIQrhsaIAMQohsLIAFBEGokACAACwYAQbiUAQskAQF/IAAEQCAAKAIAIgEEQCAAIAE2AgQgARCiGwsgABCiGwsLGQEBf0EMENUaIgBBADYCCCAAQgA3AgAgAAvqAQEFfyAAKAIEIgIgACgCCEcEQCACIAEoAgA2AgAgACACQQRqNgIEDwsCQCACIAAoAgAiBWsiBkECdSIEQQFqIgJBgICAgARJBEACf0EAIAIgBkEBdSIDIAIgA0sbQf////8DIARB/////wFJGyIDRQ0AGiADQYCAgIAETw0CIANBAnQQ1RoLIgIgBEECdGoiBCABKAIANgIAIAIgA0ECdGohASAEQQRqIQMgBkEBTgRAIAIgBSAGEK4bGgsgACABNgIIIAAgAzYCBCAAIAI2AgAgBQRAIAUQohsLDwsQ/BoAC0HdkgEQvgIAC1IBAn8jAEEQayIDJAAgASAAKAIEIgRBAXVqIQEgACgCACEAIARBAXEEQCABKAIAIABqKAIAIQALIAMgAjYCDCABIANBDGogABECACADQRBqJAALPgECfyABIAAoAgQgACgCACIEa0ECdSIDSwRAIAAgASADayACEL8CDwsgASADSQRAIAAgBCABQQJ0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ACgCBCIDQQF1aiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALEQIACz4BAn8gASAAKAIEIAAoAgAiBGtBA3UiA0sEQCAAIAEgA2sgAhDCAg8LIAEgA0kEQCAAIAQgAUEDdGo2AgQLCzkBAX8gASAAKAIEIgRBAXVqIQEgACgCACEAIAEgAiADIARBAXEEfyABKAIAIABqKAIABSAACxEEAAtdAQJ/IwBBEGsiAyQAQQEhBCAAIAIgASgCBCABKAIAIgFrQQN1SQR/QQgQ1RoiBCABIAJBA3RqKQIANwMAIAMgBDYCCEHIngEgA0EIahADBSAECzYCACADQRBqJAALFwAgACgCACABQQN0aiACKQIANwIAQQELEAAgASACIAMgACgCABEFAAsGAEGMoAELTwECfyAABEAgACgCACIBBEACfyABIAEgACgCBCICRg0AGgNAIAJBOGsQsQYiAiABRw0ACyAAKAIACyECIAAgATYCBCACEKIbCyAAEKIbCwsrAQF/IAAoAgQiAiAAKAIIRwRAIAAgAiABEK0GQThqNgIEDwsgACABEMMCC1wBA38gASAAKAIEIgMgACgCACIFa0E4bSIESwRAIAAgASAEayACEMQCDwsgASAESQRAIAUgAUE4bGoiASADRwRAA0AgA0E4axCxBiIDIAFHDQALCyAAIAE2AgQLCxAAIAAoAgQgACgCAGtBOG0LWwECfyMAQRBrIgMkAEEBIQQgACACIAEoAgQgASgCACIBa0E4bUkEf0E4ENUaIgQgASACQThsahCtBhogAyAENgIIQcChASADQQhqEAMFIAQLNgIAIANBEGokAAsUACAAKAIAIAFBOGxqIAIQswZBAQsGAEGYowEL/QEBBX8gACgCBCICIAAoAghHBEAgAiABKQIANwIAIAIgASkCCDcCCCAAIAJBEGo2AgQPCwJAIAIgACgCACIFayIGQQR1IgRBAWoiAkGAgICAAUkEQAJ/QQAgAiAGQQN1IgMgAiADSxtB/////wAgBEH///8/SRsiA0UNABogA0GAgICAAU8NAiADQQR0ENUaCyICIARBBHRqIgQgASkCADcCACAEIAEpAgg3AgggAiADQQR0aiEBIARBEGohAyAGQQFOBEAgAiAFIAYQrhsaCyAAIAE2AgggACADNgIEIAAgAjYCACAFBEAg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QczvARCJA0Gk7wFB/+QBQcwNEJgKAAtBqX4gBUEQakHl7wEQiQNBpO8BQf/kAUHXDRCYCgALwQIBB38gBwRAIAZBBGshDCAGQQNKIQ0DQEEAIQggDQRAA0AgAiAIQQFyIglqLQAAIQogACAJai0AACELIAQgCGogAiAIai0AACAAIAhqLQAAQYACcmpBoPwDai0AADoAACAEIAlqIAogC0GAAnJqQaD8A2otAAA6AAAgAiAIQQNyIglqLQAAIQsgACAJai0AACEOIAQgCEECciIKaiACIApqLQAAIAAgCmotAABBgAJyakGg/ANqLQAAOgAAIAQgCWogCyAOQYACcmpBoPwDai0AADoAACAIQQRqIgggDEwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhqIAIgCGotAAAgACAIai0AAEGAAnJqQaD8A2otAAA6AAAgCEEBaiIIIAZHDQALCyAEIAVqIQQgAiADaiECIAAgAWohACAHDQALCwvzAgEIfyAHBEAgBkEEayEKIAZBA0ohCyAFQQF2QQF0IQwgA0EBdkEBdCENIAFBAXZBAXQhDgNAQQAhASALBEADQCACIAFBAXQiA0ECciIFai8BACEIIAAgBWovAQAhCSADIARqIAIgA2ovAQAgACADai8BAGoiD0H//wMgD0H//wNJGzsBACAEIAVqIAggCWoiBUH//wMgBUH//wNJGzsBACACIANBBnIiBWovAQAhCCAAIAVqLwEAIQkgBCADQQRyIgNqIAIgA2ovAQAgACADai8BAGoiA0H//wMgA0H//wNJGzsBACAEIAVqIAggCWoiA0H//wMgA0H//wNJGzsBACABQQRqIgEgCkwNAAsLIAdBAWshByABIAZIBEADQCAEIAFBAXQiA2ogAiADai8BACAAIANqLwEAaiIDQf//AyADQf//A0kbOwEAIAFBAWoiASAGRw0ACwsgBCAMaiEEIAIgDWohAiAAIA5qIQAgBw0ACwsLuQMBCH8gBwRAIAZBBGshCyAGQQNKIQwgBUEBdkEBdCENIANBAXZBAXQhDiABQQF2QQF0IQ8DQEEAIQEgDARAA0AgAiABQQF0IgNBAnIiBWouAQAhCCAAIAVqLgEAIQkgAyAEaiAAIANqLgEAIAIgA2ouAQBqIgpB//8BIApB//8BSBsiCkGAgH4gCkGAgH5KGzsBACAEIAVqIAggCWoiBUH//wEgBUH//wFIGyIFQYCAfiAFQYCAfkobOwEAIAIgA0EGciIFai4BACEIIAAgBWouAQAhCSAEIANBBHIiA2ogACADai4BACACIANqLgEAaiIDQf//ASADQf//AUgbIgNBgIB+IANBgIB+Shs7AQAgBCAFaiAIIAlqIgNB//8BIANB//8BSBsiA0GAgH4gA0GAgH5KGzsBACABQQRqIgEgC0wNAAsLIAdBAWshByABIAZIBEADQCAEIAFBAXQiA2ogACADai4BACACIANqLgEAaiIDQf//ASADQf//AUgbIgNBgIB+IANBgIB+Shs7AQAgAUEBaiIBIAZHDQALCyAEIA1qIQQgAiAOaiECIAAgD2ohACAHDQALCwutAgEHfyAHBEAgBkEEayEKIAZBA0ohCyAFQQJ2QQJ0IQwgA0ECdkECdCENIAFBAnZBAnQhDgNAQQAhASALBEADQCACIAFBAnQiA0EEciIFaigCACEIIAAgBWooAgAhCSADIARqIAIgA2ooAgAgACADaigCAGo2AgAgBCAFaiAIIAlqNgIAIAIgA0EMciIFaigCACEIIAAgBWooAgAhCSAEIANBCHIiA2ogAiADaigCACAAIANqKAIAajYCACAEIAVqIAggCWo2AgAgAUEEaiIBIApMDQALCyAHQQFrIQcgASAGSARAA0AgBCABQQJ0IgNqIAIgA2ooAgAgACADaigCAGo2AgAgAUEBaiIBIAZHDQALCyAEIAxqIQQgAiANaiECIAAgDmohACAHDQALCwuvAgIFfwJ9IAcEQCAGQQRrIQggBkEDSiEJIAVBAnZBAnQhCiADQQJ2QQJ0IQsgAUECdkECdCEMA0BBACEBIAkEQANAIAIgAUECdCIDQQRyIgVqKgIAIQ0gACAFaioCACEOIAMgBGogACADaioCACACIANqKgIAkjgCACAEIAVqIA4gDZI4AgAgAiADQQxyIgVqKgIAIQ0gACAFaioCACEOIAQgA0EIciIDaiAAIANqKgIAIAIgA2oqAgCSOAIAIAQgBWogDiANkjgCACABQQRqIgEgCEwNAAsLIAdBAWshByABIAZIBEADQCAEIAFBAnQiA2ogACADaioCACACIANqKgIAkjgCACABQQFqIgEgBkcNAAsLIAQgCmohBCACIAtqIQIgACAMaiEAIAcNAAsLC68CAgV/AnwgBwRAIAZBBGshCCAGQQNKIQkgBUEDdkEDdCEKIANBA3ZBA3QhCyABQQN2QQN0IQwDQEEAIQEgCQRAA0AgAiABQQN0IgNBCHIiBWorAwAhDSAAIAVqKwMAIQ4gAyAEaiAAIANqKwMAIAIgA2orAwCgOQMAIAQgBWogDiANoDkDACACIANBGHIiBWorAwAhDSAAIAVqKwMAIQ4gBCADQRByIgNqIAAgA2orAwAgAiADaisDAKA5AwAgBCAFaiAOIA2gOQMAIAFBBGoiASAITA0ACwsgB0EBayEHIAEgBkgEQANAIAQgAUEDdCIDaiAAIANqKwMAIAIgA2orAwCgOQMAIAFBAWoiASAGRw0ACwsgBCAKaiEEIAIgC2ohAiAAIAxqIQAgBw0ACwsLwQIBB38gBwRAIAZBBGshDCAGQQNKIQ0DQEEAIQggDQRAA0AgAiAIQQFyIglqLQAAIQogACAJai0AACELIAQgCGogACAIai0AAEGAAnIgAiAIai0AAGtBoPwDai0AADoAACAEIAlqIAtBgAJyIAprQaD8A2otAAA6AAAgAiAIQQNyIglqLQAAIQsgACAJai0AACEOIAQgCEECciIKaiAAIApqLQAAQYACciACIApqLQAAa0Gg/ANqLQAAOgAAIAQgCWogDkGAAnIgC2tBoPwDai0AADoAACAIQQRqIgggDEwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhqIAAgCGotAABBgAJyIAIgCGotAABrQaD8A2otAAA6AAAgCEEBaiIIIAZHDQALCyAEIAVqIQQgAiADaiECIAAgAWohACAHDQALCwulAwEIfyAHBEAgBkEEayELIAZBA0ohDCAFQQF2QQF0IQ0gA0EBdkEBdCEOIAFBAXZBAXQhDwNAQQAhASAMBEADQCACIAFBAXQiA0ECciIFai8BACEIIAAgBWovAQAhCSADIARqIAAgA2ovAQAgAiADai8BAGsiCkEAIApBAEobIgpB//8DIApB//8DSBs7AQAgBCAFaiAJIAhrIgVBACAFQQBKGyIFQf//AyAFQf//A0gbOwEAIAIgA0EGciIFai8BACEIIAAgBWovAQAhCSAEIANBBHIiA2ogACADai8BACACIANqLwEAayIDQQAgA0EAShsiA0H//wMgA0H//wNIGzsBACAEIAVqIAkgCGsiA0EAIANBAEobIgNB//8DIANB//8DSBs7AQAgAUEEaiIBIAtMDQALCyAHQQFrIQcgASAGSARAA0AgBCABQQF0IgNqIAAgA2ovAQAgAiADai8BAGsiA0EAIANBAEobIgNB//8DIANB//8DSBs7AQAgAUEBaiIBIAZHDQALCyAEIA1qIQQgAiAOaiECIAAgD2ohACAHDQALCwu5AwEIfyAHBEAgBkEEayELIAZBA0ohDCAFQQF2QQF0IQ0gA0EBdkEBdCEOIAFBAXZBAXQhDwNAQQAhASAMBEADQCACIAFBAXQiA0ECciIFai4BACEIIAAgBWouAQAhCSADIARqIAAgA2ouAQAgAiADai4BAGsiCkH//wEgCkH//wFIGyIKQYCAfiAKQYCAfkobOwEAIAQgBWogCSAIayIFQf//ASAFQf//AUgbIgVBgIB+IAVBgIB+Shs7AQAgAiADQQZyIgVqLgEAIQggACAFai4BACEJIAQgA0EEciIDaiAAIANqLgEAIAIgA2ouAQBrIgNB//8BIANB//8BSBsiA0GAgH4gA0GAgH5KGzsBACAEIAVqIAkgCGsiA0H//wEgA0H//wFIGyIDQYCAfiADQYCAfkobOwEAIAFBBGoiASALTA0ACwsgB0EBayEHIAEgBkgEQANAIAQgAUEBdCIDaiAAIANqLgEAIAIgA2ouAQBrIgNB//8BIANB//8BSBsiA0GAgH4gA0GAgH5KGzsBACABQQFqIgEgBkcNAAsLIAQgDWohBCACIA5qIQIgACAPaiEAIAcNAAsLC60CAQd/IAcEQCAGQQRrIQogBkEDSiELIAVBAnZBAnQhDCADQQJ2QQJ0IQ0gAUECdkECdCEOA0BBACEBIAsEQANAIAIgAUECdCIDQQRyIgVqKAIAIQggACAFaigCACEJIAMgBGogACADaigCACACIANqKAIAazYCACAEIAVqIAkgCGs2AgAgAiADQQxyIgVqKAIAIQggACAFaigCACEJIAQgA0EIciIDaiAAIANqKAIAIAIgA2ooAgBrNgIAIAQgBWogCSAIazYCACABQQRqIgEgCkwNAAsLIAdBAWshByABIAZIBEADQCAEIAFBAnQiA2ogACADaigCACACIANqKAIAazYCACABQQFqIgEgBkcNAAsLIAQgDGohBCACIA1qIQIgACAOaiEAIAcNAAsLC68C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IgggC0wNAAsLIAdBAWshByAGIAhKBEADQCAEIAhqQX9BACAAIAhBAXQiAWovAQAgASACai8BAEcbOgAAIAhBAWoiCCAGRw0ACwsgBCAFaiEEIAIgDWohAiAAIA5qIQAgBw0ACwsgD0EQaiQADwtBqX4gD0Gx8AEQiQNB0fABQYvwAUH3BRCYCgALywIBB38gBwRAIAZBBGshCyAGQQNKIQwgA0EBdkEBdCENIAFBAXZBAXQhDgNAQQAhASAMBEADQCACIAFBAXIiA0EBdCIIai4BACEKIAAgCGouAQAhCCABIARqQX9BACAAIAFBAXQiCWouAQAgAiAJai4BAEgbOgAAIAMgBGpBf0EAIAggCkgbOgAAIAIgAUEDciIDQQF0IghqLgEAIQogACAIai4BACEIIAQgAUECciIJakF/QQAgACAJQQF0IglqLgEAIAIgCWouAQBIGzoAACADIARqQX9BACAIIApIGzoAACABQQRqIgEgC0wNAAsLIAdBAWshByABIAZIBEADQCABIARqQX9BACAAIAFBAXQiA2ouAQAgAiADai4BAEgbOgAAIAFBAWoiASAGRw0ACwsgBCAFaiEEIAIgDWohAiAAIA5qIQAgBw0ACwsLywIBB38gBwRAIAZBBGshCyAGQQNKIQwgA0EBdkEBdCENIAFBAXZBAXQhDgNAQQAhASAMBEADQCACIAFBAXIiA0EBdCIIai4BACEKIAAgCGouAQAhCCABIARqQX9BACAAIAFBAXQiCWouAQAgAiAJai4BAEwbOgAAIAMgBGpBf0EAIAggCkwbOgAAIAIgAUEDciIDQQF0IghqLgEAIQogACAIai4BACEIIAQgAUECciIJakF/QQAgACAJQQF0IglqLgEAIAIgCWouAQBMGzoAACADIARqQX9BACAIIApMGzoAACABQQRqIgEgC0wNAAsLIAdBAWshByABIAZIBEADQCABIARqQX9BACAAIAFBAXQiA2ouAQAgAiADai4BAEwbOgAAIAFBAWoiASAGRw0ACwsgBCAFaiEEIAIgDWohAiAAIA5qIQAgBw0ACwsLtwYBB38jAEEQayIPJAACQAJAAkACQAJAAkACQAJAIAgOBgQBAwACBQcLIAAgASACIAMgBCAFIAYgBxDoBAwFCyACIAMgACABIAQgBSAGIAcQ6AQMBAsgACABIAIgAyAE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OAIAIAMgBGogDiANlDgCACAIQQRqIgggBUwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhBAnQiAWogACABaioCACABIAJqKgIAlDgCACAIQQFqIgggBkcNAAsLIAQgCkECdGohBCACIAtBAnRqIQIgACAMQQJ0aiEAIAcNAAsMAQsgB0UNACAGQQRrIQUgBkEDSiEJA0BBACEIIAkEQANAIAIgCEECdCIBQQRyIgNqKgIAIQ0gACADaioCACEOIAEgBGogDyAAIAFqKgIAu6IgASACaioCALuitjgCACADIARqIA8gDruiIA27orY4AgAgAiABQQxyIgNqKgIAIQ0gACADaioCACEOIAQgAUEIciIBaiAPIAAgAWoqAgC7oiABIAJqKgIAu6K2OAIAIAMgBGogDyAOu6IgDbuitjgCACAIQQRqIgggBUwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhBAnQiAWogDyAAIAFqKgIAu6IgASACaioCALuitjgCACAIQQFqIgggBkcNAAsLIAQgCkECdGohBCACIAtBAnRqIQIgACAMQQJ0aiEAIAcNAAsLC5MFAgZ/AXwgBUECdiEMIANBAnYhDSABQQJ2IQ4CQCAIKwMAIg9EAAAAAAAA8L+gmUQAAAAAAACAPmVBAXNFBEAgB0UNASAGQQRrIQogBkEDSiELA0BBACEIIAsEQANAIAIgCEECdCIBQQRyIgNqKAIAIQUgACADaigCACEJIAEgBGogASACaigCACAAIAFqKAIAbDYCACADIARqIAUgCWw2AgAgAiABQQxyIgNqKAIAIQUgACADaigCACEJIAQgAUEIciIBaiABIAJqKAIAIAAgAWooAgBsNgIAIAMgBGogBSAJbDYCACAIQQRqIgggCkwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhBAnQiAWogASACaigCACAAIAFqKAIAbDYCACAIQQFqIgggBkcNAAsLIAQgDEECdGohBCACIA1BAnRqIQIgACAOQQJ0aiEAIAcNAAsMAQsgB0UNACAGQQRrIQogBkEDSiELA0BBACEIIAsEQANAIAIgCEECdCIBQQRyIgNqKAIAIQUgACADaigCACEJIAEgBGogDyAAIAFqKAIAt6IgASACaigCALeiEIIVNgIAIAMgBGogDyAJt6IgBbeiEIIVNgIAIAIgAUEM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IQ0gACADaioCACEOIAEgBGogACABaioCACABIAJqKgIAlTgCACADIARqIA4gDZU4AgAgAiABQQxyIgNqKgIAIQ0gACADaioCACEOIAQgAUEIciIBaiAAIAFqKgIAIAEgAmoqAgCVOAIAIAMgBGogDiANlTgCACAIQQRqIgggBUwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhBAnQiAWogACABaioCACABIAJqKgIAlTgCACAIQQFqIgggBkcNAAsLIAQgCkECdGohBCACIAtBAnRqIQIgACAMQQJ0aiEAIAcNAAsMAQsgB0UNACAGQQRrIQUgBkEDSiEJA0BBACEIIAkEQANAIAIgCEECdCIBQQRyIgNqKgIAIQ4gACADaioCACEPIAEgBGogACABaioCACANlCABIAJqKgIAlTgCACADIARqIA8gDZQgDpU4AgAgAiABQQxyIgNqKgIAIQ4gACADaioCACEPIAQgAUEIciIBaiAAIAFqKgIAIA2UIAEgAmoqAgCVOAIAIAMgBGogDyANlCAOlTgCACAIQQRqIgggBUwNAAsLIAdBAWshByAGIAhKBEADQCAEIAhBAnQiAWogACABaioCACANlCABIAJqKgIAlTgCACAIQQFqIgggBkcNAAsLIAQgCkECdGohBCACIAtBAnRqIQIgACAMQQJ0aiEAIAcNAAsLC/YEAgV/A3wgBUEDdiEKIANBA3YhCyABQQN2IQwCQCAIKwMARAAAAAAAAPA/YQRAIAdFDQEgBkEEayEFIAZBA0ohCQNAQQAhASAJBEADQCACIAFBA3QiA0EIciIIaisDACEOIAAgCGorAwAhDyADIARqIAAgA2orAwAgAiADaisDAKM5AwAgBCAIaiAPIA6jOQMAIAIgA0EYciIIaisDACEOIAAgCGorAwAhDyAEIANBEHIiA2ogACADaisDACACIANqKwMAozkDACAEIAhqIA8gDqM5AwAgAUEEaiIBIAVMDQALCyAHQQFrIQcgASAGSARAA0AgBCABQQN0IgNqIAAgA2orAwAgAiADaisDAKM5AwAgAUEBaiIBIAZHDQALCyAEIApBA3RqIQQgAiALQQN0aiECIAAgDEEDdGohACAHDQALDAELIAdFDQAgBkEEayEJIAZBA0ohDQNAQQAhASANBEADQCACIAFBA3QiA0EIciIFaisDACEO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FyAVIAItAAG4oqAhFyAWIBUgAi0AALiioCEWIAIgDGohAiAAQQFqIgAgAUcNAAsLIAogBEECdGoiAiAWIAOitjgCACACIBkgA6K2OAIMIAIgGCADorY4AgggAiAXIAOitjgCBCAEQQRqIgQgBUwNAAsLIAQgCEgEQANAAkAgAUEBSARARAAAAAAAAAAAIRUMAQsgBCANaiECQQAhAEQAAAAAAAAAACEVA0AgFSAHIABBAnRqKgIAuyACLQAAuKKgIRUgAiAMaiECIABBAWoiACABRw0ACwsgCiAEQQJ0aiAVIAOitjgCACAEQQFqIgQgCEcNAAsLIAogEkECdGohCiAGQQFqIgYgCEcNAAsLIAcgEUcEQCAHEKIbCyALQaAIaiQAC68IAxR/AX0BfCMAQaAIayIHJAAgASgCMEECdiESIAAoAjAhDSABKAIQIQogACgCECEOIAAoAigiACgCACELIAAoAgQhBAJAIAIoAhAiCEUEQCALQQFIDQEgBEF8cSEJIARBBGshBkEAIQggBEEDSiEQA0AgDiAIIA1saiEBIAghDANAIA4gDCANbGohAkEAIQBEAAAAAAAAAAAhGQJ/IBAEQANAIBkgACABai0AALggACACai0AALiiIAEgAEEBciIFai0AALggAiAFai0AALiioCABIABBAnIiBWotAAC4IAIgBWotAAC4oqAgASAAQQNyIgVqLQAAuCACIAVqLQAAuKKgoCEZIABBBGoiACAGTA0ACyAJIQALIAAgBEgLBEADQCAZIAAgAWotAAC4IAAgAmotAAC4oqAhGSAAQQFqIgAgBEcNAAsLIAogDEECdGogGSADorY4AgAgDEEBaiIMIAtHDQALIAogEkECdGohCiAIQQFqIgggC0cNAAsMAQsgAigCCCEBIAIoAjAhBiACKAIMIREgByAEQQJ0IgA2AgQgByAHQQhqIhM2AgAgEyEFIABBiQhPBEAgByAAENUaIgU2AgALIAtBAU4EQCAGQQJ2QQAgAUEBShshFCAEQXxxIRUgBEEEayEMIARBAUghFiAEQQNKIRcgBCARRkEEdCEQA0AgDiANIA9saiECIAggDyAUbEECdGohAQJAIAQgEUwEQEEAIQAgBEEATA0BA0AgBSAAQQJ0IgZqIAAgAmotAACzIAEgBmoqAgCTOAIAIABBAWoiACAERw0ACwwB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AANAIAQgAEEDdCICaiACIAZqKwMAIAErAwChOQMAIABBAWoiACAFRw0ACwsgDyEIA0AgEyAIIBVsQQN0aiEAIAggDWxBA3QhAiAFIBFKBEAgByAAKwMAIhg5A6AIIAcgGDkDqAggByAYOQOYCCAHIBg5A5AIIAdBkAhqIQALIAIgDmohAUQAAAAAAAAAACEYQQAhAgJ/IAVBA0oEQANAIBggBCACQQN0IgZqKwMAIAEgBmorAwAgACsDAKGiIAQgBkEIciIMaisDACABIAxqKwMAIAArAwihoqAgBCAGQRByIgxqKwMAIAEgDGorAwAgACsDEKGioCAEIAZBGHIiBmorAwAgASAGaisDACAAKwMYoaKgoCEYIAAgEGohACACQQRqIgIgC0wNAAsgFiECCyACIAVICwRAA0AgGCAEIAJBA3QiBmorAwAgASAGaisDACAAKwMAoaKgIRggAEEIaiEAIAJBAWoiAiAFRw0ACwsgCSAIQQN0aiAYIAOiOQMAIAhBAWoiCCAKRw0ACyAJIBJBA3RqIQkgD0EBaiIPIApHDQALCyAEIBRGDQAgBBCiGwsgB0GwCGokAAvMAQIDfwF8An8gAkEETgRAIAJBBGshBQNAIAYgACADai0AALggASADai0AALiiIAAgA0EBciIEai0AALggASAEai0AALiioCAAIANBAnIiBGotAAC4IAEgBGotAAC4oqAgACADQQNyIgRqLQAAuCABIARqLQAAuKKgoCEGIANBBGoiAyAFTA0ACyACQXxxIQMLIAIgA0oLBEADQCAGIAAgA2otAAC4IAEgA2otAAC4oqAhBiADQQFqIgMgAkcNAAsLIAZEAAAAAAAAAACgC8wBAgN/AXwCfyACQQROBEAgAkEEayEFA0AgBiAAIANqLAAAtyABIANqLAAAt6IgACADQQFyIgRqLAAAtyABIARqLAAAt6KgIAAgA0ECciIEaiwAALcgASAEaiwAALeioCAAIANBA3IiBGosAAC3IAEgBGosAAC3oqCgIQYgA0EEaiIDIAVMDQALIAJBfHEhAwsgAiADSgsEQANAIAYgACADaiwAALcgASADaiwAALeioCEGIANBAWoiAyACRw0ACwsgBkQAAAAAAAAAAKAL1gECBH8BfAJ/IAJBBE4EQCACQQRrIQYDQCAHIAAgA0EBdCIEai8BALggASAEai8BALiiIAAgBEECciIFai8BALggASAFai8BALiioCAAIARBBHIiBWovAQC4IAEgBWovAQC4oqAgACAEQQZyIgRqLwEAuCABIARqLwEAuKKgoCEHIANBBGoiAyAGTA0ACyACQXxxIQMLIAIgA0oLBEADQCAHIAAgA0EBdCIEai8BALggASAEai8BALiioCEHIANBAWoiAyACRw0ACwsgB0QAAAAAAAAAAKAL1gECBH8BfAJ/IAJBBE4EQCACQQRrIQYDQCAHIAAgA0EBdCIEai4BALcgASAEai4BALeiIAAgBEECciIFai4BALcgASAFai4BALeioCAAIARBBHIiBWouAQC3IAEgBWouAQC3oqAgACAEQQZyIgRqLgEAtyABIARqLgEAt6KgoCEHIANBBGoiAyAGTA0ACyACQXxxIQMLIAIgA0oLBEADQCAHIAAgA0EBdCIEai4BALcgASAEai4BALeioCEHIANBAWoiAyACRw0ACwsgB0QAAAAAAAAAAKALzAECBH8BfAJ/IAJBBE4EQCACQQRrIQYDQCAHIAAgA0ECdCIEaigCALcgASAEaigCALeiIAAgBEEEciIFaigCALcgASAFaigCALeioCAAIARBCHIiBWooAgC3IAEgBWooAgC3oqAgACAEQQxyIgRqKAIAtyABIARqKAIAt6KgoCEHIANBBGoiAyAGTA0ACyACQXxxIQMLIAIgA0oLBEADQCAHIAAgA0ECdCIEaigCALcgASAEaigCALeioCEHIANBAWoiAyACRw0ACwsgBwvWAQIEfwF8An8gAkEETgRAIAJBBGshBgNAIAcgACADQQJ0IgRqKgIAuyABIARqKgIAu6IgACAEQQRyIgVqKgIAuyABIAVqKgIAu6KgIAAgBEEIciIFaioCALsgASAFaioCALuioCAAIARBDHIiBGoqAgC7IAEgBGoqAgC7oqCgIQcgA0EEaiIDIAZMDQALIAJBfHEhAwsgAiADSgsEQANAIAcgACADQQJ0IgRqKgIAuyABIARqKgIAu6KgIQcgA0EBaiIDIAJHDQALCyAHRAAAAAAAAAAAoAvqCgEEfyMAQdACayIHJAACQCAAEMwHQYCABEYEQCAHQZgCaiAAKAIEEK0GGgwBCyAHQZgCaiAAEMkHCwJAIAEQzAdBgIAERgRAIAdB4AFqIAEoAgQQrQYaDAEL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QQJ0akEANgIAIAFBAWoiASAAKAI0SA0ACwsgCyAAKAJcIgFHBEAgARDuAwsgAEH4AGohAQJAIAAoAowBIghFDQAgCCAIKAIMIglBAWs2AgwgCUEBRw0AIAAoAowBIglFDQAgAEEANgKMAQJAIAkoAgQiCA0AIAAoAogBIggNABCgBiEICyAIIAkgCCgCACgCGBECAAsgAEEANgKMASABQgA3AgggAUIANwIAIAAoAmxBAU4EQCAAKAKQASEIQQAhAQNAIAggAUECdGpBADYCACABQQFqIgEgACgCbEgNAAsLIAAoApQBIgEgBUYNACABEO4DCyAAQaACaiQADwtBqX4gAEHoAGpBvoMCEIkDQYGEAkHggwJBwAAQmAoAC9cHAQR/IwBBoAJrIgAkAAJAAkAgAUUNACACRQ0AIAIoAhAhCiABKAIQIQsgA0EBTgRAIANBAmshDUEAIQEDQCAEIAFBAnQiAmooAgAiCUF/TA0DIAlFDQIgBQRAQQEhDCALIAEgDUwEfyACIAZqKAIABSAMCyACIAVqKAIAbGohCwsgBwRAQQEhDCAKIAEgDUwEfyACIAhqKAIABSAMCyACIAdqKAIAbGohCgsgAEGgAWogAmogCTYCACABQQFqIgEgA0cNAAsLIABB/ABqIgFCADcCACAAQgA3AnRBACECIABBADYCjAEgAEIANwKEASAAQZgBaiIFQgA3AwAgASALNgIAIABCADcCbCAAQYCA/JcENgJoIAAgBTYClAEgACAAQfAAajYCkAEgACALNgJ4IABB6ABqIAMgAEGgAWogBkEBEJ4GIABB6ABqEJ8GIABBxABqIgFCADcCACAAQgA3AjwgAEEANgJUIABCADcCTCAAQeAAaiIHQgA3AwAgASAKNgIAIABCADcCNCAAIAc2AlwgACAAQThqNgJYIABBgID8lwQ2AjAgACAKNgJAIABBMGogAyAAQaABaiAIQQEQngYgAEEwahCfBiAAIABBMGo2AiwgACAAQegAajYCKCAAIABBKGogAEEgakECEKwHIgEoAhAEQCABKAIUIQkDQCAAKAIkIAAoAiAgCRCuGxogARCtByACQQFqIgIgASgCEEkNAAsLIABBQGshAQJAIAAoAlQiAkUNACACIAIoAgwiCUEBazYCDCAJQQFHDQAgACgCVCIJRQ0AIABBADYCVAJAIAko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BCAFKQOQAzcDsAEgBCAFKwOgAzkDwAEgBCAKKwMAOQPIASAEIAsrAwA5A9ABIAQgDCsDADkD2AEgCBCxBhogBxCxBhogBhCxBhogAxCxBhogAhCxBhogARCxBhogABCxBhoLIAVBwANqJAALgwcDDX8BfgJ8IwBBwANrIgQkAAJAIAAgASAAKAIAKAIIEQMABEAgASkDACERIARBqAFqEKcGIQAgBEHwAGoQpwYhBSAEQThqEKcGIQYgASsDsAEhEiABKwO4ASETIAQgETcD4AEgBEHoAWogABCtBiEHIARBoAJqIAUQrQYhCCAEQdgCaiAGEK0GIQkgBEGYA2oiCiATOQMAIAQgEjkDkAMgBCABKwPAATkDoAMgBEGoA2oiCyABKwPIATkDACAEQbADaiIMIAErA9ABOQMAIARBuANqIg0gASsD2AE5AwAgAyAEKQPgATcDACADQQhqIg4gBxC5BhogA0FAayIPIAgQuQYaIANB+ABqIhAgCRC5BhogAyAKKQMANwO4ASADIAQpA5ADNwOwASADIAQrA6ADOQPAASADIAsrAwA5A8gBIAMgDCsDADkD0AEgAyANKwMAOQPYASAJELEGGiAIELEGGiAHELEGGiAGELEGGiAFELEGGiAAELEGGiABKAIYBEAgBEHgAWogAUEIaiACEL4GIA4gBEHgAWoQuQYaIARB4AFqELEGGgsgASgCUARAIARB4AFqIAFBQGsgAhC+BiAPIARB4AFqELkGGiAEQeABahCxBhoLIAEoAogBRQ0BIARB4AFqIAFB+ABqIAIQvgYgECAEQeABahC5BhogBEHgAWoQsQYaDAELIARBqAFqEKcGIQAgASgCACIFIAEgAEF/IAUoAgAoAgwRBgAgBEHwAGogACACEL4GIARBOGoQpwYhASAEEKcGIQIgBEEANgLkASAEQeTOCjYC4AEgBEHoAWogBEHwAGoQrQYhBSAEQaACaiABEK0GIQYgBEHYAmogAhCtBiEHIARBmANqIghCgICAgICAgPg/NwMAIARBqANqIglCADcDACAEQbADaiIKQgA3AwAgBEG4A2oiC0IANwMAIARCADcDoAMgBEKAgICAgICA+D83A5ADIAMgBCkD4AE3AwAgA0EIaiAFELkGGiADQUBrIAYQuQYaIANB+ABqIAcQuQYaIAMgCCkDADcDuAEgAyAEKQOQAzcDsAEgAyAEKwOgAzkDwAEgAyAJKwMAOQPIASADIAorAwA5A9ABIAMgCysDADkD2AEgBxCxBhogBhCxBhogBRCxBhogAhCxBhogARCxBhogBEHwAGoQsQYaIAAQsQYaCyAEQcADaiQAC58BAQJ/IwBB8ABrIgAkACAAQQhqEKcGIQMgASgCACIEIAEgA0F/IAQoAgAoAgwRBgAgAEIANwNoIAAgAjYCZCAAQYCAhAg2AmAgAEIANwNYIAAgAzYCVCAAQYCAhAg2AlAgACACNgJEIABBgICEkHw2AkAgAEIANwNIIABB4ABqIABB0ABqIABBQGtB1NYKENsFIAMQsQYaIABB8ABqJAALnwEBAn8jAEHwAGsiACQAIABBCGoQpwYhAyABKAIAIgQgASADQX8gBCgCACgCDBEGACAAQgA3A2ggACACNgJkIABBgICECDYCYCAAQgA3A1ggACADNgJUIABBgICECDYCUCAAIAI2AkQgAEGAgISQfDYCQCAAQgA3A0ggAEHgAGogAEHQAGogAEFAa0HU1goQ3QUgAxCxBhogAEHwAGokAAvjAQECfyMAQbABayIAJAAgABCnBiEDIAEoAgAiBCABIANBfyAEKAIAKAIMEQYAIABCADcDqAEgACACNgKkASAAQYCAhAg2AqABIABCADcDmAEgACADNgKUASAAQYCAhAg2ApABIABByABqEKcGIQEgAEIANwOIASAAIAE2AoQBIABBgICECDYCgAEgACACNgI8IABBgICEEDYCOCAAQgA3A0AgAEGgAWogAEGQAWpEAAAAAAAA8D8gAEGAAWpEAAAAAAAAAAAgAEE4akEAEIIGIAEQsQYaIAMQsQYaIABBsAFqJAALpAEBAn8jAEHwAGsiACQAIABBCGoQpwYhAyABKAIAIgQgASADQX8gBCgCACgCDBEGACAAQgA3A2ggACACNgJkIABBgICECDYCYCAAQgA3A1ggACADNgJUIABBgICECDYCUCAAIAI2AkQgAEGAgISQfDYCQCAAQgA3A0ggAEHgAGogAEHQAGogAEFAa0QAAAAAAADwPxDgBSADELEGGiAAQfAAaiQAC58BAQJ/IwBB8ABrIgAkACAAQQhqEKcGIQMgASgCACIEIAEgA0F/IAQoAgAoAgwRBgAgAEIANwNoIAAgAjYCZCAAQYCAhAg2AmAg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IAAQrQYhBiAEQagCaiACEK0GIQcgBEGIA2oiCCAPOQMAIARBgANqIgkgDDkDACAEQfgCaiIKIA05AwAgBEHoAmoiCyAROQMAIAQgDjkD8AIgBCAQOQPgAiADIAQpA7ABNwMAIANBCGogARC5BhogA0FAayAGELkGGiADQfgAaiAHELkGGiADIAspAwA3A7gBIAMgBCkD4AI3A7ABIAMgBCsD8AI5A8ABIAMgCisDADkDyAEgAyAJKwMAOQPQASADIAgrAwA5A9gBIAcQsQYaIAYQsQYaIAEQsQYaIAIQsQYaIAAQsQYaIAUQsQYaDAELIAUgASACIAMgBSgCACgCPBEGAAsgBEGQA2okAAv0AgEJfyMAQZADayIAJAAgAEFAaxCnBiEFIAIoAgAiBCACIAVBfyAEKAIAKAIMEQYAIABBCGoQpwYhAiAAQfgAahCnBiEEIABBADYCtAEgAEHozgo2ArABIABBuAFqIAUQrQYhBiAAQfABaiACEK0GIQcgAEGoAmogBBCtBiEIIABB6AJqIglCADcDACAAQoCAgICAgID4v383A+ACIAAgASsDADkD8AIgAEH4AmoiCiABKwMIOQMAIABBgANqIgsgASsDEDkDACAAQYgDaiIMIAErAxg5AwAgAyAAKQOwATcDACADQQhqIAYQuQYaIANBQGsgBxC5BhogA0H4AGogCBC5BhogAyAJKQMANwO4ASADIAApA+ACNwOwASADIAArA/ACOQPAASADIAorAwA5A8gBIAMgCysDADkD0AEgAyAMKwMAOQPYASAIELEGGiAHELEGGiAGELEGGiAEELEGGiACELEGGiAFELEGGiAAQZADaiQAC6oKAgh/AXwjAEGQA2siBSQAAkAgACACKAIAIgZGBEAgBUFAaxCnBiEAIAVBCGoQpwYhBgJAAkACQAJAIAEoAgAiB0HszgpHDQAgASgCBEEvRw0AIAEoAlAEQCABKwO4AUQAAAAAAAAAAGINAgsCQAJAIAIoAgAiB0HozgpHDQAgAigCUARAIAIrA7gBRAAAAAAAAAAAYg0BCyACKwPAAUQAAAAAAAAAAGINACACKwPIAUQAAAAAAAAAAGINACACKwPQAUQAAAAAAAAAAGINACACKwPYAUQAAAAAAAAAAGINACACKwOwASENIAYgAkEIahCzBiANIASiIQQMAQsgByAC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ADkD0AEgAyALKwMAOQPYASAHELEGGiAFELEGGiABELEGGiACELEGGiAAELEGGiAGELEGGgwBCyAGIAEgAiADIAYoAgAoAlwRBgALIARBkANqJAALRQECfyMAQUBqIgQkACAEQQhqEKcGIQAgASgCACIFIAEgAEF/IAUoAgAoAgwRBgAgAyACIAAQ+gYgABCxBhogBEFAayQAC7wCAQl/IwBB0AJrIgMkACADQThqEKcGIQQgAxCnBiEFIAMgATYCdCADQfTOCjYCcCADQfgAaiACEK0GIQIgA0GwAWogBBCtBiEBIANB6AFqIAUQrQYhBiADQagCaiIHQgA3AwAgA0GwAmoiCEIANwMAIANBuAJqIglCADcDACADQcACaiIKQgA3AwAgA0HIAmoiC0IANwMAIANCgICAgICAgPg/NwOgAiAAIAMpA3A3AwAgAEEIaiACELkGGiAAQUBrIAEQuQYaIABB+ABqIAYQuQYaIAAgBykDADcDuAEgACADKQOgAjcDsAEgACAIKwMAOQPAASAAIAkrAwA5A8gBIAAgCisDADkD0AEgACALKwMAOQPYASAGELEGGiABELEGGiACELEGGiAFELEGGiAEELEGGiADQdACaiQACzsAIAACfyACQTBqIAJBCGoQtwZFDQAaIAJB6ABqIAJBQGsQtwYNABogAkGgAWoLKAIAKQIAQiCJNwIACy8AAkAgAUEIaiIAELcGRQ0AIAFBQGsiABC3Bg0AIAFB+ABqIQALIAAoAgBB/x9xC8QDAQ9/IwBBoAJrIgMkAAJAIAEQtwZFBEAgAhC3BkUNAQtBeyADQUBrQaCpAhCJA0HHqQJB6p0CQSAQmAoACyAAQgA3AwAgAEEIahCnBiEGIABBQGsQpwYhByAAQfgAahCnBiEIIABB2AFqIglCADcDACAAQdABaiIKQgA3AwAgAEHIAWoiC0IANwMAIABBwAFqIgxCADcDACAAQbgBaiINQgA3AwAgAEIANwOwASADQQhqEKcGIQQgA0EANgJEIANB6M4KNgJAIANByABqIAEQrQYhASADQYABaiACEK0GIQIgA0G4AWogBBCtBiEFIANB+AFqIg5CgICAgICAgPi/fzcDACADQYgCaiIPQgA3AwAgA0GQAmoiEEIANwMAIANBmAJqIhFCADcDACADQgA3A4ACIANCgICAgICAgPg/NwPwASAAIAMpA0A3AwAgBiABELkGGiAHIAIQuQYaIAggBRC5BhogDSAOKQMANwMAIAAgAykD8AE3A7ABIAwgAysDgAI5AwAgCyAPKwMAOQMAIAogECsDADkDACAJIBErAwA5AwAgBRCxBhogAhCxBhogARCxBhogBBCxBhogA0GgAmokAAvCAwESfyMAQdACayICJAAgARC3BgRAQXsgAkHwAGpB2qkCEIkDQcepAkHqnQJBGBCYCgALIABCADcDACAAQQhqEKcGIQcgAEFAaxCnBiEIIABB+ABqEKcGIQkgAEHYAWoiCkIANwMAIABB0AFqIgtCADcDACAAQcgBaiIMQgA3AwAgAEHAAWoiDUIANwMAIABBuAFqIg5CADcDACAAQgA3A7ABIAIQpwYhAyACQThqEKcGIQQgAkEANgJ0IAJB6M4KNgJwIAJB+ABqIAEQrQYhASACQbABaiADEK0GIQUgAkHoAWogBBCtBiEGIAJBqAJqIg9CADcDACACQbACaiIQQgA3AwAgAkG4AmoiEUIANwMAIAJBwAJqIhJCADcDACACQcgCaiITQgA3AwAgAkKAgICAgICA+L9/NwOgAiAAIAIpA3A3AwAgByABELkGGiAIIAUQuQYaIAkgBhC5BhogDiAPKQMANwMAIAAgAikDoAI3A7ABIA0gECsDADkDACAMIBErAwA5AwAgCyASKwMAOQMAIAogEysDADkDACAGELEGGiAFELEGGiABELEGGiAEELEGGiADELEGGiACQdACaiQAC8MDAQ9/IwBBoAJrIgMkAAJAIAEQtwZFBEAgAhC3BkUNAQtBeyADQUBrQaCpAhCJA0HHqQJB6p0CQSAQmAoACyAAQgA3AwAgAEEIahCnBiEGIABBQGsQpwYhByAAQfgAahCnBiEIIABB2AFqIglCADcDACAAQdABaiIKQgA3AwAgAEHIAWoiC0IANwMAIABBwAFqIgxCADcDACAAQbgBaiINQgA3AwAgAEIANwOwASADQQhqEKcGIQQgA0EANgJEIANB8M4KNgJAIANByABqIAEQrQYhASADQYABaiACEK0GIQIgA0G4AWogBBCtBiEFIANB+AFqIg5CgICAgICAgPg/NwMAIANBiAJqIg9CADcDACADQZACaiIQQgA3AwAgA0GYAmoiEUIANwMAIANCADcDgAIgA0KAgICAgICA+D83A/ABIAAgAykDQDcDACAGIAEQuQYaIAcgAhC5BhogCCAFELkGGiANIA4pAwA3AwAgACADKQPwATcDsAEgDCADKwOAAjkDACALIA8rAwA5AwAgCiAQKwMAOQMAIAkgESsDADkDACAFELEGGiACELEGGiABELEGGiAEELEGGiADQaACaiQAC7kDARJ/IwBB0AJrIgMkACABELcGBEBBeyADQfAAakHaqQIQiQNBx6kCQeqdAkEYEJgKAAsgAEIANwMAIABBCGoQpwYhCCAAQUBrEKcGIQkgAEH4AGoQpwYhCiAAQdgBaiILQgA3AwAgAEHQAWoiDEIANwMAIABByAFqIg1CADcDACAAQcABaiIOQgA3AwAgAEG4AWoiD0IANwMAIABCADcDsAEgAxCnBiEEIANBOGoQpwYhBSADQQA2AnQgA0Hozgo2AnAgA0H4AGogARCtBiEBIANBsAFqIAQQrQYhBiADQegBaiAFEK0GIQcgA0GoAmoiEEIANwMAIANBsAJqIhFCADcDACADQbgCaiISQgA3AwAgA0HAAmoiE0IANwMAIANByAJqIhRCADcDACADIAI5A6ACIAAgAykDcDcDACAIIAEQuQYaIAkgBhC5BhogCiAHELkGGiAPIBApAwA3AwAgACADKQOgAjcDsAEgDiARKwMAOQMAIA0gEisDADkDACAMIBMrAwA5AwAgCyAUKwMAOQMAIAcQsQYaIAYQsQYaIAEQsQYaIAUQsQYaIAQQsQYaIANB0AJqJAAL/gEBBH8jAEHgAWsiAyQAIABCADcDACAAQQhqEKcGGiAAQUBrEKcGGiAAQfgAahCnBhogAEIANwPYASAAQgA3A9ABIABCADcDyAEgAEIANwPAASAAQgA3A7gBIABCADcDsAEgASgCACEEIANBADYCBCADQeTOCjYCACADQQhqIAIQrQYhAiADQUBrEKcGIQUgA0H4AGoQpwYhBiADQgA3A8ABIANCADcDyAEgA0IANwPQASADQgA3A9gBIANCADcDuAEgA0KAgICAgICA+D83A7ABIAQgASADIAAgBCgCACgCXBEGACAGELEGGiAFELEGGiACELEGGiADQeABaiQAC58CAQR/IwBB4AFrIgMkACABELcGBEBBeyADQdqpAhCJA0HHqQJB6p0CQRgQmAoACyAAQgA3AwAgAEEIahCnBhogAEFAaxCnBhogAEH4AGoQpwYaIABCADcD2AEgAEIANwPQASAAQgA3A8gBIABCADcDwAEgAEIANwO4ASAAQgA3A7ABIAIoAgAhBCADQQA2AgQgA0Hkzgo2AgAgA0EIaiABEK0GIQEgA0FAaxCnBiEFIANB+ABqEKcGIQYgA0IANwPAASADQgA3A8gBIANCADcD0AEgA0IANwPYASADQgA3A7gBIANCgICAgICAgPg/NwOwASAEIAMgAiAAIAQoAgAoAlwRBgAgBhCxBhogBRCxBhogARCxBhogA0HgAWokAAvFAgEJfyMAQdACayIDJAAgA0E4ahCnBiEEIAMQpwYhBSADQeEANgJ0IANB7M4KNgJwIANB+ABqIAEQrQYhASADQbABaiAEEK0GIQYgA0HoAWogBRCtBiEHIANBqAJqIghCADcDACADQoCAgICAgID4PzcDoAIgAyACKwMAOQOwAiADQbgCaiIJIAIrAwg5AwAgA0HAAmoiCiACKwMQOQMAIANByAJqIgsgAisDGDkDACAAIAMpA3A3AwAgAEEIaiABELkGGiAAQUBrIAYQuQYaIABB+ABqIAcQuQYaIAAgCCkDADcDuAEgACADKQOgAjcDsAEgACADKwOwAjkDwAEgACAJKwMAOQPIASAAIAorAwA5A9ABIAAgCysDADkD2AEgBxCxBhogBhCxBhogARCxBhogBRCxBhogBBCxBhogA0HQAmokAAueAQEBfyMAQRBrIgAkAAJAAkACQCADQX9HBEAgASgCCCIEQf8fcSADRw0BCyACIAFBCGoQswYMAQsgAyAEc0H4H3ENASAAIAI2AgQgAEGAgIQQNgIAIABCADcDCCABQQhqIAAgA0QAAAAAAADwP0QAAAAAAAAAABCIAwsgAEEQaiQADwtBqX4gAEHAnQIQiQNB450CQeqdAkGBChCYCgAL5hQCB38DfCMAQfABayIEJAAgBEG4AWoQpwYhCQJ/IANBf0cEQCAJIAEoAghB/x9xIANHDQEaCyACCyEAIAFBwAFqIQUCQAJAIAEoAlAEQCABQUBrIQMgASsDyAEhCwJAAkACQAJAIAErA8ABRAAAAAAAAAAAYg0AIAtEAAAAAAAAAABiDQAgASsD0AFEAAAAAAAAAABiDQAgASsD2AFEAAAAAAAAAABhDQIgC0QAAAAAAAAAAGENAQwCCyALRAAAAAAAAAAAYg0BCyABKwPQAUQAAAAAAAAAAGINACABKwPYAUQAAAAAAAAAAGENAQsgASsDuAEhCwJAIAErA7ABIgxEAAAAAAAA8D9hBEAgC0QAAAAAAADwP2EEQCAEQgA3AxAgBEGAgIQINgIIIAQgAUEIajYCDCAEQgA3A7ABIAQgAzYCrAEgBEGAgIQINgKoASAEIAA2ApwBIARBgICEEDYCmAEgBEIANwOgASAEQQhqIARBqAFqIARBmAFqQdTWChDbBQwCCyALRAAAAAAAAPC/YQRAIARCADcDECAEQYCAhAg2AgggBCABQQhqNgIMIARCADcDsAEgBCADNgKsASAEQYCAhAg2AqgBIAQgADYCnAEgBEGAgIQQNgKYASAEQgA3A6ABIARBCGogBEGoAWogBEGYAWpB1NYKEN0FDAILIARCADcDECAEIAM2AgwgBEGAgIQINgIIIARCADcDsAEgBCABQQhqNgKsASAEQYCAhAg2AqgBIAQgADYCnAEgBEGAgIQQNgKYASAEQgA3A6ABIARBCGogCyAEQagBaiAEQZgBahCDBgwBCyALRAAAAAAAAPA/YQRAIAxEAAAAAAAA8L9hBEAgBEIANwMQIAQgAzYCDCAEQYCAhAg2AgggBEIANwOwASAEIAFBCGo2AqwBIARBgICECDYCqAEgBCAANgKcASAEQYCAhBA2ApgBIARCADcDoAEgBEEIaiAEQagBaiAEQZgBakHU1goQ3QUMAgsgBEIANwMQIARBgICECDYCCCAEIAFBCGo2AgwgBEIANwOwASAEIAM2AqwBIARBgICECDYCqAEgBCAANgKcASAEQYCAhBA2ApgBIARCADcDoAEgBEEIaiAMIARBqAFqIARBmAFqEIMGDAELIARCADcDECAEQYCAhAg2AgggBCABQQhqNgIMIARCADcDsAEgBCADNgKsASAEQYCAhAg2AqgBIAQgADYCnAEgBEGAgIQQNgKYASAEQgA3A6ABIARBCGogDCAEQagBaiALRAAAAAAAAAAAIARBmAFqQX8Q4gULAkAgASsDyAFEAAAAAAAAAABiDQAgASsD0AFEAAAAAAAAAABiDQAgASsD2AFEAAAAAAAAAABhDQMLIARCADcDECAEIAA2AgwgBEGAgIQINgIIIARCgYCAgMAANwOwASAEIAU2AqwBIARBhoCI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ASADIAErA8ABOQPAASADIAErA8gBOQPIASADIAErA9ABOQPQASADIAErA9gBOQPYASADIAMrA7ABIAKiOQOwAQ8LIAMgASACIAMQ8gYL+wICCX8BfCMAQdACayIAJAACQAJAIAIoAgRBL0cNACACKAJQBEAgAisDuAFEAAAAAAAAAABiDQELIAAQpwYhBCACKwOwASENIABBOGoQpwYhBSAAQQA2AnQgAEHozgo2AnAgAEH4AGogAkEIahCtBiECIABBsAFqIAQQrQYhBiAAQegBaiAFEK0GIQcgAEGoAmoiCEIANwMAIABBsAJqIglCADcDACAAQbgCaiIKQgA3AwAgAEHAAmoiC0IANwMAIABByAJqIgxCADcDACAAIAEgDaM5A6ACIAMgACkDcDcDACADQQhqIAIQuQYaIANBQGsgBhC5BhogA0H4AGogBxC5BhogAyAIKQMANwO4ASADIAApA6ACNwOwASADIAkrAwA5A8ABIAMgCisDADkDyAEgAyALKwMAOQPQASADIAwrAwA5A9gBIAcQsQYaIAYQsQYaIAIQsQYaIAUQsQYaIAQQsQYaDAELIAAgASACIAMQ9AYLIABB0AJqJAAL2wECAn8BfCMAQeAAayIEJAAgBEEoahCnBiEFAn8gA0F/RwRAIAUgASgCCEH/H3EgA0cNARoLIAILIQAgBEIANwMgIARBgICECDYCGCAEIAFBCGo2AhwgBEGAgIQQNgIIIARCADcDECAEIAA2AgwgBEEYaiAEQQhqELQHIAAoAhAgAigCEEZBACABKwOwASIGRAAAAAAAAPA/YRtFBEAgBCACNgIcIARBgICEEDYCGCAEQgA3AyAgACAEQRhqIAMgBkQAAAAAAAAAABCIAwsgBRCxBhogBEHgAGokAAuMAQAgAyABKQMANwMAIANBCGogAUEIahCzBiADQUBrIAFBQGsQswYgA0H4AGogAUH4AGoQswYgAyABKQO4ATcDuAEgAyABKQOwATcDsAEgAyABKwPAATkDwAEgAyABKwPIATkDyAEgAyABKwPQATkD0AEgAyABKwPYATkD2AEgAyADKwOwASACojkDsAEL5AICCX8BfCMAQdACayIAJAAgAUEIaiEDAkAgASsDsAFEAAAAAAAA8D9hBEAgAiADEJIHDAELIAAQpwYhBCABKwOwASEMIABBOGoQpwYhASAAQQA2AnQgAEHozgo2AnAgAEH4AGogAxCtBiEDIABBsAFqIAQQrQYhBSAAQegBaiABEK0GIQYgAEGoAmoiB0IANwMAIABBsAJqIghCADcDACAAQbgCaiIJQgA3AwAgAEHAAmoiCkIANwMAIABByAJqIgtCADcDACAAIAw5A6ACIAIgACkDcDcDACACQQhqIAMQuQYaIAJBQGsgBRC5BhogAkH4AGogBhC5BhogAiAHKQMANwO4ASACIAApA6ACNwOwASACIAgrAwA5A8ABIAIgCSsDADkDyAEgAiAKKwMAOQPQASACIAsrAwA5A9gBIAYQsQYaIAUQsQYaIAMQsQYaIAEQsQYaIAQQsQYaCyAAQdACaiQAC7wCAQp/IwBB0AJrIgIkACACQThqEKcGIQMgAhCnBiEEIAJBADYCdCACQeTOCjYCcCACQfgAaiABEK0GIQEgAkGwAWogAxCtBiEFIAJB6AFqIAQQrQYhBiACQagCaiIHQgA3AwAgAkGwAmoiCEIANwMAIAJBuAJqIglCADcDACACQcACaiIKQgA3AwAgAkHIAmoiC0IANwMAIAJCgICAgICAgPg/NwOgAiAAIAIpA3A3AwAgAEEIaiABELkGGiAAQUBrIAUQuQYaIABB+ABqIAYQuQYaIAAgBykDADcDuAEgACACKQOgAjcDsAEgACAIKwMAOQPAASAAIAkrAwA5A8gBIAAgCisDADkD0AEgACALKwMAOQPYASAGELEGGiAFELEGGiABELEGGiAEELEGGiADELEGGiACQdACaiQAC6cCAgJ/AnwjAEGAAWsiBCQAIARByABqEKcGIQUCfyADQX9HBEAgBSABKAIIQf8fcSADRw0BGgsgAgshACAEQgA3A0AgBEGAgIQINgI4IAQgAUEIajYCPCAEQgA3AzAgBCABQUBrNgIsIARBgICECDYCKCABKwOwASEGIARCADcDICAEIAFB+ABqNgIcIARBgICECDYCGCABKwO4ASEHIARBgICEEDYCCCAEQgA3AxAgBCAANgIMIARBOGogBEEoaiAGIARBGGogByAEQQhqIAEoAgQQggYgACgCECACKAIQRwRAIAQgAjYCPCAEQYCAhBA2AjggBEIANwNAIAAgBEE4aiADRAAAAAAAAPA/RAAAAAAAAAAAEIgDCyAFELEGGiAEQYABaiQAC4kIAgV/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BEH4AGogAUEIahCtBiEBIARBuAFqIgYgCjkDACAEQcgBaiIAQgA3AwAgBEHQAWoiB0IANwMAIARB2AFqIghCADcDACAEQgA3A8ABIAQgCZo5A7ABIAMgBCkDADcDACADQQhqIAUQuQYaIANBQGsgAhC5BhogA0H4AGogARC5BhogAyAGKQMANwO4ASADIAQpA7ABNwOwASADIAQrA8ABOQPAASADIAArAwA5A8gBIAMgBysDADkD0AEgAyAIKwMAOQPYASABELEGGiACELEGGiAFELEGGgwBCyAAIAVGBEAgBSABIAIgAxDvBgwBCyAFIAEgAiADIAUoAgAoAjwRBgALIARB4AFqJAALngEAIAMgASkDADcDACADQQhqIAFBCGoQswYgA0FAayABQUBrELMGIANB+ABqIAFB+ABqELMGIANBuAFqIgAgASkDuAE3AwAgAyABKQOwATcDsAEgAyABKwPAATkDwAEgAyABKwPIATkDyAEgAyABKwPQATkD0AEgAyABKwPYATkD2AEgAyADKwOwASACojkDsAEgACAAKwMAIAKiOQMAC64BAQF/IAIgASkDADcDACACQQhqIgAgAUEIahCzBiACQUBrIgMgAUFAaxCzBiACQfgAaiABQfgAahCzBiACIAEpA7gBNwO4ASACIAEpA7ABNwOwASACIAErA8ABOQPAASACIAErA8gBOQPIASACIAErA9ABOQPQASACIAErA9gBOQPYASACIAEoAgQiAUEBdEECcSABQQRxciABQQF2QQFxckEHczYCBCAAIAMQrgcLzwEBAn8jAEHgAGsiBCQAIARBKGoQpwYhBQJ/IANBf0cEQCAFIAEoAghB/x9xIANHDQEaCyACCyEAIARCADcDICAEQYCAhAg2AhggBCABQQhqNgIcIARBgICEEDYCCCAEQgA3AxAgBCAANgIMIARBGGogBEEIaiABKAIEEKsEIAAoAhAgAigCEEcEQCAEIAI2AhwgBEGAgIQQNgIYIARCADcDICAAIARBGGogA0QAAAAAAADwP0QAAAAAAAAAABCIAwsgBRCxBhogBEHgAGokAAuMAwEGfyMAQaACayIEJAAgAigCACEFAkACQCABKAIAQfTOCkcNACAFQeTOCkcNACABKAIEIQAgBEEIahCnBiEFIAQgADYCRCAEQfzOCjYCQCAEQcgAaiAB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QdDWChCBGwtBzNYKKAIAIQYgBCACKQIAIg03AwggBCANNwOAASAEQYgBaiAEQQhqIANB7t27935BABCwBiECIARByABqEKcGIQMgBEEQahCnBiEFIAQgATYCxAEgBCAGNgLAASAEQcgBaiACEK0GIQEgBEGAAmogAxCtBiEGIARBuAJqIAUQrQYhByAEQfgCaiIIQgA3AwAgBEGAA2oiCUIANwMAIARBiANqIgpCADcDACAEQZADaiILQgA3AwAgBEGYA2oiDEIANwMAIAREAAAAAAAA8D85A/ACIAAgBCkDwAE3AwAgAEEIaiABELkGGiAAQUBrIAYQuQYaIABB+ABqIAcQuQYaIAAgCCkDADcDuAEgACAEKQPwAjcDsAEgACAJKwMAOQPAASAAIAorAwA5A8gBIAAgCysDADkD0AEgACAMKwMAOQPYASAHELEGGiAGELEGGiABELEGGiAFELEGGiADELEGGiACELEGGiAEQaADaiQAC4cBAgF/AX4jAEEQayIDJAAgAEIANwMAIABBCGoQpwYaIABBQGsQpwYaIABB+ABqEKcGGiAAQgA3A9gBIABCADcD0AEgAEIANwPIASAAQgA3A8ABIABCADcDuAEgAEIANwOwASADIAEpAgAiBDcDACADIAQ3AwggAEEwIAMgAhCgByADQRBqJAALigEBAX8jAEEQayIEJAAgAEIANwMAIABBCGoQpwYaIABBQGsQpwYaIABB+ABqEKcGGiAAQgA3A9gBIABCADcD0AEgAEIANwPIASAAQgA3A8ABIABCADcDuAEgAEIANwOwASAEIAE2AgwgBCACNgIIIAQgBCkDCDcDACAAQTEgBCADEKAHIARBEGokAAuHAQIBfwF+IwBBEGsiAyQAIABCADcDACAAQQhqEKcGGiAAQUBrEKcGGiAAQfgAahCnBhogAEIANwPYASAAQgA3A9ABIABCADcDyAEgAEIANwPAASAAQgA3A7gBIABCADcDsAEgAyABKQIAIgQ3AwAgAyAENwMIIABBMSADIAIQoAcgA0EQaiQAC4sBAQF/IwBBEGsiBCQAIABCADcDACAAQQhqEKcGGiAAQUBrEKcGGiAAQfgAahCnBhogAEIANwPYASAAQgA3A9ABIABCADcDyAEgAEIANwPAASAAQgA3A7gBIABCADcDsAEgBCABNgIMIAQgAjYC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AAAAXhu7IRQMCAsgAygCqCEhAgJAAkAgB0EGaw4CAAECCyACIAQQhQq3IRQMCAtBACEBQQAgBEEESA0GGiAEQQRrIQVBACEAA0AgAiAAQQNyai0AAEHg0QJqLQAAIAIgAEECcmotAABB4NECai0AACACIABBAXJqLQAAQeDRAmotAAAgASAAIAJqLQAAQeDRAmotAABqampqIQEgAEEEaiIAIAVMDQALDAULIANB4CBqELcGRQRAIAMvAeAgQf8fcQ0CCyAFQQZGBEAgA0HgIGoQtwZFBEAgA0EIahCnBiEAIANCADcDoCAgA0GAgIQINgKYICADIANBmCFqNgKcICADQgA3A9ggIANBgICECDYC0CAgAyADQeAgajYC1CAgAyAANgLEICADQYCAhBA2AsAgIANCADcDyCAgA0GYIGogA0HQIGogA0HAIGpB1NYKENQFIANCADcDoCAgAyAANgKcICADQYCAhAg2ApggIANBmCBqIAdB1NYKEIcIIRQgABCxBhoMCAtBACEAIANBADYCnCAgAyADQZghajYCmCAgA0EANgLQICADQQhqIANBmCBqIANB0CBqQX8QrAciAigCEEUNB0EBQQIgB0EGRhshBCACKAIUIQVBACEBA0AgAygC0CAgBSAEEIUIIABqIQAgAhCtByABQQFqIgEgAigCEEkNAAsgALchFAwHCyAHQQR0QeAAcUEFIAogCkEHRhtBAnRyQdDbAmooAgAiDUUNAiADQQA2AtggIAMgA0HgIGo2AtQgIAMgA0GYIWo2AtAgIANCADcDwCAgA0IANwO4ICADQZggaiADQdAgaiADQcAgakF/EKwHIggoAhQiAUH/////B08NAwJAAkAgB0ECRiAKQQRJcUUEQCAFQQRGIApBAklxRQ0BCyADKAKcISIAQQFOBEAgAygCxCEgAEECdGpBBGsoAgAhDgsgA0EANgIIQYCAgARBgIACIApBAkkbQYCAAiAHQQJGGyAJbiELIAgoAhBFDQEgCyABIAEgC0obIQJBACEFA0AgDEEBaiEMIAFBAU4EQEEAIQQgAygCxCAhBiADKALAICEPA0AgDyAGIANBCGogAiABIARrIgAgACACShsiACAJIA0RCQAaAkAgCyAAIAVqIgUgAmpKBEAgACAEaiABSA0BIAwgCCgCEEkNAQsgAygCCCEGQQAhBSAD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DAELIAAoAgQhByAAKAIAIQggBSAAKAALNgALIAUgACgCCDYCCCAAQgA3AgQgAC0ADyEJIABBADYCDCAAKAIUIQogACgCECELIABCADcCECAAQQRqIQQgBgRAIAAgAigCADYCACAEIAIoAgw2AgggBCACKQIENwIAIAJBADoADyACQQA6AAQgAigCFCEDIAIoAhAhASACQgA3AhAgACABNgIQIAAoAhQhASAAIAM2AhQCQCABRQ0AIAEgASgCBCIAQQFrNgIEIAANACABIAEoAgAoAggRAQAgARDQGgsgAiAINgIAIAIsAA9Bf0wEQCACKAIEEKIbCyACIAc2AgQgAiAFKAIINgIIIAIgBSgACzYACyACIAs2AhAgAiAJOgAPIAIoAhQhASACIAo2AhQCQCABRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgtBAQwCCyAAIAEoAgA2AgAgBCABKAIMNgIIIAQgASkCBDcCACABQQA6AA8gAUEAOgAEIAEoAhQhBiABKAIQIQQgAUIANwIQIAAgBDYCECAAKAIUIQQgACAGNgIUAkAgBEUNACAEIAQoAgQiAEEBazYCBCAADQAgBCAEKAIAKAIIEQEAIAQQ0BoLIAFBBGohBiABIAg2AgAgASwAD0F/TARAIAYoAgAQohsLIAEgBzYCBCABQQhqIgcgBSgCCDYCACABIAUoAAs2AAsgASALNgIQIAEgCToADyABKAIUIQAgASAKNgIUAkAgAEUNACAAIAAoAgQiBEEBazYCBCAEDQAgACAAKAIAKAIIEQEAIAAQ0BoLQQEgAiABIAMoAgARAwBFDQEaIAEoAgQhAyABKAIAIQQgBSAHKAIANgIIIAUgBygAAzYACyABLQAPIQcgBkIANwIAIAZBCGoiAEEANgIAIAEoAhQhCCABKAIQIQkgAUIANwIQIAEgAigCADYCACAAIAIoAgw2AgAgBiACKQIENwIAIAJBADoADyACQQA6AAQgAigCFCEGIAIoAhAhACACQgA3AhAgASAANgIQIAEoAhQhACABIAY2AhQCQCAARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAQAgABDQGgsgAiAENgIAIAIsAA9Bf0wEQCACKAIEEKIbCyACIAM2AgQgAiAFKAIINgIIIAIgBSgA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QCABKAIIEKIbCyABEKIbIAIiAQ0ACwsgACgCiAIhASAAQQA2AogCIAEEQCABEKIbCyAAKAL4ASIBBEAgACABNgL8ASABEKIbCyAAKALsASIBBEAgACABNgLwASABEKIbCyAAKALgASIEBEACfyAEIAQgACgC5AEiAUYNABoDQCABIgJBCGshAQJAIAJBBGsoAgAiAkUNACACIAIoAgQiA0EBazYCBCADDQAgAiACKAIAKAIIEQEAIAIQ0BoLIAEgBEcNAAsgACgC4AELIQEgACAENgLkASABEKIbCyAAKALUASIBBEAgACABNgLYASABEKIbCyAAKAK4ASIBBEAgACABNgK8ASABEKIbCyAAKAKsASIBBEAgACABNgKwASABEKIbCwJAIAAoAqABIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCwJAIAAoApgBIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCwJAIAAoApABIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAQfQAaiIDEO0IAkAgACgCeCIBIAAoAnwiAkYNAANAIAEoAgAQohsgAUEEaiIBIAJHDQALIAAoAnwiASAAKAJ4IgJGDQAgACABIAEgAmtBBGtBAnZBf3NBAnRqNgJ8CyADKAIAIgEEQCABEKIbCyAAKAJkIgEEQCAAIAE2AmggARCiGwsgAEHMAGoiAxDuCAJAIAAoAlAiASAAKAJUIgJGDQADQCABKAIAEKIbIAFBBGoiASACRw0ACyAAKAJUIgEgACgCUCICRg0AIAAgASABIAJrQQRrQQJ2QX9zQQJ0ajYCVAsgAygCACIBBEAgARCiGwsgACwAE0F/TARAIAAoAggQohsLIAAL0gQBB38jAEEQayIDJAACQAJAIAAtACRFDQACQCABRQ0AIAEsAAtBf0wEQCABKAIAQQA6AAAgAUEANgIEDAELIAFBADoACyABQQA6AAALAkAgAC0AJkUNACAAKAJgQQJPBEADQCAAEO8IIAAoAmBBAUsNAAsLIAAgACgCACgCOBEAABoCQAJAIAAoAihBCGsOEQACAgICAgICAgICAgICAgIBAgsgAEHU6AIgACgCACgCDBECAAwBCyAAQefo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ICADQgA3ABggA0IANwAQIANCADcACCADQgA3AAAgAEEcaiIFQQA2AgAgAEIANwIUIAAgBzYCDCAAQcEAENUaIgQ2AhQgBSAEQcEAaiIFNgIAIARBAEHBABCvGxogACAHNgIoIAAgAzYCICAAIAU2AhggACADNgIkIAEtACYEQCACBEAgASABKAIAKAI4EQAAGgsgBkEQaiQADwtBqX4gBkHBgwMQiQNB3IMDQbyCA0EcEJgKAAuBAgEEfyMAQeAAayIDJAACQCAAKAIgIgEgACgCFCAAKAIkIAFrEMUJRQ0AIAAgACgCIDYCJCAALQAERQRAIAAoAgAiASAAKAIUIAEoAgAoAgwRAgAMAQsgA0EKOwFeIANBICAAKAIAIgEoAlAgASgCYCABKAJcakEBayIEQcwBbiICQQJ0aigCACAEIAJBzAFsa0EUbGooAhAiBBCvGyICIARqQQA6AAAgASACIAEoAgAoAgwRAgAgACgCACIBIAAoAhQgASgCACgCDBECACAAKAIAIgEgAkHeAGogASgCACgCDBECACAAKAIAIgAgACgCACgCOBEAABoLIANB4ABqJAALZwECfyAAKAIAIgEEQCABKAIkIAEoAiBHBEAgARDICQsgASgCFCICBEAgASACNgIYIAIQohsLIAEoAggiAgRAIAEgAjYCDCACEKIbCyABEKIbCyAALAAPQX9MBEAgACgCBBCiGwsgAAvUAgEDfyAAQSBqIgIgARDfGiAAQQA2AiwgACgCMCIBQQhxBEACQCACLAALIgNBf0wEQCAAKAIgIgMgACgCJGohBAwBCyACIANB/wFxaiEEIAIhAwsgACAENgIQIAAgAzYCDCAAIAM2AgggACAENgIsCwJAIAFBEHFFDQAgAgJ/IAIsAAsiAUEATgRAIAAgAiABQf8BcSIBajYCLEEKDAELIAAgACgCJCIBIAAoAiBqNgIsIAAoAihB/////wdxQQFrCxDiGgJ/IAIsAAsiA0F/TARAIAAoAiAhAiAAKAIkDAELIANB/wFxCyEDIAAgAjYCFCAAIAI2AhggACACIANqNgIcIAAtADBBA3FFDQACQCABQX9MBEAgAkECayACQf////8HaiABQf////8HayIBQQBIIgMbIQJBASABIAMbIQEMAQsgAUUNAQsgACABIAJqNgIYCws6AQF/QRQQ1RoiAkIA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EIkDQdSzA0HusQNBuQUQmAoACyAMQRBqJAAL3AEBA38gAkEESAR/QQAFIAJBBGshBQNAIAQgASADai0AACAAIANqLQAAc0HgzwJqLQAAaiABIANBAXIiBGotAAAgACAEai0AAHNB4M8Cai0AAGogASADQQJyIgRqLQAAIAAgBGotAABzQeDPAmotAABqIAEgA0EDciIEai0AACAAIARqLQAAc0HgzwJqLQAAaiEEIANBBGoiAyAFTA0ACyACQXxxCyIDIAJIBEADQCAEIAEgA2otAAAgACADai0AAHNB4M8Cai0AAGohBCADQQFqIgMgAkcNAAsLIAQLqQEBA38gAUEESAR/QQAFIAFBBGshBANAIAAgAkEDcmotAABB4M8Cai0AACAAIAJBAnJqLQAAQeDPAmotAAAgACACQQFyai0AAEHgzwJqLQAAIAMgACACai0AAEHgzwJqLQAAampqaiEDIAJBBGoiAiAETA0ACyABQXxxCyICIAFIBEADQCADIAAgAmotAABB4M8Cai0AAGohAyACQQFqIgIgAUcNAAsLIAML0wgBCn8CQAJAAkAgAUUEQAJAAkACQCAEQQRvIgFBAWsOAwABAgYLIAIoAgAhByADQQRIBEAgACEFDAULIANBBGshCCAEQQJ0IQkgBEEDbCELIARBAXQhCiAAIQUDQCAFIAtqLQAAIAUgCmotAAAgBCAFai0AACAHIAUtAABqampqIQcgBSAJaiEFIAZBBGoiBiAITA0ACwwDCyACKAIEIQcgAigCACEIIANBAU4EQCAAIQUDQCAHIAUtAAFqIQcgCCAFLQAAaiEIIAQgBWohBSAGQQFqIgYgA0cNAAsgAyEGCyACIAc2AgQgAiAINgIADAQLIAIoAgghByACKAIEIQggAigCACEJIANBAU4EQCAAIQUDQCAHIAUtAAJqIQcgCCAFLQABaiEIIAkgBS0AAGohCSAEIAVqIQUgBkEBaiIGIANHDQALIAMhBgsgAiAHNgIIIAIgCDYCBCACIAk2AgAMAwsCQAJAAkACQCAEQQFrDgMBAAIACyADQQFODQJBAA8LIAIoAgAhBiADQQFOBEADQCABIAVqLQAABEAgB0EBaiEHIAYgACAFai0AAGohBgsgBUEBaiIFIANHDQALCyACIAY2AgAgBw8LIAIoAgghBiACKAIEIQcgAigCACEI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KAIAIAFB6ABqIAItAAsiBEEYdEEYdUEASCIFGyACKAIEIAQgBRsQzAMaIAIsAAtBf0wEQCACKAIAEKIbCwJ/IAMsAAsiAkF/TARAIAAoAhghAiAAKAIUDAELIAJB/wFxIQIgAwshBCACIARqQQFrLQAAQQpHBEAgAUHoAGogBiABKAKAAUEMaygCAGoQphYgAUHoAGpBvJgLELkXIgJBCiACKAIAKAIcEQMAIQIgAUHoAGoQtBcgBiACENQWIAYQpRYLIAFB6ABqIAkQ0QMgAywAC0F/TARAIAMoAgAQohsLIAMgASkDaDcCACADIAEoAnA2AgggAUH8yAE2ArgBIAFB1MgBNgJ4IAFBlMsBNgKEASABQejIATYCgAEgASwArwFBf0wEQCABKAKkARCiGwsgChCIFhogAUG4AWoQhBYaCwJAAn8gACwAKyICQX9MBEAgACgCJAwBCyACQf8BcQsEQCAAQSBqIQIgCEF/RwRAIABBLGohBCAALAA3QX9MBEAgBCgCACEECyAAKAI4IQUgACgCECIHEJMKIQYgACwAK0F/TARAIAIoAgAhAgsgASADLAALQX9MBH8gAygCAAUgAws2AlggASACNgJUIAEgBjYCUCABIAc2AkwgASAFNgJIIAEgBDYCRCABQfC0AzYCQCABQfgAakG7tAMgAUFAaxCUCiAAQQRqIQIgACwAD0F/TARAIAIoAgAQohsLIAIgASkDeDcCACACIAEoAoABNgIIDAILIABBLGohBCAALAA3QX9MBEAgBCgCACEECyAAKAI4IQUgACgCECIHEJMKIQYgACwAH0F/TARAIAMoAgAhAwsgASACLAALQX9MBH8gAigCAAUgAgs2AjggASADNgI0IAEgBjYCMCABIAc2AiwgASAFNgIoIAEgBDYCJCABQfC0AzYCICABQfgAakH6tAMgAUEgahCUCiAAQQRqIQIgACwAD0F/TARAIAIoAgAQohsLIAIgASkDeDcCACACIAEoAoABNgIIDAELIABBLGohAiAALAA3QX9MBEAgAigCACECCyAAKAI4IQQgACgCECIFEJMKIQcgASAALAAfQX9MBH8gAygCAAUgAws2AhQgASAHNgIQIAFB17UDQda1AyAIQX9GGzYCGCABIAU2AgwgASAENgIIIAEgAjYCBCABQfC0AzYCACABQfgAakGwtQMg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IAdB24IEEIkDQf2CBEG5ggRB+QMQmAoAC0GpfiAHQYWDBBCJA0H9ggRBuYIEQZQEEJgKAAtBrX4gB0GMgwQQiQNB/YIEQbmCBEGeBBCYCgALsAIBBX8gACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggACABKAIMNgIMIAAgASgCEDYCECAAIAEoAhQ2AhQgACABKAIYIgI2AhggASgCHCEDIAAgAEEoaiIENgIkIAAgAEEIajYCICAAIAM2AhwgBEIANwIAIAIEQCACIAIoAghBAWo2AggLIAEoAgRBAkwEQCAAKAIkIgIgASgCJCIBKAIANgIAIAIgASgCBDYCBCAADwtBACECIABBADYCBCAAIAEoAgRBAEEAQQAQzAogACgCBEEBTgRAIAAoAiQhAyABKAIkIQQgACgCICEFIAEoAiAhBgNAIAUgAkECdCIBaiABIAZqKAIANgIAIAEgA2ogASAEaigCADYCACACQQFqIgIgACgCBEgNAAsLIAALuQMBBn8gACABRwRAIAEoAhgiAgRAIAIgAigCCEEBajYCCAsCQCAAKAIYIgJFDQAgAiACKAIIIgNBAWs2AgggA0EBRw0AIAAoAhghAiAAQQA2AhggAigCBCIDIAIgAygCACgCEBECAAsCQAJAAkAgACgCBEEATARAIABBADYCGCAAIAEoAgA2AgAMAQsgACgCICEDQQAhAgNAIAMgAkECdGpBADYCACACQQFqIgIgACgCBCIESA0ACyAAQQA2AhggACABKAIANgIAIARBA0gNACABKAIEIQIMAQsgASgCBCICQQJKDQAgACACNgIEIAAgASgCCDYCCCAAIAEoAgw2AgwgACgCJCICIAEoAiQiAygCADYCACACIAMoAgQ2AgQMAQtBACEDIAAgAkEAQQBBABDMCiAAKAIEQQFIDQAgACgCJCEEIAEoAiQhBSAAKAIgIQYgASgCICEHA0AgBiADQQJ0IgJqIAIgB2ooAgA2AgAgAiAEaiACIAVqKAIANgIAIANBAWoiAyAAKAIESA0ACwsgACABKAIQNgIQIAAgASgCFDYCFCAAIAEoAhg2AhggACABKAIcNgIcCwuFAQECfwJAIAAoAhgiAUUNACABIAEoAggiAkEBazYCCCACQQFHDQAgACgCGCEBIABBADYCGCABKAIEIgIgASACKAIAKAIQ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ASADKAIYNgIYIANBCGogARDwCiABQQxqIQYgASgCDCIFBEACfyAFIAUgASgCECIERg0AGgNAIARBDGshAiAEQQFrLAAAQX9MBEAgAigCABCiGwsgAiEEIAIgBUcNAAsgBigCAAshAiABIAU2AhAgAhCiGwsgASADKAIINgIMIAEgAygCDDYCECABIAMoAhA2AhQgACAGIAFBHGoiAhDxCiADLQAcBEAgACABKAIYIAIQ8goLIAEoAhgiBCAAKAIEIAAoAgAiAmtBDG1JBEAgASACIARBDGxqNgIoIAEtACwEQCAAIAEQ8woLIANBIGokAA8LENoaAAv1AQEBfyAAKAKIASICIAEQ3xogAhDgCiACKAJEIAIoAkhGGgJAIAAoAogBIgEoAkQgASgCSEcNACAAKAKIARDjCiEBIAAoAhwgASgCDDYCBCAAKAKIARDlCiICKAIAIgEgAigCBCICRwRAA0AgACABIAEoAgxBAhDtCiABQRRqIgEgAkcNAAsLIAAoAogBQThqIgIoAgAiASACKAIEIgJHBEADQCAAIAEgASgCDEEDEO0KIAFBFGoiASACRw0ACwsgACgCiAEQ5AoiAigCACIBIAIoAgQiAkYNAANAIAAgASABKAIMEO4KIAFBFGoiASACRw0ACwsL8QEBAn8jAEEwayIEJAAgABDTGiAEQQhqIAEQ2xohASAEQQA2AiggBEIANwMgIARBAToAHCAEQgA3AhQgBCAAQSBqIgUgARD2CiIBNgIUIAEgACgCMCAAKAIsIgBrQQN1SQRAIAQgACABQQN0aiIBNgIYAkACfyAELQAcBEAgBSAEQQhqEPcKIAQoAhghAQsgAyABKAIERgsEQCABKAIAIAJGDQELIAEgAjYCACABIAM2AgQgBEEIahD4CgsgBCgCICIBBEAgBCABNgIkIAEQohsLIAQsABNBf0wEQCAEKAIIEKIbCyAEQTBqJAAPCxDaGgALsQIBAX8jAEFAaiIDJAAgABDTGiADIAEQ2xoaIANBADYCOCADQgA3AhQgA0IANwIcIANCADcCJCADQQA6ACwgA0IANwMwIANCADcCDCAAQSBqIAMQ6woCQCADKAIoIgEoAghBAUYEQCABKAIEIAJGDQELIAEgAjYCBCABQQE2AgggASgCACIBRQ0AIAEgAjYCBAsgAygCMCIBBEAgAyABNgI0IAEQohsLIAMoAhwiAQRAIAMgATYCICABEKIbCyADKAIMIgAEQAJ/IAAgACADKAIQIgJGDQAaA0AgAkEMayEBIAJBAWssAABBf0wEQCABKAIAEKIbCyABIQIgACABRw0ACyADKAIMCyEBIAMgADYCECABEKIbCyADLAALQX9MBEAgAygCABCiGwsgA0FAayQAC/gCAQh/IwBBEGsiBiQAAkACQAJAIAFBGGoiCiACEPUKIgMEQCADKAIUIQEgAEEAOgAEIAAgATYCAAwBCyAGIAEoAgQiAyABKAIAIgdrIglBDG0iBDYCBAJAIAEoAggiBSADSwRAIANCADcCACADQQA2AgggASADQQxqNgIEDAELIARBAWoiA0HWqtWqAU8NAiAEQQxsAn8gAyAFIAdrQQxtIgVBAXQiBCADIARLG0HVqtWqASAFQarVqtUASRsiBQRAIAVB1qrVqgFPDQUgBUEMbBDVGiEICyAIC2oiA0IANwIAIANBADYCCCADIAlBdG1BDGxqIQQgCCAFQQxsaiEIIANBDGohAyAJQQFOBEAgBCAHIAkQrhsaCyABIAg2AgggASADNgIEIAEgBDYCACAHRQ0AIAcQohsLIAZBCGogCiACIAIgBkEEahD6CiAGKAIEIQEgAEEBOgAEIAAgATYCAAsgBkEQaiQADwsQ/BoAC0HYjAQQvgIAC8wBAQV/IwBBEGsiBCQAIAEoAgQhBSABLQALIQMgAEEANgIIIABCADcCACAFIAMgA0EYdEEYdUEASBsiBQRAA0ACQCAFIAFBLiACEOoaIgMgA0F/RhsiAyACTQ0AIAQgASACIAMgAmsgARDdGiEGIAAoAgQiAiAAKAIISQRAIAIgBCkDADcCACACIAQoAgg2AgggACACQQxqNgIEDAELIAAgBhD5CiAELAALQX9KDQAgBCgCABCiGwsgA0EBaiICIAVJDQALCyAEQRBqJAAL7AEBBX8jAEEQayIGJAAgASgCACEDIAEoAgQhBCAGQX82AgwCQCAEIANrIgRBDG0iAyACKAIEIAIoAgAiB2tBAnUiBUsEQCACIAMgBWsgBkEMahD7CgwBCyADIAVPDQAgAiAHIANBAnRqNgIECwJAAkAgBARAIANBASADQQFLGyEHQQAhAwNAIAEoAgQgASgCACIEa0EMbSADTQ0CIAAgBCADQQxsahD2CiEEIAIoAgQgAigCACIFa0ECdSADTQ0DIAUgA0ECdGogBDYCACADQQFqIgMgB0cNAAsLIAZBEGokAA8LENoaAAsQ2hoAC9QBAgR/BH4CQCACKAIEIgQgAigCACIDayIFRQ0AIAMgBEcEQCAAQdQAaiEEIABBQGshBiAFQQJ1rSEIIAGtIQkDQCADIAenQQJ0aigCACEAQRQQ1RoiAyABNgIIIAMgATYCBCADQQA2AgAgAyAHQiCGIgogAK2ENwIMIAYgAxD8CkEUENUaIgMgCSAKhDcCDCADIAA2AgggAyAANgIEIANBADYCACAEIAMQ/AogB0IBfCIHIAhaDQIgByACKAIEIAIoAgAiA2tBAnWtVA0ACwsQ2hoACwvaBAEMfyABIAEoAjAiAjYCNCABKAIoIQogASgCGCELAkACQAJAAkACQAJAIAEoAiAiBSABKAIcIgdrIgNBAnUiBCABKAI4IAJrQRRtTQ0AIARBzZmz5gBPDQEgASAEQRRsIggQ1RoiBDYCNCABIAQ2AjAgASAEIAhqNgI4IAJFDQAgAhCiGwsgAwRAIAFBMGohDCADQX8gA0F/ShsiAkEBIAJBAUgbIAcgBWsiAiADIAIgA0obQQJ2bCIDQQEgA0EBSxshDUEAIQMDQCABKAIgIAEoAhwiAmtBAnUgA00NAyACIANBAnRqKAIAIgQgACgCECAAKAIMIgVrQQN1Tw0EIAUgBEEDdGohBwJAIAEoAjQiAiABKAI4IgZJBEAgAiAHNgIQIAIgCjYCDCACIAM2AgggAiAENgIEIAIgCzYCACABIAJBFGo2AjQMAQsgAiAMKAIAIgVrIghBFG0iCUEBaiICQc2Zs+YATw0GIAlBFGwCf0EAIAIgBiAFa0EUbSIGQQF0IgkgAiAJSxtBzJmz5gAgBkHmzJkzSRsiBkUNABogBkHNmbPmAE8NCCAGQRRsENUaCyIJaiICIAc2AhAgAiAKNgIMIAIgAzYCCCACIAQ2AgQgAiALNgIAIAIgCEFsbUEUbGohBCAJIAZBFGxqIQcgAkEUaiECIAhBAU4EQCAEIAUgCBCuGxoLIAEgBzYCOCABIAI2AjQgASAENgIwIAVFDQAgBRCiGwsgA0EBaiIDIA1HDQALCw8LQdiMBBC+AgALENoaAAsQ2hoACxD8GgALQdiMBBC+AgALWgEBfyAAENMaAkACQAJAIABBOGogARD1CiICRQ0AIAIoAhQiAiAAKAIkIAAoAiAiAWtBDG1PDQIgAUUNACABIAJBDGxqKAIAIgENAQtBACEBCyABDwsQ2hoAC5wEAQp/IAEoAgQgAS0ACyICIAJBGHRBGHVBAEgiAxsiBCECIAEoAgAgASADGyIIIQEgBCEDIARBBE8EQCAIIQEgBCECA0AgASgAAEGV08feBWwiBkEYdiAGc0GV08feBWwgAkGV08feBWxzIQIgAUEEaiEBIANBBGsiA0EDSw0ACwsCQAJAAkACQCADQQFrDgMCAQADCyABLQACQRB0IAJzIQILIAEtAAFBCHQgAnMhAgsgAiABLQAAc0GV08feBWwhAgtBACEDAkAgACgCBCIFRQ0AIAJBDXYgAnNBldPH3gVsIgFBD3YgAXMhByAAKAIAAn8gByAFQQFrcSAFaSIJQQFNDQAaIAcgBSAHSw0AGiAHIAVwCyIKQQJ0aigCACIBRQ0AIAEoAgAiAUUNACAFQQFrIQsDQAJAAkAgByABKAIEIgJHBEACQCAJQQFNBEAgAiALcSECDAELIAIgBUkNACACIAVwIQILIAIgCkYNAQwCCyABKAIMIAEtABMiAyADQRh0QRh1QQBIIgIbIARHDQAgAUEIaiIGKAIAIQACQCACRQRAIAQNASABDwsgBEUEQCABDwsgACAGIAIbIAggBBD4FA0BIAEPCyAIIgItAAAgAEH/AXFHDQADQCADQQFrIgMEQCACLQABIQAgAkEBaiECIAZBAWoiBi0AACAARg0BDAILCyABDwsgASgCACIBDQELC0EAIQMLIAMLwgIBB38jAEEQayIFJAACQAJAAn8gAEEsaiIIIAEQ9QoiAgRAIAIoAhQMAQsgBSAAKAIQIgIgACgCDCIGayIHQQN1IgQ2AgQCQCAAKAIUIgMgAksEQCACQgA3AgAgACACQQhqNgIQDAELIARBAWoiAkGAgICAAk8NAiAEQQN0An9BACACIAMgBmsiA0ECdSIEIAIgBEsbQf////8BIANBA3VB/////wBJGyIDRQ0AGiADQYCAgIACTw0EIANBA3QQ1RoLIgJqIgRCADcCACACIANBA3RqIQMgBEEIaiEEIAdBAU4EQCACIAYgBxCuGxoLIAAgAzYCFCAAIAQ2AhAgACACNgIMIAZFDQAgBhCiGwsgBUEIaiAIIAEgASAFQQRqEPoKIAUoAgQLIQAgBUEQaiQAIAAPCxD8GgALQdiMBBC+AgALmAcBDX8gASgCECENIAEoAgwhBgJAIAAoAlgiBEUNACAAKAJUAn8gBEEBayAGcSAEaSICQQFNDQAaIAYgBCAGSw0AGiAGIARwCyIHQQJ0aigCACIDRQ0AIAMoAgAiA0UNACAEQQFrIQogAkEBSyEIA0ACQCADKAIEIgIgBkcEQAJAIAhFBEAgAiAKcSECDAELIAIgBEkNACACIARwIQILIAIgB0cNAwwBCyADKAIIIAZHDQADQCAFQQFqIQUgAygCACIDRQ0DIAMoAgggBkYNAAsMAgsgAygCACIDDQALCyABIAEoAhgiAzYCHAJAAn8gBiAFIAEoAiAgA2tBFG1NDQAaIAVBzZmz5gBPDQEgASAFQRRsIgUQ1RoiAjYCHCABIAI2AhggASACIAVqNgIgIAYgA0UNABogAxCiGyAAKAJYIQQgASgCDAshBQJAIARFDQAgACgCVAJ/IARBAWsgBXEgBGkiAkEBTQ0AGiAFIAQgBUsNABogBSAEcAsiB0ECdGooAgAiA0UNACADKAIAIgNFDQAgAUEYaiEOIARBAWshCiACQQFLIQgDQAJAIAUgAygCBCICRwRAAkAgCEUEQCACIApxIQIMAQsgAiAESQ0AIAIgBHAhAgsgAiAHRw0DDAELIAMoAgggBUcNACADIQQDQCAEKAIAIgQEQCAEKAIIIAVGDQELCyADIARGDQICQAJAA0AgAygCDCIFIAAoAgQgACgCACICa0EMbUkEQCADKAIQIQggAiAFQQxsaiEKAkAgASgCHCICIAEoAiAiCUkEQCACIA02AhAgAiAKNgIMIAIgCDYCCCACIAY2AgQgAiAFNgIAIAEgAkEUajYCHAwBCyACIA4oAgAiB2siDEEUbSILQQFqIgJBzZmz5gBPDQMgC0EUbAJ/QQAgAiAJIAdrQRRtIglBAXQiCyACIAtLG0HMmbPmACAJQebMmTNJGyIJRQ0AGiAJQc2Zs+YATw0FIAlBFGwQ1RoLIgtqIgIgDTYCECACIAo2AgwgAiAINgIIIAIgBjYCBCACIAU2AgAgAiAMQWxtQRRsaiEFIAsgCUEUbGohCCACQRRqIQIgDEEBTgRAIAUgByAMEK4bGgsgASAINgIgIAEgAjYCHCABIAU2AhggB0UNACAHEKIbCyAEIAMoAgAiA0cNAQwGCwsQ2hoACxD8GgALQdiMBBC+AgALIAMoAgAiAw0ACwsPC0HYjAQQvgIAC/IBAQh/IwBBEGsiAiQAIAAtABQEQCAAKAIcIAAoAhgiBWsiA0EUbSEBAkACQAJAIAAoAhAiACgCBCIEDgICAAELQal+IAJBu4wEEIkDQZCMBEG9iwRBgQIQmAoACyADRQ0AIAAoAgAhBiABQQEgAUEBSxshB0EAIQAgBEECayEIA0ACQCAFIABBFGxqIgQoAgwiASgCACIDRQ0AIAEoAghBAUYNAAJAAkAgCA4CAAECCyAEKAIIDQELIAMgBjYCBAsgAEEBaiIAIAdHDQALCyACQRBqJAAPC0GpfiACQeuLBBCJA0GQjARBvYsEQfwBEJgKAAuAAwEFfwJAAkACQCAAKAIEIAAoAgAiAmtBDG0iBUEBaiIDQdaq1aoBSQRAIAMgACgCCCACa0EMbSICQQF0IgYgAyAGSxtB1arVqgEgAkGq1arVAEkbIgIEQCACQdaq1aoBTw0CIAJBDGwQ1RohBAsgBCAFQQxsaiIDIAEpAgA3AgAgAyABQQhqIgUoAgA2AgggAUIANwIAIAVBADYCACAEIAJBDGxqIQUgA0EMaiEGIAAoAgQiASAAKAIAIgJGDQIDQCADQQxrIgMgAUEMayIBKQIANwIAIAMgAUEIaiIEKAIANgIIIAFCADcCACAEQQA2AgAgASACRw0ACyAAIAU2AgggACgCBCEEIAAgBjYCBCAAKAIAIQIgACADNgIAIAIgBEYNAwNAIARBDGshASAEQQFrLAAAQX9MBEAgASgCABCiGwsgASEEIAEgAkcNAAsMAwsQ/BoAC0HYjAQQvgIACyAAIAU2AgggACAGNgIEIAAgAzYCAAsgAgRAIAIQohsLC4MHAgx/An0gAigCBCACLQALIgUgBUEYdEEYdUEASCIHGyIJIQUgAigCACACIAcbIg0hAiAJIgdBBE8EQCANIQIgCSEFA0AgAigAAEGV08feBWwiCkEYdiAKc0GV08feBWwgBUGV08feBWxzIQUgAkEEaiECIAdBBGsiB0EDSw0ACwsCQAJAAkACQCAHQQFrDgMCAQADCyACLQACQRB0IAVzIQULIAItAAFBCHQgBXMhBQsgBSACLQAAc0GV08feBWwhBQsgBUENdiAFc0GV08feBWwiAkEPdiACcyEIAkACQCABKAIEIgZFDQAgASgCAAJ/IAggBkEBa3EgBmkiD0EBTQ0AGiAIIAYgCEsNABogCCAGcAsiC0ECdGooAgAiAkUNACACKAIAIgJFDQAgBkEBayEQA0AgCCACKAIEIgVHBEACQCAPQQFNBEAgBSAQcSEFDAELIAUgBkkNACAFIAZwIQULIAUgC0cNAgsCQCACKAIMIAItABMiByAHQRh0QRh1QQBIIgUbIAlHDQAgAkEIaiIKKAIAIQwgBUUEQCAJRQ0EIA0iBS0AACAMQf8BcUcNAQNAIAdBAWsiB0UNBSAFLQABIQwgBUEBaiEFIAwgCkEBaiIKLQAARg0ACwwBCyAJRQ0DIAwgCiAFGyANIAkQ+BRFDQMLIAIoAgAiAg0ACwtBGBDVGiICQQhqIAMQ2xoaIAQoAgAhBSACIAg2AgQgAiAFNgIUIAJBADYCACABKgIQIREgASgCDEEBarMhEgJAIAYEQCARIAazlCASXUEBcw0BCyAGIAZBAWtxQQBHIAZBA0lyIAZBAXRyIQUgAQJ/IBIgEZWNIhFDAACAT10gEUMAAAAAYHEEQCARqQwBC0EACyIHIAUgBSAHSRsQgAsgASgCBCIGIAZBAWtxRQRAIAZBAWsgCHEhCwwBCyAGIAhLBEAgCCELDAELIAggBnAhCwsCQAJAIAEoAgAgC0ECdGoiBygCACIFRQRAIAIgASgCCDYCACABIAI2AgggByABQQhqNgIAIAIoAgAiBUUNAiAFKAIEIQUCQCAGIAZBAWsiB3FFBEAgBSAHcSEFDAELIAUgBkkNACAFIAZwIQULIAEoAgAgBUECdGohBQwBCyACIAUoAgA2AgALIAUgAjYCAAtBASEOIAEgASgCDEEBajYCDAsgACAOOgAEIAAgAjYCAAuqAgEFfyABIAAoAggiBCAAKAIEIgNrQQJ1TQRAIAAgAQR/IAMgAUECdGohAQNAIAMgAigCADYCACADQQRqIgMgAUcNAAsgAQUgAws2AgQPCwJAIAMgACgCACIGayIHQQJ1IgUgAWoiA0GAgICABEkEQCAFQQJ0An9BACADIAQgBmsiBEEBdSIFIAMgBUsbQf////8DIARBAnVB/////wFJGyIFRQ0AGiAFQYCAgIAETw0CIAVBAnQQ1RoLIgRqIgMgAUECdGohAQNAIAMgAigCADYCACADQQRqIgMgAUcNAAsgBCAFQQJ0aiEDIAdBAU4EQCAEIAYgBxCuGxoLIAAgAzYCCCAAIAE2AgQgACAENgIAIAYEQCAGEKIbCw8LEPwaAAtB2IwEEL4CAAuyAgEEfyABIAEoAggiAjYCBCAAIAIgAUEIahCCCyEDIAEoAgQhAgJAIAAoAgQiBGkiBUEBTQRAIARBAWsgAnEhAgwBCyACIARJDQAgAiAEcCECCwJAIANFBEAgASAAKAIINgIAIAAgATYCCCAAKAIAIAJBAnRqIABBCGo2AgAgASgCACICRQ0BIAIoAgQhAgJAIAVBAU0EQCACIARBAWtxIQIMAQsgAiAESQ0AIAIgBHAhAgsgACgCACACQQJ0aiABNgIADAELIAEgAygCADYCACADIAE2AgAgASgCACIDRQ0AIAMoAgQhAwJAIAVBAU0EQCADIARBAWtxIQMMAQsgAyAESQ0AIAMgBHAhAwsgAiADRg0AIAAoAgAgA0ECdGogATYCAAsgACAAKAIMQQFqNgIMCxUAIABBpI0ENgIAIABBDGoQ4QogAAsYACAAQaSNBDYCACAAQQxqEOEKIAAQohsLCgAgAEEMahDhCgu+AQIDfwF9An9BAiABQQFGDQAaIAEgASABQQFrcUUNABogARD8FQsiAiAAKAIEIgFLBEAgACACEIELDwsCQCABIAJNDQAgAUEDSSEEAn8gACgCDLMgACoCEJWNIgVDAACAT10gBUMAAAAAYHEEQCAFqQwBC0EACyEDAn8CQCAEDQAgAWlBAUsNACADQQFBICADQQFrZ2t0IANBAkkbDAELIAMQ/BULIgMgAiACIANJGyICIAFPDQAgACACEIELCwugBQERfwJAIAEEQCABQYCAgIAESQRAIAFBAnQQ1RohAyAAKAIAIQIgACADNgIAIAIEQCACEKIbCyAAIAE2AgQgAUEBIAFBAUsbIQNBACECA0AgACgCACACQQJ0akEANgIAIAJBAWoiAiADRw0ACyAAKAIIIgdFDQIgAEEIaiECIAcoAgQhBgJAIAFpIgNBAU0EQCAGIAFBAWtxIQYMAQsgASAGSw0AIAYgAXAhBgsgACgCACAGQQJ0aiACNgIAIAcoAgAiBEUNAiABQQFrIREgA0EBSyESA0AgBCgCBCECAkAgEkUEQCACIBFxIQIMAQsgASACSw0AIAIgAXAhAgsCQCACIAZGBEAgBCEHDAELAkACQCACQQJ0Ig0gACgCAGoiAygCAARAQQAhCCAEKAIAIgINASAEIQsMAgsgAyAHNgIAIAQhByACIQYMAgsgBCgCDCAELQATIg4gDkEYdEEYdUEASCIPGyEJIARBCGohDCAEIQUDQCAFIQsgAiIFKAIMIAItABMiAiACQRh0QRh1QQBIIgIbIAlHBEAgBSEIDAILIAVBCGoiAygCACADIAIbIQIgDCgCACEKAkAgD0UEQCAJRQ0BIA4hAyAMIRAgAi0AACAKQf8BcUcEQCAFIQgMBAsDQCADQQFrIgNFDQIgAi0AASEKIAJBAWohAiAKIBBBAWoiEC0AAEYNAAsgBSEIDAMLIAlFDQAgCiAMIA8bIAIgCRD4FEUNACAFIQgMAgsgBSgCACICDQALIAUhCwsgByAINgIAIAsgACgCACANaigCACgCADYCACAAKAIAIA1qKAIAIAQ2AgALIAcoAgAiBA0ACwwCC0HYjAQQvgIACyAAKAIAIQIgAEEANgIAIAIEQCACEKIbCyAAQQA2AgQLC8cCAgh/An0gACoCECELIAAoAgxBAWqzIQwCQCAAKAIEIgMEQCALIAOzlCAMXUEBcw0BCyADIANBAWtxQQBHIANBA0lyIANBAXRyIQQgAAJ/IAwgC5WNIgtDAACAT10gC0MAAAAAYHEEQCALqQwBC0EACyIFIAQgBCAFSRsQgwsgACgCBCEDCyAAKAIAAn8gA0EBayABcSADaSIFQQFNDQAaIAEgASADSQ0AGiABIANwCyIGQQJ0aigCACIERQRAQQAPCyADQQFrIQcgAigCACEIQQAhACAFQQFLIQkDQAJAIAAhBSAEIgooAgAiBEUNACAEKAIEIQACfyAAIAdxIAlFDQAaIAAgACADSQ0AGiAAIANwCyAGRw0AQQAhAiAAIAFGBEAgBCgCCCAIRiECCyACIAVyIQAgAg0BIAVBAXNBAXENAQsLIAoLvgECA38BfQJ/QQIgAUEBRg0AGiABIAEgAUEBa3FFDQAaIAEQ/BULIgIgACgCBCIBSwRAIAAgAhCECw8LAkAgASACTQ0AIAFBA0khBAJ/IAAoAgyzIAAqAhCVjSIFQwAAgE9dIAVDAAAAAGBxBEAgBakMAQtBAAshAwJ/AkAgBA0AIAFpQQFLDQAgA0EBQSAgA0EBa2drdCADQQJJGwwBCyADEPwVCyIDIAIgAiADSRsiAiABTw0AIAAgAhCECwsLuQMBCX8CQAJAIAEEQCABQYCAgIAETw0CIAFBAnQQ1RohBCAAKAIAIQIgACAENgIAIAIEQCACEKIbCyAAIAE2AgQgAUEBIAFBAUsbIQRBACECA0AgACgCACACQQJ0akEANgIAIAJBAWoiAiAERw0ACyAAKAIIIgZFDQEgAEEIaiECIAYoAgQhBQJAIAFpIgNBAU0EQCAFIAFBAWtxIQUMAQsgASAFSw0AIAUgAXAhBQsgACgCACAFQQJ0aiACNgIAIAYoAgAiBEUNASABQQFrIQggA0EBSyEJA0AgBCgCBCEDAkAgCUUEQCADIAhxIQMMAQsgASADSw0AIAMgAXAhAwsCQCADIAVGBEAgBCEGDAELIAQhAiADQQJ0IgcgACgCAGoiCigCAEUEQCAKIAY2AgAgBCEGIAMhBQwBCwNAIAIiAygCACICBEAgBCgCCCACKAIIRg0BCwsgBiACNgIAIAMgACgCACAHaigCACgCADYCACAAKAIAIAdqKAIAIAQ2AgALIAYoAgAiBA0ACwwBCyAAKAIAIQIgAEEANgIAIAIEQCACEKIbCyAAQQA2AgQLDwtB2IwEEL4CAAvr7wEEL38CfhJ9AnwjAEHQAmsiCCQAIAhBADYCyAIgCEIANwPAAiAEBEAgBEIANwIAIARCADcCCAsgCEIANwO4AiAIQgA3A7ACIAhCADcDqAIgCEIANwOgAiAIQgA3AowCIAhCADcClAIgCEEAOgCCAiAIQQA7AYACIAhCADcChAIgCEIANwLsASAIQgA3AvQBIAhBADoA4gEgCEEAOwHgASAIQgA3AuQBAkAgABDMB0GAgARGBEAgCEGoAWogACgCBBCtBhoMAQsgCEGoAWogABDJBwsgCEHwAGoQpwYhJSABENgHRQRAAkAgARDMB0GAgARGBEAgCEEwaiABKAIEEK0GGgwBCyAIQTBqIAEQyQcLICUgCEEwahC5BhogCEEwahCxBhoLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAgoAqgBIgBBA3ZB/wNxIgpBAWpB/QdxQQFGBEAgCCgC0AEiASgCACENIAEoAgQhDCAHQfsBcUEAIAdB/wFxIiZBCEcbDQEgAEEHcSELIABB/x9xIQ4gJRC3BiAHQYCACHEiL0VxIQFBACEAA0AgBSAAQQN0IglqKwMAIktEAAAAAAAAAABjDQMgBiAJaisDACJMRAAAAAAAAAAAY0EBc0UNA0EAIEyZRAAAAAAAALA8YyBLmUQAAAAAAACwPGNBf3MgAUF/c3JBAXEbIQEgACAKRyEJIABBAWohACAJDQALIAIoAgAiECAMTw0DIAIoAgQiGCANTw0DIAMgCEGgAmogDkEAEIgEAkAgDSAMIAwgDUgbQQF0IgAgCCgCxAIgCCgCwAIiA2tBDG0iCUsEQCAIQcACaiAAIAlrEIYLDAELIAAgCU8NACAIIAMgAEEMbGo2AsQCCyABRQ0LQQAhACAIKALUASEJQQAhASAIKAKsASIDQQFOBEAgA0ECdCAJakEEaygCACEBCyAJKAIAIQMgCCgCuAEhFAJAIAFFDQAgFCADIBhsaiABIBBsaiEJA0AgACAJai0AACAIQaACaiAAai0AAEcNASAAQQFqIgAgAUcNAAsMDAsgACABRg0LAkAgDg4WAAUFBQkIBQUFBQUFBQUFBQoFBQUHBgULIBQgAyACKQIAIjdCIIgiOKciG2xqIgkgN6ciEmoiAC0AACEKIAgoAtABIgEoAgAhGiABKAIEIQ0gCCgCxAIhByAIKALAAiEPIAAgCC0AoAIiCzoAAAJAIA0gEkEBaiIFTARAIBIhFwwBCyAKQf8BcSIBIAUgCWoiAC0AAEcEQCASIRcMAQsDQAJAIAAgCzoAACAFIhdBAWoiBSANRg0AIAEgBSAJaiIALQAARg0BDAILCyANIQULAkAgEkEBSA0AIApB/wFxIQYDQCAJIBJBAWsiAGoiAS0AACAGRw0BIAEgCzoAACASQQFKIQEgACESIAENAAtBACESCyAPQQE7AQogDyAXOwEIIA8gBTsBBiAPIBc7AQQgDyASOwECIA8gOD0BACAHIA9BDGoiDEYEQAJAIAgoAsQCIgcgCCgCwAIiD2tBDG0iAEEDbEEBdiIBIABLBEAgCEHAAmogASAAaxCGCyAIKALEAiEHIAgoAsACIQ8MAQsgACABTQ0AIAggDyABQQxsaiIHNgLEAgsgD0EMaiEMCyAmQQhGIRUgCkH/AXEhCiAbIRwDQCAMQQxrIgwvAQAhESAMLwECIRggDC8BBiEBIAwuAQohACAMLwEIIQkgCCAMLwEEIhQgFWoiBTYCUCAIIAlBAWo2AkwgCCAANgJIIAggAUEBazYCRCAIIBggFWsiATYCQCAIIAA2AjwgCCAFNgI4IAggATYCNCAIQQAgAGsiADYCMCAgIBhrQQFqIRlBACEOA0ACQCAAIBFqIgMgGk8NACAIQTBqIA5BDGxqIgEoAgQiCSABKAIIIgJKDQAgCCgCuAEgCCgC1AEoAgAgA2xqIQZBACAAayEQA0ACQCAJIA1PBEAgCSEBDAELIAogBiAJaiIALQAARwRAIAkhAQwBCyAAIAs6AAAgCSEAAkAgCUEBSA0AA0AgBiAAQQFrIgFqIgUtAAAgCkcNASAFIAs6AAAgAEEBSiEFIAEhACAFDQALQQAhAAsCQCAJQQFqIgEgDU4NACABIAZqIgUtAAAgCkcNAANAAkAgBSALOgAAIAEiCUEBaiIBIA1GDQAgCiABIAZqIgUtAABGDQEMAgsLIA0hAQsgDCAQOwEKIAwgFDsBCCAMIBg7AQYgDCAJOwEEIAwgADsBAiAMIAM7AQAgDEEMaiIMIAdHDQACQCAIKALEAiIFIAgoAsACIgBrQQxtIglBA2xBAXYiDCAJSwRAIAhBwAJqIAwgCWsQhgsgCCgCxAIhBSAIKALAAiEADAELIAkgDE0NACAIIAAgDEEMbGoiBTYCxAILIAAgByAPa0EMbUEMbGohDCAFIQcgACEPCyABQQFqIQkgASACSA0ACwsgDkEBaiIOQQNHBEAgCEEwaiAOQQxsaigCACEADAELCyARIBwgESAcSBshHCARIBsgESAbShshGyAYIBIgEiAYShshEiAUIBcgFCAXShshFyAUIBlqISAgDCAPRw0ACwwKC0F7IAhBMGpBoI4EEIkDQdGOBEHbjgRB6wMQmAoAC0GyfiAIQTBqQYKPBBCJA0HRjgRB244EQfADEJgKAAtBeyAIQTBqQaWPBBCJA0HRjgRB244EQfcDEJgKAAtBrX4gCEEwakHOjwQQiQNB0Y4EQduOBEH9AxCYCgALQa5+IAhBMGpB7Y8EEIkDQdGOBEHbjgRBnAQQmAoACyAUIAMgAikCACI3QiCIIjinIhtsaiIJIDenIhJBDGxqIgAqAgghPiAIKALQASIBKAIAIQ4gASgCBCEFIAgoAsQCIRAgCCgCwAIhFSAIKgKgAiE5IAgqAqQCIT8gACAIKgKoAiJBOAIIIAAqAgQhOyAAID84AgQgACoCACE6IAAgOTgCAAJAIAUgEkEBaiIGTARAIBIhFwwBCyA6IAkgBkEMbGoiASoCAFwEQCASIRcMAQsgOyAJIAZBDGxqIgAqAgRcBEAgEiEXDAELIABBBGohCiASIRcDQCA+IAkgBiIAQQxsaiIGKgIIXARAIAAhBgwCCyABIDk4AgAgCiA/OAIAIAYgQTgCCCAFIABBAWoiBkcEQCA6IAkgBkEMbCIKaiIBKgIAXARAIAAhFwwDCyAJIApqIgtBBGohCiAAIRcgCyoCBCA7XA0CDAELCyAAIRcgBSEGCwJAIBJBAUgNAANAIAkgEkEBayIBQQxsaiIAKgIAIDpcDQEgACoCBCA7XA0BIAAqAgggPlwNASAAIDk4AgAgACA/OAIEIAAgQTgCCCASQQFKIQAgASESIAANAAtBACESCyAVQQE7AQogFSAXOwEIIBUgBjsBBiAVIBc7AQQgFSASOwECIBUgOD0BACAQIBVBDGoiDEYEQAJAIAgoAsQCIhAgCCgCwAIiFWtBDG0iAEEDbEEBdiIBIABLBEAgCEHAAmogASAAaxCGCyAIKALEAiEQIAgoAsACIRUMAQsgACABTQ0AIAggFSABQQxsaiIQNgLEAgsgFUEMaiEMCyAmQQhGIRkgGyEcA0AgDEEMayIMLwEAIQcgDC8BAiEYIAwvAQYhASAMLgEKIQAgDC8BCCEJIAggDC8BBCIPIBlqIgY2AlAgCCAJQQFqNgJMIAggADYCSCAIIAFBAWs2AkQgCCAYIBlrIgE2AkAgCCAANgI8IAggBjYCOCAIIAE2AjQgCEEAIABrIgE2AjAgICAYa0EBaiETQQAhCwNAAkAgASAHaiICIA5PDQAgCEEwaiALQQxsaiIJKAIEIgAgCSgCCCIJSg0AIAgoArgBIAgoAtQBKAIAIAJsaiEGQQAgAWshAwNAAkAgACAFTwRAIAAhAQwBCyA6IAYgAEEMbGoiASoCAFwEQCAAIQEMAQsgOyABKgIEXARAIAAhAQwBCyA+IAEqAghcBEAgACEBDAELIAEgOTgCACABID84AgQgASBBOAIIIAAhCgJAIABBAUgNAANAIAYgCkEBayINQQxsaiIBKgIAIDpcDQEgASoCBCA7XA0BIAEqAgggPlwNASABIDk4AgAgASA/OAIEIAEgQTgCCCAKQQFKIQEgDSEKIAENAAtBACEKCwJAIABBAWoiASAFTg0AIAYgAUEMbCINaiIUKgIAIDpcDQAgBiANaiINKgIEIDtcDQAgDUEEaiERA0AgPiAGIAEiDUEMbGoiASoCCFwEQCANIQEMAgsgFCA5OAIAIBEgPzgCACABIEE4AgggBSANQQFqIgFHBEAgOiAGIAFBDGwiAGoiFCoCAFwEQCANIQAMAwsgACAGaiIaQQRqIREgDSEAIBoqAgQgO1wNAgwBCwsgDSEAIAUhAQsgDCADOwEKIAwgDzsBCCAMIBg7AQYgDCAAOwEEIAwgCjsBAiAMIAI7AQAgDEEMaiIMIBBHDQACQCAIKALEAiINIAgoAsACIgBrQQxtIgpBA2xBAXYiDCAKSwRAIAhBwAJqIAwgCmsQhgsgCCgCxAIhDSAIKALAAiEADAELIAogDE0NACAIIAAgDEEMbGoiDTYCxAILIAAgECAVa0EMbUEMbGohDCANIRAgACEVCyABQQFqIQAgASAJSA0ACwsgC0EBaiILQQNHBEAgCEEwaiALQQxsaigCACEBDAELCyAHIBwgByAcSBshHCAHIBsgByAbShshGyAYIBIgEiAYShshEiAPIBcgDyAXShshFyAPIBNqISAgDCAVRw0ACwwECyAUIAMgAikCACI3QiCIIjinIhtsaiIFIDenIhJBDGxqIgAoAgghByAIKALQASIBKAIAIRUgASgCBCEJIAgoAsQCIRMgCCgCwAIhHyAIKAKgAiEDIAgoAqQCIRAgACAIKAKoAiIYNgIIIAAoAgQhDSAAIBA2AgQgACgCACELIAAgAzYCAAJAIAkgEkEBaiIGTARAIBIhFwwBCyALIAUgBkEMbGoiASgCAEcEQCASIRcMAQsgDSAFIAZBDGxqIgAoAgRHBEAgEiEXDAELIABBBGohCiASIRcDQCAHIAUgBiIAQQxsaiIGKAIIRwRAIAAhBgwCCyABIAM2AgAgCiAQNgIAIAYgGDYCCCAJIABBAWoiBkcEQCALIAUgBkEMbCIKaiIBKAIARwRAIAAhFwwDCyAFIApqIgxBBGohCiAAIRcgDCgCBCANRw0CDAELCyAAIRcgCSEGCwJAIBJBAUgNAANAIAUgEkEBayIBQQxsaiIAKAIAIAtHDQEgACgCBCANRw0BIAAoAgggB0cNASAAIAM2AgAgACAQNgIEIAAgGDYCCCASQQFKIQAgASESIAANAAtBACESCyAfQQE7AQogHyAXOwEIIB8gBjsBBiAfIBc7AQQgHyASOwECIB8gOD0BACATIB9BDGoiAkYEQAJAIAgoAsQCIhMgCCgCwAIiH2tBDG0iAEEDbEEBdiIBIABLBEAgCEHAAmogASAAaxCGCyAIKALEAiETIAgoAsACIR8MAQsgACABTQ0AIAggHyABQQxsaiITNgLEAgsgH0EMaiECCyAmQQhGISMgGyEcA0AgAkEMayICLwEAIREgAi8BAiEiIAIvAQYhASACLgEKIQAgAi8BCCEFIAggAi8BBCIeICNqIgY2AlAgCCAFQQFqNgJMIAggADYCSCAIIAFBAWs2AkQgCCAiICNrIgE2AkAgCCAANgI8IAggBjYCOCAIIAE2AjQgCEEAIABrIgE2AjAgICAia0EBaiEgQQAhDgNAAkAgASARaiIUIBVPDQAgCEEwaiAOQQxsaiIFKAIEIgAgBSgCCCIGSg0AIAgoArgBIAgoAtQBKAIAIBRsaiEFQQAgAWshHQNAAkAgACAJTwRAIAAhAQwBCyALIAUgAEEMbGoiASgCAEcEQCAAIQEMAQsgDSABKAIERwRAIAAhAQwBCyAHIAEoAghHBEAgACEBDAELIAEgAzYCACABIBA2AgQgASAYNgIIIAAhCgJAIABBAUgNAANAIAUgCkEBayIMQQxsaiIBKAIAIAtHDQEgASgCBCANRw0BIAEoAgggB0cNASABIAM2AgAgASAQNgIEIAEgGDYCCCAKQQFKIQEgDCEKIAENAAtBACEKCwJAIABBAWoiASAJTg0AIAUgAUEMbCIMaiIPKAIAIAtHDQAgBSAMaiIMKAIEIA1HDQAgDEEEaiEaA0AgByAFIAEiDEEMbGoiASgCCEcEQCAMIQEMAgsgDyADNgIAIBogEDYCACABIBg2AgggCSAMQQFqIgFHBEAgCyAFIAFBDGwiAGoiDygCAEcEQCAMIQAMAwsgACAFaiIZQQRqIRogDCEAIBkoAgQgDUcNAgwBCwsgDCEAIAkhAQsgAiAdOwEKIAIgHjsBCCACICI7AQYgAiAAOwEEIAIgCjsBAiACIBQ7AQAgAkEMaiICIBNHDQACQCAIKALEAiIMIAgoAsACIgBrQQxtIgpBA2xBAXYiAiAKSwRAIAhBwAJqIAIgCmsQhgsgCCgCxAIhDCAIKALAAiEADAELIAIgCk8NACAIIAAgAkEMbGoiDDYCxAILIAAgEyAfa0EMbUEMbGohAiAMIRMgACEfCyABQQFqIQAgASAGSA0ACwsgDkEBaiIOQQNHBEAgCEEwaiAOQQxsaigCACEBDAELCyARIBwgESAcSBshHCARIBsgESAbShshGyAiIBIgEiAiShshEiAeIBcgFyAeSBshFyAeICBqISAgAiAfRw0ACwwDCyAUIAMgAikCACI3QiCIIjinIhtsaiIFIDenIhJBAnRqIgAqAgAhOiAIKALQASIBKAIAIRogASgCBCEKIAgoAsQCIRQgCCgCwAIhByAAIAgqAqACIjs4AgAgFCAHa0EMbSEGAkAgCiASQQFqIglMBEAgEiEXDAELIDogBSAJQQJ0aiIAKgIAXARAIBIhFwwBCwNAAkAgACA7OAIAIAkiF0EBaiIJIApGDQAgOiAFIAlBAnRqIgAqAgBbDQEMAgsLIAohCQsCQCASQQFIDQADQCAFIBJBAWsiAEECdGoiASoCACA6XA0BIAEgOzgCACASQQFKIQEgACESIAENAAtBACESCyAHQQE7AQogByAXOwEIIAcgCTsBBiAHIBc7AQQgByASOwECIAcgOD0BACAUIAdBDGoiC0YEQAJAIAYgBkEDbEEBdiIASQRAIAhBwAJqIAAgBmsQhgsgCCgCxAIhFCAIKALAAiEHDAELIAAgBk8NACAIIAcgAEEMbGoiFDYCxAILIAdBDGohCwsgJkEIRiEVIAchDyAUIQwgGyEcA0AgC0EMayILLwEAIREgCy8BAiEQIAsvAQYhASALLgEKIQAgCy8BCCEJIAggCy8BBCIYIBVqIgU2AlAgCCAJQQFqNgJMIAggADYCSCAIIAFBAWs2AkQgCCAQIBVrIgE2AkAgCCAANgI8IAggBTYCOCAIIAE2AjQgCEEAIABrIgA2AjAgICAQa0EBaiEZQQAhDgNAAkAgACARaiICIBpPDQAgCEEwaiAOQQxsaiIBKAIEIgUgASgCCCINSg0AIAgoArgBIAgoAtQBKAIAIAJsaiEGQQAgAGshAwNAAkAgBSAKTwRAIAUhAQwBCyA6IAYgBUECdGoiACoCAFwEQCAFIQEMAQsgACA7OAIAAkAgBSIAQQFIDQADQCAGIABBAWsiAUECdGoiCSoCACA6XA0BIAkgOzgCACAAQQFKIQkgASEAIAkNAAtBACEACwJAIAVBAWoiASAKTg0AIAYgAUECdGoiCSoCACA6XA0AA0ACQCAJIDs4AgAgASIFQQFqIgEgCkYNACA6IAYgAUECdGoiCSoCAFsNAQwCCwsgCiEBCyALIAM7AQogCyAYOwEIIAsgEDsBBiALIAU7AQQgCyAAOwECIAsgAjsBACALQQxqIgsgDEcNAAJAIBQgB2tBDG0iAEEDbEEBdiIJIABLBEAgCEHAAmogCSAAaxCGCyAIKALEAiEUIAgoAsACIQcMAQsgACAJTQ0AIAggByAJQQxsaiIUNgLEAgsgByAMIA9rQQxtQQxsaiELIBQhDCAHIQ8LIAFBAWohBSABIA1IDQALCyAOQQFqIg5BA0cEQCAIQTBqIA5BDGxqKAIAIQAMAQsLIBEgHCARIBxIGyEcIBEgGyARIBtKGyEbIBAgEiAQIBJIGyESIBggFyAXIBhIGyEXIBggGWohICALIA9HDQALDAILIBQgAyACKQIAIjdCIIgiOKciG2xqIgkgN6ciEkECdGoiACgCACEKIAgoAtABIgEoAgAhGSABKAIEIQ0gCCgCxAIhESAIKALAAiEQIAAgCCgCoAIiCzYCACARIBBrQQxtIQYCQCANIBJBAWoiBUwEQCASIRcMAQsgCiAJIAVBAnRqIgAoAgBHBEAgEiEXDAELA0ACQCAAIAs2AgAgBSIXQQFqIgUgDUYNACAKIAkgBUECdGoiACgCAEYNAQwCCwsgDSEFCwJAIBJBAUgNAANAIAkgEkEBayIAQQJ0aiIBKAIAIApHDQEgASALNgIAIBJBAUohASAAIRIgAQ0AC0EAIRILIBBBATsBCiAQIBc7AQggECAFOwEGIBAgFzsBBCAQIBI7AQIgECA4PQEAIBEgEEEMaiIMRgRAAkAgBiAGQQNsQQF2IgBJBEAgCEHAAmogACAGaxCGCyAIKALEAiERIAgoAsACIRAMAQsgACAGTw0AIAggECAAQQxsaiIRNgLEAgsgEEEMaiEMCyAmQQhGIRMgECEaIBEhByAbIRwDQCAMQQxrIgwvAQAhFSAMLwECIRQgDC8BBiEBIAwuAQohACAMLwEIIQkgCCAMLwEEIg8gE2oiBTYCUCAIIAlBAWo2AkwgCCAANgJIIAggAUEBazYCRCAIIBQgE2siATYCQCAIIAA2AjwgCCAFNgI4IAggATYCNCAIQQAgAGsiADYCMCAgIBRrQQFqIR1BACEOA0ACQCAAIBVqIgMgGU8NACAIQTBqIA5BDGxqIgEoAgQiCSABKAIIIgJKDQAgCCgCuAEgCCgC1AEoAgAgA2xqIQZBACAAayEYA0ACQCAJIA1PBEAgCSEBDAELIAogBiAJQQJ0aiIAKAIARwRAIAkhAQwBCyAAIAs2AgAgCSEAAkAgCUEBSA0AA0AgBiAAQQFrIgFBAnRqIgUoAgAgCkcNASAFIAs2AgAgAEEBSiEFIAEhACAFDQALQQAhAAsCQCAJQQFqIgEgDU4NACAGIAFBAnRqIgUoAgAgCkcNAANAAkAgBSALNgIAIAEiCUEBaiIBIA1GDQAgCiAGIAFBAnRqIgUoAgBGDQEMAgsLIA0hAQsgDCAYOwEKIAwgDzsBCCAMIBQ7AQYgDCAJOwEEIAwgADsBAiAMIAM7AQAgDEEMaiIMIAdHDQACQCARIBBrQQxtIgBBA2xBAXYiCSAASwRAIAhBwAJqIAkgAGsQhgsgCCgCxAIhESAIKALAAiEQDAELIAAgCU0NACAIIBAgCUEMbGoiETYCxAILIBAgByAaa0EMbUEMbGohDCARIQcgECEaCyABQQFqIQkgASACSA0ACwsgDkEBaiIOQQNHBEAgCEEwaiAOQQxsaigCACEADAELCyAVIBwgFSAcSBshHCAVIBsgFSAbShshGyAUIBIgEiAUShshEiAPIBcgDyAXShshFyAPIB1qISAgDCAaRw0ACwwBCyAUIAMgAikCACI3QiCIIjinIhtsaiIFIDenIhJBA2xqIgAtAAIhGSAIKALQASIBKAIAIRMgASgCBCEJIAgoAsQCISIgCCgCwAIhISAILQCgAiEDIAgtAKECIRAgACAILQCiAiIYOgACIAAtAAEhFCAAIBA6AAEgAC0AACELIAAgAzoAAAJAIAkgEkEBaiIKTARAIBIhFwwBCyAFIApBA2xqIgEtAAAgC0H/AXFHBEAgEiEXDAELIAUgCkEDbGoiAC0AASAUQf8BcUcEQCASIRcMAQsgAEEBaiEGIBlB/wFxIQwgEiEXA0AgDCAFIAoiAEEDbGoiCi0AAkcEQCAAIQoMAgsgASADOgAAIAYgEDoAACAKIBg6AAIgCSAAQQFqIgpHBEAgBSAKQQNsIgZqIgEtAAAgC0H/AXFHBEAgACEXDAMLIAUgBmoiDUEBaiEGIAAhFyANLQABIBRB/wFxRw0CDAELCyAAIRcgCSEKCwJAIBJBAUgNACALQf8BcSEGA0AgBSASQQFrIgFBA2xqIgAtAAAgBkcNASAALQABIBRB/wFxRw0BIAAtAAIgGUH/AXFHDQEgACADOgAAIAAgEDoAASAAIBg6AAIgEkEBSiEAIAEhEiAADQALQQAhEgsgIUEBOwEKICEgFzsBCCAhIAo7AQYgISAXOwEEICEgEjsBAiAhIDg9AQAgIiAhQQxqIgJGBEACQCAIKALEAiIiIAgoAsACIiFrQQxtIgBBA2xBAXYiASAASwRAIAhBwAJqIAEgAGsQhgsgCCgCxAIhIiAIKALAAiEhDAELIAAgAU0NACAIICEgAUEMbGoiIjYCxAILICFBDGohAgsgJkEIRiEkIAtB/wFxIQsgGyEcA0AgAkEMayICLwEAIRogAi8BAiEfIAIvAQYhASACLgEKIQAgAi8BCCEFIAggAi8BBCIjICRqIgY2AlAgCCAFQQFqNgJMIAggADYCSCAIIAFBAWs2AkQgCCAfICRrIgE2AkAgCCAANgI8IAggBjYCOCAIIAE2AjQgCEEAIABrIgE2AjAgICAfa0EBaiEgQQAhDgNAAkAgASAaaiIPIBNPDQAgCEEwaiAOQQxsaiIFKAIEIgAgBSgCCCIGSg0AIAgoArgBIAgoAtQBKAIAIA9saiEFQQAgAWshHgNAAkAgACAJTwRAIAAhAQwBCyALIAUgAEEDbGoiAS0AAEcEQCAAIQEMAQsgFEH/AXEiDSABLQABRwRAIAAhAQwBCyAZQf8BcSIHIAEtAAJHBEAgACEBDAELIAEgAzoAACABIBA6AAEgASAYOgACIAAhCgJAIABBAUgNAANAIAUgCkEBayIMQQNsaiIBLQAAIAtHDQEgAS0AASANRw0BIAEtAAIgB0cNASABIAM6AAAgASAQOgABIAEgGDoAAiAKQQFKIQEgDCEKIAENAAtBACEKCwJAIABBAWoiASAJTg0AIAUgAUEDbCIMaiIRLQAAIAtHDQAgBSAMaiIMLQABIA1HDQAgDEEBaiEVA0AgByAFIAEiDEEDbGoiAS0AAkcEQCAMIQEMAgsgESADOgAAIBUgEDoAACABIBg6AAIgCSAMQQFqIgFHBEAgCyAFIAFBA2wiAGoiES0AAEcEQCAMIQAMAwsgACAFaiIdQQFqIRUgDCEAIB0tAAEgDUcNAgwBCwsgDCEAIAkhAQsgAiAeOwEKIAIgIzsBCCACIB87AQYgAiAAOwEEIAIgCjsBAiACIA87AQAgAkEMaiICICJHDQACQCAIKALEAiINIAgoAsACIgBrQQxtIgpBA2xBAXYiDCAKSwRAIAhBwAJqIAwgCmsQhgsgCCgCxAIhDSAIKALAAiEADAELIAogDE0NACAIIAAgDEEMbGoiDTYCxAILIAAgIiAha0EMbUEMbGohAiANISIgACEhCyABQQFqIQAgASAGSA0ACwsgDkEBaiIOQQNHBEAgCEEwaiAOQQxsaigCACEBDAELCyAaIBwgGiAcSBshHCAaIBsgGiAbShshGyAfIBIgEiAfShshEiAjIBcgFyAjSBshFyAgICNqISAgAiAhRw0ACwsgBEUNASAEIBw2AgQgBCASNgIAIAQgGyAca0EBajYCDCAEIBcgEmtBAWo2AggMAQsCfwJAAkACQAJAAkACQAJAAkACQCAlELcGBEAgCEEwaiANQQJqIAxBAmpBABCoBiEAIAhCADcDGCAIQgA3AxAgCEIANwMIIAhCgYCAgMAANwMoIAhBhoCIiHw2AiAgCEIANwMAIAggCDYCJCAAIAhBIGpB1NYKEJkEICUgABCzBiAAELEGGiAlKAIMIQEMAQsgJSgCCCANQQJqRw0CICUoAgwiASAMQQJqRw0CICUvAQBB/x9xDQELQQEhACAlKAIQQQEgARCvGxogJSgCECAlKAIsKAIAICUoAghBAWtsakEBICUoAgwQrxsaIA1BAU4EQANAICUoAgwgJSgCECAlKAIsKAIAIABsampBAWtBAToAACAlKAIQICUoAiwoAgAgAGxqQQE6AAAgACANRyEBIABBAWohACABDQALC0EAIQACQAJAAkACQAJAIAsOBgACAgIBAwILA0AgCEGAAmogC2oCfyAFIAtBA3QiAWorAwAiS5lEAAAAAAAA4EFjBEAgS6oMAQtBgICAgHgLIgAgSyAAt2NrIgBBACAAQQBKGyIAQf8BIABB/wFIGzoAACAIQeABaiALagJ/IAEgBmorAwAiS5lEAAAAAAAA4EFjBEAgS6oMAQtBgICAgHgLIgAgSyAAt2NrIgBBACAAQQBKGyIAQf8BIABB/wFIGzoAACAKIAtGIQAgC0EBaiELIABFDQALDAMLA0AgCCAAQQJ0IgtqAn8gBSAAQQN0IglqKwMAIkuZRAAAAAAAAOBBYwRAIEuqDAELQYCAgIB4CyIBIEsgAbdjazYChAIgCCALagJ/IAYgCWorAwAiS5lEAAAAAAAA4EFjBEAgS6oMAQtBgICAgHgLIgEgSyABt2NrNgLkASAAIApGIQEgAEEBaiEAIAFFDQALDAILQa5+IAhBMGpB7Y8EEIkDQdGOBEHbjgRBygQQmAoACwNAIAggAEECdCIBaiAFIABBA3QiCWorAwC2OAKQAiABIAhqIAYgCWorAwC2OALwASAAIApGIQEgAEEBaiEAIAFFDQALCyAHQQh2QQEgB0GA/gNxGyEAAkACQCAODhYAAQEBBwUBAQEBAQEBAQEBCQEBAQYEAQtBACEBQQAgJSgCMCISICUoAhBqQQFqIh8gEiACKQIAIjdCIIgiOKciIWxqIgogN6ciBWoiCy0AAA0JGiAILQCAAiINIAgtAOABaiEGIAgoAtgBIR4gCCgCuAEhIiAIKALEAiEaIAgoAsACIRMgCC0AoAIhLSALIAA6AAAgIiAeICFsaiIBIAVqLQAAIQIgCiAFQQFqIglqIgstAAAhDAJAAkACQAJAIAdBgIAEcSIjBEAgBSEcIAxB/wFxDQIgDSACayIMIAEgCWotAABqIAZLDQIMAQsgBSEcAkAgDEH/AXENACABIAlqIgwtAAAgDSACa2ogBksNAANAIAsgADoAACAKIAkiHEEBaiIJaiILLQAADQEgDSAMLQAAayABIAlqIgwtAABqIAZNDQALCyAKIAVBAWsiCWoiCy0AAEUNAiAFIRYMAwsDQCALIAA6AAAgCiAJIhxBAWoiCWoiCy0AAA0BIAwgASAJai0AAGogBk0NAAsLIAogBUEBayIJaiILLQAABEAgBSEWDAILIAYgDSACayIMIAEgCWotAABqSQRAIAUhFgwCCwNAIAsgADoAACAKIAkiFkEBayIJaiILLQAADQIgDCABIAlqLQAAaiAGTQ0ACwwBCwNAIAYgASAJIhZqLQAAIA1qIAEgBWotAABrSQRAIAUhFgwCCyALIAA6AAAgCiAWIgVBAWsiCWoiCy0AAEUNAAsLIBNBATsBCiATIBw7AQggEyAcOwEEIBMgFjsBAiATIDg9AQAgEyAcQQFqOwEGIBogE0EMaiILRgRAAkAgCCgCxAIiGiAIKALAAiITa0EMbSIBQQNsQQF2IgkgAUsEQCAIQcACaiAJIAFrEIYLIAgoAsQCIRogCCgCwAIhEwwBCyABIAlNDQAgCCATIAlBDGxqIho2AsQCCyATQQxqIQsLICZBCEYhKCANIAJrIQ4gJkEIRiEbICEhJANAIAtBDGsiCy8BACEdIAsvAQIhFCALLwEGIQEgCy4BCiEJIAsvAQghBSAIIAsvAQQiESAoaiICNgJQIAggBUEBajYCTCAIIAk2AkggCCABQQFrNgJEIAggFCAoayIBNgJAIAggCTYCPCAIIAI2AjggCCABNgI0IAhBACAJayIKNgIwIBEgFGshECAgQQFqISAgIiAdIB5sIixqIRhBACEZA0AgHyAKIB1qIhUgEmxqIQUgIiAVIB5saiEJAkAgIwRAIAEgAkoNAUEAIAprIQMDQAJAIAEgBWoiCi0AAARAIAEhCgwBCyAGIA4gASAJai0AAGpJBEAgASEKDAELIAogADoAACABIQcCQCAFIAFBAWsiCmoiDC0AAA0AIA4gCSAKai0AAGogBksNAANAIAwgADoAACAFIAoiB0EBayIKaiIMLQAADQEgDiAJIApqLQAAaiAGTQ0ACwsCQCAFIAFBAWoiCmoiDC0AAA0AIA4gCSAKai0AAGogBksNAANAIAwgADoAACAFIAoiAUEBaiIKaiIMLQAADQEgDiAJIApqLQAAaiAGTQ0ACwsgCyADOwEKIAsgETsBCCALIBQ7AQYgCyABOwEEIAsgBzsBAiALIBU7AQAgC0EMaiILIBpHDQACQCAIKALEAiIMIAgoAsACIgFrQQxtIgtBA2xBAXYiByALSwRAIAhBwAJqIAcgC2sQhgsgCCgCxAIhDCAIKALAAiEBDAELIAcgC08NACAIIAEgB0EMbGoiDDYCxAILIAEgGiATa0EMbUEMbGohCyAMIRogASETCyAKQQFqIQEgAiAKSg0ACwwBCyAbRQRAIAEgAkoNAUEAIAprIQ8DQAJAIAEgBWoiCi0AAARAIAEhCgwBCyAGIAEgCWotAAAgDWogASAYai0AAGtJBEAgASEKDAELIAogADoAACABIQcCQCAFIAFBAWsiCmoiDC0AAA0AA0AgCSAKai0AACANaiAHIAlqLQAAayAGSw0BIAwgADoAACAKIQcgBSAKQQFrIgpqIgwtAABFDQALCwJAIAUgAUEBaiIKaiIMLQAADQADQAJAIAkgCmotAAAgDWoiAyABIAlqLQAAayAGTQ0AIAEgEU4NAiADIAogGGotAABrIAZNDQAMAgsgDCAAOgAAIAUgCiIBQQFqIgpqIgwtAABFDQALCyALIA87AQogCyAROwEIIAsgFDsBBiALIAE7AQQgCyAHOwECIAsgFTsBACALQQxqIgsgGkcNAAJAIAgoAsQCIgwgCCgCwAIiAWtBDG0iC0EDbEEBdiIHIAtLBEAgCEHAAmogByALaxCGCyAIKALEAiEMIAgoAsACIQEMAQsgByALTw0AIAggASAHQQxsaiIMNgLEAgsgASAaIBNrQQxtQQxsaiELIAwhGiABIRMLIApBAWohASACIApKDQALDAELIAEgAkoNAEEAIAprIRcDQAJAIAEgBWoiCi0AAARAIAEhCgwBCyABIAlqLQAAIQcCQCAQIAEgFGsiDEEBa08EQCAHIA1qIAEgGGpBAWstAABrIAZNDQELIAwgEE0EQCAHIA1qIAEgGGotAABrIAZNDQELIBAgDEEBakkEQCABIQoMAgsgByANaiABIBhqLQABayAGTQ0AIAEhCgwBCyAKIAA6AAAgASEDAkAgBSABQQFrIgpqIgwtAAANAANAIAkgCmotAAAgDWogAyAJai0AAGsgBksNASAMIAA6AAAgCiEDIAUgCkEBayIKaiIMLQAARQ0ACwsgASEMAkAgBSABQQFqIgpqIgctAAANAANAIAEhDAJAIAkgCiIBai0AACANaiIKIAkgDGotAABrIAZNDQAgECABIBRrIg9BAWtPBEAgCiAMIBhqLQAAayAGTQ0BCyAPIBBNBEAgCiABIBhqLQAAayAGTQ0BCyAQIA9BAWpJBEAgASEKDAMLIAogDCAYai0AAmsgBk0NACABIQoMAgsgByAAOgAAIAEhDCAFIAFBAWoiCmoiBy0AAEUNAAsLIAsgFzsBCiALIBE7AQggCyAUOwEGIAsgDDsBBCALIAM7AQIgCyAVOwEAIAtBDGoiCyAaRw0AAkAgCCgCxAIiDCAIKALAAiIBa0EMbSILQQNsQQF2IgcgC0sEQCAIQcACaiAHIAtrEIYLIAgoAsQCIQwgCCgCwAIhAQwBCyAHIAtPDQAgCCABIAdBDGxqIgw2AsQCCyABIBogE2tBDG1BDGxqIQsgDCEaIAEhEwsgCkEBaiEBIAIgCkoNAAsLIBlBAWoiGUEDRwRAIAhBMGogGUEMbGoiCSgCCCECIAkoAgQhASAJKAIAIQoMAQsLIB0gIUghASAdICRKIQkgFCAWSCEFIBEgHEohCgJAIC8NACARIBRJDQAgIiAUICxqaiAtIBBBAWoQrxsaCyAdICEgARshISAdICQgCRshJCAUIBYgBRshFiARIBwgChshHCAQICBqISAgCyATRw0ACyAkICFrQQFqIQEgISEnIBwgFmtBAWoMCQtBrn4gCEEwakHtjwQQiQNB0Y4EQduOBEHtBBCYCgALQal+IAhBMGpBppAEEIkDQdGOBEHbjgRBrAQQmAoAC0GpfiAIQTBqQe6PBBCJA0HRjgRB244EQasEEJgKAAtBACEBQQAgJSgCMCIeICUoAhBqQQFqIhIgHiACKQIAIjdCIIgiOKciHGxqIgYgN6ciBWoiCi0AAA0FGiAIKALYASEdIAgoArgBISIgCCoCkAKMITkgCCoC+AEhOiAIKgL0ASE+IAgqApgCjCE7IAgqApQCjCFBIAgoAsQCIQ8gCCgCwAIhGSAIKgLwASE/IAgqAqgCIUcgCCoCpAIhSCAIKgKgAiFJIAogADoAACAGIAVBAWoiCmoiCy0AACENICIgHCAdbGoiCSAFQQxsaiIBKgIIIUQgASoCBCFFIAEqAgAhRgJAAkACQCAHQYCABHEiHwRAIAUhGwJAIA1B/wFxDQADQCAJIApBDGxqIgEqAgggRJMiPCA6X0EBcw0BIDsgPF9BAXMNASABKgIEIEWTIjwgPl9BAXMNASABKgIAIEaTIj0gOWBBAXMNASA9ID9fQQFzDQEgPCBBYEEBcw0BIAsgADoAACAKIRsgBiAKQQFqIgpqIgstAABFDQALCyAGIAVBAWsiAWoiCi0AAEUNASAFIRYMAwsgBSEbIA1B/wFxDQEgRCE8IEUhPSBGIUADQCAJIAoiDUEMbGoiASoCCCA8kyI8IDpfQQFzDQIgOyA8X0EBcw0CIAEqAgQgPZMiPCA+X0EBcw0CIAEqAgAgQJMiPSA5YEEBcw0CID0gP19BAXMNAiA8IEFgQQFzDQIgCyAAOgAAIAYgDUEBaiIKaiILLQAABEAgDSEbDAMFIAEqAgghPCABKgIEIT0gASoCACFAIA0hGwwBCwALAAsDQCAJIAEiFkEMbGoiASoCCCBEkyI8IDpfQQFzBEAgBSEWDAMLIDsgPF9BAXMEQCAFIRYMAwsgASoCBCBFkyI8ID5fQQFzBEAgBSEWDAMLIAEqAgAgRpMiPSA5YEEBcwRAIAUhFgwDCyA9ID9fQQFzBEAgBSEWDAMLIDwgQWBBAXMEQCAFIRYMAwsgCiAAOgAAIAYgFiIFQQFrIgFqIgotAABFDQALDAELIAYgBUEBayIBaiILLQAABEAgBSEWDAELA0AgCSABIhZBDGxqIgEqAgggCSAFQQxsaiIKKgIIkyI8IDpfQQFzBEAgBSEWDAILIAEqAgQgCioCBJMiPSA+X0EBcwRAIAUhFgwCCyABKgIAIAoqAgCTIkAgOWBBAXMEQCAFIRYMAgsgPyBAYEEBcwRAIAUhFgwCCyA9IEFgQQFzBEAgBSEWDAILIDsgPF9BAXMEQCAFIRYMAgsgCyAAOgAAIAYgFiIFQQFrIgFqIgstAABFDQALCyAZQQE7AQogGSAbOwEIIBkgGzsBBCAZIBY7AQIgGSA4PQEAIBkgG0EBajsBBiAPIBlBDGoiC0YEQAJAIAgoAsQCIg8gCCgCwAIiGWtBDG0iAUEDbEEBdiIJIAFLBEAgCEHAAmogCSABaxCGCyAIKALEAiEPIAgoAsACIRkMAQsgASAJTQ0AIAggGSAJQQxsaiIPNgLEAgsgGUEMaiELCyAmQQhGISQgJkEIRiEXIBwhIQNAIAtBDGsiCy8BACETIAsvAQIhECALLwEGIQEgCy4BCiEJIAsvAQghBSAIIAsvAQQiFCAkaiIMNgJQIAggBUEBajYCTCAIIAk2AkggCCABQQFrNgJEIAggECAkayIBNgJAIAggCTYCPCAIIAw2AjggCCABNgI0IAhBACAJayIGNgIwIBQgEGshByAgQQFqISAgIiATIB1saiEDQQAhFQNAIBIgBiATaiIRIB5saiEFICIgESAdbGohCQJAIB8EQCABIAxKDQFBACAGayEOA0ACQCABIAVqIgYtAAAEQCABIQYMAQsgCSABQQxsaiIKKgIIIESTIjwgOl9BAXMEQCABIQYMAQsgOyA8X0EBcwRAIAEhBgwBCyAKKgIEIEWTIjwgPl9BAXMEQCABIQYMAQsgCioCACBGkyI9IDlgQQFzBEAgASEGDAELID0gP19BAXMEQCABIQYMAQsgPCBBYEEBcwRAIAEhBgwBCyAGIAA6AAAgASECAkAgBSABQQFrIgZqIg0tAAANAANAIAkgBiIKQQxsaiIGKgIIIESTIjwgOl9BAXMNASA7IDxfQQFzDQEgBioCBCBFkyI8ID5fQQFzDQEgBioCACBGkyI9IDlgQQFzDQEgPSA/X0EBcw0BIDwgQWBBAXMNASANIAA6AAAgCiECIAUgCkEBayIGaiINLQAARQ0ACwsCQCAFIAFBAWoiBmoiDS0AAA0AA0AgCSAGQQxsaiIKKgIIIESTIjwgOl9BAXMNASA7IDxfQQFzDQEgCioCBCBFkyI8ID5fQQFzDQEgCioCACBGkyI9IDlgQQFzDQEgPSA/X0EBcw0BIDwgQWBBAXMNASANIAA6AAAgBSAGIgFBAWoiBmoiDS0AAEUNAAsLIAsgDjsBCiALIBQ7AQggCyAQOwEGIAsgATsBBCALIAI7AQIgCyAROwEAIAtBDGoiCyAPRw0AAkAgCCgCxAIiDSAIKALAAiIBa0EMbSIKQQNsQQF2IgsgCksEQCAIQcACaiALIAprEIYLIAgoAsQCIQ0gCCgCwAIhAQwBCyAKIAtNDQAgCCABIAtBDGxqIg02AsQCCyABIA8gGWtBDG1BDGxqIQsgDSEPIAEhGQsgBkEBaiEBIAYgDEgNAAsMAQsgF0UEQCABIAxKDQFBACAGayEYA0ACQCABIAVqIgYtAAAEQCABIQYMAQsgCSABQQxsIg1qIgoqAgggAyANaiINKgIIkyI8IDpfQQFzBEAgASEGDAELIAoqAgQgDSoCBJMiPSA+X0EBcwRAIAEhBgwBCyAKKgIAIA0qAgCTIkAgOWBBAXMEQCABIQYMAQsgPyBAYEEBcwRAIAEhBgwBCyA9IEFgQQFzBEAgASEGDAELIDsgPF9BAXMEQCABIQYMAQsgBiAAOgAAIAEhAgJAIAUgAUEBayIGaiIOLQAADQADQCAJIAYiDUEMbGoiBioCCCAJIAJBDGxqIgoqAgiTIjwgOl9BAXMNASAGKgIEIAoqAgSTIj0gPl9BAXMNASAGKgIAIAoqAgCTIkAgOWBBAXMNASA/IEBgQQFzDQEgPSBBYEEBcw0BIDsgPF9BAXMNASAOIAA6AAAgDSECIAUgDUEBayIGaiIOLQAARQ0ACwsCQCAFIAFBAWoiBmoiDS0AAA0AA0AgCSAGIgpBDGwiDmoiBioCACE9IAYqAgQhPAJAAkAgBioCCCJCIAkgAUEMbGoiBioCCJMiQCA6X0EBcw0AIDwgBioCBJMiQyA+X0EBcw0AID0gBioCAJMiSiA5YEEBcw0AID8gSmBBAXMNACBBIENfQQFzDQAgOyBAXw0BCyBCIAMgDmoiBioCCJMiQCA7YEEBcwRAIAohBgwDCyA8IAYqAgSTIjwgPl9BAXMEQCAKIQYMAwsgPSAGKgIAkyI9IDlgQQFzBEAgCiEGDAMLID0gP19BAXMEQCAKIQYMAwsgPCBBYEEBcwRAIAohBgwDCyABIBROBEAgCiEGDAMLIDogQGBBAXNFDQAgCiEGDAILIA0gADoAACAFIAoiAUEBaiIGaiINLQAARQ0ACwsgCyAYOwEKIAsgFDsBCCALIBA7AQYgCyABOwEEIAsgAjsBAiALIBE7AQAgC0EMaiILIA9HDQACQCAIKALEAiINIAgoAsACIgFrQQxtIgpBA2xBAXYiCyAKSwRAIAhBwAJqIAsgCmsQhgsgCCgCxAIhDSAIKALAAiEBDAELIAogC00NACAIIAEgC0EMbGoiDTYCxAILIAEgDyAZa0EMbUEMbGohCyANIQ8gASEZCyAGQQFqIQEgBiAMSA0ACwwBCyABIAxKDQBBACAGayEjA0ACQCABIAVqIgYtAAAEQCABIQYMAQsgCSABQQxsIg1qIgoqAgghPCAKKgIEIT0gCioCACFAAkACQCABIBBrIgpBAWsgB0sNACA8IAMgDWpBDGsiAioCCJMiQiA6X0EBcw0AIDsgQl9BAXMNACA9IAIqAgSTIkIgPl9BAXMNACBAIAIqAgCTIkMgOWBBAXMNACA/IENgQQFzDQAgQSBCXw0BCwJAIAcgCkkNACA8IAMgDWoiAioCCJMiQiA6X0EBcw0AIDsgQl9BAXMNACA9IAIqAgSTIkIgPl9BAXMNACBAIAIqAgCTIkMgOWBBAXMNACA/IENgQQFzDQAgQSBCXw0BCyAHIApBAWpJBEAgASEGDAILIDwgAyANaiIKKgIUkyI8IDpfQQFzBEAgASEGDAILIDsgPF9BAXMEQCABIQYMAgsgPSAKKgIQkyI8ID5fQQFzBEAgASEGDAILIEAgCioCDJMiPSA5YEEBcwRAIAEhBgwCCyA9ID9fQQFzBEAgASEGDAILIDwgQWBBAXNFDQAgASEGDAELIAYgADoAACABIQICQCAFIAFBAWsiBmoiDi0AAA0AA0AgCSAGIg1BDGxqIgYqAgggCSACQQxsaiIKKgIIkyI8IDpfQQFzDQEgBioCBCAKKgIEkyI9ID5fQQFzDQEgBioCACAKKgIAkyJAIDlgQQFzDQEgPyBAYEEBcw0BID0gQWBBAXMNASA7IDxfQQFzDQEgDiAAOgAAIA0hAiAFIA1BAWsiBmoiDi0AAEUNAAsLIAEhCgJAIAUgAUEBaiIGaiINLQAADQADQCABIQogCSAGIgFBDGwiGGoiBioCACE9IAYqAgQhPAJAAkAgBioCCCJCIAkgCkEMbCIOaiIGKgIIkyJAIDpfQQFzDQAgOyBAX0EBcw0AIDwgBioCBJMiQCA+X0EBcw0AID0gBioCAJMiQyA5YEEBcw0AID8gQ2BBAXMNACBAIEFgDQELAkAgASAQayIGQQFrIAdLDQAgQiADIA5qIhoqAgiTIkAgOl9BAXMNACA7IEBfQQFzDQAgPCAaKgIEkyJAID5fQQFzDQAgPSAaKgIAkyJDIDlgQQFzDQAgPyBDYEEBcw0AIEAgQWANAQsCQCAGIAdLDQAgQiADIBhqIhgqAgiTIkAgOl9BAXMNACA7IEBfQQFzDQAgPCAYKgIEkyJAID5fQQFzDQAgPSAYKgIAkyJDIDlgQQFzDQAgPyBDYEEBcw0AIEAgQWANAQsgByAGQQFqSQRAIAEhBgwDCyBCIAMgDmoiBioCIJMiQCA6X0EBcwRAIAEhBgwDCyA7IEBfQQFzBEAgASEGDAMLIDwgBioCHJMiPCA+X0EBcwRAIAEhBgwDCyA9IAYqAhiTIj0gOWBBAXMEQCABIQYMAwsgPSA/X0EBcwRAIAEhBgwDCyA8IEFgQQFzRQ0AIAEhBgwCCyANIAA6AAAgASEKIAUgAUEBaiIGaiINLQAARQ0ACwsgCyAjOwEKIAsgFDsBCCALIBA7AQYgCyAKOwEEIAsgAjsBAiALIBE7AQAgC0EMaiILIA9HDQACQCAIKALEAiINIAgoAsACIgFrQQxtIgpBA2xBAXYiCyAKSwRAIAhBwAJqIAsgCmsQhgsgCCgCxAIhDSAIKALAAiEBDAELIAogC00NACAIIAEgC0EMbGoiDTYCxAILIAEgDyAZa0EMbUEMbGohCyANIQ8gASEZCyAGQQFqIQEgBiAMSA0ACwsgFUEBaiIVQQNHBEAgCEEwaiAVQQxsaiIJKAIIIQwgCSgCBCEBIAkoAgAhBgwBCwsgEyAcSCEFIBMgIUohBiAQIBZIIQogFCAbSiENAkAgLw0AIBQgECIBSQ0AA0AgAyABQQxsaiIJIEc4AgggCSBIOAIEIAkgSTgCACABIBRHIQkgAUEBaiEBIAkNAAsLIBMgHCAFGyEcIBMgISAGGyEhIBAgFiAKGyEWIBQgGyANGyEbIAcgIGohICALIBlHDQALICEgHGtBAWohASAcIScgGyAWa0EBagwFC0EAIQFBACAlKAIwIiIgJSgCEGpBAWoiHiAiIAIpAgAiN0IgiCI4pyIbbGoiBiA3pyIFaiIKLQAADQQaIAgoAtgBIRMgCCgCuAEhHSAIKgKQAowhOiAIKALEAiEPIAgoAsACIRUgCCoC8AEhOyAIKgKgAiFBIAogADoAACAGIAVBAWoiCWoiCi0AACELIB0gEyAbbGoiASAFQQJ0aioCACE+AkACQAJAAkAgB0GAgARxIhIEQCAFIRcgC0H/AXENAiABIAlBAnRqKgIAID6TIjkgOmBBAXMNAiA5IDtfQQFzDQIMAQsgBSEXAkAgC0H/AXENACABIAlBAnRqIgsqAgAgPpMiOSA6YEEBcw0AIDkgO19BAXMNAANAIAogADoAACAGIAkiF0EBaiIJaiIKLQAADQEgASAJQQJ0aiINKgIAIAsqAgCTIjkgOmBBAXMNASANIQsgOSA7Xw0ACwsgBiAFQQFrIglqIgotAABFDQIgBSEWDAMLA0AgCiAAOgAAIAYgCSIXQQFqIglqIgotAAANASABIAlBAnRqKgIAID6TIjkgOmBBAXMNASA5IDtfQQFzRQ0ACwsgBiAFQQFrIglqIgotAAAEQCAFIRYMAgsgASAJQQJ0aioCACA+kyI5IDpgQQFzBEAgBSEWDAILIDkgO19BAXMEQCAFIRYMAgsDQCAKIAA6AAAgBiAJIhZBAWsiCWoiCi0AAA0CIAEgCUECdGoqAgAgPpMiOSA6YEEBcw0CIDkgO19BAXNFDQALDAELA0AgASAJIhZBAnRqKgIAIAEgBUECdGoqAgCTIjkgOmBBAXMEQCAFIRYMAgsgOSA7X0EBcwRAIAUhFgwCCyAKIAA6AAAgBiAWIgVBAWsiCWoiCi0AAEUNAAsLIBVBATsBCiAVIBc7AQggFSAXOwEEIBUgFjsBAiAVIDg9AQAgFSAXQQFqOwEGIA8gFUEMaiIKRgRAAkAgCCgCxAIiDyAIKALAAiIVa0EMbSIBQQNsQQF2IgkgAUsEQCAIQcACaiAJIAFrEIYLIAgoAsQCIQ8gCCgCwAIhFQwBCyABIAlNDQAgCCAVIAlBDGxqIg82AsQCCyAVQQxqIQoLICZBCEYhISAmQQhGISMgGyEcA0AgCkEMayIKLwEAIRkgCi8BAiEDIAovAQYhASAKLgEKIQkgCi8BCCEFIAggCi8BBCIUICFqIg02AlAgCCAFQQFqNgJMIAggCTYCSCAIIAFBAWs2AkQgCCADICFrIgE2AkAgCCAJNgI8IAggDTYCOCAIIAE2AjQgCEEAIAlrIgY2AjAgFCADayEHICBBAWohICAdIBMgGWxqIQ5BACEaA0AgHiAGIBlqIhEgImxqIQUgHSARIBNsaiEJAkAgEgRAIAEgDUoNAUEAIAZrIQIDQAJAIAEgBWoiBi0AAARAIAEhBgwBCyAJIAFBAnRqKgIAID6TIjkgOmBBAXMEQCABIQYMAQsgOSA7X0EBcwRAIAEhBgwBCyAGIAA6AAAgASEMAkAgBSABQQFrIgZqIgstAAANACAJIAZBAnRqKgIAID6TIjkgOmBBAXMNACA5IDtfQQFzDQADQCALIAA6AAAgBSAGIgxBAWsiBmoiCy0AAA0BIAkgBkECdGoqAgAgPpMiOSA6YEEBcw0BIDkgO19BAXNFDQALCwJAIAUgAUEBaiIGaiILLQAADQAgCSAGQQJ0aioCACA+kyI5IDpgQQFzDQAgOSA7X0EBcw0AA0AgCyAAOgAAIAUgBiIBQQFqIgZqIgstAAANASAJIAZBAnRqKgIAID6TIjkgOmBBAXMNASA5IDtfQQFzRQ0ACwsgCiACOwEKIAogFDsBCCAKIAM7AQYgCiABOwEEIAogDDsBAiAKIBE7AQAgCkEMaiIKIA9HDQACQCAIKALEAiILIAgoAsACIgFrQQxtIgpBA2xBAXYiDCAKSwRAIAhBwAJqIAwgCmsQhgsgCCgCxAIhCyAIKALAAiEBDAELIAogDE0NACAIIAEgDEEMbGoiCzYCxAILIAEgDyAVa0EMbUEMbGohCiALIQ8gASEVCyAGQQFqIQEgBiANSA0ACwwBCyAjRQRAIAEgDUoNAUEAIAZrIRADQAJAIAEgBWoiBi0AAARAIAEhBgwBCyAJIAFBAnQiC2oqAgAgCyAOaioCAJMiOSA6YEEBcwRAIAEhBgwBCyA5IDtfQQFzBEAgASEGDAELIAYgADoAACABIQsCQCAFIAFBAWsiBmoiDC0AAA0AA0AgCSAGQQJ0aioCACAJIAtBAnRqKgIAkyI5IDpgQQFzDQEgOSA7X0EBcw0BIAwgADoAACAFIAYiC0EBayIGaiIMLQAARQ0ACwsCQCAFIAFBAWoiBmoiDC0AAA0AA0ACQCAJIAZBAnQiAmoqAgAiPyAJIAFBAnRqKgIAkyI5IDpgQQFzRUEAIDkgO18bDQAgPyACIA5qKgIAkyI5IDpgQQFzDQIgASAUTg0CIDkgO19BAXNFDQAMAgsgDCAAOgAAIAUgBiIBQQFqIgZqIgwtAABFDQALCyAKIBA7AQogCiAUOwEIIAogAzsBBiAKIAE7AQQgCiALOwECIAogETsBACAKQQxqIgogD0cNAAJAIAgoAsQCIgsgCCgCwAIiAWtBDG0iCkEDbEEBdiIMIApLBEAgCEHAAmogDCAKaxCGCyAIKALEAiELIAgoAsACIQEMAQsgCiAMTQ0AIAggASAMQQxsaiILNgLEAgsgASAPIBVrQQxtQQxsaiEKIAshDyABIRULIAZBAWohASAGIA1IDQALDAELIAEgDUoNAEEAIAZrIR8DQAJAIAEgBWoiBi0AAARAIAEhBgwBCyAJIAFBAnQiDGoqAgAhOQJAAkAgASADayILQQFrIAdLDQAgOSAMIA5qQQRrKgIAkyI/IDpgQQFzDQAgOyA/YA0BCwJAIAcgC0kNACA5IAwgDmoqAgCTIj8gOmBBAXMNACA7ID9gDQELIAcgC0EBakkEQCABIQYMAgsgOSAMIA5qKgIEkyI5IDpgQQFzBEAgASEGDAILIDkgO19BAXNFDQAgASEGDAELIAYgADoAACABIQICQCAFIAFBAWsiBmoiCy0AAA0AA0AgCSAGQQJ0aioCACAJIAJBAnRqKgIAkyI5IDpgQQFzDQEgOSA7X0EBcw0BIAsgADoAACAGIQIgBSAGQQFrIgZqIgstAABFDQALCyABIQsCQCAFIAFBAWoiBmoiDC0AAA0AA0AgASELAkAgCSAGIgFBAnQiEGoqAgAiPyAJIAtBAnQiBmoqAgCTIjkgOmBBAXNFQQAgOSA7XxsNAAJAIAEgA2siGEEBayAHSw0AID8gBiAOaioCAJMiOSA6YEEBcw0AIDkgO18NAQsCQCAHIBhJDQAgPyAOIBBqKgIAkyI5IDpgQQFzDQAgOSA7Xw0BCyAHIBhBAWpJBEAgASEGDAMLID8gBiAOaioCCJMiOSA6YEEBcwRAIAEhBgwDCyA5IDtfQQFzRQ0AIAEhBgwCCyAMIAA6AAAgASELIAUgAUEBaiIGaiIMLQAARQ0ACwsgCiAfOwEKIAogFDsBCCAKIAM7AQYgCiALOwEEIAogAjsBAiAKIBE7AQAgCkEMaiIKIA9HDQACQCAIKALEAiILIAgoAsACIgFrQQxtIgpBA2xBAXYiDCAKSwRAIAhBwAJqIAwgCmsQhgsgCCgCxAIhCyAIKALAAiEBDAELIAogDE0NACAIIAEgDEEMbGoiCzYCxAILIAEgDyAVa0EMbUEMbGohCiALIQ8gASEVCyAGQQFqIQEgBiANSA0ACwsgGkEBaiIaQQNHBEAgCEEwaiAaQQxsaiIJKAIIIQ0gCSgCBCEBIAkoAgAhBgwBCwsgGSAbSCEFIBkgHEohBiADIBZIIQsgFCAXSiENAkAgLw0AIBQgAyIBSQ0AA0AgDiABQQJ0aiBBOAIAIAEgFEchCSABQQFqIQEgCQ0ACwsgGSAbIAUbIRsgGSAcIAYbIRwgAyAWIAsbIRYgFCAXIA0bIRcgByAgaiEgIAogFUcNAAsgHCAba0EBaiEBIBshJyAXIBZrQQFqDAQLICUoAjAiKSAlKAIQakEBaiIwICkgAikCACI3QiCIIjinIidsaiIJIDenIhZqIgEtAAANAUEAIAgoAoQCayENQQAgCCgCjAJrIQpBACAIKAKIAmshAiAIKALYASEsIAgoArgBIS0gCCgC7AEhBiAIKALoASELIAgoAsQCIRsgCCgCwAIhJCAIKALkASEMIAgoAqgCITEgCCgCpAIhMiAIKAKgAiEqIAEgADoAACAJIBZBAWoiDmoiAy0AACEPIC0gJyAsbGoiBSAWQQxsaiIBKAIIIRAgASgCBCEYIAEoAgAhFAJAIAdBgIAEcSIzBEAgFiErAkAgD0H/AXENAANAIAUgDiIHQQxsaiIBKAIIIBBrIg4gBkoNASAKIA5KDQEgASgCBCAYayIOIAtKDQEgASgCACAUayIBIA1IDQEgASAMSg0BIAIgDkoNASADIAA6AAAgByErIAkgB0EBaiIOaiIDLQAARQ0ACwsgCSAWQQFrIgdqIg4tAAANAQNAIAUgByIBQQxsaiIHKAIIIBBrIgMgBkoNAiADIApIDQIgBygCBCAYayIDIAtKDQIgBygCACAUayIHIA1IDQIgByAMSg0CIAIgA0oNAiAOIAA6AAAgASEWIAkgAUEBayIHaiIOLQAARQ0ACwwBCyAWISsCQCAPQf8BcQ0AIBAhDyAYIREgFCEaA38gBSAOIgdBDGxqIgEoAgggD2siDiAGSg0BIAogDkoNASABKAIEIBFrIg4gC0oNASABKAIAIBprIg8gDUgNASAMIA9IDQEgAiAOSg0BIAMgADoAACAJIAdBAWoiDmoiAy0AAAR/IAcFIAEoAgghDyABKAIEIREgASgCACEaIAchKwwBCwshKwsgCSAWQQFrIgdqIgMtAAANAANAIAUgByIBQQxsaiIHKAIIIAUgFkEMbGoiDigCCGsiDyAGSg0BIAcoAgQgDigCBGsiESALSg0BIAcoAgAgDigCAGsiByANSA0BIAcgDEoNASACIBFKDQEgCiAPSg0BIAMgADoAACABIRYgCSABQQFrIgdqIgMtAABFDQALCyAkQQE7AQogJCArOwEIICQgKzsBBCAkIBY7AQIgJCA4PQEAICQgK0EBajsBBiAbICRBDGoiA0YEQAJAIAgoAsQCIhsgCCgCwAIiJGtBDG0iAUEDbEEBdiIJIAFLBEAgCEHAAmogCSABaxCGCyAIKALEAiEbIAgoAsACISQMAQsgASAJTQ0AIAggJCAJQQxsaiIbNgLEAgsgJEEMaiEDCyAmQQhGITUgJkEIRiEuICchJgNAIANBDGsiAy8BACEoIAMvAQIhHyADLwEGIQEgAy4BCiEJIAMvAQghBSAIIAMvAQQiFyA1aiIaNgJQIAggBUEBajYCTCAIIAk2AkggCCABQQFrNgJEIAggHyA1ayIBNgJAIAggCTYCPCAIIBo2AjggCCABNgI0IAhBACAJayIHNgIwIBcgH2shIiAgQQFqITYgLSAoICxsaiEeQQAhIANAIDAgByAoaiIcIClsaiEFIC0gHCAsbGohCQJAIDMEQCABIBpKDQFBACAHayEZA0ACQCABIAVqIgctAAAEQCABIQcMAQsgBiAJIAFBDGxqIg4oAgggEGsiD0gEQCABIQcMAQsgCiAPSgRAIAEhBwwBCyALIA4oAgQgGGsiD0gEQCABIQcMAQsgDSAOKAIAIBRrIg5KBEAgASEHDAELIAwgDkgEQCABIQcMAQsgAiAPSgRAIAEhBwwBCyAHIAA6AAAgASEVAkAgBSABQQFrIgdqIg8tAAANAANAIAkgByIOQQxsaiIHKAIIIBBrIhEgBkoNASAKIBFKDQEgBygCBCAYayIRIAtKDQEgBygCACAUayIHIA1IDQEgByAMSg0BIAIgEUoNASAPIAA6AAAgDiEVIAUgDkEBayIHaiIPLQAARQ0ACwsCQCAFIAFBAWoiB2oiDy0AAA0AA0AgBiAJIAdBDGxqIg4oAgggEGsiEUgNASAKIBFKDQEgCyAOKAIEIBhrIhFIDQEgDSAOKAIAIBRrIg5KDQEgDCAOSA0BIAIgEUoNASAPIAA6AAAgBSAHIgFBAWoiB2oiDy0AAEUNAAsLIAMgGTsBCiADIBc7AQggAyAfOwEGIAMgATsBBCADIBU7AQIgAyAcOwEAIANBDGoiAyAbRw0AAkAgCCgCxAIiDyAIKALAAiIBa0EMbSIOQQNsQQF2IgMgDksEQCAIQcACaiADIA5rEIYLIAgoAsQCIQ8gCCgCwAIhAQwBCyADIA5PDQAgCCABIANBDGxqIg82AsQCCyABIBsgJGtBDG1BDGxqIQMgDyEbIAEhJAsgB0EBaiEBIAcgGkgNAAsMAQsgLkUEQCABIBpKDQFBACAHayEhA0ACQCABIAVqIgctAAAEQCABIQcMAQsgBiAJIAFBDGwiD2oiDigCCCAPIB5qIg8oAghrIhFIBEAgASEHDAELIAsgDigCBCAPKAIEayIVSARAIAEhBwwBCyANIA4oAgAgDygCAGsiDkoEQCABIQcMAQsgDCAOSARAIAEhBwwBCyACIBVKBEAgASEHDAELIAogEUoEQCABIQcMAQsgByAAOgAAIAEhEQJAIAUgAUEBayIHaiIVLQAADQADQCAJIAciD0EMbGoiBygCCCAJIBFBDGxqIg4oAghrIhkgBkoNASAHKAIEIA4oAgRrIhMgC0oNASAHKAIAIA4oAgBrIgcgDUgNASAHIAxKDQEgAiATSg0BIAogGUoNASAVIAA6AAAgBSAPIhFBAWsiB2oiFS0AAEUNAAsLAkAgBSABQQFqIgdqIhktAAANAANAIAkgByIOQQxsIh1qIgcoAgAhFSAHKAIEIQ8CQAJAIAcoAggiEiAJIAFBDGxqIgcoAghrIhMgBkoNACAPIAcoAgRrIiMgC0oNACAVIAcoAgBrIgcgDUgNACAHIAxKDQAgAiAjSg0AIAogE0wNAQsgCiASIB0gHmoiBygCCGsiE0oEQCAOIQcMAwsgCyAPIAcoAgRrIg9IBEAgDiEHDAMLIA0gFSAHKAIAayIHSgRAIA4hBwwDCyAHIAxKBEAgDiEHDAMLIAIgD0oEQCAOIQcMAwsgASAXTgRAIA4hBwwDCyAGIBNODQAgDiEHDAILIBkgADoAACAFIA4iAUEBaiIHaiIZLQAARQ0ACwsgAyAhOwEKIAMgFzsBCCADIB87AQYgAyABOwEEIAMgETsBAiADIBw7AQAgA0EMaiIDIBtHDQACQCAIKALEAiIPIAgoAsACIgFrQQxtIg5BA2xBAXYiAyAOSwRAIAhBwAJqIAMgDmsQhgsgCCgCxAIhDyAIKALAAiEBDAELIAMgDk8NACAIIAEgA0EMbGoiDzYCxAILIAEgGyAka0EMbUEMbGohAyAPIRsgASEkCyAHQQFqIQEgByAaSA0ACwwBCyABIBpKDQBBACAHayE0A0ACQCABIAVqIgctAAAEQCABIQcMAQsgCSABQQxsIg9qIg4oAgghESAOKAIEIRUgDigCACEZAkACQCABIB9rIg5BAWsgIksNACARIA8gHmpBDGsiEygCCGsiHSAGSg0AIAogHUoNACAVIBMoAgRrIh0gC0oNACAZIBMoAgBrIhMgDUgNACAMIBNIDQAgAiAdTA0BCwJAIA4gIksNACARIA8gHmoiEygCCGsiHSAGSg0AIAogHUoNACAVIBMoAgRrIh0gC0oNACAZIBMoAgBrIhMgDUgNACAMIBNIDQAgAiAdTA0BCyAiIA5BAWpJBEAgASEHDAILIAYgESAPIB5qIg4oAhRrIg9IBEAgASEHDAILIAogD0oEQCABIQcMAgsgCyAVIA4oAhBrIg9IBEAgASEHDAILIA0gGSAOKAIMayIOSgRAIAEhBwwCCyAMIA5IBEAgASEHDAILIAIgD0wNACABIQcMAQsgByAAOgAAIAEhGQJAIAUgAUEBayIHaiIRLQAADQADQCAJIAciD0EMbGoiBygCCCAJIBlBDGxqIg4oAghrIhUgBkoNASAHKAIEIA4oAgRrIhMgC0oNASAHKAIAIA4oAgBrIgcgDUgNASAHIAxKDQEgAiATSg0BIAogFUoNASARIAA6AAAgDyEZIAUgD0EBayIHaiIRLQAARQ0ACwsgASEOAkAgBSABQQFqIgdqIhEtAAANAANAIAEhDiAJIAciAUEMbCIjaiIHKAIAIRUgBygCBCEPAkACQCAHKAIIIh0gCSAOQQxsIhJqIgcoAghrIhMgBkoNACAKIBNKDQAgDyAHKAIEayITIAtKDQAgFSAHKAIAayIHIA1IDQAgByAMSg0AIAIgE0wNAQsCQCABIB9rIgdBAWsgIksNACAdIBIgHmoiEygCCGsiISAGSg0AIAogIUoNACAPIBMoAgRrIiEgC0oNACAVIBMoAgBrIhMgDUgNACAMIBNIDQAgAiAhTA0BCwJAIAcgIksNACAdIB4gI2oiEygCCGsiIyAGSg0AIAogI0oNACAPIBMoAgRrIiMgC0oNACAVIBMoAgBrIhMgDUgNACAMIBNIDQAgAiAjTA0BCyAiIAdBAWpJBEAgASEHDAMLIAYgHSASIB5qIgcoAiBrIhNIBEAgASEHDAMLIAogE0oEQCABIQcMAwsgCyAPIAcoAhxrIg9IBEAgASEHDAMLIA0gFSAHKAIYayIHSgRAIAEhBwwDCyAHIAxKBEAgASEHDAMLIAIgD0wNACABIQcMAgsgESAAOgAAIAEhDiAFIAFBAWoiB2oiES0AAEUNAAsLIAMgNDsBCiADIBc7AQggAyAfOwEGIAMgDjsBBCADIBk7AQIgAyAcOwEAIANBDGoiAyAbRw0AAkAgCCgCxAIiDyAIKALAAiIBa0EMbSIOQQNsQQF2IgMgDksEQCAIQcACaiADIA5rEIYLIAgoAsQCIQ8gCCgCwAIhAQwBCyADIA5PDQAgCCABIANBDGxqIg82AsQCCyABIBsgJGtBDG1BDGxqIQMgDyEbIAEhJAsgB0EBaiEBIAcgGkgNAAsLICBBAWoiIEEDRwRAIAhBMGogIEEMbGoiCSgCCCEaIAkoAgQhASAJKAIAIQcMAQsLICcgKEohBSAmIChIIQcgFiAfSiEOIBcgK0ohDwJAIC8NACAfIgEgF0sNAANAIB4gAUEMbGoiCSAxNgIIIAkgMjYCBCAJICo2AgAgASAXRyEJIAFBAWohASAJDQALCyAoICcgBRshJyAoICYgBxshJiAfIBYgDhshFiAXICsgDxshKyAiIDZqISAgAyAkRw0ACyAmICdrQQFqIQEgKyAWa0EBagwDCyAlKAIwIhcgJSgCEGpBAWoiGyAXIAIpAgAiN0IgiCI4pyInbGoiASA3pyIWaiIJLQAADQBBACAIKAKEAmshBiAIKALYASEfIAgoArgBISMgCCgCxAIhGSAIKALAAiEeIAgoAuQBIQogCCgCoAIhISAJIAA6AAAgASAWQQFqIgVqIgstAAAhDSAjIB8gJ2xqIgkgFkECdGooAgAhDgJAAkACQCAHQYCABHEiHARAIBYhKCANQf8BcQ0CIAkgBUECdGooAgAgDmsiDSAGSA0CIAogDUgNAgwBCyAWISgCQCANQf8BcQ0AIAkgBUECdGoiDSgCACAOayIMIAZIDQAgCiAMSA0AA0AgCyAAOgAAIAEgBSIoQQFqIgVqIgstAAANASAJIAVBAnRqIgwoAgAgDSgCAGsiAiAGSA0BIAwhDSACIApMDQALCyABIBZBAWsiC2oiDS0AAA0CA0AgCSALIgVBAnRqKAIAIAkgFkECdGooAgBrIgsgBkgNAyAKIAtIDQMgDSAAOgAAIAUhFiABIAVBAWsiC2oiDS0AAEUNAAsMAgsDQCALIAA6AAAgASAFIihBAWoiBWoiCy0AAA0BIAkgBUECdGooAgAgDmsiDSAGSA0BIAogDU4NAAsLIAEgFkEBayIFaiILLQAADQAgCSAFQQJ0aigCACAOayINIAZIDQAgCiANSA0AA0AgCyAAOgAAIAEgBSIWQQFrIgVqIgstAAANASAJIAVBAnRqKAIAIA5rIg0gBkgNASAKIA1ODQALCyAeQQE7AQogHiAoOwEIIB4gKDsBBCAeIBY7AQIgHiA4PQEAIB4gKEEBajsBBiAZIB5BDGoiDUYEQAJAIAgoAsQCIhkgCCgCwAIiHmtBDG0iAUEDbEEBdiIJIAFLBEAgCEHAAmogCSABaxCGCyAIKALEAiEZIAgoAsACIR4MAQsgASAJTQ0AIAggHiAJQQxsaiIZNgLEAgsgHkEMaiENCyAmQQhGIS0gJkEIRiEkICchLANAIA1BDGsiDS8BACESIA0vAQIhESANLwEGIQEgDS4BCiEJIA0vAQghBSAIIA0vAQQiFSAtaiICNgJQIAggBUEBajYCTCAIIAk2AkggCCABQQFrNgJEIAggESAtayIBNgJAIAggCTYCPCAIIAI2AjggCCABNgI0IAhBACAJayILNgIwIBUgEWshGCAgQQFqISkgIyASIB9saiEUQQAhHQNAIBsgCyASaiITIBdsaiEFICMgEyAfbGohCQJAIBwEQCABIAJKDQFBACALayEQA0ACQCABIAVqIgstAAAEQCABIQsMAQsgBiAJIAFBAnRqKAIAIA5rIgxKBEAgASELDAELIAogDEgEQCABIQsMAQsgCyAAOgAAIAEhAwJAIAUgAUEBayILaiIMLQAADQAgCSALQQJ0aigCACAOayIHIAZIDQAgByAKSg0AA0AgDCAAOgAAIAUgCyIDQQFrIgtqIgwtAAANASAJIAtBAnRqKAIAIA5rIgcgBkgNASAHIApMDQALCwJAIAUgAUEBaiILaiIMLQAADQAgCSALQQJ0aigCACAOayIHIAZIDQAgByAKSg0AA0AgDCAAOgAAIAUgCyIBQQFqIgtqIgwtAAANASAJIAtBAnRqKAIAIA5rIgcgBkgNASAHIApMDQALCyANIBA7AQogDSAVOwEIIA0gETsBBiANIAE7AQQgDSADOwECIA0gEzsBACANQQxqIg0gGUcNAAJAIAgoAsQCIgwgCCgCwAIiAWtBDG0iDUEDbEEBdiIHIA1LBEAgCEHAAmogByANaxCGCyAIKALEAiEMIAgoAsACIQEMAQsgByANTw0AIAggASAHQQxsaiIMNgLEAgsgASAZIB5rQQxtQQxsaiENIAwhGSABIR4LIAtBAWohASACIAtKDQALDAELICRFBEAgASACSg0BQQAgC2shGgNAAkAgASAFaiILLQAABEAgASELDAELIAYgCSABQQJ0IgxqKAIAIAwgFGooAgBrIgxKBEAgASELDAELIAogDEgEQCABIQsMAQsgCyAAOgAAIAEhDAJAIAUgAUEBayILaiIHLQAADQADQCAJIAtBAnRqKAIAIAkgDEECdGooAgBrIgMgBkgNASADIApKDQEgByAAOgAAIAshDCAFIAtBAWsiC2oiBy0AAEUNAAsLAkAgBSABQQFqIgtqIgctAAANAANAAkAgBiAJIAtBAnQiEGooAgAiDyAJIAFBAnRqKAIAayIDTEEAIAMgCkwbDQAgBiAPIBAgFGooAgBrIgNKDQIgASAVTg0CIAMgCkwNAAwCCyAHIAA6AAAgBSALIgFB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IgRFDQAgBC0ADA0AIARBDGohBAwCCwJAIAEgAygCAEYEQCADIQQMAQsgAyADKAIEIgQoAgAiATYCBCAEIAEEfyABIAM2AgggAygCCAUgAgs2AgggAygCCCICIAIoAgAgA0dBAnRqIAQ2AgAgBCADNgIAIAMgBDYCCCAEKAIIIQILIARBAToADCACQQA6AAwgAiACKAIAIgMoAgQiBDYCACAEBEAgBCACNgIICyADIAIoAgg2AgggAigCCCIEIAQoAgAgAkdBAnRqIAM2AgAgAyACNgIEIAIgAzYCCA8LAkAgBEUNACAELQAMDQAgBEEMaiEEDAELAkAgASADKAIARwRAIAMhAQwBCyADIAEoAgQiBDYCACABIAQEfyAEIAM2AgggAygCCAUgAgs2AgggAygCCCICIAIoAgAgA0dBAnRqIAE2AgAgASADNgIEIAMgATYCCCABKAIIIQILIAFBAToADCACQQA6AAwgAiACKAIEIgMoAgAiBDYCBCAEBEAgBCACNgIICyADIAIoAgg2AgggAigCCCIEIAQoAgAgAkdBAnRqIAM2AgAgAyACNgIAIAIgAzYCCAwCCyADQQE6AAwgAiAAIAJGOgAMIARBAToAACACIQEgACACRw0ACwsLSgEBf0EgENUaIgFCADcCBCABQpCAgIAQNwIYIAFChICAgIABNwIQIAFB7JIENgIAIAFB4JMENgIMIAAgATYCBCAAIAFBDGo2AgALkwIBBH8jAEHQAGsiAyQAIANBmJgELQAAOgAsIANBlJgEKAAANgIoIAMgA0EoajYCJEEBIQQgAyACKAIIQQFHBH8gASgCEEUFIAQLOgAjIANBADoAIiACKAIAIQVBsAEQ1RoiBEIANwIEIARB0JQENgIAIANBOGoiBiACNgIAIAMgAUEMaiABQQhqIAVBB3FBBkYbIgI2AkggAyACNgIYIAMgA0EkajYCPCADIAYpAwA3AwggAyADQSJqNgJEIANBQGsiAiADQSNqNgIAIAMgAikDADcDECADQcaUBDYCNCADQcSUBDYCMCADIAMpAzA3AwAgBEEMaiICIAMQkAsgACAENgIEIAAgAjYCACADQdAAaiQAC/4CAQV/IwBB4ABrIgIkAAJAIAEoAgAiBRC4GyIDQXBJBEACQAJAIANBC08EQCADQRBqQXBxIgYQ1RohBCACIAZBgICA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CwsgAwu7AQEEfyABQQRIBH9BAAUgAUEEayEFA0AgAyAAIARBA3QiAmorAwBEAAAAAAAAAABiaiAAIAJBCHJqKwMARAAAAAAAAAAAYmogACACQRByaisDAEQAAAAAAAAAAGJqIAAgAkEYcmorAwBEAAAAAAAAAABiaiEDIARBBGoiBCAFTA0ACyABQXxxCyICIAFIBEADQCADIAAgAkEDdGorAwBEAAAAAAAAAABiaiEDIAJBAWoiAiABRw0ACwsgAwuoAgEFfyMAQfAAayIBJAACQAJAIAAQywdB+B9xRQRAAkAgABDMB0GAgARGBEAgAUE4aiAAKAIEEK0GGgwBCyABQThqIAAQyQcLIAEoAjhBB3EiAEEHRg0BIAFBADYCNCABIAFBOGo2AjAgAUEANgIsIAFBCGogAUEwaiABQSxqQX8QrAciAigCEEUEQEEAIQAMAwsgAEECdEHQogRqKAIAIQQgAigCFCEFQQAhAANAIAEoAiwgBSAEEQMAIABqIQAgAhCtByADQQFqIgMgAigCEEkNAAsMAgtBqX4gAUE4akHwogQQiQNB+KIEQYWjBEGAARCYCgALQal+IAFBCGpBt6MEEIkDQfiiBEGFowRBkAEQmAoACyABQThqELEGGiABQfAAaiQAIAALmgcCEn8EfCMAQfAJayIDJAACQCABEMwHQYCABEYEQCADQbgJaiABKAIEEK0GGgwBCyADQbgJaiABEMkHCwJAIAIQzAdBgIAERgRAIANBgAlqIAIoAgQQrQYaDAELIANBgAlqIAIQyQcLAkACQCADQYAJahC3BkUEQCADLwGACUH/H3ENAQsgAygCuAkhASADQfgIakIANwMAIANB8AhqQgA3AwAgA0HoCGpCADcDACADQgA3A+AIIAFBB3EiAkECdEHwswNqKAIAIQ4gAUEDdkH/A3EiCkEDSw0BIA5FDQEgCkEBaiEPIANBADYC3AggAyADQYAJajYC2AggAyADQbgJajYC1AggA0IANwPICCADQagIaiADQdQIaiADQcgIakF/EKwHIggoAhQhBCADQYgCNgIEIAMgA0EIaiIQNgIAIANB4AhqIQUgBCEGIAJBA00EQCADIA82AgQgEEEAIApBAnRBBGoQrxshAUGAgIAEQYCAAiACQQJJGyIRIAQgBCARShshBiADKAK8CSIFQQFOBEAgAygC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IANBgApqQQBB2AEQrxsaDAsLRAAAAAAAAAAAIRAgAkUNCSADQYAKakEAQdgBEK8bGiADQoCAgICAgIDwv383A/gKIANCgICAgICAgPC/fzcDmAsgA0KAgICAgICA8D83A6gLIANCgICAgICAgPC/fzcDqAogA0KAgICAgICA8D83A9gKIANCgICAgICAgPA/NwO4CgwJC0QAAAAAAADwPyAPIA+goyEQIAIEQCADQgA3A6ADIANCADcDmAMgA0IANwOQAyADQgA3A8gDIANCADcD0AMgA0IANwPoAyADQgA3A/ADIANCADcDiAQgA0IANwOQBCADQgA3A4gDIANCADcDgAMgA0IANwPAAyADQoCAgICAgID4v383A7gDIANCADcDsAMgA0KAgICAgICA+D83A6gDIANCADcD4AMgA0KAgICAgICA+L9/NwPYAyADQgA3A4AEIANCgICAgICAgPg/NwP4AyADQgA3A7gEIANCADcDwAQgA0IANwPIBCADQgA3A9AEIANCADcD8AQgA0IANwPoBCADQgA3A5AFIANCADcDiAUgA0KAgICAgICA+L9/NwOoBCADQgA3A6AEIANCgICAgICAgPg/NwOYBCADQgA3A7AEIANCADcD4AQgA0IANwOABSADRAAAAAAAAPC/IA+jIhdEAAAAAAAA4D+iIhY5A6AFIAMgFyAVIBCaoiAPo0QAAAAAAADgP6KiIg85A9gEIAMgDzkD+AQgAyAPOQOYBSADQgA3A7gFIANCADcDsAUgA0IANwOoBSADIBY5A8AFIANCADcD2AUgA0IANwPQBSADQgA3A8gFIAMgFjkD4AUgA0IANwPgBiADQgA3A/gGIANCADcDoAcgA0IANwOoByADQgA3A8gHIANCADcD0AcgA0IANwPYByADQgA3A+AHIANCADcD2AYgAyAQOQPQBiADQgA3A/AGIANCADcDmAcgA0IANwOIByADIBA5A4AHIANCADcDwAcgAyAQOQOwByADIBE5A7gHIAMgFDkD6AYgAyASOQOQByADQoCAgICAgID4PzcD6AcgA0IANwOwAiADQgA3A+gCIANCADcDqAIgAyATOQOgAiADQgA3A+ACIAMgEiAQojkD2AIgA0IANwPQAiADIBM5A8gCIANCADcDwAIgAyAUIBCiOQO4AiADIBEgEKI5A/gCIAMgEzkD8AIgA0KGgImShAk3A4ACIANChYCAgJABNwKUAiADQgA3A4gCIAMgA0GAA2o2ApACIANChoCJkoQFNwPgASADQoSAgIDQADcC9AEgA0IANwPoASADIANB0AZqNgLwASADQoaAiZKEBDcDwAEgA0KDgICAwAA3AtQBIANCADcDyAEgAyADQaACajYC0AEgA0KGgImShAU3AyAgA0KDgICA0AA3AjQgA0IANwMoIAMgA0FAazYCMCADQcABaiADQeABakQAAAAAAADwP0EARAAAAAAAAPA/IANBIGpBABCGBiADQSBqIANBgAJqRAAAAAAAAPA/QQBEAAAAAAAA8D8gA0HgCWpBABCGBiADKwOYCiEPIAMgAysDiAo5A5gKIAMgDzkDiAogAysDkAohDyADIAMrA7AKOQOQCiADIA85A7AKIAMrA6gKIQ8gAyADKwO4CjkDqAogAyAPOQO4CiADKwPQCiEPIAMgAysD4Ao5A9AKIAMgDzkD4AogAysD2AohDyADIAMrA/gKOQPYCiADIA85A/gKIAMrA4ALIQ8gAyADKwPwCjkDgAsgAyAPOQPwCiADKwOoCyEPIAMgAysDmAs5A6gLIAMgDzkDmAsgAysDwAshDyADIAMrA6ALOQPACyADIA85A6ALIAMrA8gLIQ8gAyADKwO4CzkDyAsgAyAPOQO4CwsgESAQIBOiIhOiIRAgEiAToiERIBQgE6IhFAwJCyAcIBaiIRIgGCAWoiETIBYgGaIhD0EAIQBEAAAAAAAA8D8hFANAIABBA3QiAUHIAGoiBCADQYAKamogDyAUoiATIANBQGsgAWorAwCioCAQIANBgANqIARqKwMAoqAgEiADQaACaiABaisDAKKgIBEgA0HQBmogBGorAwCioDkDACAAQQFqIgBBCUZFBEAgA0GwCGogAEEDdGorAwAhFAwBCwsgHCAXoiESIBggF6IhEyAXIBmiIQ9BACEARAAAAAAAAPA/IRQDQCAAQQN0IgFBkAFqIgQgA0GACmpqIA8gFKIgEyADQUBrIAFqKwMAoqAgECADQYADaiAEaisDAKKgIBIgA0GgAmogAWorAwCioCARIANB0AZqIARqKwMAoqA5AwAgAEEBaiIAQQlGDQsgA0GwCGogAEEDdGorAwAhFAwACwALQa5+IANBgANqQe6lBBCJA0GxpQRB46QEQYsC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hAEgAEEBOgCAASAAQgE3A3ggACAIOQNwIAZBQGskAAvHBQECfyAAQQA2AgAgACgCBCEBIABBADYCBAJAIAFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAQQA2AgggAEEMaiICKAIAIQEgAkEANgIAAkAgAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLIABBADYCECAAQRRqIgIoAgAhASACQQA2AgACQCABRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgsgAEEANgIYIABBHGoiAigCACEBIAJBADYCAAJAIAFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAQQA2AiAgAEEkaiICKAIAIQEgAkEANgIAAkAgAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLIABBADYCKCAAQSxqIgIoAgAhASACQQA2AgACQCABRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgsgAEEANgIwIABBNGoiAigCACEBIAJBADYCAAJAIAFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAQQA2AjggAEE8aiICKAIAIQEgAkEANgIAAkAgAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLIABBADYCQCAAQcQAaiICKAIAIQEgAkEANgIAAkAgAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLIABBADYCSCAAQcwAaiIBKAIAIQAgAUEANgIAAkAgAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQEAIAAQ0BoLC/0DAQJ/IAAQzwsCQCAAKAJMIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCwJAIAAoAkQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLAkAgACgCPCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAg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IARByAFqIARBwAFqELoGIQcgBEIANwNIIAQgBzYCRCAEQYCAhJB8NgJAIAYgBEFAaxCWBCAHELEGGiAGELEGGiACKAIAIQYgAigCBCEHCyAFIAcgBmtIDQALCyAEQgA3A1ggBEGAgIyIeDYCUCAEIAM2AlQgASAEQdAAahC+CyAKQQYQqgYgAygCBCIHIAMoAgAiBmtBAU4EQEEAIQhBACEFA0ACQCAFIAZqLQAARQRAIAVBAWohBQwBCyAEIAU2AgggBCAFQQFqIgU2AgwgBEKAgICA+P////8ANwNAIARB0ABqIAkgBEEIaiAEQUBrELoGIQYgBCAINgLIASAEIAhBAWoiCDYCzAEgBEKAgICA+P////8ANwPAASAEQQhqIAEgBEHIAWogBEHAAWoQugYhByAEQgA3A0ggBCAHNgJEIARBgICEkHw2AkAgBiAEQUBrEJYEIAcQsQYaIAYQsQYaIAMoAgAhBiADKAIEIQcLIAUgByAGa0gNAAsLIAkQsQYaIARB0AFqJAALiQUBAX8jAEGAA2siAyQAIANByAJqIABBABDNBiADQZACaiABQQAQzQYCQCADLwHIAkH4H3ENACADKALQAkF+cUECRw0AIAMoAtQCQQRIDQAgA0IANwPgASADQYCAhAg2AtgBIAMgA0HIAmo2AtwBIANBgICEEDYCoAEgA0IANwOoASADIANByAJqNgKkASADQdgBaiADQaABahC0BwsCQCADLwGQAkH4H3ENACADKAKYAkF+cUECRw0AIAMoApwCQQRIDQAgA0IANwPgASADQYCAhAg2AtgBIAMgA0GQAmo2AtwBIANBgICEEDYCoAEgA0IANwOoASADIANBkAJqNgKkASADQdgBaiADQaABahC0BwsgA0HYAWogAkEAEM0GIANBoAFqQQBBABDNBiADQgA3AyggA0GAgIQINgIgIAMgA0HIAmo2AiQgA0IANwMIIANBgICECDYCACADIANBkAJqNgIEIANCADcDYCADQQA2AlwgA0GAgIAQNgJYIANB6ABqIANBIGogAyADQdgAahDWCwJAIANB6ABqELcGBEAgA0EgaiACQQAQzQYgA0IANwMYIANCADcDECADQgA3AwggA0KBgICAwAA3A2AgA0GGgIiIfDYCWCADQgA3AwAgAyADNgJcIANBIGogA0HYAGpB1NYKEJkEIANBIGoQsQYaDAELIANBgICEkHw2AiAgA0IANwMoIAMoAtgBIQAgAyADQdgBajYCJCADQegAaiADQSBqIABB/x9xRAAAAAAAAPA/RAAAAAAAAAAAEIgDCyADQegAahCxBhogA0GgAWoQsQYaIANB2AFqELEGGiADQZACahCxBhogA0HIAmoQsQYaIANBgANqJAALsAcBBH8jAEHwAWsiAiQAIAJBuAFqIABBABDNBiACQYABaiABQQAQzQYgAkHIAGogAkGAAWoQrQYhAQJAIAIoArgBQQN2Qf8DcSIABEAgAEEBaiEADAELIAIoAsQBIgAgAigCwAEiA0wNACACQgA3AwggAkGAgIQINgIAIAIgAkG4AWo2AgQgAkGAgIQQNgI4IAJCADcDQCACIAJBuAFqNgI8IAIgAkE4ahC0ByADIQALAkAgAigCgAFBA3ZB/wNxIgNBAWogAigCiAEiBCACKAKMASIFIAQgBUgbIAMbIgMgAEYEQCACQYCAhBA2AgAgAkIANwMIIAIgAkGAAWo2AgQgAkG4AWogAhCWBAwBCyAAIANIBEAgAkIANwMIIAJBgICECDYCACACIAJBuAFqNgIEIAJBgICEEDYCOCACQgA3A0AgAiACQYABajYCPCACIAJBOGoQ2QsMAQsgAkIANwMIIAJBgICECDYCACACIAJBuAFqNgIEIAJBgICEEDYCOCACQgA3A0AgAiACQYABajYCPCACIAJBOGoQ1wsLIAIgAkGAAWogASgCAEEDdkH/A3EiAEEBaiABKAIMIgQgASgCCCAARSADIARIcSIAGxDBBiACQYABaiACELkGGiACELEGGgJAAkACQCAABEAgAigCiAEgASgCDEcNAiACKAKMASABKAIIRw0CIAIoAoABIAEoAgBzQf8fcUUEQCACQgA3AwggAkGAgIQINgIAIAIgAkGAAWo2AgQgAiABNgI8IAJBgICEkHw2AjggAkIANwNAIAIgAkE4ahC0BwwCCyACQgA3AwggAkGAgIQINgIAIAIgAkGAAWo2AgQgAkGAgIQQNgI4IAJCADcDQCACIAJBgAFqNgI8IAIgAkE4ahC0ByACQYCAhJB8NgIAIAJCADcDCCACIAE2AgQgAkGAAWogAiABKAIAQf8fcUQAAAAAAADwP0QAAAAAAAAAABCIAwwBCyACKAKoASIAKAIEIAEo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OQOQASABIAArA4gBIAihOQOYASABIAArA6ABIAihOQOgASABIAArA3ggACsDYCIIoTkDqAEgASAAKwOQASAIoTkDsAEgASAAKwOoASAIoTkDuAEgASAAKwOAASAAKwNoIgihOQPAASABIAArA5gBIAihOQPIASABIAArA7ABIAihOQPQASABQSBqIAEQtwQgACgCUCIFQQFOBEAgACgCOCEGIAAoAiAhBwNAIAYgA0EFdGoiBCABKwNAIAcgA0EYbGoiAisDACAAKwNYoaIgASsDSCACKwMIIAArA2ChoqAgASsDUCACKwMQIAArA2ihoqAiCDkDCCAEIAErA1ggAisDACAAKwNYoaIgASsDYCACKwMIIAArA2ChoqAgASsDaCACKwMQIAArA2ihoqAiCTkDECAEIAErA3AgAisDACAAKwNYoaIgASsDeCACKwMIIAArA2ChoqAgASsDgAEgAisDECAAKwNooaKgIgo5AxggBEQAAAAAAADwPyAIoSAJoSAKoTkDACADQQFqIgMgBUcNAAsLIAFB4AFqJAALqAMBAnwgACsDECEGIAMrAwAhByABKAIQIAJB4ABsaiIBQgA3AwggASAHIAaiOQMAIAMrAwAhBiAAKwMAIQcgAUIANwNgIAEgBiAHIAShojkDECABIAMrAwAgACsDGKI5A2ggASADKwMAIAArAwggBaGiOQNwIAArAxAhBiADKwMIIQcgAUIANwMgIAEgByAGojkDGCADKwMIIQYgACsDACEHIAFCADcDeCABIAYgByAEoaI5AyggASADKwMIIAArAxiiOQOAASABIAMrAwggACsDCCAFoaI5A4gBIAArAxAhBiADKwMQIQcgAUIANwM4IAEgByAGojkDMCADKwMQIQYgACsDACEHIAFCADcDkAEgASAGIAcgBKGiOQNAIAEgAysDECAAKwMYojkDmAEgASADKwMQIAArAwggBaGiOQOgASAAKwMQIQYgAysDGCEHIAFCADcDUCABIAcgBqI5A0ggAysDGCEGIAArAwAhByABQgA3A6gBIAEgBiAHIAShojkDWCABIAMrAxggACsDGKI5A7ABIAEgAysDGCAAKwMIIAWhojkDuAELwAICBH8MfCAAQbgBakEAQeAAEK8bIQYDQCAGIBIgASAFQQN0aiIDKwMAIAJBCyAFa0HgAGxqIgQrAwCioCISOQMAIAAgESADKwMAIAQrAwiioCIROQPAASAAIBAgAysDACAEKwMQoqAiEDkDyAEgACAPIAMrAwAgBCsDGKKgIg85A9ABIAAgDiADKwMAIAQrAyCioCIOOQPYASAAIA0gAysDACAEKwMooqAiDTkD4AEgACAMIAMrAwAgBCsDMKKgIgw5A+gBIAAgCyADKwMAIAQrAziioCILOQPwASAAIAogAysDACAEKwNAoqAiCjkD+AEgACAJIAMrAwAgBCsDSKKgIgk5A4ACIAAgCCADKwMAIAQrA1CioCIIOQOIAiAAIAcgAysDACAEKwNYoqAiBzkDkAIgBUEBaiIFQQRHDQALC+YBAQZ/IAAoAlAiBEEBTgRAIAAoAkQhBSAAKAI4IQYDQCAFIAJBGGxqIgMgBiACQQV0aiIBKwMAIAArA7gBoiABKwMIIAArA9ABoqAgASsDECAAKwPoAaKgIAErAxggACsDgAKioDkDACADIAErAwAgACsDwAGiIAErAwggACsD2AGioCABKwMQIAArA/ABoqAgASsDGCAAKwOIAqKgOQMIIAMgASsDACAAKwPIAaIgASsDCCAAKwPgAaKgIAErAxAgACsD+AGioCABKwMYIAArA5ACoqA5AxAgAkEBaiICIARHDQALCwuNCwIFfw18IwBBkB1rIgMkACAAEJ4MIAAQnwwgAyAAKAJQQQF0QQxBBhD3AyIFNgKMHSAAKAJQQQFOBEADQCAAIAUgBEEBdCAAKAI4IARBBXRqIAAoAiwiByAEQQR0IgZqKwMAIAcgBkEIcmorAwAQoAwgBEEBaiIEIAAoAlBIDQALCyADQYAUakEAQYAJEK8bGiADQaATakEAQeAAEK8bGiADQaAKakEAQYAJEK8bGiADQoaAiZKEDDcDgAogA0KMgICAwAE3ApQKIANCADcDiAogAyADQYAUajYCkAogA0KGgImShAE3A+AJIANCjICAgBA3AvQJIANCADcD6AkgAyADQaATajYC8AkgA0KGgImShAw3A8AJIANCjICAgMABNwLUCSADQgA3A8gJIAMgA0GgCmo2AtAJIAUgA0GACmpBABCHBiADQYAKaiADQeAJaiADQcAJakEAQQMQuQQgA0GMHWoQ+wMgA0HgBWpBAEHgAxCvGxogA0HYBWoiBEIANwMAIANB0AVqIgdCADcDACADQcgF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+AIgAyAPIAUrAxAgHKEgBCsDECAQoaKgIg85A4ADIAZBAWoiBiAHRw0ACwsgA0HgAGogA0FAayADQSBqIANBARC5BCABIAMrA9ABIhMgAysDgAEiFKIgAysD2AEiCyADKwOIASIVoqAgAysD4AEiDCADKwOQASIWoqAiDzkDACABIBMgAysDmAEiF6IgCyADKwOgASIdoqAgDCADKwOoASIeoqAiCjkDCCABIBMgAysDsAEiGKIgCyADKwO4ASIZoqAgDCADKwPAASILoqAiEzkDECABIBggAysD6AEiDKIgGSADKwPwASIaoqAgCyADKwP4ASIboqAiHzkDKCABIAwgF6IgGiAdoqAgGyAeoqAiIDkDICABIAwgFKIgGiAVoqAgGyAWoqAiGjkDGCABQUBrIBggAysDgAIiG6IgGSADKwOIAiIYoqAgCyADKwOQAiIZoqAiCzkDACABIBsgF6IgGCAdoqAgGSAeoqAiDDkDOCABIBsgFKIgGCAVoqAgGSAWoqAiFDkDMCAPICCiIAuiIAogH6IgFKKgIBMgGqIgDKKgIBQgICAToqKhIAsgCiAaoqKhIA8gH6IgDKKhRAAAAAAAAAAAYwRAIAEgC5o5A0AgASAMmjkDOCABIBSaOQMwCyACIBEgDyANoiAKIA6ioCATIBCioKE5AwAgAiASIA0gASsDGKIgDiABKwMgoqAgECABKwMooqChOQMIIAIgHCANIAErAzCiIA4gASsDOKKgIBAgASsDQKKgoTkDECADQZADaiQAC8wCAgN/FXwCQCAAKAJQIgNBAUgEQAwBCyABQUBrKwMAIQkgASsDOCEKIAErAyghCyABKwMgIQwgACgCLCEEIAArAxghDSAAKwMIIQ4gACsDECEPIAArAwAhECACKwMQIREgASsDMCESIAIrAwghEyABKwMYIRQgAisDACEVIAErAxAhFiABKwMIIRcgASsDACEYIAAoAiAhBUEAIQEDQCAGIAQgAUEEdCICaisDACAQIBUgGCAFIAFBGGxqIgArAwAiBqIgFyAAKwMIIgeioCAWIAArAxAiCKKgoCAPokQAAAAAAADwPyARIAYgEqIgByAKoqAgCCAJoqCgoyIZoqChIhogGqIgBCACQQhyaisDACAOIBkgEyAGIBSiIAcgDKKgIAggC6KgoCANoqKgoSIGIAaioJ+gIQYgAUEBaiIBIANHDQALCyAGIAO3owvuAwIHfwJ8IwBB8AFrIgMkACADQeAAakEAQZABEK8bGiADQgA3A1AgA0IANwNIIANCADcDQCADQoaAiZKEAzcDICADQoaAgIAwNwI0IANCADcDKCADIANB4ABqNgIwIANChoCJkoQBNwMAIANCg4CAgBA3AhQgA0IANwMIIAMgA0FAazYCECAAKAIEIQggACgCAEH/H3FBBUchCQNAIAQgCGwiBSAAKAIQaiEHAnwgCUUEQCAEQRhsIgYgAygCMGogByoCALs5AwAgAygCMCAGaiAAKAIQIAVqKgIEuzkDCCAAKAIQIAVqKgIIuwwBCyAEQRhsIgYgAygCMGogBysDADkDACADKAIwIAZqIAAoAhAgBWorAwg5AwggACgCECAFaisDEAshCiADKAIwIAZqIAo5AxAgBEEBaiIEQQZHDQALIANBIGogASADELgEAkAgAysDQCIKRAAAAAAAAAAAYwRAIAIgCpqfIgs5AwAgAysDUCIKRAAAAAAAAAAAYyEEIAqaIQoMAQsgAiAKnyILOQMAIAMrA1AiCkQAAAAAAAAAAGQhBAsgAiAKn0QAAAAAAAAAACAEGzkDCCADKwNIRAAAAAAAAAAAY0EBc0UEQCACIAuaOQMACyACQgA3AxAgAkIANwMYIANB8AFqJAAL4wQCB38CfCMAQeACayIDJAAgA0HwAGpBAEHwARCvGxogA0IANwNgIANCADcDWCADQgA3A1AgA0IANwNIIANCADcDQCADQoaAiZKEBTcDICADQoaAgIDQADcCNCADQgA3AyggAyADQfAAajYCMCADQoaAiZKEATcDACADQoWAgIAQNwIUIANCADcDCCADIANBQGs2AhAgACgCBCEIIAAoAgBB/x9xQQVHIQkDQCAGIAhsIgQgACgCEGohBwJ8IAlFBEAgBkEobCIFIAMoAjBqIAcqAgC7OQMAIAMoAjAgBWogACgCECAEaioCBLs5AwggAygCMCAFaiAAKAIQIARqKgIIuzkDECADKAIwIAVqIAAoAhAgBGoqAgy7OQMYIAAoAhAgBGoqAhC7DAELIAZBKGwiBSADKAIwaiAHKwMAOQMAIAMoAjAgBWogACgCECAEaisDCDkDCCADKAIwIAVqIAAoAhAgBGorAxA5AxAgAygCMCAFaiAAKAIQIARqKwMY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IhUrAwA5AxggFSAMKAIAaisDACErIAIgLCAuoiApICqioJo5AyggAiArOQMgIAIgASsDADkDMCACIBQrAwA5AzggAiABIApBAXRqKwMAOQNAIANCADcDUCADQgA3A1ggA0HoAGoiAUIANwMAIANCADcDSCADQoOAgIAwNwNAIANChoD9lyQ3AzggAyABNgJkIAMgA0FAazYCYCADQfAIakEDQQNBBiACQQAQrgYhASADQYCAhBA2ArgBIANCADcDwAEgAyADQThqNgK8ASABIANBuAFqEJYEIAEQsQYaIANBuAFqICEgA0E4ahD/BiADQThqELEGGiADQfAIaiADQbgBaiAgEIEHIAMQpwYhCiADKALwCCIBIANB8AhqIApBfyABKAIAKAIMEQYAIANBOGogChDDCyACIANBOGpByAAQrhshASAKELEGGiAJELEGGiAIELEGGiANELEGGiAQELEGGiARELEGGiASELEGGiABIAErA0AiKUQAAAAAAADwPyApoyIpojkDQCABICkgASsDOKI5AzggASApIAErAzCiOQMwIAEgKSABKwMoojkDKCABICkgASsDIKI5AyAgASApIAErAxiiOQMYIAEgKSABKwMQojkDECABICkgASsDCKI5AwggASABKwMAICmiOQMAIAUQsQYaIAQQsQYaIAAQsQYaIAYQsQYaIA8QsQYaIAsQsQYaIAcQsQYaIBoQsQYaIB8QsQYaIB4QsQYaIB0QsQYaIBwQsQYaIBsQsQYaICYQsQYaIBgQsQYaIBkQsQYaIBcQsQYaIBYQsQYaICUQsQYaICQQsQYaICMQsQYaICIQsQYaICgQsQYaICEQsQYaICAQsQYaICcQsQYaIBMQsQYaIA4QsQYaIANB4BBqJAAL0ggCA38IfCMAQaADayIFJAAgA0EEQQRBBkEAQQAQ9wcgBEEEQQRBBkEAQQAQ9wcCQCADEMwHQYCABEYEQCAFQeACaiADKAIEEK0GGgwBCyAFQeACaiADEMkHCwJAIAQQzAdBgIAERgRAIAVBqAJqIAQoAgQQrQYaDAELIAVBqAJqIAQQyQcLIAVCgYCAgBA3A/gBIAVBhoCIiHw2AvABIAVCADcDuAEgBSAFQbgBajYC9AEgBUHgAmogBUHwAWpB1NYKEJkEIAUoAvACIAUoAowDKAIAQQNsakKAgICAgICA+D83AxggBUKBgICAEDcD+AEgBUGGgIiIfDYC8AEgBUIANwO4ASAFIAVBuAFqNgL0ASAFQagCaiAFQfABakHU1goQmQQgBSgCuAIgBSgC1AIoAgBBA2xqQoCAgICAgID4PzcDGCACKwMAIQwgAisDCCENIAIrAxAhCCACKwMYIQ4gAisDMCEKIAIrAyAhDyACKwMoIQkgAisDOCELIAVCgICAgPj/////ADcD8AEgBUKAgICAMDcDgAEgBUG4AWogBUHgAmogBUHwAWogBUGAAWoQugYhBCAFQoCAgIAwNwOAASAFQoCAgID4/////wA3A0ggBUHwAWogBCAFQYABaiAFQcgAahC6BiECIAQQsQYaIAVCgICAgPj/////ADcDuAEgBUKAgICAMDcDSCAFQYABaiAFQagCaiAFQbgBaiAFQcgAahC6BiEDIAVCgICAgDA3A0ggBUKAgICA+P////8ANwMQIAVBuAFqIAMgBUHIAGogBUEQahC6BiEEIAMQsQYaIAUgAjYChAEgBUGAgIQQNgKAASAFQgA3A4gBIAUgBDYCTCAFQYCAhBA2AkggBUIANwNQIAwgCiAIoqEgDSAIIAuioSAOIAogCaKhIA8gCyAJoqEgCCAJIAVBgAFqIAVByABqELoMIAVCgICAgPj/////ADcDgAEgBUKDgICAwAA3AxAgBUHIAGogBUHgAmogBUGAAWogBUEQahC6BiEDIAVCgICAgDA3AxAgBUKAgICA+P////8ANwMAIAVBgAFqIAMgBUEQaiAFELoGIQYgAxCxBhogBUKAgICA+P////8ANwNIIAVCg4CAgMAANwMAIAVBEGogBUGoAmogBUHIAGogBRC6BiEDIAVCgICAgDA3AwAgBUKAgICA+P////8ANwOYAyAFQcgAaiADIAUgBUGYA2oQugYhByADELEGGiAFQgA3AxggBSACNgIUIAVBgICECDYCECAFIAY2AgQgBUGAgIQQNgIAIAVCADcDCCAAIAEgBUEQaiAFELsMIAVCADcDGCAFIAQ2AhQgBUGAgIQINgIQIAUgBzYCBCAFQYCAhBA2AgAgBUIANwMIIAAgASAFQRBqIAUQuwwgBxCxBhogBhCxBhogBBCxBhogAhCxBhogBUGoAmoQsQYaIAVB4AJqELEGGiAFQaADaiQAC6gNAhB/An0jAEHABWsiBCQAIARBiAVqEKcGIQ4CQCABEMwHQYCABEYEQCAEQdAEaiABKAIEEK0GGgwBCyAEQdAEaiABEMkHCyAEQZgEahCnBiEPAkAgAhDMB0GAgARGBEAgBEGoA2ogAigCBBCtBhoMAQsgBEGoA2ogAhDJBwsgBEKAgICA+P////8ANwPIASAEQoCAgIAwNwNwIARB4ANqIARBqANqIARByAFqIARB8ABqELoGIQEgBEKAgICAMDcDOCAEQoCAgID4/////wA3A7gBIARByAFqIAEgBEE4aiAEQbgBahC6BiEFIARCADcDeCAEIAU2AnQgBEGAgIQINgJwIAQgDzYCPCAEQYCAhBA2AjggBEIANwNAIARB8ABqIARBOGoQsgwgBRCxBhogARCxBhogBEGoA2oQsQYaIARByAFqQQNBA0EGEKQHIARB4ANqEKcGIRAgBCgCyAEiASAEQcgBaiAQQX8gASgCACgCDBEGACAEQcACahCxBhogBEGIAmoQsQYaIARB0AFqELEGGiAEQcgBahCnBiESIARCADcDwAEgBCAPNgK8ASAEQYCAhAg2ArgBAkAgAhDMB0GAgARGBEAgBEE4aiACKAIEEK0GGgwBCyAEQThqIAIQyQcLIARCgICAgPj/////ADcDqAMgBEKDgICAwAA3A6gBIARB8ABqIARBOGogBEGoA2ogBEGoAWoQugYhAiAEQoCAgIAwNwMoIARCgICAgPj/////ADcDGCAEQagDaiACIARBKGogBEEYahC6BiEBIARCADcDsAEgBCABNgKsASAEQYCAhAg2AqgBIARCADcDMCAEIBA2AiwgBEGAgIQINgIoIARCADcDICAEIBI2AhwgBEGAgIQINgIYIARBgICEEDYCCCAEQgA3AxAgBCAONgIMIAAgBEG4AWogBEGoAWogBEEoaiAEQRhqIARBCGpB1NYKEMkLIAEQsQYaIAIQsQYaIARBOGoQsQYaQQAhAiADQQA2AgACQCAAENIHIAAQ0wdsIhNBAEwEQCADKgIAIRQMAQsgBCgC0ARBgIABcSEAIA4oAgAiEUGAgAFxIQEgDigCLCEIIA4oAhAhBSAOKAIMIQkgDigCKCEKIAQoAvwEIQsgBCgC4AQhByAEKALcBCEMIAQoAvgEIQ0gEUEHcUEFRyERA0AgAyADKgIAAn0gEUUEQAJ/AkAgAUUEQCAKKAIAQQFHDQELIAUgAkEDdGoMAQsgCigCBEEBRgRAIAUgCCgCACACbGoMAQsgBSACIAltIgYgCCgCAGxqIAIgBiAJbGtBA3RqCyoCAAJ/AkAgAEUEQCANKAIAQQFHDQELIAcgAkEEdGoMAQsgDSgCBEEBRgRAIAcgCygCACACbGoMAQsgByACIAxtIgYgCygCAGxqIAIgBiAMbGtBBHRqCysDALaTIRQCfwJAIAFFBEAgCigCAEEBRw0BCyAFIAJBA3RqDAELIAooAgRBAUYEQCAFIAgoAgAgAmxqDAELIAUgAiAJbSIGIAgoAgBsaiACIAYgCWxrQQN0agsqAgQCfwJAIABFBEAgDSgCAEEBRw0BCyAHIAJBBHRqDAELIA0oAgRBAUYEQCAHIAsoAgAgAmxqDAELIAcgAiAMbSIGIAsoAgBsaiACIAYgDGxrQQR0agsrAwi2kwwBCwJ/AkAgAUUEQCAKKAIAQQFHDQELIAUgAkEEdGoMAQsgCigCBEEBRgRAIAUgCCgCACACbGoMAQsgBSACIAltIgYgCCgCAGxqIAIgBiAJbGtBBHRqCysDAAJ/AkAgAEUEQCANKAIAQQFHDQELIAcgAkEEdGoMAQsgDSgCBEEBRgRAIAcgCygCACACbGoMAQsgByACIAxtIgYgCygCAGxqIAIgBiAMbGtBBHRqCysDAKG2IRQCfwJAIAFFBEAgCigCAEEBRw0BCyAFIAJBBHRqDAELIAooAgRBAUYEQCAFIAgoAgAgAmxqDAELIAUgAiAJbSIGIAgoAgBsaiACIAYgCWxrQQR0agsrAwgCfwJAIABFBEAgDSgCAEEBRw0BCyAHIAJBBHRqDAELIA0oAgRBAUYEQCAHIAsoAgAgAmxqDAELIAcgAiAMbSIGIAsoAgBsaiACIAYgDGxrQQR0agsrAwihtgsiFSAVlCAUIBSUkpIiFDgCACACQQFqIgIgE0cNAAsLIAMgFCATsiIVIBWSlZE4AgAgEhCxBhogEBCxBhogDxCxBhogBEHQBGoQsQYaIA4QsQYaIARBwAVqJAALsw0DBH8IfQl8IwBBQGoiAyQAAkAgARDMB0GAgARGBEAgA0EIaiABKAIEEK0GGgwBCyADQQhqIAEQyQcLIAMoAggiAUGAgAFxIQQCfCABQf8fcUEVRgRAAkACfwJAAn8gBEUEQCADQRhqIAMoAjAiBCgCAEEBRg0BGiADKAIYIgEqAgghByABKgIEIQggASoCACEJAn8gBCgCBEEBRgRAIAEgAygCNCgCAGoMAQsgASADKAIUIgVBACAFQQFqQQNJGyIGIAMoAjQoAgBsakEBIAUgBmxrQQxsagsqAgAhCgJ/IAQoAgRBAUYEQCABIAMoAjQoAgBqDAELIAEgAygCFCIGQQAgBkEBakEDSRsiBSADKAI0KAIAbGpBASAFIAZsa0EMbGoLKgIEIQsCfyAEKAIEQQFGBEAgASADKAI0KAIAagwBCyABIAMoAhQiBUEAIAVBAWpBA0kbIgYgAygCNCgCAGxqQQEgBSAGbGtBDGxqCyoCCCEMAn8gBCgCBEEBRgRAIAEgAygCNCgCAEEBdGoMAQsgAUECIAMoAhQiBW0iBiADKAI0KAIAbGpBAiAFIAZsa0EMbGoLKgIAIQ0gBCgCBEEBRw0CIAEgAygCNCgCAEEBdGoMAwsgA0EYagsoAgAiAUEYaiEEIAEqAhwhDiABKgIUIQwgASoCECELIAEqAgwhCiABKgIEIQggASoCACEJIAEqAgghByABKgIYIQ0MAgsgAUECIAMoAhQiBW0iBiADKAI0KAIAbGpBAiAFIAZsa0EMbGoLKgIEIQ4gBCgCBEEBRgRAIAEgAygCNCgCAEEBdGohBAwBCyABQQIgAygCFCIEbSIFIAMoAjQoAgBsakECIAQgBWxrQQxsaiEECyAOuyETIAy7IRYgCrshEiAIuyEPIAm7IRAgB7shESALuyEUIA27IRUgBCoCCLsMAQsCQAJ/AkACfyAERQRAIANBGGogAygCMCIEKAIAQQFGDQEaIAMoAhgiASsDECERIAErAwghDyABKwMAIRACfyAEKAIEQQFGBEAgASADKAI0KAIAagwBCyABIAMoAhQiBUEAIAVBAWpBA0kbIgYgAygCNCgCAGxqQQEgBSAGbGtBGGxqCysDACESAn8gBCgCBEEBRgRAIAEgAygCNCgCAGoMAQsgASADKAIUIgZBACAGQQFqQQNJGyIFIAMoAjQoAgBsakEBIAUgBmxrQRhsagsrAwghFAJ/IAQoAgRBAUYEQCABIAMoAjQoAgBqDAELIAEgAygCFCIFQQAgBUEBakEDSRsiBiADKAI0KAIAbGpBASAFIAZsa0EYbGoLKwMQIRYCfyAEKAIEQQFGBEAgASADKAI0KAIAQQF0agwBCyABQQIgAygCFCIFbSIGIAMoAjQoAgBsakECIAUgBmxrQRhsagsrAwAhFSAEKAIEQQFHDQIgASADKAI0KAIAQQF0agwDCyADQRhqCygCACIBQTBqIQQgASsDOCETIAErAyghFiABKwMgIRQgASsDGCESIAErAwghDyABKwMAIRAgASsDECERIAErAzAhFQwCCyABQQIgAygCFCIFbSIGIAMoAjQoAgBsakECIAUgBmxrQRhsagsrAwghEyAEKAIEQQFGBEAgASADKAI0KAIAQQF0aiEEDAELIAFBAiADKAIUIgRtIgUgAygCNCgCAGxqQQIgBCAFbGtBGGxqIQQLIAQrAxALIRcgECASoSISIA8gE6EiE6IgDyAUoSIUIBAgFaEiFaKhIg8gD6IgFCARIBehIheiIBEgFqEiESAToqEiECAQoiARIBWiIBIgF6KhIhEgEaKgoJ8iEiAAKwMAZCIBQQFzRQRARAAAAAAAAPA/IRMCfCAPIBKjIg8gDyAPoiAQIBKjIg8gD6IgESASoyIQIBCioKCfIhGjRAAAAAAAAPA/oCISmUQAAAAAAACAPmNBAXNFBEAgAkIANwMIIAJCADcDOCACQgA3AzAgAkIANwMoIAJCADcDICACQgA3AxggAkIANwMQRAAAAAAAAPC/IQ9EAAAAAAAA8D8MAQsgAiAQIBGjIhA5AzggAiAPIBGjIg85AzAgAiAQmjkDKCACIA+aIhE5AxAgAiAQIBGiRAAAAAAAAPA/IBKjIhGiIhI5AxggAiASOQMIRAAAAAAAAPA/IA8gD6IiEiAQIBCiIhCgIBGioSEPRAAAAAAAAPA/IBIgEaKhIRNEAAAAAAAA8D8gECARoqELIRAgAiAPOQNAIAIgEDkDICACIBM5AwALIANBCGoQsQYaIANBQGskACABC7IHAgl/AXwjAEGACGsiAyQAIAJBA0EDQQZBAEEAEPcHAkAgAhDMB0GAgARGBEAgA0HIB2ogAigCBBCtBhoMAQsgA0HIB2ogAhDJBwsgA0GgBmoQpwYhCCADQdgGahCnBiEJIANBkAdqEKcGIQogA0HoBWoQpwYhAiADQbAFahCnBiEFIANB+ARqEKcGIQcCQCABEMwHQYCABEYEQCADQdACaiABKAIEEK0GGgwBCyADQdACaiABEMkHCwJAIAEQzAdBgIAERgRAIANBOGogASgCBBCtBhoMAQsgA0E4aiABEMkHCyADQfAAaiADQThqEJwHIANBiANqIANB0AJqIANB8ABqEIIHIANB6ARqIANBiANqEKYHIQEgA0GAgIQQNgIoIANCADcDMCADIAI2AiwgAyAFNgIcIANBgICEEDYCGCADQgA3AyAgAyAHNgIMIANBgICEEDYCCCADQgA3AxAgASADQShqIANBGGogA0EIakEAEK8EIANBgARqELEGGiADQcgDahCxBhogA0GQA2oQsQYaIANB6AFqELEGGiADQbABahCxBhogA0H4AGoQsQYaIANBOGoQsQYaIANB0AJqELEGGgJAAn8CQAJAIAItAAFBwABxDQAgAigCKCIBKAIAQQFGDQAgASgCBEEBRw0BIAIoAhAiBCACKAIsKAIAQQF0agwCCyACKAIQIgRBCGohASAEKwMQIQwMAgsgAigCECIEQQIgAigCDCIGbSILIAIoAiwoAgBsakECIAYgC2xrQQN0agsrAwAhDCABKAIEQQFGBEAgBCACKAIsKAIAaiEBDAELIAQgAigCDCIBQQAgAUEBakEDSRsiBiACKAIsKAIAbGpBASABIAZsa0EDdGohAQsgACsDACAMIAErAwCjZARAIANBiANqIAUQnAcgAygCiAMiASADQYgDaiADQcgHakF/IAEoAgAoAgwRBgAgA0GABGoQsQYaIANByANqELEGGiADQZADahCxBhogA0IANwOQAyADQYCAhAg2AogDIAMgA0HIB2o2AowDIANBiANqEKoERAAAAAAAAAAAY0EBc0UEQCADKALYByADKAL0BygCAEEBdGoiASABKwMAmjkDACABIAErAwiaOQMIIAEgASsDEJo5AxALIAcQsQYaIAUQsQYaIAIQsQYaIAoQsQYaIAkQsQYaIAgQsQYaIANByAdqELEGGiADQYAIaiQADwtBqX4gA0GIA2pBouwEEIkDQbfsBEGm3QRB1QYQmAoAC4UUAwx/AX0FfCMAQeADayIEJAACQCAAEMwHQYCABEYEQCAEQagDaiAAKAIEEK0GGgwBCyAEQagDaiAAEMkHCwJAAkACQCAEKAKwAyIMQQFHQQAgBCgCtAMiCUEBRxtFBEAgBCgCqANBA3ZB/wNxQQFrQQJPDQEgCSAMbCIJQQNMDQIgABDLByIKQRZLDQNBASAK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aiAIQcgBahC6BiEAIAhCgICAgDA3A4ABIAhCgICAgPj/////ADcDcCAIQThqIAAgCEGAAWogCEHwAGoQugYhBCAIQgA3A9ABIAggBDYCzAEgCEGAgIQINgLIASAIQcgBaiACELIMIAQQsQYaIAAQsQYaIAhCgICAgPj/////ADcDOCAIQoCAgIAwNwPIASAIIAogCEE4aiAIQcgBahC6BiEAIAhCgICAgDA3A4ABIAhCgICAgPj/////ADcDcCAIQThqIAAgCEGAAWogCEHwAGoQugYhBCAIQgA3A9ABIAggBDYCzAEgCEGAgIQINgLIASAIQcgBaiAFELIMIAQQsQYaIAAQsQYaIAhCgICAgPj/////ADcDOCAIQoOAgIDAADcDyAEgCCABIAhBOGogCEHIAWoQugYhACAIQoCAgIAwNwPIASAIQoCAgID4/////wA3A4ABIAhBOGogACAIQcgBaiAIQYABahC6BiIEIAMQlgQgBBCxBhogABCxBhogCEKAgICA+P////8ANwM4IAhCg4CAgMAANwPIASAIIAogCEE4aiAIQcgBahC6BiEAIAhCgICAgDA3A8gBIAhCgICAgPj/////ADcDgAEgCEE4aiAAIAhByAFqIAhBgAFqELoGIgQgBhCWBCAEELEGGiAAELEGGiAKELEGGiABELEGGiAOELEGGiANELEGGiAJELEGGiAMELEGGiAIQYAEahCxBhogCxCxBhogCEHwBGokAAuREQIEfxV8IwBBwAFrIgMkAAJ8An8CQAJAIAAQywdBDUcEQCAAEMsHQQ5HDQELAkAgABDMB0GAgARGBEAgA0GIAWogACgCBBCtBhoMAQsgA0GIAWogABDJBwsgABDLByEAIAMoAogBQYCAAXEhBSAAQQ1GBEACQAJAIAVFBEAgAygCmAEiACoCBIy7IQ0gACoCAIy7IQ4CQAJAAkACQAJAAkACQCADKAKwASIFKAIAQQFHBEACfyAFKAIEQQFGBEAgACADKAK0ASgCAGoMAQsgACADKAKUASIEQQAgBEEBakEDSRsiBiADKAK0ASgCAGxqQQEgBCAGbGtBA3RqCyoCAIy7IQoMAQsgACoCCIy7IQogAygCsAEiBSgCAEEBRg0BCwJ/IAUoAgRBAUYEQCAAIAMoArQBKAIAagwBCyAAIAMoApQBIgRBACAEQQFqQQNJ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ACsDkAIgGyABKwMIoqE5A5ACIAAgACsDmAIgHCABKwMIoqE5A5gCIAAgACsD2AIgHSABKwMIoqE5A9gCIAAgACsD4AIgHiABKwMIoqE5A+ACIAAgACsDqAMgHyABKwMIoqE5A6gDIAAgGCAYoiAZIBmioCIQIBqiIAArA+ADoDkD4AMgACAQIBuiIAArA+gDoDkD6AMgACAQIByiIAArA/ADoDkD8AMgACAQIB2iIAArA7AEoDkDsAQgACAQIB6iIAArA7gEoDkDuAQgACAQIB+iIAArA4AFoDkDgAUgAyACKwMAIAMrA7gJoDkDuAkgAyACKwMIIAMrA8AJoDkDwAkgAyACKwMQIAMrA8gJoDkDyAkgAyACKwMAIAMrA5gKoDkDmAogAyACKwMIIAMrA6AKoDkDoAogAyACKwMQIAMrA6gKoDkDqAogAyADKwPoCSABKwMAIAIrAwCioTkD6AkgAyADKwPwCSABKwMAIAIrAwiioTkD8AkgAyADKwP4CSABKwMAIAIrAxCioTkD+AkgAyADKwOwCiABKwMIIAIrAwCioTkDsAogAyADKwO4CiABKwMIIAIrAwiioTkDuAogAyADKwPACiABKwMIIAIrAxCioTkDwAogAyADKwPICiABKwMAIAIrAwCioTkDyAogAyADKwPQCiABKwMAIAIrAwiioTkD0AogAyADKwPYCiABKwMAIAIrAxCioTkD2AogAyADKwPgCiABKwMIIAIrAwCioTkD4AogAyADKwPoCiABKwMIIAIrAwiioTkD6AogAyADKwPwCiABKwMIIAIrAxCioTkD8AogAyADKwP4CiAQIAIrAwCioDkD+AogAyADKwOACyAQIAIrAwiioDkDgAsgAyADKwOICyAQIAIrAxCioDkDiAsgIiARoCEiICEgEqAhISAgIBegISAgEyAZoCETIBUgGKAhFSAWIBCgIRYgBEEBaiIEIAVHDQALCyAAIAArAzg5A3ggACAAKwNAOQPAASAAIAArA4gBOQPIASAAIAArA5ACOQPQAiAAIAArA5gCOQOYAyAAIAArA+ACOQOgAyAAIAArA+gDOQOoBCAAIAArA/ADOQPwBCAAIAArA7gEOQP4BCAAIAArAwA5A/ABIAAgACsDCCIQOQP4ASAAIAArAxAiETkDgAIgACAAKwNQOQPAAiAAIAArA1giEjkD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IAIrAwAgA0HAA2ogAWorAwCgOQMAIARBAWoiBEHRAEcNAAsgA0KJgICAkAE3A8gDIANBhoCIiHw2AsADIAMgADYCxAMgA0GYAmoQpwYhByADQdACahCnBiEFIANBiANqEKcGIQYgA0GYAmogA0HAA2oQtQQgA0HAA2ogBRDZDCAAQYgFaiADQcADakHIABCuGxogAyAGEJwHIANB4AFqEKcGIQEgAygCACICIAMgAUF/IAIoAgAoAgwRBgAgA0HAA2ogARDaDCAAQdAFaiADQcADakGIBRCuGxogARCxBhogA0H4AGoQsQYaIANBQGsQsQYaIANBCGoQsQYaAkACQCAAKwOIBURIr7ya8td6PmZBAXNFBEAgAEEAIAAoAsgMIgFrQQN0aisDwAVESK+8mvLXej5jDQEgASEEDAILQal+IANBwANqQYOBBRCJA0H2gAVBwPwEQfsBEJgKAAsDQEEGIAFrIQIgAUEBaiIEIQEgACACQQN0aisDiAVESK+8mvLXej5jDQALCyAAIARBAWo2AsgMIARBBk4NASAAQcAMaiAiIBSjOQMAIABBuAxqICEgFKM5AwAgACAgIBSjOQOwDCAGELEGGiAFELEGGiAHELEGGiADQcgIahCxBhogA0GACWoQsQYaIANBkAtqJAAPC0GpfiADQcADakHAgAUQiQNB9oAFQcD8BEHuARCYCgALQal+IANBwANqQZGBBRCJA0H2gAVBwPwEQf8BEJgKAAu8HAIFfxt8IwBB0ANrIgEkACABQv/////////3/wA3A8gDRP///////+9/IQdBCSAAKALIDCICa0EIIAJBAEobIgRBCEwEQCABQZgCaiEFIAQhAwNAIAAgA0EDdGoiAisD0AUhCCACKwOYBiEJIAIrA+AGIQogAisDqAchCyACKwPwByEMIAJBuAhqKwMAIQ0gAkGACWorAwAhDiACQcgJaisDACEPIAEgAkGQCmorAwBEqkxY6Hq2+z+iIgc5A8ADIAEgD0SqTFjoerb7P6IiDzkDuAMgASAORKpMWOh6tvs/oiIOOQOwAyABIA1EqkxY6Hq2+z+iIg05A6gDIAEgDESqTFjoerb7P6IiDDkDoAMgASALRKpMWOh6tvs/oiILOQOYAyABIApEqkxY6Hq2+z+iIgo5A5ADIAEgCUSqTFjoerb7P6IiCTkDiAMgASAI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NgIAAkAgACgCECIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgsCQCAAKAIIIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAEOMLGiAAEKIbCxgAIAAoAgQiACABIAIgACgCACgCIBEFAAu9AgEDfyMAQRBrIgMkACADQQhqIAEoAgQiAiACKAIAKAIsEQIAIAMgASgCDCIBIAEoAgAoAiwRAgBBIBDVGiIBQgA3AgQgAUGokgU2AgAgAUEMaiIEEOMLGiABQaSTBTYCDCABIAMoAgg2AhAgASADKAIMIgI2AhQgAgRAIAIgAigCBEEBajYCBAsgASADKAIANgIYIAEgAygCBCICNgIcAkAgAkUEQCAAIAE2AgQgACAENgIADAELIAIgAigCBEEBajYCBCADKAIEIQIgACABNgIEIAAgBDYCACACRQ0AIAIgAigCBCIBQQFrNgIEIAENACACIAIoAgAoAggRAQAgAhDQGgsCQCADKAIMIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyADQRBqJAALiQEBA38gAEG0lQU2AgwgAEG8lAU2AgACQCAAKAIcIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAQQxqIQICQCAAKAIUIgFFDQAgASABKAIEIgNBAWs2AgQgAw0AIAEgASgCACgCCBEBACABENAaCyACEOMLGiAAC4wBAQN/IABBtJUFNgIMIABBvJQFNgIAAkAgACgCHCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgsgAEEMaiECAkAgACgCFCIBRQ0AIAEgASgCBCIDQQFrNgIEIAMNACABIAEoAgAoAggRAQAgARDQGgsgAhDjCxogABCiGwt5AQJ/IABBtJUFNgIAAkAgACgCECIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgsCQCAAKAIIIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCyAAEOMLGiAAC3wBAn8gAEG0lQU2AgACQCAAKAIQIgFFDQAgASABKAIEIgJBAWs2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GiIBQYAFaiEMIAEgCiACayIKaiENIApBAU4EQCABIAIgChCuGxoLIAAgDDYCiAEgACANNgKEASAAIAE2AoABIAJFDQAgAhCiGwsgACAFIAYQ7w1BACECIABBADoAvAEgAEL/////////9/8ANwNQIABBADYCHCAAIAlBAkkiCiAJQQNGciIBOgC9ASAKRQRAIAtBADYCCCALQgA3AwBBACEKQQAhCSADBEAgA0GAgICABE8NAiALIANBAnQiAxDVGiIJNgIAIAsgAyAJaiICNgIIIAlBACADEK8bGiALIAI2AgQgAiEKCyAAKAKYASIDBEAgACADNgKcASADEKIbIAsoAgghAiALKAIEIQogCygCACEJIAAtAL0BIQELIAAgAjYCoAEgACAKNgKcASAAIAk2ApgBCyAAIAFBAXM6AL4BIAtBEGokAA8LEPwaAAtXAQN/IABB8LcFNgIQIABB9LYFNgIAIABBEGohAgJAIAAoAhgiAUUNACABIAEoAgQiA0EBazYCBCADDQAgASABKAIAKAIIEQEAIAEQ0BoLIAIQ4wsaIAALWgEDfyAAQfC3BTYCECAAQfS2BTYCACAAQRBqIQICQCAAKAIYIgFFDQAgASABKAIEIgNBAWs2AgQgAw0AIAEgASgCACgCCBEBACABENAaCyACEOMLGiAAEKIbCxMAIABBEGogACgCECgCABEAABoLRwECfyAAQfC3BTYCAAJAIAAoAggiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLIAAQ4wsaIAALSgECfyAAQfC3BTYCAAJAIAAoAggiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLIAAQ4wsaIAAQohsLjgECAn8BfSABKAIEIgMgAiADKAIAKAIgEQIAAkAgASgCDEEBSARAQQAhAwwBC0EAIQJBACEDA0AgASgCBCIEIAIgBCgCACgCJBEZACEFIAErAxiaIAMgASsDECAFu2RqIgMgASgCDCIEIAJrardkDQEgAkEBaiICIARIDQALCyAAIAM2AgAgACADt5o5AwgLJgAjAEEQayIAJABBq34gAEGguQUQiQNBsbkFQbq5BUHjARCYCgALpQECAn8BfCAAKwMQIQUgACgCBCIAIAEgACgCACgCKBEDACEA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QCADQThrELEGIgMgBEcNAAsgACgCgAELIQMgACAENgKEASADEKIbCyAAIAU2AoQBIAAgATYCgAEgACAFNgKIASAJQRBqJAAPCxD8GgAL3QkBAX8jAEEQayILJAAgABDjCxogAEHs8wU2AgAgACABKAIANgIEIAAgASgCBCIBNgIIIAEEQCABIAEoAgRBAWo2AgQLIAAgAigCADYCDCAAIAIoAgQiATYCECABBEAgASABKAIEQQFqNgIECyAAIAMoAgAiATYCFCAAIAMoAgQiAjYCGCACBEAgAiACKAIEQQFqNgIEIAAoAhQhAQsgAEIANwIcQQAhAiAAQQA2AmAgAEIANwNwIAAgBTkDaCAAIAk2AlggACAINgJUIABCADcCJCAAQgA3AiwgAEIANwI0IABCADcCPCAAQgA3AkQgAEIANwJMIABCADcDeCAAQgA3A4ABIABBADYCiAEgASABKAIAKAI0EQAAIQEgACAGOgBkIAAgATYCXAJAIAYEQCAAIAc2AmAgC0EAIAQgBxD6EyALKAIAIQEgCygCBCIDBEAgAyADKAIEQQFqNgIECyAAIAE2AhwgACgCICEBIAAgAzYCIAJAIAFFDQAgASABKAIEIgNBAWs2AgQgAw0AIAEgASgCACgCCBEBACABENAaCwJAIAsoAgQiAUUNACABIAEoAgQiA0EBazYCBCADDQAgASABKAIAKAIIEQEAIAEQ0BoLQQAhAyAAKAIEIgEgASgCACgCNBEAACEBIAtBADYCCCALQgA3AwAgAQRAIAFBpZLJJE8NAiALIAFBOGwiAxDVGiIBNgIAIAsgATYCBCALIAEgA2oiAzYCCANAIAEQpwZBOGoiASADRw0ACyALIAM2AgQLIAAoAjAiBgRAAn8gBiAGIAAoAjQiAUYNABoDQCABQThrELEGIgEgBkcNAAsgACgCMAshASAAIAY2AjQgARCiGyALKAIEIQMLIAsoAgAhASAAIAM2AjQgACABNgIwIAAgCygCCDYCOEEAIQEgC0EANgIIIAtCADcDAEEAIQMgBARAIARBgICAgARPDQIgCyAEQQJ0IgYQ1RoiAzYCACALIAMgBmoiATYCCCADQQAgBhCvGxogCyABNgIECyABIQYgACAAKAJIIgcEfyAAIAc2AkwgBxCiGyALKAIEIQYgCygCACEDIAsoAggFIAELNgJQIAAgBjYCTCAAIAM2AkggACAAKwNoIgUgCqIiCjkDcCAAIAogBaEgCbejOQN4CyAAKAIEIgEgASgCACgCNBEAACEBIAtBADYCCCALQgA3AwAgAQRAIAFBpZLJJE8NASALIAFBOGwiAhDVGiIBNgIAIAsgATYCBCALIAEgAmoiAjYCCANAIAEQpwZBOGoiASACRw0ACyALIAI2AgQLIAAoAiQiAwRAAn8gAyADIAAoAigiAUYNABoDQCABQThrELEGIgEgA0cNAAsgACgCJAshASAAIAM2AiggARCiGyALKAIEIQILIAsoAgAhASAAIAI2AiggACABNgIkIAAgCygCCDYCLEEAIQEgC0EANgIIIAtCADcDAEEAIQIgBARAIARBgICAgARPDQEgCyAEQQJ0IgMQ1RoiAjYCACALIAIgA2oiATYCCCACQQAgAxCvGxogCyABNgIECyABIQMgACgCPCIGBEAgACAGNgJAIAYQohsgCygCBCEDIAsoAgAhAiALKAIIIQELIAAgAzYCQCAAIAI2AjwgACABNgJEIAtBEGokAA8LEPwaAAvYCQECfyMAQRBrIg0kACAAEOMLGiAAQYz2BTYCACAAIAEoAgA2AgQgACABKAIEIgw2AgggDARAIAwgDCgCBEEBajYCBAsgACADKAIANgIMIAAgAygCBCIMNgIQIAwEQCAMIAwoAgRBAWo2AgQLIAAgAigCADYCFCAAIAIoAgQiDDYCGCAMBEAgDCAMKAIEQQFqNgIECyAAIAQoAgA2AhwgACAEKAIEIgw2AiAgDARAIAwgDCgCBEEBajYCBAsQvw0hDCAAIAo5A0AgACAIOQMwIAAgBzYCKCAAIAw2AiQgASgCACIBIAEoAgAoAigRAAAhASAAIAk5A3AgACABNgJIIAMoAgAiAyADKAIAKAI4EQAAIQMgAEIANwKYASAAIAs5A5ABIAAgCzkDiAEgACAGNgKEASAAIAM2AoABIABCADcCoAEgAEIANwKoASAAQgA3ArABIABCADcCuAEgAEIANwLAASAAQgA3AsgBQQAhASAAQQA2AtABIABC/////w83A+gBIAAgACgCJBDlCjYC8AEgACAAKwOQASILIAuiIgggCKAiCDkDYCAAIAAoAii3RAAAAAAAAPC/oEQAAAAAAADgP6IiCTkDOCAAIAhEAAAAAAAA4D+iOQN4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FBEBAAsgABCiGws1ACAAKAIYIgBFBEBBBBAVIgBBoOgINgIAIABByOgIQY8MEBYACyAAIAEgACgCACgCGBECAAtbACABQaiCBjYCACABIAApAgQ3AgQgASAAKQIMNwIMIAEgACkCFDcCFCABIAApAhw3AhwgASAAKQIkNwIkIAEgACkCLDcCLCABIAApAjQ3AjQgASAAKAI8NgI8CwoAIABBBGoQ/Q4L8hcDGH8CfgJ8IwBBwAJrIgEkAAJAAkACQCAAKAIALQAAQQFxDQAgACgCCCEIIAAoAgQiAiACKAIAIglBAWo2AgAgCCgCTCECIAFBqAJqIAgoAggiAyADKAIAKAI4EQIAIAFBoAJqIAgoAjAiAyACIAlBCmxqIgIgAygCACgCLBEEACABQZgCaiAIKAIQIgMgAygCACgCPBECACABQZACaiAIKAIoIgMgAkEBaiADKAIAKAI0EQQAIAJBAmohAyAAKAIMLQAABEAgAUHQAWogCCgCOCIGIAMgBigCACgCJBEEACABKALQASEOAkAgASgC1AEiCkUNACAKIAooAgRBAWo2AgQgASgC1AEiA0UNACADIAMoAgQiBkEBazYCBCAGDQAgAyADKAIAKAIIEQEAIAMQ0BoLIAJBA2ohAwsgAUGIAmogCCgCICICIAIoAgAoAiQRAgACQCAAKAIQLQAADQAgAUHQAWogCCgCGCICIAMgAigCACgCKBEEACABKALQASEWIAEoAtQBIgtFDQAgCyALKAIEQQFqNgIEIAEoAtQBIgJFDQAgAiACKAIEIgNBAWs2AgQgAw0AIAIgAigCACgCCBEBACACENAaCyABQdABahCnBiEHIAFBmAFqEKcGIRMgAUHgAGoQpwYhDyABQv/////////3/wA3A1ggAUEANgJQIAFC//////////f/ADcDSCABQQA2AkAgAUL/////////9/8ANwM4IAFBADYCMCABQv/////////3/wA3AyggAUEANgIgIAEoAqgCIgIgAigCACgCKBEAACECIAFBADYCGCABQgA3AxAgAgRAIAJBgICAgARPDQMgASACQQJ0IgIQ1RoiAzYCECABIAIgA2oiBjYCGCADQQAgAhCvGxogASAGNgIUCyABKAKoAiICIAIoAgAoAjARAAAhAiABQQA2AgggAUIANwMAIAIEQCACQaWSySRPDQIg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ASIBBEAgACABNgKkASABEKIbCyAAEOMLGiAAEKIbCw0AIAAoAiBBAWtBAkkLCAAgACgCIEULCgAgACgCIEEDRgsNACAAKAIgQQVrQQJJCwcAIAAoAhgLCAAgAC0AsQELBwAgACgCYAsHACAAKAI8CwgAIAAoApABCwcAIAAoAigLBwAgACgCHAsHACAAKwMQCwcAIAArAwgLBwAgACgCJAsIACAAKwOIAQsHACAAKwN4CwcAIAArA3ALCAAgACsDgAELBwAgACgCOAsHACAAKAIsCwcAIAAoAjALBwAgACgCNAsIACAAKwOYAQsIACAAKAKsAQsIACAAKAK8AQsIACAAKwPAAQsIACAAKwPIAQsIACAAKwPQAQsIACAAKwPYAQsIACAAKwPgAQsHACAAKwNYCwcAIAAoAkwLBwAgACgCUAsIACAAQaABagsIACAAKAK0AQsIACAAKAK4AQsJACAAIAE2AjwLCQAgACABNgIsCwkAIAAgATYCOAsJACAAIAE2AjALCgAgACABOgCxAQsJACAAIAE2AmQLCQAgACABNgJgCwoAIAAgATYCkAELCQAgACABNgJECwkAIAAgATYCSAsJACAAIAE2AkALKwAgARCIFSIBmUQAAAAAAADgQWMEQCAAIAGqNgJMDwsgAEGAgICAeDYCTAsKACAAIAE2ArQBCwoAIAAgAToAsAELCAAgAC0AsAEL+AEBBX8jAEEQayIEJAACQCABIAAoAhBOBEAgASAAKAIUIgNKBEAgBEEANgIIIARCADcDACABBEAgAUGAgICABE8NAyABQQJ0IgIQ1RoiBkEAIAIQrxsgAmohAgsgACgCBCIFBEAgACAFNgIIIAUQohsgACgCFCEDCyAAIAY2AgQgACACNgIMIAAgAjYCCAsCQCABIANGDQAgACABNgIUIAFBAUgNACAAKAIEIQNBACEBA0AgAyABQQJ0aiABNgIAIAFBAWoiASAAKAIUSA0ACwsgBEEQaiQADwtBqX4gBEH8jgYQiQNBmI8GQaaPBkEwEJgKAAsQ/BoAC9ADAgN/AnwjAEEQayIGJAAgABDjCxogAEEANgIMIABCADcCBCAAQYSRBjYCACAAQShqIAEQ+RMCQCACIANOBEAgACAENgIgIAAgAjYCECAAIAM2AhQgBkEANgIIIAZCADcDACACBEAgAkGAgICABE8N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AOBBYwRAIAeqDAELQYCAgIB4CyACIAEbIAIgB71C////////////AINCgICAgICAgPj/AFIbDwtBACECIAhEAAAAAAAAAABjDQAgCCAAKAIYIgK3IgpjQQFzRQRAIAcgCRCVFaMiByAKYyEBAn8gB5lEAAAAAAAA4EFjBEAgB6oMAQtBgICAgHgLIAIgARsgAiAHvUL///////////8Ag0KAgICAgICA+P8AUhsiAgJ/IAiZRAAAAAAAAOBBYwRAIAiqDAELQYCAgIB4CyIBIAEgAkobDwsgByAJEJUVoyIHIApjIQECfyAHmUQAAAAAAADgQWMEQCAHqgwBC0GAgICAeAsgAiABGyACIAe9Qv///////////wCDQoCAgICAgID4/wBSGw8LIAILkQEDA38BfgF8IAEoAgQhAyABKwMIIQZBMBDVGiICQgA3AgQgAkHEmwY2AgAgASkCECEFIAEoAhghASACQRBqIgQQ4wsaIAIgATYCKCACIAU3AyAgAiAGEIQVRAAAAAAAAPC/oEQAAAAAAADwP6AQlRU5AxggAiADNgIUIAJBwJwGNgIQIAAgAjYCBCAAIAQ2AgALKAAgAEHIngY2AhAgAEHEnQY2AgAgAEEYahDjCxogAEEQahDjCxogAAsrACAAQcieBjYCECAAQcSdBjYCACAAQRhqEOMLGiAAQRBqEOMLGiAAEKIbCxwAIABByJ4GNgIAIABBCGoQ4wsaIAAQ4wsaIAALHwAgAEHIngY2AgAgAEEIahDjCxogABDjCxogABCiGwuhAQIBfwF8IABBCGogASACEPAPIQEgACsDMCACtyAAKAJAt6OgIgREAAAAAAAA8D9mBH8gAwUgBCAAKAJEtxCTFSEEIAArAzhEAAAAAAAA8D8gBKEQlRWjIgS9Qv///////////wCDQoCAgICAgID4/wBSIQACfyAEmUQAAAAAAADgQWMEQCAEqgwBC0GAgICAeAsgASAAGyABIAQgAbdjGwsL4wECBX8CfCABKAIoIQMgASsDOCEHQeAAENUaIgJCADcCBCACQcSdBjYCACABKwMwIQggASgCQCEEIAEoAkQhBSABKAJIIQEgAkEQaiIGEOMLGiACQcieBjYCECACQRhqEOMLGiACIAE2AlggAiAFNgJUIAIgBDYCUCACIAcQhBVEAAAAAAAA8L+gRAAAAAAA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ECADIAQ2AhhBGBDVGiIBIANBEGogAigCABDMECABKAIAKAIIEQEAIAAgATYCACADQSBqJAAPCyADIAU2AgAgA0EQakHEtwYgAxCUCkGufiADQRBqQc23BkGApAZB0AIQmAoAC0F7IANBEGpB2bcGEIkDQc23BkGApAZB0gIQmAoAC+YCAQR/IwBBMGsiAiQAIAEQuBsiA0FwSQRAAkACQCADQQtPBEAgA0EQakFwcSIFENUaIQQgAiAFQYCAgIB4cjYCKCACIAQ2AiAgAiADNgIkDAELIAIgAzoAKyACQSBqIQQgA0UNAQsgBCABIAMQrhsaCyADIARqQQA6AAAgAkEAOgAQIAJBADoAGyACQcAAENUaIgM2AgAgAkKygICAgIiAgIB/NwIEIANBADoAMiADQfyoBi8AADsAMCADQfSoBikAADcAKCADQeyoBikAADcAICADQeSoBikAADcAGCADQdyoBikAADcAECADQdSoBikAADcACCADQcyoBikAADcAACAAQQAgAkEgaiACQRBqIAJBLhCRChogAiwAC0F/TARAIAIoAgAQohsLIAIsABtBf0wEQCACKAIQEKIbCyACLAArQX9MBEAgAigCIBCiGwsgAEGIqQY2AgAgAkEwaiQADwsQ2RoAC7ICAQN/IwBB0ABrIgQkACACKAIAQf+fAXFBgIABRgRAIAIoAgghBiACKAIMIQUgBCACKAIQNgI0IAQgBTYCLCAEIAY2AiggBCAFNgIwIARCADcCHCAEIARBGGpBBHI2AhggBCAAKAIINgIUIARBADoAESAEQfyhBi0AADoAECAEQQk6ABMgBEH0oQYpAAA3AwggBCAEQQhqNgJAIARByABqIARBGGogBEEIaiAEQUBrEJAQIAQoAkhBHGogBEEUahCOECAELAATQX9MBEAgBCgCCBCiGwtBGBDVGiICIARBKGogBEEYahDMECADIAIoAgAoAhgRAgAgASACNgIAIARBGGogBCgCHBD/DyAEQdAAaiQADwtBqX4gBEEoakGxmgcQiQNB85oHQYCkBkGGBhCYCgALsgIBA38jAEHQAGsiBCQAIAIoAgBB/58BcUGFgAFGBEAgAigCCCEGIAIoAgwhBSAEIAIoAhA2AjQgBCAFNgIsIAQgBjYCKCAEIAU2AjAgBEIANwIcIAQgBEEYakEEcjYCGCAEIAAo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KAIoEQAANgI0IAIgASABKAIAKAIcEQAANgI4IAIgASABKAIAKAIgEQAANgI8IAJBEGpBMEEBIAMQtBsaIAIgACgCBDYCECACQRBqQQRBASADELQbGiABIAMgASgCACgCFBECAAwCCyADEJoVQXsgAkEQakHYowYQiQNBtqUGQYCkBkH7BRCYCgALIAAoAhAhASACQaSoBigAADYCGCACQgA3ACcgAkEAOgAvIAJBrZoHKAAANgAjIAJBnKgGKQAANwMQIAJBADYCHCACQaqaBygAADYCICACQQQ2AjAgAiABIAEoAgAoAigRAAA2AjQgAiABIAEoAgAoAhwRAAA2AjggAiABIAEoAgAoAiARAAA2AjwgAkEQakEwQQEgAxC0GxogAiAAKAIENgIQIAJBEGpBBEEBIAMQtBsaIAEgAyABKAIAKAIUEQIACyADEJoVIAJBQGskAA8LIAIgASgCACABIAEsAAtBAEgbNgIAIAJBEGpBiKUGIAIQlApBfiACQRBqQbalBkGApAZB1wUQmAoAC40BAQF/IwBB8ABrIgMkACAAIAAoAgAoAhwRAQACQCABEMwHQYCABEYEQCADIAEoAgQQrQYaDAELIAMgARDJBwsgA0E4aiADELQGIABBFGoiASADQThqELkGGiADQThqELEGGiADELEGGiADQThqIAEQrQYhASAAIAIQlRAhACABELEGGiADQfAAaiQAIAALDQAgABCVChogABCiGwuXAgEHfyAAQQRqIQQCQCAAKAIEIgAEQCACKAIAIAIgAi0ACyIDQRh0QRh1QQBIIgUbIQggAigCBCADIAUbIQIDQAJAAkACQAJAAkACQCAAKAIUIAAtABsiAyADQRh0QRh1QQBIIgYbIgMgAiACIANLIgkbIgUEQCAIIABBEGoiBygCACAHIAYbIgcgBRD4FCIGRQRAIAIgA0kNAgwDCyAGQX9KDQIMAQsgAiADTw0CCyAAKAIAIgMNBCABIAA2AgAgAA8LIAcgCCAFEPgUIgMNAQsgCQ0BDAULIANBf0oNBAsgAEEEaiEEIAAoAgQiA0UNAyAEIQALIAAhBCADIQAMAAsACyABIAQ2AgAgBA8LIAEgADYCACAECxgAIAEoAgAiAARAIAAQohsLIAFBADYCAAsMACACQQEQ1Ro2AgALBwAgASgCAAsGAEHkqwYLDgAgAUHsqwZBCxDMAxoLDAAgAiABKAIANgIACwQAIAELBgBB/NIJCw0AIAEgAigCABDNFhoLDAAgAiABKgIAOAIACwYAQazTCQsMACABIAIqAgAQzxYLDAAgAiABLQAAOgAACwYAQbTSCQsMACABIAItAAAQxxYLGABBBBDVGiIAIAEoAgA2AgAgAiAANgIACxsAQQQQ1RoiACABKAIAKAIANgIAIAIgADYCAAsSACACKAIAIAEoAgAoAgA2AgALBgBB0LEGCxAAIAEgAigCACgCABDNFhoLBgBB0LMGCysAIAEoAgAiAARAIAAsAAtBf0wEQCAAKAIAEKIbCyAAEKIbCyABQQA2AgALFgBBDBDVGiIAIAEQ2xoaIAIgADYCAAsZAEEMENUaIgAgASgCABDbGhogAiAANgIACyoAIAIoAgAiACwAC0F/TAR/IAAoAgAQohsgAigCAAUgAAsgASgCABDfGgsEAEEMCwYAQdS8AQspACABAn8gAigCACICLAALQX9MBEAgAigCACECCyACCyACELgbEMwDGgsYAEEIENUaIgAgASsDADkDACACIAA2AgALGwBBCBDVGiIAIAEoAgArAwA5AwAgAiAANgIACxIAIAIoAgAgASgCACsDADkDAAsGAEG40wkLDwAgASACKAIAKwMAENEWC4QDAQd/IwBBQGoiAyQAIABBiLgGNgIAIABBEGoiB0IANwIAIAAgBzYCDCACKAIAIgYgAkEEaiIIRwRAIABBDGohCQNAIAkgByAGIgRBEGoQzRACQCAEKAIEIgVFBEAgBCgCCCIGKAIAIARGDQEgBEEIaiEEA0AgBCgCACIFQQhqIQQgBSAFKAIIIgYoAgBHDQALDAELA0AgBSIGKAIAIgUNAAsLIAYgCEcNAAsLIANBADoAMSADQfyhBi0AADoAMCADQQk6ADMgA0H0oQYpAAA3AyggAiADQShqEM4QIQUgAywAM0F/TARAIAMoAigQohsLIABBADoACAJAIAVB/gFGBEAgA0EIOgATIANBADoAECADQubSsavmrdi25QA3AwggA0EYaiACIANBCGoQzxAgACABIANBGGoQ0BA2AgQgAywAI0F/TARAIAMoAhgQohsLIAMsABNBf0wEQCADKAIIEKIbCyAAQQE6AAgMAQsgACABIAIQ0RA2AgQLIANBQGskACAAC48BAQJ/IwBBEGsiAyQAIAAgASADQQxqIANBCGogAhDvECIEKAIARQRAQSQQ1RoiAUEQaiACEPAQIAEgAygCDDYCCCABQgA3AgAgBCABNgIAAn8gASAAKAIAKAIAIgJFDQAaIAAgAjYCACAEKAIACyECIAAoAgQgAhCNCyAAIAAoAghBAWo2AggLIANBEGokAAu5AQECfyMAQUBqIgMkAAJAIAAgARCBECICIABBBGpHBEAgAigCHCIAIAAoAgAoAhwRAAAoAgRBsLEGRw0BIAIoAhwiACACQSBqIAAoAgAoAhQRAwAoAgAhAiADQUBrJAAgAg8LQTwQFSECIANBIGogA0EQakHkvQYQiQMgARDSECADQTBqIANBIGogA0H4vQYQiQMQ0hAgAiADQTBqENMQIAJBkKgGQeMHEBYAC0EBEBVBnLYGQQAQFgALuAEBAn8jAEFAaiIDJAACQCABIAIQgRAiBCABQQRqRwRAIAQoAhwiASABKAIAKAIcEQAAKAIEQeS7AUcNASAAIAQoAhwiASAEQSBqIAEoAgAoAhQRAwAQ2xoaIANBQGskAA8LQTwQFSEEIANBIGogA0EQakHkvQYQiQMgAhDSECADQTBqIANBIGogA0H4vQYQiQMQ0hAgBCADQTBqENMQIARBkKgGQeMHEBYAC0EBEBVBnLYGQQAQFgALnAMBAn8jAEHwAGsiAiQAAkACQAJAAkAgASgCACABIAEsAAtBAEgbQbulBhCjFSIBBEAgAkEgakEwQQEgARCoFUEBRw0BIAJBIGpBnKgGQQwQ+BQNAiACKAJAQQRHDQMgAigCSCAAKAIARw0EIAIoAkwgACgCBEcNBCACQgA3AhQgAiACQRBqQQRyNgIQIAJBADoACSACQfyhBi0AADoACCACQQk6AAsgAkH0oQYpAAA3AwAgAiACNgJgIAJB6ABqIAJBEGogAiACQeAAahCQECACKAJoQRxqIAJBxABqEI4QIAIsAAtBf0wEQCACKAIAEKIbCyAAIAJBEGoQ0RAiAyABIAMoAgAoAhgRAgAgARCaFSACQRBqIAIoAhQQ/w8LIAJB8ABqJAAgAw8LQTwQFSICQdSnBhCZECACQZCoBkHjBxAWAAtBPBAVIgJBqKgGEJkQIAJBkKgGQeMHEBYACyABEJoVQTwQFSICQZK+BhCZECACQZCoBkHjBxAWAAsgARCaFUE8EBUiAkHWvgYQmRAgAkGQqAZB4wcQFgAL+QIBBn8jAEEQayIDJAAgA0EAOgAJIANB/KEGLQAAOgAIIANBCToACyADQfShBikAADcDACABIAMQzhAhBCADLAALQX9MBEAgAygCABCiGwsCQAJAAkACQAJAAkAgBA4HAAMEAwMBAgMLQSQQ1RoiAkGgvwY2AgAgAiAAKQIANwIEIAIgACkCCDcCDCACQgA3AhggAiACQRhqIgU2AhQgASgCACIAIAFBBGoiBkYNBCACQRRqIQcDQCAHIAUgACIEQRBqEM0QAkAgACgCBCIBRQRAIAQoAggiACgCACAERg0BIARBCGohBANAIAQoAgAiAUEIaiEEIAEgASgCCCIAKAIARw0ACwwBCwNAIAEiACgCACIBDQALCyAAIAZHDQALDAQLQegAENUaIgIgACABEPEQDAMLQcwAENUaIgIgACABEPIQDAILQTwQFSIBQYW/BhCZECABQZCoBkHjBxAWAAtB7AAQ1RoiAiAAIAEQ8xALIANBEGokACACC1QBAX8gACABIAIoAgAgAiACLQALIgFBGHRBGHVBAEgiAxsgAigCBCABIAMbEOcaIgIpAgA3AgAgACACQQhqIgAoAgA2AgggAkIANwIAIABBADYCAAvcAQECfyMAQSBrIgIkACACQQA6ABAgAkEAOgAbIAJBwAAQ1RoiAzYCACACQrKAgICAiICAgH83AgQgA0EAOgAyIANB/KgGLwAAOwAwIANB9KgGKQAANwAoIANB7KgGKQAANwAgIANB5KgGKQAANwAYIANB3KgGKQAANwAQIANB1KgGKQAANwAIIANBzKgGKQAANwAAIABBACABIAJBEGogAkEwEJEKGiACLAALQX9MBEAgAigCABCiGwsgAiwAG0F/TARAIAIoAhAQohsLIABBiKkGNgIAIAJBIGokAAszAQF/IABBiLgGNgIAIAAoAgQiAQRAIAEgASgCACgCBBEBAAsgAEEMaiAAKAIQEP8PIAALNgEBfyAAQYi4BjYCACAAKAIEIgEEQCABIAEoAgAoAgQRAQALIABBDGogACgCEBD/DyAAEKIbCx0AIAAtAAhFBEAgACgCBCIAIAAoAgAoAggRAQALCx4AIAAoAgQiACABIAIgAyAEIAUgACgCACgCDBENAAseACAAKAIEIgAgASACIAMgBCAFIAAo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IQALAkACQAJAAkAgBkH/AXFFDQAgAEUNACAHBEADQCACLQAMIQECQCACIAIoAggiAygCAEcEQAJAAn8gAUH/AXFFBEAgAkEBOgAMIANBADoADCADIAMoAgQiASgCACIENgIEIAQEQCAEIAM2AggLIAEgAygCCDYCCCADKAIIIgQgBCgCACADR0ECdGogATYCACABIAM2AgAgAyABNgIIIAIgACAAIAIoAgAiA0YbIQAgAygCBCECCyACKAIAIgMLBEAgAy0ADEUNAQsgAigCBCIBBEAgAS0ADEUNBwsgAkEAOgAMAkAgACACKAIIIgJGBEAgACECDAELIAItAAwNAwsgAkEBOgAMDwsgAigCBCIBDQUMBgsCQCABQf8BcQRAIAIhAQwBCyACQQE6AAwgA0EAOgAMIAMgAigCBCIBNgIAIAEEQCABIAM2AggLIAIgAygCCDYCCAJAIAMgAygCCCIEKAIARgRAIAQgAjYCACADKAIAIQEMAQsgBCACNgIECyACIAM2AgQgAyACNgIIIAIgACAAIANGGyEACwJAAkAgASgCACIDRQ0AIAMtAAwNACABIQIMAQsCQCABKAIEIgIEQCACLQAMRQ0BCyABQQA6AAwgACABKAIIIgJHBEAgAi0ADA0DCyACQQE6AAwPCyADBEAgAy0ADEUEQCABIQIMAgsgASgCBCECCyACQQE6AAwgAUEAOgAMIAEgAigCACIDNgIEIAMEQCADIAE2AggLIAIgASgCCDYCCCABKAIIIgMgAygCACABR0ECdGogAjYCACACIAE2AgAgASACNgIIIAEhAwsgAiACKAIIIgAtAAw6AAwgAEEBOgAMIANBAToADCAAIAAoAgAiAigCBCIDNgIAIAMEQCADIAA2AggLIAIgACgCCDYCCCAAKAIIIgMgAygCACAAR0ECdGogAjYCACACIAA2AgQgACACNgIIDwsgAigCCCIDIAMoAgAgAkZBAnRqKAIAIQIMAAsACyAEQQE6AAwLDwsgAS0ADA0AIAIhAwwBCyADQQE6AAwgAkEAOgAMIAIgAygCBCIANgIAIAAEQCAAIAI2AggLIAMgAigCCDYCCCACKAIIIgAgACgCACACR0ECdGogAzYCACADIAI2AgQgAiADNgIIIAIhAQsgAyADKAIIIgItAAw6AAwgAkEBOgAMIAFBAToADCACIAIo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BEAgAhCiGyAAKAJIIANqQQA2AgAgACgCECEECyABQQFqIgEgBE4NASAAKAJIIQIMAAsACyAEQQFIDQBB7OQIKAIAIQYDQEF/IAAoAjwiAkECdCACQf////8DcSACRxsQ1RohASAFQQJ0IgMgACgCSGogATYCACACBEAgACgCSCADaigCACEEQQAhAQNAIAQgAUECdGogATYCACABQQFqIgEgAkcNAAsLAkACfyAAKAJQIgJBIE4EQCAAKAJYDAELIAAgACgCZCACajYCZEGAwAAQoRsiAUUEQEHkxQZBG0EBIAYQtBsaQQAhAQwCCyABIAAoAlQ2AgAgACABNgJUQfw/IQIgAUEEagshASAAIAJBIGs2AlAgACABQSBqNgJYIAAgACgCYEEgajYCYAsgACgCRCADaiABNgIAIAAoAkQgA2ooAgAiAUIANwIAIAFCADcCGCABQgA3AhAgAUIANwIIIAAgACgCRCADaigCACAAKAJIIANqKAIAIAAoAjwQhREgACAAKAJEIANqKAIAIAAoAkggA2ooAgAgACgCPCAAKAIMQQAQhhEgBUEBaiIFIAAoAhBIDQALCw8LQTwQFSIBQcDFBhCZECABQZCoBkHjBxAWAAusCgMOfwJ+A3wgACgCQCIKENUaIQ0gACAKIAAoAmhqNgJoQX8gCkEFdCIHIApBA3QiDEH4////A3EgDEcbENUaQQAgBxCvGyEHIAMEfCAMQQFrQQN2IQ8gACgCKCEQIAAoAiwhEQNAIBEgECACIA5BAnRqKAIAbGohC0EAIQlBACEEQQAhBSAKBEADQCAFIAQgC2otAABBgMYGai0AAGohBSAEQQFqIgQgCkcNAAsLIAUgBWytIRNBACEGIAwEQANAIAcgBkECdCIEaiIFIAUoAgAgCSALaiIFLQAAQQFxajYCACAHIARBBHJqIgggCCgCACAFLQAAQQF2QQFxajYCACAHIARBCHJqIgggCCgCACAFLQAAQQJ2QQFxajYCACAHIARBDHJqIgggCCgCACAFLQAAQQN2QQFxajYCACAHIARBEHJqIgggCCgCACAFLQAAQQR2QQFxajYCACAHIARBFHJqIgggCCgCACAFLQAAQQV2QQFxajYCACAHIARBGHJqIgggCCgCACAFLQAAQQZ2QQFxajYCACAHIARBHHJqIgQgBCgCACAFLQAAQQd2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IABBJGogACgCKBD/DyAAKAIEIgIEQAJ/IAIgAiAAKAIIIgFGDQAaA0AgAUHIAGsQsBEiASACRw0ACyAAKAIECyEBIAAgAjYCCCABEKIbCyAAEKIbC8QCAgd/AXwjAEHQAGsiBiQAAkAgACgCMCIBIAAoAggiAiAAKAIEIgRrQcgAbSIDSwRAIABBBGogASADaxCzEQwBCyABIANPDQAgBCABQcgAbGoiASACRwRAA0AgAkHIAGsQsBEiAiABRw0ACwsgACABNgIICyAAKAIwQQFOBEADQCAAKAIEIAVByABsaiIBIAZBCGogACgCICAAKAI0ELQRIgIQtREgAhCwERogACgCHCEEIAAoAhghByABQQxqAn8gACgCECIDIAEoAhhquEQzMzMzMzPzP6IiCEQAAAAAAADwQWMgCEQAAAAAAAAAAGZxBEAgCKsMAQtBAAsQnBFBACECIAMEQANAIAEgAiAEIAIgB2xqELYRIAJBAWoiAiADRw0ACwsgARC3ESAFQQFqIgUgACgCMEgNAAsLIAZB0ABqJAALkgQBBX8gASAAKAIIIgMgACgCBCICa0HIAG1NBEAgACABBH8gAiABQcgAbGohAwNAIAJCADcCACACQgA3AiAgAkIANwIQIAJCADcCCCACQoCAgICAgIDAPzcCGCACQgA3AiggAkIANwIwIAJCADcCOCACQUBrQgA3AgAgAkHIAGoiAiADRw0ACyADBSACCzYCBA8LAkACQAJAIAIgACgCACIEa0HIAG0iBSABaiICQeTxuBxJBEAgBUHIAGwCf0EAIAIgAyAEa0HIAG0iA0EBdCIEIAIgBEsbQePxuBwgA0HxuJwOSRsiBUUNABogBUHk8bgcTw0CIAVByABsENUaCyIGaiIDIAFByABsaiEEIAMhAgNAIAJCADcCACACQgA3AiAgAkIANwIQIAJCADcCCCACQoCAgICAgIDAPzcCGCACQgA3AiggAkIANwIwIAJCADcCOCACQUBrQgA3AgAgAkHIAGoiAiAERw0ACyAGIAVByABsaiEGIAAoAgQiAiAAKAIAIgFGDQIDQCADQcgAayIDIAJByABrIgIQwREgASACRw0ACyAAIAY2AgggACgCBCECIAAgBDYCBCAAKAIAIQEgACADNgIAIAEgAkYNAwNAIAJByABrELARIgIgAUcNAAsMAwsQ/BoA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CwNAIAIiASgCACICDQALCyABIAdHDQALCyAAQgA3AjAgAEEANgJUIABCADcCPCAAQgA3AkwgAEKAgICAgIAINwJEIAAgACkCDDcCKCADQYyiBi0AADoAOCADQQk6ADsgA0EAOgA5IANBhKIGKQAANwMwAkACQAJAAkAgACAFIAYgA0EwahCBECICRwR/IAIoAhwiASABKAIAKAIcEQAAKAIEQYDTCSgCAEcNASACKAIcIgEgAkEgaiABKAIAKAIUEQMAKAIABUEgCzYCWCADLAA7QX9MBEAgAygCMBCiGwsgA0EQENUaIgI2AiAgA0KMgICAgIKAgIB/NwIkIAJBADoADCACQaGiBigAADYACCACQZmiBikAADcAACAAIAUgBiADQSBqEIEQIgJHBH8gAigCHCIBIAEoAgAoAhwRAAAoAgRBrLMGRw0CIAIoAhwiASACQSBqIAEoAgAoAhQRAwAoAgAFQQALNgJgIAMsACtBf0wEQCADKAIgEKIbCyADQQU6ABsgA0EAOgAVIANB/qEGKAAANgIQIANBgqIGLQAAOgAUIAACf0EEIAUgBiADQRBqEIEQIgJGDQAaIAIoAhwiASABKAIAKAIcEQAAKAIEQYDTCSgCAEcNAyACKAIcIgEgAkEgaiABKAIAKAIUEQMAKAIACzYCXCADLAAbQX9MBEAgAygCEBCiGwsgA0EAOgAJIANB6qIGLQAAOgAIIANBCToACyADQeKiBikAADcDACAAAn9B5AAgBSAGIAMQgRAiAkYNABogAigCHCIBIAEoAgAoAhwRAAAoAgRBgNMJKAIARw0EIAIoAhwiASACQSBqIAEoAgAoAhQRAwAoAgALNgJkIAMsAAtBf0wEQCADKAIAEKIbC0HFDSECAkACQAJAAkACQCAAKAJgDgQEAwABAgtBxg0hAgwDC0HHDSECDAILQTwQFSICQczCBhCZECACQZCoBkHjBxAWAAtByA0hAgsgACACNgIEIABBADYCCCAAQX8gACgCXCIEQQJ0IARB/////wNxIARHGyICENUaIgE2AjAgACACENUaNgI0QQEhAgJAIARBAUgNACABQQA2AgAgACgCNEEANgIAIARBAUYNAANAIAJBAnQiASAAKAIwakEANgIAIAAoAjQgAWpBADYCACACQQFqIgIgBEcNAAsLIANBQGskAA8LQQEQFUGc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ACgCRCIDRQ0AIAAoAhAiBUEBSA0AQQAhBANAIAMgBEECdGooAgAiAwRAIAAgAxCbEiAAKAIQIQULIARBAWoiBCAFTg0BIAAoAkQhAwwACwALAkACQAJAAkACQCAAQQxqIgdBBEEBIAEQqBVBAUYEQCAAQRRqIghBBEEBIAEQqBVBAUcNASAAQegAakEEQQEgARCoFUEBRw0CIABBHGoiCUEEQQEgARCoFUEBRw0DIABBEGoiCkEEQQEgARCoFUEBRw0EIABBfyAAKAIQIgRBAnQgBEH/////A3EgBEcbENUaNgJIIARBAU4EQEEAIQMDQEF/IAAoAjwiBEECdCAEQf////8DcSAERxsQ1RohBiADQQJ0IgUgACgCSGogBjYCACAAKAJIIAVqKAIAQQQgBCABEKgVIARHDQcgACABIAAoAkQgBWogAxCjEiADQQFqIgMgACgCEEgNAAsLIAIgACAAKAIAKAIoEQAANgIQIAJBADoACSACQQhqIgNB/KEGLQAAOgAAIAJBCToACyACQfShBikAADcDACACIAI2AiAgAkEoaiAAQTBqIgQgAiACQSBqEJAQIAIoAihBHGogAkEQahCOECACLAALQX9MBEAgAigCABCiGwsgAkEAOgAJIANBjKIGLQAAOgAAIAJBCToACyACQYSiBikAADcDACACIAI2AiAgAkEoaiAEIAIgAkEgahCQECACKAIoQRxqIAcQhhAgAiwAC0F/TARAIAIoAgAQohsLIAJBBToACyACQQA6AAUgAkH+oQYoAAA2AgAgAkGCogYtAAA6AAQgAiACNgIgIAJBKGogBCACIAJBIGoQkBAgAigCKEEcaiAKEIYQIAIsAAtBf0wEQCACKAIAEKIbCyACQZaiBi8AADsBCCACQYAUOwEKIAJBjqIGKQAANwMAIAIgAjYCICACQShqIAQgAiACQSBqEJAQIAIoAihBHGogCBCGECACLAALQX9MBEAgAigCABCiGwsgAkEQENUaIgM2AgAgAkKMgICAgIKAgIB/NwIEIANBADoADCADQaGiBigAADYACCADQZmiBikAADcAACACIAI2AiAgAkEoaiAEIAIgAkEgahCQECACKAIoQRxqIABBGGoQkRAgAiwAC0F/TARAIAIoAgAQohsLIAJBADoACCACQuPE/crmjdmy+AA3AwAgAkEIOgALIAIg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IGoQugYhCiAFIAQ2AiQgBSABNgIgIAVCgICAgPj/////ADcDECAFQTBqIAggBUEgaiAFQRBqELoGIQEgACgCLCELIAVCADcDKCAFIAk2AiQgBUGAgIQINgIgIAUgCjYCFCAFQYCAhBA2AhAgBUIANwMYIAUgATYCBCAFQYCAhBA2AgAgBUIANwMIIAsgBUEgaiAFQRBqIAUgDCAGIAAoAiQgCygCACgCEBFDABogARCxBhogChCxBhogCRCxBhogBCIBIAUoAtACSA0ACwsgAEE0aiAHIAggAhDoEyAIELEGGiAHELEGGiAFQcgCahCxBhogBUGAA2okAAuXAQECfyAAQfycBzYCACAAKAIQIgEEQAJ/IAEgASAAKAIUIgJGDQAaA0AgAkEwaxDYCiICIAFHDQALIAAoAhALIQIgACABNgIUIAIQohsLIAAoAgQiAQRAAn8gASABIAAoAggiAkYNABoDQCACQThrELEGIgIgAUcNAAsgACgCBAshAiAAIAE2AgggAhCiGwsgABDjCxogAAvTAQECfyAAQaybBzYCNCAAQfCfBzYCACAAKAJwIgEEQCAAIAE2AnQgARCiGwsgAEE4ahCxBhoCQCAAKAIwIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEBACABENAaCwJAIAAoAigiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQEAIAEQ0BoLAkAgACgCICIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAQAgARDQGgsgABDrExogAAsKACAAEOwTEKIbCxYAIABBhKYHNgIAIABBDGoQ7BMaIAALGQAgAEGEpgc2AgAgAEEMahDsExogABCiGwsWACAAQfimBzYCACAAQQxqEJ0QGiAACxkAIABB+KYHNgIAIABBDGoQnRAaIAAQohsLFQAgAEHopwc2AgAgAEEMahD+DyAACxgAIABB6KcHNgIAIABBDGoQ/g8gABCiGwsKACAAQQxqEP4PC1sBA3wgASsDCCECIAErAxAhAyABKwMAIQQgAEIANwNAIAAgBDkDOCAAQgA3AyAgACADOQMYIAAgAjkDECAAQgA3AwAgACACmjkDMCAAIASaOQMoIAAgA5o5AwgLhQIBCHwgACABKwMAIgIgAqIgASsDCCID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IABBDGoPCyADIAJB9LEHENUDAAvhAQEFfyMAQRBrIgUkAEEwENUaIgNCADcCBCADQYSqBzYCACABKAIEIQQgASgCCCEGIANBEGoiBxDjCxogA0IANwIcIANBiKsHNgIQQQAhASADQQA2AiQgAyACrEL/////DyACGzcDKCADIAY2AhggAyAENgIUIAVBADYCCCAFQgA3AwBBACECAkAgBARAIARBgICAgARPDQEgBEECdCIEENUaIgJBACAEEK8bIARqIQELIAMgATYCJCADIAE2AiAgAyACNgIcIAAgAzYCBCAAIAc2AgAgBUEQaiQADwsQ/BoAC3wBBH8gAEGktAc2AgwgAEGYswc2AgAgACgCECIBBEACfyABIAEgACgCFCIDRg0AGgNAIANBDGsiAigCACIEBEAgA0EIayAENgIAIAQQohsLIAIhAyABIAJHDQALIAAoAhALIQIgACABNgIUIAIQohsLIABBDGoQ4wsaIAALfwEEfyAAQaS0BzYCDCAAQZizBzYCACAAKAIQIgEEQAJ/IAEgASAAKAIUIgNGDQAaA0AgA0EMayICKAIAIgQEQCADQQhrIAQ2AgAgBBCiGwsgAiEDIAEgAkcNAAsgACgCEAshAiAAIAE2AhQgAhCiGwsgAEEMahDjCxogABCiGwtwAQR/IABBpLQHNgIAIAAoAgQiAQRAAn8gASABIAAoAggiA0YNABoDQCADQQxrIgIoAgAiBARAIANBCGsgBDYCACAEEKIbCyACIQMgASACRw0ACyAAKAIECyECIAAgATYCCCACEKIbCyAAEOMLGiAAC3MBBH8gAEGktAc2AgAgACgCBCIBBEACfyABIAEgACgCCCIDRg0AGgNAIANBDGsiAigCACIEBEAgA0EIayAENgIAIAQQohsLIAIhAyABIAJHDQALIAAoAgQLIQIgACABNgIIIAIQohsLIAAQ4wsaIAAQohsLDQAgACgCBCABQQxsagsVACAAQai2BzYCACAAQQxqEP4PIAALGAAgAEGotgc2AgAgAEEMahD+DyAAEKIbCxUAIABBpLcHNgIAIABBDGoQ/g8gAAsYACAAQaS3BzYCACAAQQxqEP4PIAAQohsL1wEBBH8gAEGguQc2AgwgAEGcuAc2AgAgACgCHCIBBEACfyABIAEgACgCICIDRg0AGgNAIANBDGsiAigCACIEBEAgA0EIayAENgIAIAQQohsLIAIhAyABIAJHDQALIAAoAhwLIQIgACABNgIgIAIQohsLIAAoAhAiAQRAAn8gASABIAAoAhQiA0YNABoDQCADQQxrIgIoAgAiBARAIANBCGsgBDYCACAEEKIbCyACIQMgASACRw0ACyAAKAIQCyECIAAgATYCFCACEKIbCyAAQQxqEOMLGiAACwoAIAAQkRQQohsLywEBBH8gAEGguQc2AgAgACgCECIBBEACfyABIAEgACgCFCIDRg0AGgNAIANBDGsiAigCACIEBEAgA0EIayAENgIAIAQQohsLIAIhAyABIAJHDQALIAAoAhALIQIgACABNgIUIAIQohsLIAAoAgQiAQRAAn8gASABIAAoAggiA0YNABoDQCADQQxrIgIoAgAiBARAIANBCGsgBDYCACAEEKIbCyACIQMgASACRw0ACyAAKAIECyECIAAgATYCCCACEKIbCyAAEOMLGiAAC84BAQR/IABBoLkHNgIAIAAoAhAiAQRAAn8gASABIAAoAhQiA0YNABoDQCADQQxrIgIoAgAiBARAIANBCGsgBDYCACAEEKIbCyACIQMgASACRw0ACyAAKAIQCyECIAAgATYCFCACEKIbCyAAKAIEIgEEQAJ/IAEgASAAKAIIIgNGDQAaA0AgA0EMayICKAIAIgQEQCADQQhrIAQ2AgAgBBCiGwsgAiEDIAEgAkcNAAsgACgCBAshAiAAIAE2AgggAhCiGwsgABDjCxogABCiGwsNACAAKAIQIAFBDGxqC4kBAQR/IABB9LsHNgIMIABB8LoHNgIAIAAoAhwiAQRAAn8gASABIAAoAiAiA0YNABoDQCADQQxrIgIoAgAiBARAIANBCGsgBDYCACAEEKIbCyACIQMgASACRw0ACyAAKAIcCyECIAAgATYCICACEKIbCyAAQRBqIAAoAhQQlxQgAEEMahDjCxogAAs2ACABBEAgACABKAIAEJcUIAAgASgCBBCXFCABKAIgIgAEQCABIAA2AiQgABCiGwsgARCiGwsLjAEBBH8gAEH0uwc2AgwgAEHwugc2AgAgACgCHCIBBEACfyABIAEgACgCICIDRg0AGgNAIANBDGsiAigCACIEBEAgA0EIayAENgIAIAQQohsLIAIhAyABIAJHDQALIAAoAhwLIQIgACABNgIgIAIQohsL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OQECAgICAgICAgICAgECAgIBAgICAgICAgICAgICAgICAgIBAgICAgICAgICAgIBAgICAgICAgICAQALIAJBmgVGDQAgAkEqRw0BCwJ/An8CfyABKAIIIgIEQCAAKAIoIAIgAxECACAAKAIcIQELIAEoAkQiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAEoAkAiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAEoAjgiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAAoAiggASAAKAIkEQIAIABBADYCHAsLmQIBA39BfiECAkAgAEUNACAAKAIgRQ0AIAAoAiRFDQAgACgCHCIBRQ0AIAEoAgAgAEcNAAJAAkAgASgCBCIDQTlrDjkBAgICAgICAgICAgIBAgICAQICAgICAgICAgICAgICAgICAQICAgICAgICAgICAQICAgICAgICAgEACyADQZoFRg0AIANBKkcNAQsgAEECNgIsIABBADYCCCAAQgA3AhQgAUEANgIUIAEgASgCCDYCECABKAIYIgJBf0wEQCABQQAgAmsiAjYCGAsgAUE5QSpB8QAgAhsgAkECRhs2AgQgAAJ/IAJBAkYEQEEAQQBBABCpFAwBC0EAQQBBABCnFAs2AjBBACECIAFBADYCKCABEMEUCyACC7cBAQJ/IAAQrBRFBEAgACgCHCIAIAAoAixBAXQ2AjwgACgCRCIBIAAoAkxBAXRBAmsiAmpBADsBACABQQAgAhCvGxogAEEANgK0LSAAQoCAgIAgNwJ0IABCADcCaCAAQoCAgIAgNwJcIABBADYCSCAAIAAoAoQBQQxsIgFB5P4Hai8BADYCkAEgACABQeD+B2ovAQA2AowBIAAgAUHi/gdqLwEANgKAASAAIAFB5v4Hai8BADYCfAsLoAYBCn8gACgCLCIHQYYCayEJIAAoAnQhBSAHIQEDQCAAKAI8IAVrIAAoAmwiCGshBiABIAlqIAhNBEAgACgCOCIBIAEgB2ogByAGaxCuGxogACAAKAJwIAdrNgJwIAAgACgCbCAHayIINgJsIAAgACgCXCAHazYCXCAAKAJEIAAoAkwiA0EBdGohASAAKAIsIQIDQCABQQJrIgFBACABLwEAIgQgAmsiBSAEIAVJGzsBACADQQFrIgMNAAsgACgCQCACQQF0aiEBIAIhAwNAIAFBAmsiAUEAIAEvAQAiBCACayIFIAQgBUkbOwEAIANBAWsiAw0ACyAGIAdqIQYLAkAgACgCACIBKAIEIgNFDQAgACgCdCEEIAYgAyADIAZLGyICBEAgACgCOCEFIAEgAyACazYCBCAFIAhqIARqIAEoAgAgAhCuGyEDAkACQAJAIAEoAhwoAhhBAWsOAgABAgsgASABKAIwIAMgAhCnFDYCMAwBCyABIAEoAjAgAyACEKkUNgIwCyABIAEoAgAgAmo2AgAgASABKAIIIAJqNgIIIAAoAnQhBAsgACACIARqIgU2AnQCQCAAKAK0LSICIAVqQQNJDQAgACAAKAI4IgYgACgCbCACayIBaiIDLQAAIgQ2AkggACAAKAJUIgogAy0AASAEIAAoAlgiCHRzcSIDNgJIA0AgAkUNASAAIAEgBmotAAIgAyAIdHMgCnEiAzYCSCAAKAJAIAAoAjQgAXFBAXRqIAAoAkQgA0EBdGoiBC8BADsBACAEIAE7AQAgACACQQFrIgI2ArQtIAFBAWohASACIAVqQQJLDQALCyAFQYUCSw0AIAAoAgAoAgRFDQAgACgCLCEBDAELCwJAIAAoAjwiAyAAKALALSIBTQ0AIAAoAnQgACgCbGoiAiABSwRAIAAoAjggAmpBACADIAJrIgFBggIgAUGCAkkbIgEQrxsaIAAgASACajYCwC0PCyACQYICaiICIAFNDQAgACgCOCABakEAIAMgAWsiAyACIAFrIgEgASADSxsiARCvGxogACAAKALALSABajYCwC0LC4M2AQp/QX4hAwJAIABFDQAgACgCIEUNACAAKAIkRQ0AIAAoAhwiAkUNACACKAIAIABHDQACQAJAIAIoAgQiBEE5aw45AQICAgICAgICAgICAQICAgECAgICAgICAgICAgICAgICAgECAgICAgICAgICAgECAgICAgICAgIBAAsgBEGaBUYNACAEQSpHDQELIAFBBUsNAAJAAkAgACgCDEUNACAAKAIEIgMEQCAAKAIARQ0BCyABQQRGDQEgBEGaBUcNAQsgAEGgrggoAgA2AhhBfg8LIAAoAhBFBEAgAEGsrggoAgA2AhhBew8LIAIoAighBiACIAE2AigCQCACKAIUBEAgAhDEFAJAIAAoAhAiBCACKAIUIgUgBCAFSRsiA0UNACAAKAIM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IAdFDQQgAiAGLQAAOgADIAdBAUYEQCACQQRqIQMMBQsgAiAELQAEOgAEIAJBBWohAwwECyADIAItAAE6AAEgA0ECaiEDDAMLIAAgBzYCGEHR/gALNgIEDAILIAMgBzoAACADQQFqIQMLIAMgDU8NACAIIA5JDQELCyAAIAM2AgwgACAIIAVBA3ZrIgI2AgAgACANIANrQYECajYCECAAIA4gAmtBBWo2AgQgCSAFQQdxIgU2AkAgCSABQX8gBXRBf3NxNgI8C2IAIABBADYCvC0gAEEAOwG4LSAAQbgWakGYngg2AgAgACAAQfwUajYCsBYgAEGsFmpBhJ4INgIAIAAgAEGIE2o2AqQWIABBoBZqQfCdCDYCACAAIABBlAFqNgKYFiAAEMIUC9oEAQF/A0AgACABQQJ0akEAOwGUASABQQFqIgFBngJHDQALIABBADsB/BQgAEEAOwGIEyAAQcQVakEAOwEAIABBwBVqQQA7AQAgAEG8FWpBADsBACAAQbgVakEAOwEAIABBtBVqQQA7AQAgAEGwFWpBADsBACAAQawVakEAOwEAIABBqBVqQQA7AQAgAEGkFWpBADsBACAAQaAVakEAOwEAIABBnBVqQQA7AQAgAEGYFWpBADsBACAAQZQVakEAOwEAIABBkBVqQQA7AQAgAEGMFWpBADsBACAAQYgVakEAOwEAIABBhBVqQQA7AQAgAEGAFWpBADsBACAAQfwTakEAOwEAIABB+BNqQQA7AQAgAEH0E2pBADsBACAAQfATakEAOwEAIABB7BNqQQA7AQAgAEHoE2pBADsBACAAQeQTakEAOwEAIABB4BNqQQA7AQAgAEHcE2pBADsBACAAQdgTakEAOwEAIABB1BNqQQA7AQAgAEHQE2pBADsBACAAQcwTakEAOwEAIABByBNqQQA7AQAgAEHEE2pBADsBACAAQcATakEAOwEAIABBvBNqQQA7AQAgAEG4E2pBADsBACAAQbQTakEAOwEAIABBsBNqQQA7AQAgAEGsE2pBADsBACAAQagTakEAOwEAIABBpBNqQQA7AQAgAEGgE2pBADsBACAAQZwTakEAOwEAIABBmBNqQQA7AQAgAEGUE2pBADsBACAAQZATakEAOwEAIABBjBNqQQA7AQAgAEIANwKsLSAAQZQJakEBOwEAIABBADYCqC0gAEEANgKg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FEUEQEHE/QpBHDYCAAwBC0GYCRChGyICDQELQQAMAQsgAkEAQZABEK8bGiABQSsQ/BRFBEAgAkEIQQQgAS0AAEHyAEYbNgIACwJAIAEtAABB4QBHBEAgAigCACEBDAELIABBA0EAECQiAUGACHFFBEAgAyABQYAIcjYCECAAQQQgA0EQahAkGgsgAiACKAIAQYABciIBNgIACyACQf8BOgBLIAJBgAg2AjAgAiAANgI8IAIgAkGYAWo2AiwCQCABQQhxDQAgAyADQRhqNgIAIABBk6gBIAMQJQ0AIAJBCjoASwsgAkH6ETYCKCACQfsRNgIkIAJB/BE2AiAgAkH9ETYCDEHM/QooAgBFBEAgAkF/NgJMCyACEMMVCyECIANBIGokACACC3EBA38jAEEQayICJAACQAJAQbTfCCABLAAAEPwURQRAQcT9CkEcNgIADAELIAEQxxUhBCACQbYDNgIAIAAgBEGAgAJyIAIQIBDrFCIAQQBIDQEgACABEKIVIgMNASAAECMaC0EAIQMLIAJBEGokACADC7sBAQJ/IwBBoAFrIgQkACAEQQhqQbjfCEGQARCuGxoCQAJAIAFBAWtB/////wdPBEAgAQ0BQQEhASAEQZ8BaiEACyAEIAA2AjQgBCAANgIcIARBfiAAayIFIAEgASAFSxsiATYCOCAEIAAgAWoiADYCJCAEIAA2AhggBEEIaiACIAMQvBUhACABRQ0BIAQoAhwiASABIAQoAhhGa0EAOgAADAELQcT9CkE9NgIAQX8hAAsgBEGgAWokACAACzQBAX8gACgCFCIDIAEgAiAAKAIQIANrIgMgAiADSRsiAxCuGxogACAAKAIUIANqNgIUIAILiwEBAn8jAEGgAWsiAyQAIANBCGpBuN8IQZABEK4bGiADIAA2AjQgAyAANgIcIANBfiAAayIEQf////8HIARB/////wdJGyIENgI4IAMgACAEaiIANgIkIAMgADYCGCADQQhqIAEgAhC/FSAEBEAgAygCHCIEIAQgAygCGEZrQQA6AAALIANBoAFqJAALiwEBAn8jAEGgAWsiAyQAIANBCGpBuN8IQZABEK4bGiADIAA2AjQgAyAANgIcIANBfiAAayIEQf////8HIARB/////wdJGyIENgI4IAMgACAEaiIANgIkIAMgADYCGCADQQhqIAEgAhDAFSAEBEAgAygCHCIEIAQgAygCGEZrQQA6AAALIANBoAFqJAALtAEBA38gAygCTBogAyADLQBKIgRBAWsgBHI6AEoCfyABIAJsIgYgAygCCCADKAIEIgVrIgRBAUgNABogACAFIAQgBiAEIAZJGyIFEK4bGiADIAMoAgQgBWo2AgQgACAFaiEAIAYgBWsLIgQEQANAAkAgAxCsFUUEQCADIAAgBCADKAIgEQUAIgVBAWpBAUsNAQsgBiAEayABbg8LIAAgBWohACAEIAVrIgQNAAsLIAJBACABGwskAQF/IwBBEGsiAyQAIAMgAjYCDCAAIAEgAhCmFSADQRBqJAALJAEBfyMAQRBrIgMkACADIAI2AgwgACABIAIQpxUgA0EQaiQACzwBAX8jAEEQayIDJAAgACgCPCABIAJB/wFxIANBCGoQpR4Q2xUhACADKQMIIQEgA0EQaiQAQn8gASAAGwt8AQJ/IAAgAC0ASiIBQQFrIAFyOgBKIAAoAhQgACgCHEsEQCAAQQBBACAAKAIkEQUAGgsgAEEANgIcIABCADcDECAAKAIAIgFBBHEEQCAAIAFBIHI2AgBBfw8LIAAgACgCLCAAKAIwaiICNgIIIAAgAjYCBCABQRt0QR91CzwAIAAoAkxBAE4EQCAAQgBBABCfFRogACAAKAIAQV9xNgIADwsgAEIAQQAQnxUaIAAgACgCAEFfcTYCAAvAAgEEfyACKAJMGiABQQFrIQQCQCABQQJOBEAgACEBAkADQAJAIARFDQACfyACKAIEIgNBCiACKAIIIANrEPoUIgYEQCAGIAIoAgQiBWtBAWoMAQsgAigCCCACKAIEIgVrCyEDIAEgBSADIAQgAyAESRsiAxCuGxogAiACKAIEIANqIgU2AgQgASADaiEBIAYNACAEIANrIgRFDQACQCACKAIIIAVLBEAgAiAFQQFqNgIEIAUtAAAhAwwBCyACEJ0VIgNBf0oNAEEAIQMgACABRg0DIAItAABBEHFFDQMMAQsgASADOgAAIAFBAWohASAEQQFrIQQgA0H/AXFBCkcNAQsLIABFBEBBACEDDAELIAFBADoAACAAIQMLDAELIAIgAi0ASiIBQQFrIAFyOgBKIAQNACAAQQA6AAAgAA8LIAMLCgAgAEEwa0EKSQuUAgACQCAABH8gAUH/AE0NAQJAQZjRCigCACgCAEUEQCABQYB/cUGAvwNGDQNBxP0KQRk2AgAMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAg8LIAFBgLADT0EAIAFBgEBxQYDAA0cbRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LQcT9CkEZNgIAC0F/BUEBCw8LIAAgAToAAEEBCxIAIABFBEBBAA8LIAAgARCwFQt/AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARCyFSEAIAEoAgBBQGoLNgIAIAAPCyABIAJB/gdrNgIAIANC/////////4eAf4NCgICAgICAgPA/hL8FIAALC/wCAQN/IwBB0AFrIgUkACAFIAI2AswBQQAhAiAFQaABakEAQSgQrxsaIAUgBSgCzAE2AsgBAkBBACABIAVByAFqIAVB0ABqIAVBoAFqIAMgBBC0FUEASARAQX8hAQwBC0EBIAIgACgCTEEAThshAiAAKAIAIQYgACwASkEATARAIAAgBkFfcTYCAAsgBkEgcSEGAn8gACgCMARAIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQtBUMAQsgAEHQADYCMCAAIAVB0ABqNgIQIAAgBTYCHCAAIAU2AhQgACgCLCEHIAAgBTYCLCAAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEELQVIgEgB0UNABogAEEAQQAgACgCJBEFABogAEEANgIwIAAgBzYCLCAAQQA2AhwgAEEANgIQIAAoAhQhAyAAQQA2AhQgAUF/IAMbCyEBIAAgACgCACIDIAZyNgIAQX8gASADQSBxGyEBIAJFDQALIAVB0AFqJAAgAQu0EQIPfwF+IwBB0ABrIgckACAHIAE2AkwgB0E3aiEVIAdBOGohEkEAIQECQANAAkAgD0EASA0AQf////8HIA9rIAFIBEBBxP0KQT02AgBBfyEPDAELIAEgD2ohDwsgBygCTCILIQECQAJAAkAgCy0AACIIBEADQAJAAkAgCEH/AXEiCEUEQCABIQgMAQsgCEElRw0BIAEhCANAIAEtAAFBJUcNASAHIAFBAmoiCTYCTCAIQQFqIQggAS0AAiEMIAkhASAMQSVGDQALCyAIIAtrIQEgAARAIAAgCyABELUVCyABDQYgBygCTCwAARCvFSEBIAcoAkwhCCAHAn8CQCABRQ0AIAgtAAJBJEcNACAILAABQTBrIRFBASETIAhBA2oMAQtBfyERIAhBAWoLIgE2AkxBACEQAkAgASwAACIMQSBrIglBH0sEQCABIQgMAQsgASEIQQEgCXQiCUGJ0QRxRQ0AA0AgByABQQFqIgg2AkwgCSAQciEQIAEsAAEiDEEgayIJQSBPDQEgCCEBQQEgCXQiCUGJ0QRxDQALCwJAIAxBKkYEQCAHAn8CQCAILAABEK8VRQ0AIAcoAkwiCC0AAkEkRw0AIAgsAAFBAnQgBGpBwAFrQQo2AgAgCCwAAUEDdCADakGAA2soAgAhDUEBIRMgCEEDagwBCyATDQZBACETQQAhDSAABEAgAiACKAIAIgFBBGo2AgAgASgCACENCyAHKAJMQQFqCyIBNgJMIA1Bf0oNAUEAIA1rIQ0gEEGAwAByIRAMAQsgB0HMAGoQthUiDUEASA0EIAcoAkwhAQtBfyEKAkAgAS0AAEEuRw0AIAEtAAFBKkYEQAJAIAEsAAIQrxVFDQAgBygCTCIBLQADQSRHDQAgASwAAkECdCAEakHAAWtBCjYCACABLAACQQN0IANqQYADaygCACEKIAcgAUEEaiIBNgJMDAILIBMNBSAABH8gAiACKAIAIgFBBGo2AgAgASgCAAVBAAshCiAHIAcoAkxBAmoiATYCTAwBCyAHIAFBAWo2AkwgB0HMAGoQthUhCiAHKAJMIQELQQAhCANAIAghCUF/IQ4gASwAAEHBAGtBOUsNCCAHIAFBAWoiDDYCTCABLAAAIQggDCEBIAggCUE6bGpBn+AIai0AACIIQQFrQQhJDQALAkACQCAIQRNHBEAgCEUNCiARQQBOBEAgBCARQQJ0aiAINgIAIAcgAyARQQN0aikDADcDQAwCCyAARQ0IIAdBQGsgCCACIAYQtxUgBygCTCEMDAILIBFBf0oNCQtBACEBIABFDQcLIBBB//97cSIUIBAgEEGAwABxGyEIQQAhDkHI4AghESASIRACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAMQQFrLAAAIgFBX3EgASABQQ9xQQNGGyABIAkbIgFB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIAFBwQBrDgcOFAsUDg4OAAsgAUHTAEYNCQwTCyAHKQNAIRZByOAIDAULQQAhAQJAAkACQAJAAkACQAJAIAlB/wFxDggAAQIDBBoFBhoLIAcoAkAgDzYCAAwZCyAHKAJAIA82AgAMGAsgBygCQCAPrDcDAAwXCyAHKAJAIA87AQAMFgsgBygCQCAPOgAADBULIAcoAkAgDzYCAAwUCyAHKAJAIA+sNwMADBMLIApBCCAKQQhLGyEKIAhBCHIhCEH4ACEBCyAHKQNAIBIgAUEgcRC4FSELIAhBCHFFDQMgBykDQFANAyABQQR2QcjgCGohEUECIQ4MAwsgBykDQCASELkVIQsgCEEIcUUNAiAKIBIgC2siAUEBaiABIApIGyEKDAILIAcpA0AiFkJ/VwRAIAdCACAWfSIWNwNAQQEhDkHI4AgMAQsgCEGAEHEEQEEBIQ5ByeAIDAELQcrgCEHI4AggCEEBcSIOGwshESAWIBIQuhUhCwsgCEH//3txIAggCkF/ShshCCAHKQNAIRYCQCAKDQAgFlBFDQBBACEKIBIhCwwMCyAKIBZQIBIgC2tqIgEgASAKSBshCgwLCyAHKAJAIgFB0uAIIAEbIgtBACAKEPoUIgEgCiALaiABGyEQIBQhCCABIAtrIAogARshCgwKCyAKBEAgBygCQAwCC0EAIQEgAEEgIA1BACAIELsVDAILIAdBADYCDCAHIAcpA0A+AgggByAHQQhqNgJAQX8hCiAHQQhqCyEJQQAhAQJAA0AgCSgCACIMRQ0BAkAgB0EEaiAMELEVIgxBAEgiCw0AIAwgCiABa0sNACAJQQRqIQkgCiABIAxqIgFLDQEMAgsLQX8hDiALDQsLIABBICANIAEgCBC7FSABRQRAQQAhAQwBC0EAIQwgBygCQCEJA0AgCSgCACILRQ0BIAdBBGogCxCxFSILIAxqIgwgAUoNASAAIAdBBGogCxC1FSAJQQRqIQkgASAMSw0ACwsgAEEgIA0gASAIQYDAAHMQuxUgDSABIAEgDUgbIQEMCAsgACAHKwNAIA0gCiAIIAEgBRFFACEBDAcLIAcgBykDQDwAN0EBIQogFSELIBQhCAwECyAHIAFBAWoiCTYCTCABLQABIQggCSEBDAALAAsgDyEOIAANBCATRQ0CQQEhAQNAIAQgAUECdGooAgAiCARAIAMgAUEDdGogCCACIAYQtxVBASEOIAFBAWoiAUEKRw0BDAYLC0EBIQ4gAUEKTw0EA0AgBCABQQJ0aigCAA0BIAFBAWoiAUEKRw0ACwwEC0F/IQ4MAwsgAEEgIA4gECALayIMIAogCiAMSBsiEGoiCSANIAkgDUobIgEgCSAIELsVIAAgESAOELUVIABBMCABIAkgCEGAgARzELsVIABBMCAQIAxBABC7FSAAIAsgDBC1FSAAQSAgASAJIAhBgMAAcxC7FQwBCwtBACEOCyAHQdAAaiQAIA4LGAAgAC0AAEEgcUUEQCABIAIgABCzGxoLC0QBA38gACgCACwAABCvFQRAA0AgACgCACICLAAAIQMgACACQQFqNgIAIAMgAUEKbGpBMGshASACLAABEK8VDQALCyABC7sCAAJAIAFBFEsNAAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOCgABAgMEBQYHCAkKCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEyAQA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEzAQA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEwAAA3AwAPCyACIAIoAgAiAUEEajYCACAAIAExAAA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAErAwA5AwAPCyAAIAIgAxECAAsLNQAgAFBFBEADQCABQQFrIgEgAKdBD3FBsOQIai0AACACcjoAACAAQgSIIgBCAFINAAsLIAELLQAgAFBFBEADQCABQQFrIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBAWsiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQQFrIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQtyAQF/IwBBgAJrIgUkAAJAIAIgA0wNACAEQYDABHENACAFIAFB/wFxIAIgA2siAkGAAiACQYACSSIDGxCvGxogA0UEQANAIAAgBUGAAhC1FSACQYACayICQf8BSw0ACwsgACAFIAIQtRULIAVBgAJqJAALEQAgACABIAJB/xFBgBIQsxULyRcDEn8CfgF8IwBBsARrIgkkACAJQQA2AiwCfyABvSIYQn9XBEBBASESIAGaIgG9IRhBwOQIDAELQQEhEkHD5AggBEGAEHENABpBxuQIIARBAXENABpBACESQQEhF0HB5AgLIRQCQCAYQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEkEDaiIMIARB//97cRC7FSAAIBQgEhC1FSAAQdvkCEHf5AggBUEgcSIGG0HT5AhB1+QIIAYbIAEgAWIbQQMQtRUgAEEgIAIgDCAEQYDAAHMQuxUMAQsgCUEQaiEQAkACfwJAIAEgCUEsahCyFSIBIAGgIgFEAAAAAAAAAABiBEAgCSAJKAIsIgZBAWs2AiwgBUEgciIVQeEARw0BDAMLIAVBIHIiFUHhAEYNAiAJKAIsIRNBBiADIANBAEgbDAELIAkgBkEdayITNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAlBMGogCUHQAmogE0EASBsiDiEIA0AgCAJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgY2AgAgCEEEaiEIIAEgBrihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIBNBAUgEQCATIQMgCCEGIA4hBwwBCyAOIQcgEyEDA0AgA0EdIANBHUgbIQMCQCAIQQRrIgYgB0kNACADrSEZQgAhGANAIAYgGEL/////D4MgBjUCACAZhnwiGCAYQoCU69wDgCIYQoCU69wDfn0+AgAgBkEEayIGIAdPDQALIBinIgZFDQAgB0EEayIHIAY2AgALA0AgByAIIgZJBEAgBkEEayIIKAIARQ0BCwsgCSAJKAIsIANrIgM2AiwgBiEIIANBAEoNAAsLIANBf0wEQCALQRlqQQltQQFqIREgFUHmAEYhFgNAQQlBACADayADQXdIGyEMAkAgBiAHTQRAIAcgB0EEaiAHKAIAGyEHDAELQYCU69wDIAx2IQ1BfyAMdEF/cyEPQQAhAyAHIQgDQCAIIAgoAgAiCiAMdiADajYCACAKIA9xIA1sIQMgCEEEaiIIIAZJDQALIAcgB0EEaiAHKAIAGyEHIANFDQAgBiADNgIAIAZBBGohBgsgCSAJKAIsIAxqIgM2AiwgDiAHIBYbIgggEUECdGogBiAGIAhrQQJ1IBFKGyEGIANBAEgNAAsLQQAhCAJAIAYgB00NACAOIAdrQQJ1QQlsIQhBCiEDIAcoAgAiCkEKSQ0AA0AgCEEBaiEIIAogA0EKbCIDTw0ACwsgC0EAIAggFUHmAEYbayAVQecARiALQQBHcWsiAyAGIA5rQQJ1QQlsQQlrSARAIANBgMgAaiIKQQltIg1BAnQgCUEwakEEciAJQdQCaiATQQBIG2pBgCBrIQxBCiEDIAogDUEJbGsiCkEHTARAA0AgA0EKbCEDIApBAWoiCkEIRw0ACwsCQEEAIAYgDEEEaiIRRiAMKAIAIg0gDSADbiIPIANsayIKGw0ARAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAogA0EBdiIWRhtEAAAAAAAA+D8gBiARRhsgCiAWSRshGkQBAAAAAABAQ0QAAAAAAABAQyAPQQFxGyEBAkAgFw0AIBQtAABBLUcNACAamiEaIAGaIQELIAwgDSAKayIKNgIAIAEgGqAgAWENACAMIAMgCmoiCDYCACAIQYCU69wDTwRAA0AgDEEANgIAIAcgDEEEayIMSwRAIAdBBGsiB0EANgIACyAMIAwoAgBBAWoiCDYCACAIQf+T69wDSw0ACwsgDiAHa0ECdUEJbCEIQQohAyAHKAIAIgpBCkkNAANAIAhBAWohCCAKIANBCmwiA08NAAsLIAxBBGoiAyAGIAMgBkkbIQYLA0AgBiIDIAdNIgpFBEAgA0EEayIGKAIARQ0BCwsCQCAVQecARwRAIARBCHEhDwwBCyAIQX9zQX8gC0EBIAsbIgYgCEogCEF7SnEiDBsgBmohC0F/QX4gDBsgBWohBSAEQQhxIg8NAEF3IQYCQCAKDQAgA0EEaygCACIMRQ0AQQohCkEAIQYgDEEKcA0AA0AgBiINQQFqIQYgDCAKQQpsIgpwRQ0ACyANQX9zIQYLIAMgDmtBAnVBCWwhCiAFQV9xQcYARgRAQQAhDyALIAYgCmpBCWsiBkEAIAZBAEobIgYgBiALShshCwwBC0EAIQ8gCyAIIApqIAZqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsLIAsgD3IiFkEARyEKIABBICACAn8gCEEAIAhBAEobIAVBX3EiDUHGAEYNABogECAIIAhBH3UiBmogBnOtIBAQuhUiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBAgBmtBAkgNAAsLIAZBAmsiESAFOgAAIAZBAWtBLUErIAhBAEgbOgAAIBAgEWsLIAsgEmogCmpqQQFqIgwgBBC7FSAAIBQgEhC1FSAAQTAgAiAMIARBgIAEcxC7FQJAAkACQCANQcYARgRAIAlBEGpBCHIhDSAJQRBqQQlyIQggDiAHIAcgDksbIgohBwNAIAc1AgAgCBC6FSEGAkAgByAKRwRAIAYgCUEQak0NAQNAIAZBAWsiBkEwOgAAIAYgCUEQaksNAAsMAQsgBiAIRw0AIAlBMDoAGCANIQYLIAAgBiAIIAZrELUVIAdBBGoiByAOTQ0ACyAWBEAgAEHj5AhBARC1FQsgAyAHTQ0BIAtBAUgNAQNAIAc1AgAgCBC6FSIGIAlBEGpLBEADQCAGQQFrIgZBMDoAACAGIAlBEGpLDQALCyAAIAYgC0EJIAtBCUgbELUVIAtBCWshBiAHQQRqIgcgA08NAyALQQlKIQogBiELIAoNAAsMAgsCQCALQQBIDQAgAyAHQQRqIAMgB0sbIQ0gCUEQakEIciEOIAlBEGpBCXIhAyAHIQgDQCADIAg1AgAgAxC6FSIGRgRAIAlBMDoAGCAOIQYLAkAgByAIRwRAIAYgCUEQak0NAQNAIAZBAWsiBkEwOgAAIAYgCUEQaksNAAsMAQsgACAGQQEQtRUgBkEBaiEGIA9FQQAgC0EBSBsNACAAQePkCEEBELUVCyAAIAYgAyAGayIKIAsgCiALSBsQtRUgCyAKayELIAhBBGoiCCANTw0BIAtBf0oNAAsLIABBMCALQRJqQRJBABC7FSAAIBEgECARaxC1FQwCCyALIQYLIABBMCAGQQlqQQlBABC7FQsgAEEgIAIgDCAEQYDAAHMQuxUMAQsgFEEJaiAUIAVBIHEiCBshCwJAIANBC0sNAEEMIANrIgZFDQBEAAAAAAAAIEAhGgNAIBpEAAAAAAAAMECiIRogBkEBayIGDQALIAstAABBLUYEQCAaIAGaIBqhoJohAQwBCyABIBqgIBqhIQELIBAgCSgCLCIGIAZBH3UiBmogBnOtIBAQuhUiBkYEQCAJQTA6AA8gCUEPaiEGCyASQQJyIQ8gCSgCLCEHIAZBAmsiDSAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhCiAJQRBqIQcDQCAHIgYCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0Gw5AhqLQAAIAhyOgAAIAEgB7ehRAAAAAAAADBAoiEBAkAgBkEBaiIHIAlBEGprQQFHDQACQCAKDQAgA0EASg0AIAFEAAAAAAAAAABhDQELIAZBLjoAASAGQQJqIQcLIAFEAAAAAAAAAABiDQALIABBICACIA8CfwJAIANFDQAgByAJa0ESayADTg0AIAMgEGogDWtBAmoMAQsgECAJQRBqayANayAHagsiBmoiDCAEELsVIAAgCyAPELUVIABBMCACIAwgBEGAgARzELsVIAAgCUEQaiAHIAlBEGprIgcQtRUgAEEwIAYgByAQIA1rIghqa0EAQQAQuxUgACANIAgQtRUgAEEgIAIgDCAEQYDAAHMQuxULIAlBsARqJAAgAiAMIAIgDEobCykAIAEgASgCAEEPakFwcSIBQRBqNgIAIAAgASkDACABKQMIEO4VOQMACxAAIAAgASACQQBBABCzFRoLEQAgACABIAJB/xFBABCzFRoLCQAgACgCPBAjCyQBAX8jAEEQayIDJAAgAyACNgIMIAAgASACEL8VIANBEGokAAsuAQF/IABBqIYLKAIANgI4QaiGCygCACIBBEAgASAANgI0C0GohgsgADYCACAACwQAQgAL1AIBB38jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEGQQIhByADQRBqIQECfwJAAkAgACgCPCADQRBqQQIgA0EMahAhENsVRQRAA0AgBiADKAIMIgRGDQIgBEF/TA0DIAEgBCABKAIEIghLIgVBA3RqIgkgBCAIQQAgBRtrIgggCSgCAGo2AgAgAUEMQQQgBRtqIgkgCSgCACAIazYCACAGIARrIQYgACgCPCABQQhqIAEgBRsiASAHIAVrIgcgA0EMahAhENsVRQ0ACwsgBkF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgASgCBGsLIQQgA0EgaiQAIAQLKAACQCAAKAJMQX9MBEAgACgCACEADAELIAAoAgAhAAsgAEEEdkEBcQt2AQF/QQIhAQJ/IABBKxD8FEUEQCAALQAAQfIARyEBCyABQYABcgsgASAAQfgAEPwUGyIBQYCAIHIgASAAQeUAEPwUGyIBIAFBwAByIAAtAAAiAEHyAEYbIgFBgARyIAEgAEH3AEYbIgFBgAhyIAEgAEHhAEYbCz8CAn8BfiAAIAE3A3AgACAAKAIIIgIgACgCBCIDa6wiBDcDeCAAIAMgAadqIAIgASAEUxsgAiABQgBSGzYCaAuvAQIDfwF+AkACQCAAKQNwIgRQRQRAIAApA3ggBFkNAQsgABCdFSIDQX9KDQELIABBADYCaEF/DwsgAAJ/IAAoAggiASAAKQNwIgRQDQAaIAEgBCAAKQN4Qn+FfCIEIAEgACgCBCICa6xZDQAaIAIgBKdqCzYCaCAAKAIEIQIgAQRAIAAgACkDeCABIAJrQQFqrHw3A3gLIAJBAWsiAC0AACADRwRAIAAgAzoAAAsgAwvWCgIFfwR+IwBBEGsiByQAAkACQAJAAkACQAJAIAFBJE0EQANAAn8gACgCBCIEIAAoAmhJBEAgACAEQQFqNgIEIAQtAAAMAQsgABDJFQsiBBDnFA0ACwJAAkAgBEEraw4DAAEAAQtBf0EAIARBLUYbIQYgACgCBCIEIAAoAmhJBEAgACAEQQFqNgIEIAQtAAAhBAwBCyAAEMkVIQQLAkACQCABQW9xDQAgBEEwRw0AAn8gACgCBCIEIAAoAmhJBEAgACAEQQFqNgIEIAQtAAAMAQsgABDJFQsiBEFfcUHYAEYEQEEQIQECfyAAKAIEIgQgACgCaEkEQCAAIARBAWo2AgQgBC0AAAwBCyAAEMkVCyIEQfHkCGotAABBEEkNBSAAKAJoRQRAQgAhAyACDQoMCQsgACAAKAIEIgRBAWs2AgQgAkUNCCAAIARBAms2AgRCACEDDAkLIAENAUEIIQEMBAsgAUEKIAEbIgEgBEHx5AhqLQAASw0AIAAoAmgEQCAAIAAoAgRBAWs2AgQLQgAhAyAAQgAQyBVBxP0KQRw2AgAMBwsgAUEKRw0CIARBMGsiAkEJTQRAQQAhAQNAIAIgAUEKbGohAQJ/IAAoAgQiBCAAKAJoSQRAIAAgBEEBajYCBCAELQAADAELIAAQyRULIgRBMGsiAkEJTUEAIAFBmbPmzAFJGw0ACyABrSEJCyACQQlLDQEgCUIKfiEKIAKtIQsDQCAKIAt8IQkCfyAAKAIEIgQgACgCaEkEQCAAIARBAWo2AgQgBC0AAAwBCyAAEMkVCyIEQTBrIgJBCUsNAiAJQpqz5syZs+bMGVoNAiAJQgp+IgogAq0iC0J/hVgNAAtBCiEBDAMLQcT9CkEcNgIAQgAhAwwFC0EKIQEgAkEJTQ0BDAILIAEgAUEBa3EEQCAEQfHkCGotAAAiAiABSQRAA0AgAiABIAVsaiIFQcbj8ThNQQACfyAAKAIEIgQgACgCaEkEQCAAIARBAWo2AgQgBC0AAAwBCyAAEMkVCyIEQfHkCGotAAAiAiABSRsNAAsgBa0hCQsgASACTQ0BIAGtIQoDQCAJIAp+IgsgAq1C/wGDIgxCf4VWDQIgCyAMfCEJIAECfyAAKAIEIgQgACgCaEkEQCAAIARBAWo2AgQgBC0AAAwBCyAAEMkVCyIEQfHkCGotAAAiAk0NAiAHIAogCRDjFSAHKQMIUA0ACwwBCyABQRdsQQV2QQdxQfHmCGosAAAhCCAEQfHkCGotAAAiAiABSQRAA0AgAiAFIAh0ciIFQf///z9NQQACfyAAKAIEIgQgACgCaEkEQCAAIARBAWo2AgQgBC0AAAwBCyAAEMkVCyIEQfHkCGotAAAiAiABSRsNAAsgBa0hCQtCfyAIrSIKiCILIAlUDQAgASACTQ0AA0AgAq1C/wGDIAkgCoaEIQkCfyAAKAIEIgQgACgCaEkEQCAAIARBAWo2AgQgBC0AAAwBCyAAEMkVCyEEIAkgC1YNASABIARB8eQIai0AACICSw0ACwsgASAEQfHkCGotAABNDQADQCABAn8gACgCBCIEIAAoAmhJBEAgACAEQQFqNgIEIAQtAAAMAQsgABDJFQtB8eQIai0AAEsNAAtBxP0KQcQANgIAIAZBACADQgGDUBshBiADIQkLIAAoAmgEQCAAIAAoAgRBAWs2AgQLAkAgAyAJVg0AAkAgA6dBAXENACAGDQBBxP0KQcQANgIAIANCAX0hAwwDCyADIAlaDQBBxP0KQcQANgIADAILIAkgBqwiA4UgA30hAwwBC0IAIQMgAEIAEMgVCyAHQRBqJAAgAwsNACAAIAEgAkJ/EMwVC3wBAX8jAEGQAWsiBCQAIAQgADYCLCAEIAA2AgQgBEEANgIAIARBfzYCTCAEQX8gAEH/////B2ogAEEASBs2AgggBEIAEMgVIAQgAkEBIAMQyhUhAyABBEAgASAAIAQoAgQgBCgCeGogBCgCCGtqNgIACyAEQZABaiQAIAMLEgAgACABIAJCgICAgAgQzBWnCzUAIAAgATcDACAAIAJC////////P4MgBEIwiKdBgIACcSACQjCIp0H//wFxcq1CMIaENwMIC8QCAQF/IwBB0ABrIgQkAAJAIANBgIABTgRAIARBIGogASACQgBCgICAgICAgP//ABDqFSAEKQMoIQIgBCkDICEBIANB//8BSARAIANB//8AayEDDAILIARBEGogASACQgBCgICAgICAgP//ABDqFSADQf3/AiADQf3/AkgbQf7/AWshAyAEKQMYIQIgBCkDECEBDAELIANBgYB/Sg0AIARBQGsgASACQgBCgICAgICAwAAQ6hUgBCkDSCECIAQpA0AhASADQYOAfkoEQCADQf7/AGohAwwBCyAEQTBqIAEgAkIAQoCAgICAgMAAEOoVIANBhoB9IANBhoB9ShtB/P8BaiEDIAQpAzghAiAEKQMwIQELIAQgASACQgAgA0H//wBqrUIwhhDqFSAAIAQpAwg3AwggACAEKQMANwMAIARB0ABqJAALlAgCBn8CfiMAQTBrIgYkAAJAIAJBAk0EQCABQQRqIQUgAkECdCICQcznCGooAgAhCCACQcDnCGooAgAhCQNAAn8gASgCBCICIAEoAmhJBEAgBSACQQFqNgIAIAItAAAMAQsgARDJFQsiAhDnFA0AC0EBIQcCQAJAIAJBK2sOAwABAAELQX9BASACQS1GGyEHIAEoAgQiAiABKAJoSQRAIAUgAkEBajYCACACLQAAIQIMAQsgARDJFSECCwJAAkADQCAEQfrmCGosAAAgAkEgckYEQAJAIARBBksNACABKAIEIgIgASgCaEkEQCAFIAJBAWo2AgAgAi0AACECDAELIAEQyRUhAgsgBEEBaiIEQQhH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DQAgAC0AAEUNACAAQT0Q/BQNAEGshgsoAgAoAgAiAkUNAAJAA0AgACACIAQQgBUhA0GshgsoAgAhAiADRQRAIAIgAUECdGooAgAgBGoiAy0AAEE9Rg0CCyACIAFBAWoiAUECdGooAgAiAg0AC0EADwsgA0EBaiEBCyABCxYAIABFBEBBAA8LQcT9CiAANgIAQX8LAwABC9kBAQN/IABFBEBBHA8LQbCGCygCAEUEQEGwhgtBBDYCAEG0hgtBEBChGzYCAAtBuIYLKAIAIgMEQEG0hgsoAgAhAgJAA0AgAiABQQN0aigCBEUNASABQQFqIgEgA0cNAAsgAyEBCyADQQJ0IQILQbCGCygCACABRgRAQbCGCyABQQF0NgIAQbSGC0G0hgsoAgAgAhCjGzYCAEG4hgsoAgAhAwsgAUEBaiECIAEgA0YEQEG4hgsgAjYCAAtBtIYLKAIAIAFBA3RqQoCAgIAQNwIAIAAgAjYCAEEAC0UBAX9BHCEBAkAgAEEBayIAQbiGCygCAE8NAEG0hgsoAgAgAEEDdGoiACgCBEUNAEEAIQEgAEEANgIAIABBADYCBAsgAQs2AAJ/QQAgAEEBayIAQbiGCygCAE8NABpBAEG0hgsoAgAgAEEDdGoiACgCBEUNABogACgCAAsLPgEBf0EcIQICQCAAQQFrIgBBuIYLKAIATw0AQbSGCygCACAAQQN0aiIAKAIERQ0AIAAgATYCAEEAIQILIAIL2wECAX8CfkEBIQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQAgACAChCAFIAaEhFAEQEEADwsgASADg0IAWQRAQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvEAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQBBACACQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACAAIAQgBYSEUARAQQAPCyABIAKDQgBZBEBBACABIAJTIAEgAlEbDQEgACABIAKFhEIAUg8LIABCAFIgASACVSABIAJRGw0AIAAgASAChYRCAFIhAwsgAwtpAQN+IAAgAkIgiCIDIAFCIIgiBH4gAkL/////D4MiAiABQv////8PgyIBfiIFQiCIIAIgBH58IgJCIIh8IAEgA34gAkL/////D4N8IgJCIIh8NwMIIAAgBUL/////D4MgAkIghoQ3AwALUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgL4QkCBH8EfiMAQfAAayIFJAAgBEL///////////8AgyEKAkACQCABQgF9IglCf1EgAkL///////////8AgyILIAEgCVatfEIBfSIJQv///////7///wBWIAlC////////v///AFEbRQRAIANCAX0iCUJ/UiAKIAMgCVatfEIBfSIJQv///////7///wBUIAlC////////v///AFEbDQELIAFQIAtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIAtCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCkKAgICAgIDA//8AhYRQDQEgASALhFAEQCADIAqEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAqEUEUNACABIQMgAiEEDAELIAMgASABIANUIAogC1YgCiALURsiBxshCiAEIAIgBxsiC0L///////8/gyEJIAIgBCAHGyICQjCIp0H//wFxIQggC0IwiKdB//8BcSIGRQRAIAVB4ABqIAogCSAKIAkgCVAiBht5IAZBBnStfKciBkEPaxDkFSAFKQNoIQkgBSkDYCEKQRAgBmshBgsgASADIAcbIQMgAkL///////8/gyEEIAhFBEAgBUHQAGogAyAEIAMgBCAEUCIHG3kgB0EGdK18pyIHQQ9rEOQVQRAgB2shCCAFKQNYIQQgBSkDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEEIAlCA4YgCkI9iIQhASACIAuFIQkCfiADQgOGIgMgBiAIayIHRQ0AGiAHQf8ASwRAQgAhBEIBDAELIAVBQGsgAyAEQYABIAdrEOQVIAVBMGogAyAEIAcQ5xUgBSkDOCEEIAUpAzAgBSkDQCAFKQNIhEIAUq2ECyEDIAFCgICAgICAgASEIQwgCkIDhiECAkAgCUJ/VwRAIAIgA30iASAMIAR9IAIgA1StfSIEhFAEQEIAIQNCACEEDAMLIARC/////////wNWDQEgBUEgaiABIAQgASAEIARQIgcbeSAHQQZ0rXynQQxrIgcQ5BUgBiAHayEGIAUpAyghBCAFKQMgIQEMAQsgAiADfCIBIANUrSAEIAx8fCIEQoCAgICAgIAIg1ANACABQgGDIARCP4YgAUIBiISEIQEgBkEBaiEGIARCAYghBAsgC0KAgICAgICAgIB/gyECIAZB//8BTgRAIAJCgICAgICAwP//AIQhBEIAIQMMAQtBACEHAkAgBkEASgRAIAYhBwwBCyAFQRBqIAEgBCAGQf8AahDkFSAFIAEgBEEBIAZrEOcVIAUpAwAgBSkDECAFKQMYhEIAUq2EIQEgBSkDCCEECyAEQj2GIAFCA4iEIgMgAyABp0EHcSIGQQRLrXwiAVatIARCA4hC////////P4MgAoQgB61CMIaEfCEEAkACQCAGQQRHBEAgASEDDAELIAQgAUIBgyICIAF8IgMgAlStfCEEDAELIAZFDQELCyAAIAM3AwAgACAENwMIIAVB8ABqJAALxwECA38CfiMAQRBrIgMkAAJ+IAG8IgRB/////wdxIgJBgICABGtB////9wdNBEAgAq1CGYZCgICAgICAgMA/fAwBCyACQYCAgPwHTwRAIAStQhmGQoCAgICAgMD//wCEDAELIAJFBEBCAAwBCyADIAKtQgAgAmciAkHRAGoQ5BUgAykDACEFIAMpAwhCgICAgICAwACFQYn/ACACa61CMIaECyEGIAAgBTcDACAAIAYgBEGAgICAeHGtQiCGhDcDCCADQRBqJAALUAEBfgJAIANBwABxBEAgAiADQUBqrYghAUIAIQIMAQsgA0UNACACQcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgLtgMCA38BfiMAQSBrIgMkAAJAIAFC////////////AIMiBUKAgICAgIDAwD99IAVCgICAgICAwL/AAH1UBEAgAUIZiKchBCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURtFBEAgBEGBgICABGohAgwCCyAEQYCAgIAEaiECIAAgBUKAgIAIhYRCAFINASACIARBAXFqIQIMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQhmIp0H///8BcUGAgID+B3IhAgwBC0GAgID8ByECIAVC////////v7/AAFYNAEEAIQIgBUIwiKciBEGR/gBJDQAgA0EQaiAAIAFC////////P4NCgICAgICAwACEIgUgBEGB/gBrEOQVIAMgACAFQYH/ACAEaxDnFSADKQMIIgVCGYinIQIgAykDACADKQMQIAMpAxiEQgBSrYQiAFAgBUL///8PgyIFQoCAgAhUIAVCgICACFEbRQRAIAJBAWohAgwBCyAAIAVCgICACIWEQgBSDQAgAkEBcSACaiECCyADQSBqJAAgAiABQiCIp0GAgICAeHFyvgv6AQICfwN+IwBBEGsiAiQAAn4gAb0iBUL///////////8AgyIEQoCAgICAgIAIfUL/////////7/8AWARAIARCPIYhBiAEQgSIQoCAgICAgICAPHwMAQsgBEKAgICAgICA+P8AWgRAIAVCPIYhBiAFQgSIQoCAgICAgMD//wCEDAELIARQBEBCAAwBCyACIARCACAFp2dBIGogBEIgiKdnIARCgICAgBBUGyIDQTFqEOQVIAIpAwAhBiACKQMIQoCAgICAgMAAhUGM+AAgA2utQjCGhAshBCAAIAY3AwAgACAEIAVCgICAgICAgICAf4OENwMIIAJBEGokAAueCwIFfw9+IwBB4ABrIgUkACACQiCGIAFCIIiEIQ4gBEIvhiADQhGIhCELIARC////////P4MiDEIPhiADQjGIhCEQIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghESAMQhGIIRIgBEIwiKdB//8BcSEGAkACfyACQjCIp0H//wFxIghBAWtB/f8BTQRAQQAgBkEBa0H+/wFJDQEaCyABUCACQv///////////wCDIg9CgICAgICAwP//AFQgD0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgD0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIA+EIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIA+EUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyAPQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIHG3kgB0EGdK18pyIHQQ9rEOQVIAUpA1giDUIghiAFKQNQIgFCIIiEIQ4gDUIgiCERQRAgB2shBwsgByACQv///////z9WDQAaIAVBQGsgAyAMIAMgDCAMUCIJG3kgCUEGdK18pyIJQQ9rEOQVIAUpA0giAkIPhiAFKQNAIgNCMYiEIRAgAkIvhiADQhGIhCELIAJCEYghEiAHIAlrQRBqCyEHIAtC/////w+DIgIgAUL/////D4MiBH4iEyADQg+GQoCA/v8PgyIBIA5C/////w+DIgN+fCIOQiCGIgwgASAEfnwiCyAMVK0gAiADfiIVIAEgDUL/////D4MiDH58Ig8gEEL/////D4MiDSAEfnwiECAOIBNUrUIghiAOQiCIhHwiEyACIAx+IhYgASARQoCABIQiDn58IhEgAyANfnwiFCASQv////8Hg0KAgICACIQiASAEfnwiEkIghnwiF3whBCAGIAhqIAdqQf//AGshBgJAIAwgDX4iGCACIA5+fCICIBhUrSACIAEgA358IgMgAlStfCADIA8gFVStIA8gEFatfHwiAiADVK18IAEgDn58IAEgDH4iAyANIA5+fCIBIANUrUIghiABQiCIhHwgAiABQiCGfCIBIAJUrXwgASASIBRUrSARIBZUrSARIBRWrXx8QiCGIBJCIIiEfCIDIAFUrXwgAyAQIBNWrSATIBdWrXx8IgIgA1StfCIBQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyABQgGGIAJCP4iEIQEgAkIBhiAEQj+IhCECIAtCAYYhCyADIARCAYaEIQQLIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIIQYABTwRAQgAhAQwDCyAFQTBqIAsgBCAGQf8AaiIGEOQVIAVBIGogAiABIAYQ5BUgBUEQaiALIAQgCBDnFSAFIAIgASAIEOcVIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEEIAUpAwAhAiAFKQMIDAELIAFC////////P4MgBq1CMIaECyAKhCEKIAtQIARCf1UgBEKAgICAgICAgIB/URtFBEAgCiACQgF8IgEgAlStfCEKDAELIAsgBEKAgICAgICAgIB/hYRQRQRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAtBAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRDlFSAAIAUpAwA3AwAgACAFKQMINwMIIAVBEGokAAt/AgJ/AX4jAEEQayIDJAAgAAJ+IAFFBEBCAAwBCyADIAEgAUEfdSICaiACcyICrUIAIAJnIgJB0QBqEOQVIAMpAwhCgICAgICAwACFQZ6AASACa61CMIZ8IAFBgICAgHhxrUIghoQhBCADKQMACzcDACAAIAQ3AwggA0EQaiQAC4gRAgV/DH4jAEHAAWsiBSQAIARC////////P4MhEiACQv///////z+DIRAgAiAEhUKAgICAgICAgIB/gyERIARCMIinQf//AXEhBwJAAkACQCACQjCIp0H//wFxIghBAWtB/f8BTQRAIAdBAWtB/v8BSQ0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCERDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIREgAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACERDAMLIBFCgICAgICAwP//AIQhEUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASALhFANAiACIAOEUARAIBFCgICAgICAwP//AIQhEUIAIQEMAgsgC0L///////8/WARAIAVBsAFqIAEgECABIBAgEFAiBht5IAZBBnStfKciBkEPaxDkFUEQIAZrIQYgBSkDuAEhECAFKQOwASEBCyACQv///////z9WDQAgBUGgAWogAyASIAMgEiASUCIJG3kgCUEGdK18pyIJQQ9rEOQVIAYgCWpBEGshBiAFKQOoASESIAUpA6ABIQMLIAVBkAFqIBJCgICAgICAwACEIhRCD4YgA0IxiIQiAkKEyfnOv+a8gvUAIAJ9IgQQ4xUgBUGAAWpCACAFKQOYAX0gBBDjFSAFQfAAaiAFKQOIAUIBhiAFKQOAAUI/iIQiBCACEOMVIAVB4ABqIARCACAFKQN4fRDjFSAFQdAAaiAFKQNoQgGGIAUpA2BCP4iEIgQgAhDjFSAFQUBrIARCACAFKQNYfRDjFSAFQTBqIAUpA0hCAYYgBSkDQEI/iIQiBCACEOMVIAVBIGogBEIAIAUpAzh9EOMVIAVBEGogBSkDKEIBhiAFKQMgQj+IhCIEIAIQ4xUgBSAEQgAgBSkDGH0Q4xUgBiAIIAdraiEHAn5CACAFKQMIQgGGIAUpAwBCP4iEQgF9IgtC/////w+DIgQgAkIgiCIKfiIMIAtCIIgiCyACQv////8PgyIPfnwiAkIgiCACIAxUrUIghoQgCiALfnwgAkIghiIKIAQgD358IgIgClStfCACIAQgA0IRiEL/////D4MiDH4iDyALIANCD4ZCgID+/w+DIg1+fCIKQiCGIg4gBCANfnwgDlStIAsgDH4gCiAPVK1CIIYgCkIgiIR8fHwiCiACVK18IApCAFKtfH0iAkL/////D4MiDCAEfiIPIAsgDH4iDSAEIAJCIIgiDn58IgJCIIZ8IgwgD1StIAsgDn4gAiANVK1CIIYgAkIgiIR8fCAMQgAgCn0iAkIgiCIKIAR+Ig8gAkL/////D4MiDSALfnwiAkIghiIOIAQgDX58IA5UrSAKIAt+IAIgD1StQiCGIAJCIIiEfHx8IgIgDFStfCACQgJ9Ig8gAlStfEIBfSIKQv////8PgyICIBBCAoYgAUI+iIRC/////w+DIgR+IgwgAUIeiEL/////D4MiCyAKQiCIIgp+fCINIAxUrSANIA9CIIgiDCAQQh6IQv//7/8Pg0KAgBCEIhB+fCIOIA1UrXwgCiAQfnwgAiAQfiITIAQgCn58Ig0gE1StQiCGIA1CIIiEfCAOIA1CIIZ8Ig0gDlStfCANIAsgDH4iEyAPQv////8PgyIPIAR+fCIOIBNUrSAOIAIgAUIChkL8////D4MiE358IhUgDlStfHwiDiANVK18IA4gCiATfiINIA8gEH58IgogBCAMfnwiBCACIAt+fCICQiCIIAIgBFStIAogDVStIAQgClStfHxCIIaEfCIKIA5UrXwgCiAVIAwgE34iBCALIA9+fCILQiCIIAQgC1atQiCGhHwiBCAVVK0gBCACQiCGfCAEVK18fCIEIApUrXwiAkL/////////AFgEQCABQjGGIARC/////w+DIgEgA0L/////D4MiC34iCkIAUq19QgAgCn0iDyAEQiCIIgogC34iDSABIANCIIgiDH58IhBCIIYiDlStfSACQv////8PgyALfiABIBJC/////w+DfnwgCiAMfnwgDSAQVq1CIIYgEEIgiIR8IAQgFEIgiH4gAyACQiCIfnwgAiAMfnwgCiASfnxCIIZ8fSELIAdBAWshByAPIA59DAELIARCIYghDCABQjCGIAJCP4YgBEIBiIQiBEL/////D4MiASADQv////8PgyILfiIKQgBSrX1CACAKfSIQIAEgA0IgiCIKfiIPIAwgAkIfhoQiDUL/////D4MiDiALfnwiDEIghiITVK19IAQgFEIgiH4gAyACQiGIfnwgAkIBiCICIAp+fCANIBJ+fEIghiAKIA5+IAJC/////w+DIAt+fCABIBJC/////w+DfnwgDCAPVK1CIIYgDEIgiIR8fH0hCyAQIBN9CyEBIAdBgIABTgRAIBFCgICAgICAwP//AIQhEUIAIQEMAQsgB0H//wBqIQggB0GBgH9MBEACQCAIDQAgBCABQgGGIANWIAtCAYYgAUI/iIQiASAUViABIBRRG618IgEgBFStIAJC////////P4N8IgNCgICAgICAwACDUA0AIAMgEYQhEQwCC0IAIQEMAQsgBCABQgGGIANaIAtCAYYgAUI/iIQiASAUWiABIBRRG618IgEgBFStIAJC////////P4N8IAitQjCGfCARhCERCyAAIAE3AwAgACARNwMIIAVBwAFqJAAPCyAAQgA3AwAgAEKAgICAgIDg//8AIBEgAiADhFAbNwMIIAVBwAFqJAAL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBEKAgICAgIDAgDx9IARCgICAgICAwP/DAH1UBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQUMAgsgBEKAgICAgICAgEB9IQUgAEKAgICAgICAgAiFQgBSDQEgBSAEQgGDfCEFDAELIABQIARCgICAgICAwP//AFQgBEKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBQwBC0KAgICAgICA+P8AIQUgBEL///////+//8MAVg0AQgAhBSAEQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQYH3AGsQ5BUgAiAAIARBgfgAIANrEOcVIAIpAwhCBIYgAikDACIEQjyIhCEFIAIpAxAgAikDGIRCAFKtIARC//////////8Pg4QiBEKBgICAgICAgAhaBEAgBUIBfCEFDAELIARCgICAgICAgIAIhUIAUg0AIAVCAYMgBXwhBQsgAkEgaiQAIAUgAUKAgICAgICAgIB/g4S/C2QCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahDkFSACKQMIQoCAgICAgMAAhUGegAEgAWutQjCGfCEDIAIpAwALNwMAIAAgAzcDCCACQRBqJAALNQEBfyMAQRBrIgIkACACIAAtAAA6AA8gACABLQAAOgAAIAEgAkEPai0AADoAACACQRBqJAALNQEBfyMAQRBrIgIkACACIAAoAgA2AgwgACABKAIANgIAIAEgAkEMaigCADYCACACQRBqJAALnwUBBn8DQCABQQRrIQcDQCAAIQMDQAJAAkACQAJAAkACQAJAAkAgASADayIAQQJ1IgUOBgcHAAQBAgMLIAFBBGsiACADEPMVRQ0GIAMgABDxFQ8LIAMgA0EEaiADQQhqIAFBBGsQ9BUaDwsgAyADQQRqIANBCGogA0EMaiABQQRrEPUVGg8LIABB+wBMBEAgAyABEPYVDwsgAyAFQQJtQQJ0aiEEAn8gAEGdH04EQCADIAMgBUEEbUECdCIAaiAEIAAgBGogBxD1FQwBCyAD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fyABQQJxDQEgAEECOgAAQQEFQQALDwsACx4BAX8jAEEQayIBJAAgASAAEP4aEIIbIAFBEGokAAszAQF/IwBBEGsiASQAIAFBCGogACgCBBCTGCgCAEEBOgAAIAAoAghBAToAACABQRBqJAALAwAACw0AQYjVCigCABEOAAALBgBB4c0JCy0BAX8gAEGkzgk2AgAgAEEEaigCAEEMayIBQQhqELwZQX9MBEAgARCiGwsgAAsKACAAEIYbEKIbCw0AIAAQhhsaIAAQohsLCwAgACABQQAQihsLLQAgAkUEQCAAKAIEIAEoAgRGDwsgACABRgRAQQEPCyAAEM0UIAEQzRQQ/xRFC6cBAQF/IwBBQGoiAyQAAn9BASAAIAFBABCKGw0AGkEAIAFFDQAaQQAgAUG8zwlB7M8JEIwbIgFFDQAaIANBCGpBBHJBAEE0EK8bGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAujAgEDfyMAQUBqIgMkACAAKAIAIgVBBGsoAgAhBCAFQQhrKAIAIQUgA0EANgIUIAMgATYCECADIAA2AgwgAyACNgIIQQAhASADQRhqQQBBJxCvGxogACAFaiEAAkAgBCACQQAQihsEQCADQQE2AjggBCADQQhqIAAgAEEBQQAgBCgCACgCFBENACAAQQAgAygCIEEBRhshAQwBCyAEIANBCGogAEEBQQAgBCgCACgCGBEIAAJAAkAgAygCLA4CAAECCyADKAIcQQAgAygCKEEBRhtBACADKAIkQQFGG0EAIAMoAjBBAUYbIQEMAQsgAygCIEEBRwRAIAMoAjANASADKAIkQQFHDQEgAygCKEEBRw0BCyADKAIYIQELIANBQGskACABC10BAX8gACgCECIDRQRAIABBATYCJCAAIAI2AhggACABNgIQDwsCQCABIANGBEAgACgCGEECRw0BIAAgAjYCGA8LIABBAToANiAAQQI2AhggACAAKAIkQQFqNgIkCwsaACAAIAEoAghBABCKGwRAIAEgAiADEI0bCwszACAAIAEoAghBABCKGwRAIAEgAiADEI0bDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALUgEB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DQA/AEEQdCAASQRAIAAQKkUNAQtBjNUKIAA2AgAgAQ8LQcT9CkEwNgIAQX8LRgAgAL1C////////////AINCgICAgICAgPj/AFgEQCAAIAAgAaUgAb1C////////////AINCgICAgICAgPj/AFYbDwsgAQucBgIEfwN+IwBBgAFrIgUkAAJAAkACQCADIARCAEIAEOEVRQ0AIAMgBBCtGyEHIAJCMIinIghB//8BcSIGQf//AUYNACAHDQELIAVBEGogASACIAMgBBDqFSAFIAUpAxAiBCAFKQMYIgMgBCADEO0VIAUpAwghAiAFKQMAIQQMAQsgASACQv///////z+DIAatQjCGhCIKIAMgBEL///////8/gyAEQjCIp0H//wFxIgetQjCGhCIJEOEVQQBMBEAgASAKIAMgCRDhFQRAIAEhBAwCCyAFQfAAaiABIAJCAEIAEOoVIAUpA3ghAiAFKQNwIQQMAQsgBgR+IAEFIAVB4ABqIAEgCkIAQoCAgICAgMC7wAAQ6hUgBSkDaCIKQjCIp0H4AGshBiAFKQNgCyEEIAdFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABDqFSAFKQNYIglCMIinQfgAayEHIAUpA1AhAwsgCUL///////8/g0KAgICAgIDAAIQhCyAKQv///////z+DQoCAgICAgMAAhCEKIAYgB0oEQANAAn4gCiALfSADIARWrX0iCUIAWQRAIAkgBCADfSIEhFAEQCAFQSBqIAEgAkIAQgAQ6hUgBSkDKCECIAUpAyAhBAwFCyAJQgGGIARCP4iEDAELIApCAYYgBEI/iIQLIQogBEIBhiEEIAZBAWsiBiAHSg0ACyAHIQYLAkAgCiALfSADIARWrX0iCUIAUwRAIAohCQwBCyAJIAQgA30iBIRCAFINACAFQTBqIAEgAkIAQgAQ6hUgBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIQMgBkEBayEGIARCAYYhBCADIAlCAYaEIglCgICAgICAwABUDQALCyAIQYCAAnEhByAGQQBMBEAgBUFAayAEIAlC////////P4MgBkH4AGogB3KtQjCGhEIAQoCAgICAgMDDPxDqFSAFKQNIIQIgBSkDQCEEDAELIAlC////////P4MgBiAHcq1CMIaEIQILIAAgBDcDACAAIAI3AwggBUGAAWokAAu4AgMCfwF+AnwCQAJ8IAC9IgNCIIinQf////8HcSIBQYDgv4QETwRAAkAgA0IAUw0AIAFBgIDAhARJDQAgAEQAAAAAAADgf6IPCyABQYCAwP8HTwRARAAAAAAAAPC/IACjDwsgAEQAAAAAAMyQwGVBAXMNAkQAAAAAAAAAACADQn9XDQEaDAILIAFB//+/5ANLDQEgAEQAAAAAAADwP6ALDwsgAEQAAAAAAAC4QqAiBL2nQYABaiIBQQR0QfAfcSICQZDWCWorAwAiBSAFIAAgBEQAAAAAAAC4wqChIAJBCHJBkNYJaisDAKEiAKIgACAAIAAgAER0XIcDgNhVP6JEAAT3iKuygz+gokSmoATXCGusP6CiRHXFgv+9v84/oKJE7zn6/kIu5j+goqAgAUGAfnFBgAJtEKwbC6gBAAJAIAFBgAhOBEAgAEQAAAAAAADgf6IhACABQf8PSARAIAFB/wdrIQEMAgsgAEQAAAAAAADgf6IhACABQf0XIAFB/RdIG0H+D2shAQwBCyABQYF4Sg0AIABEAAAAAAAAEACiIQAgAUGDcEoEQCABQf4HaiEBDAELIABEAAAAAAAAEACiIQAgAUGGaCABQYZoShtB/A9qIQELIAAgAUH/B2qtQjSGv6ILRAIBfwF+IAFC////////P4MhAwJ/IAFCMIinQf//AXEiAkH//wFHBEBBBCACDQEaQQJBAyAAIAOEUBsPCyAAIAOEUAsLggQBA38gAkGABE8EQCAAIAEgAhArGiAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIAJBAUgEQCAAIQIMAQsgAEEDcUUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA08NASACQQNxDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJBEAgACECDAELIAAgA0EEayIESwRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQQFrIAE6AAAgACABOgAAIAJBA0kNACADQQJrIAE6AAAgACABOgABIANBA2sgAToAACAAIAE6AAIgAkEHSQ0AIANBBGsgAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkEgayICQR9LDQALCyAAC+kCAQF/AkAgACABRg0AIAEgAGsgAmtBACACQQF0a00EQCAAIAEgAhCuGxoPCyAAIAFzQQNxIQMCQAJAIAAgAUkEQCADBEAgACEDDAMLIABBA3FFBEAgACEDDAILIAAhAwNAIAJFDQQgAyABLQAAOgAAIAFBAWohASACQQFrIQIgA0EBaiIDQQNxDQALDAELAkAgAw0AIAAgAmpBA3EEQANAIAJFDQUgACACQQFrIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBBGsiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQQFrIgJqIAEgAmotAAA6AAAgAg0ACwwCCyACQQNNDQADQCADIAEoAgA2AgAgAUEEaiEBIANBBGohAyACQQRrIgJBA0sNAAsLIAJFDQADQCADIAEtAAA6AAAgA0EBaiED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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAIgMsAAAiBEHMAGsOKQATExMTExMTARMTExMTExMTExMTEwMTBAUGAgcTCBMTCQoLDA0ODxAREgsgABD3GyECDBULIAAQ6BshAgwUCwJAIABBARDDGyICQfAARwRAIAJB/wFxQcwARw0BIABBAhDDG0Ewa0EJSw0BCyAAEK8cIQIMFAsgABCwHCECDBMLAkACQAJAAkACQAJAAkAgAywAASIEQeEAaw4EARkZAgALIARBzgBGDQMgBEHTAEYNBCAEQe4ARg0CIARB9ABGDQUgBEH6AEcNGCAAIANBAmo2AgAgASAAEPYbIgI2AvgEIAJFDRcgAEGZ/gkgAUH4BGoQlxwhAgwYCyAAIANBAmo2AgAgASABQagFakGP/gkQwBspAgA3AxAgACABQRBqELEcIQIMFwsgACADQQJqNgIAIAEgAUGgBWpBkv4JEMAbKQIANwMYIAAgAUEYahCyHCECDBYLIAAgA0ECajYCACABIAFBmAVqQZL+CRDAGykCADcDICAAIAFBIGoQsRwhAgwVCyAAIANBAmo2AgAgASABQZAFakGU/gkQwBspAgA3AyggACABQShqELEcIQIMFAsgACADQQJqNgIAIAEgAUGIBWpBl/4JEMAbKQIANwMwIAAgAUEwahCxHCECDBMLIAAgA0ECajYCACABIAAQyRsiAjYC+AQgAkUNESAAQZn+CSABQfgEahCXHCECDBILAkACQAJAAkACQCADLAABIgRB7ABrDgQBAhYDAAsgBEH2AEYNAyAEQeMARw0VIAAgA0ECajYCACABIAAiAxDJGyICNgL4BCACRQ0UIAEgAxD2GyICNgKEBSACRQ0UIABBoANqQaP+CSABQfgEaiABQYQFahDEHCECDBULIAAgA0ECajYCACABIAAiBBD2GyIDNgKEBSADRQ0UIABBCGoiBRD2ASEGA0AgAEHFABDFG0UEQCABIAQQ9hsiAzYC+AQgA0UNFiAFIAFB+ARqENgbDAELCyABQfgEaiAAIAYQ2RsgAEGgA2ogAUGEBWogAUH4BGoQxRwhAgwUCyAAIANBAmo2AgAgASABQfAEakGu/gkQwBspAgA3AzggACABQThqELEcIQIMEwsgACADQQJqNgIAIAEgAUHoBGpBsP4JEMAbKQIANwNAIAAgAUFAaxCyHCECDBILIAAQsxwhAgwRCwJAAkACQAJAAkACQAJAIAMsAAEiBEHsAGsOCwEXAhcXFxcDBBcFAAsCQAJAAkAgBEHhAGsOBQAZARkCCAsgACADQQJqNgIAIAEgABD2GyICNgL4BCACRQ0XIAFBAToAhAUgACABQfgEaiABQb8FaiABQYQFahC0HCECDBgLIAAgA0ECajYCACABIAAiAxDJGyICNgL4BCACRQ0WIAEgAxD2GyICNgKEBSACRQ0WIABBoANqQbL+CSABQfgEaiABQYQFahDEHCECDBcLIAAgA0ECajYCACABIAFB4ARqQb/+CRDAGykCADcDSCAAIAFByABqELIcIQIMFgsgACADQQJqNgIAIAEgABD2GyICNgL4BCACRQ0UIAFBADoAhAUgACABQfgEaiABQb8FaiABQYQFahC0HCECDBULIAAQtRwhAgwUCyAAIANBAmo2AgAgASAAIgMQ9hsiAjYC+AQgAkUNEiABIAMQ9hsiAjYChAUgAkUNEiAAIAFB+ARqQcH+CSABQYQFahC2HCECDBMLIAAgA0ECajYCACABIAAiAxD2GyICNgL4BCACRQ0RIAEgAxD2GyICNgKEBSACRQ0RIABBoANqIAFB+ARqQcT+CSABQYQFahDMHCECDBILIAAgA0ECajYCACABIAFB2ARqQcb+CRDAGykCADcDUCAAIAFB0ABqELEcIQIMEQsgBEHWAEcNECAAIANBAmo2AgAgASABQdAEakHI/gkQwBspAgA3A1ggACABQdgAahCxHCECDBALAkACQAJAIAMsAAEiBEHvAGsOAwASAgELIAAgA0ECajYCACABIAFByARqQcv+CRDAGykCADcDYCAAIAFB4ABqELEcIQIMEQsgBEHPAEcNECAAIANBAmo2AgAgASABQcAEakHN/gkQwBspAgA3A2ggACABQegAahCxHCECDBALIAAgA0ECajYCACABIAFBuARqQdD+CRDAGykCADcDcCAAIAFB8ABqELEcIQIMDwsgAywAASIEQfQARwRAIARB5QBHDQ8gACADQQJqNgIAIAEgAUGwBGpB0/4JEMAbKQIANwN4IAAgAUH4AGoQsRwhAgwPCyAAIANBAmo2AgAgASABQagEakHW/gkQwBspAgA3A4ABIAAgAUGAAWoQsRwhAgwOCyADLAABIgRB7ABHBEAgBEH4AEcNDiAAIANBAmo2AgAgASAAIgMQ9hsiAjYC+AQgAkUNDSABIAMQ9hsiAjYChAUgAkUNDSAAQaADakEQEPwbIAFB+ARqKAIAIAFBhAVqKAIAEK0dIQIMDgsgACADQQJqNgIAIABBCGoiBBD2ASEFA0AgAEHFABDFG0UEQCABIAAQtxwiAzYC+AQgA0UNDyAEIAFB+ARqENgbDAELCyABQQA2AoQFIAFB+ARqIAAgBRDZGyAAQaADaiABQYQFaiABQfgEahDOHCECDA0LAkACQAJAAkAgAywAASIEQfMAaw4CAQMACyAEQdMARg0BIARB5QBHDQ8gACADQQJqNgIAIAEgAUGgBGpB2P4JEMAbKQIANwOIASAAIAFBiAFqELEcIQIMDwsgACADQQJqNgIAIAEgAUGYBGpB2/4JEMAbKQIANwOQASAAIAFBkAFqELEcIQIMDgsgACADQQJqNgIAIAEgAUGQBGpB3v4JEMAbKQIANwOYASAAIAFBmAFqELEcIQIMDQsgACADQQJqNgIAIAEgAUGIBGpB4v4JEMAbKQIANwOgASAAIAFBoAFqELEcIQIMDAsCQAJAAkACQAJAAkAgAywAASIEQekAaw4FARERAwUACyAEQckAaw4EARAQAxALIAAgA0ECajYCACABIAFBgARqQeT+CRDAGykCADcDqAEgACABQagBahCxHCECDA8LIAAgA0ECajYCACABIAFB+ANqQeb+CRDAGykCADcDsAEgACABQbABahCxHCECDA4LIAAgA0ECajYCACABIAFB8ANqQb/+CRDAGykCADcDuAEgACABQbgBahCxHCECDA0LIAAgA0ECajYCACABIAFB6ANqQen+CRDAGykCADcDwAEgACABQcABahCxHCECDAwLIAAgA0ECajYCACAAQd8AEMUbBEAgASABQeADakHs/gkQwBspAgA3A8gBIAAgAUHIAWoQshwhAgwMCyABIAAQ9hsiAjYC+AQgAkUNCiAAIAFB+ARqQez+CRC4HCECDAsLAkACQAJAAkACQAJAIAMsAAEiBEHhAGsOBwEQEBACEAMACyAEQfQAaw4FAw8PAAQPCyAAELkcIQIMDgsgACADQQJqNgIAIAEgAUHYA2pB7/4JEMAbKQIANwPQASAAIAFB0AFqELEcIQIMDQsgACAD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Amo2AgAgAEGDnAoQ3hshAgwKCyAAIAAoAgBBAmo2AgAgAEGOnAoQ3hshAgwJCwJAAkACQAJAAkACQCAAQQEQwxsiAUHhAGsOBwEODg4CDgMACyABQfQAaw4EAw0NBA0LIAAgACgCAEECajYCACAAQZmcChDeGyECDAwLIAAgACgCAEECajYCACAAQaicChDeGyECDAsLIAAgACgCAEECajYCACAAQe6bChDeGyECDAoLIAAgACgCAEECajYCACAAQbOcChDeGyECDAkLIAAgACgCAEECajYCACAAQb2cChDeGyECDAgLAkACQAJAIABBARDDGyIBQe8Aaw4EAAoKAQILIAAgACgCAEECajYCACAAQcqcChDeGyECDAkLIAAgACgCAEECajYCACAAQdWcChDeGyECDAgLIAFB0gBHDQcgACAAKAIAQQJqNgIAIABB35wKEN4bIQIMBwsCQAJAAkACQAJAAkAgAEEBEMMbIgFB7ABrDgkBAAwMAwwMBAUCCyAAIAAoAgBBAmo2AgAgAEHqnAoQ3hshAgwLCyAAIAAoAgBBAmo2AgAgAEH2nAoQ3hshAgwKCyABQcwARw0JIAAgACgCAEECajYCACAAQYCdChDeGyECDAkLIAAgACgCAEECajYCACAAQYudChDeGyECDAgLIAAgACgCAEECajYCACAAQfacChDeGyECDAcLIAAgACgCAEECajYCACAAQZadChDeGyECDAYLIABBARDDG0H1AEcNBSAAIAAoAgBBAmo2AgAgAEGhnQoQ3hshAgwFCwJAAkAgAEEBEMMbIgFBzQBHBEAgAUHTAEYNAiABQfMARg0BIAFB7QBHDQcgACAAKAIAQQJqNgIAIABBq50KEN4bIQIMBwsgACAAKAIAQQJqNgIAIABBtZ0KEN4bIQIMBgsgACAAKAIAQQJqNgIAIABBwJ0KEN4bIQIMBQsgACAAKAIAQQJqNgIAIABBy50KEN4bIQIMBAsgAEEBEMMbQfMARw0DIAAgACgCAEECajYCACAAQdedChDeGyECDAMLIABBARDDG0Ewa0EJSw0CIAAgACgCAEECajYCACADIAAQmhwiAjYCGCACRQ0BIAAgA0EYahCjHSECDAILIAAgACgCAEECajYCACAAQfiZChDeGyECDAELQQAhAgsgA0EgaiQAIAILJAAgAEEHQQFBAUEBEIAcIABBvPsJNgIAIAAgASkCADcCCCAACzACAX8BfiMAQRBrIgIkACACIAApAggiAzcDACACIAM3AwggASACEIIcIAJBEGokAAsoACAAQRdBAUEBQQEQgBwgACACNgIMIAAgATYCCCAAQaD8CTYCACAAC0MBAX8jAEEQayICJAAgACgCCCABELwbIAIgAkEIakGA/QkQwBspAgA3AwAgASACEIIcIAAoAgwgARC8GyACQRBqJAALFgAgACABKAIMIgEgASgCACgCGBECAAsuAQF/An9BACAAKAIAIgEgACgCBEYNABogACABQQFqNgIAIAEtAAALQRh0QRh1Cy8AIABBJEECQQJBAhCAHCAAQQA6ABAgAEEANgIMIAAgATYCCCAAQZD9CTYCACAAC0EBA38jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARCkHCEEIAAoAgwgARClHCEDIAQQphwLIAJBEGokACADC0kBAX8jAEEQayIDJAAgAyACOgAPIAAgATYCACABLQAAIQEgAEEBOgAFIAAgAToABCAAKAIAIANBD2otAAA6AAAgA0EQaiQAIAALJAEBfyAALQAFIgJBAkcEQCACRQ8LIAAgASAAKAIAKAIAEQMACxoAIAAtAAUEQCAAKAIAIABBBGotAAA6AAALC0EBA38jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARCkHCEEIAAoAgwgARCoHCEDIAQQphwLIAJBEGokACADCyQBAX8gAC0ABiICQQJHBEAgAkUPCyAAIAEgACgCACgCBBEDAAtBAQN/IwBBEGsiAiQAIAAtABBFBEAgAkEIaiAAQRBqQQEQpBwhBCAAKAIMIAEQqhwhAyAEEKYcCyACQRBqJAAgAwskAQF/IAAtAAciAkECRwRAIAJFDwsgACABIAAoAgAoAggRAwALSwECfyMAQRBrIgIkACAALQAQRQRAIAJBCGogAEEQakEBEKQcIQMgACgCDCIAIAEgACgCACgCDBEDACEAIAMQphwLIAJBEGokACAAC0cBAn8jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARCkHCEDIAAoAgwiACABIAAoAgAoAhARAgAgAxCmHAsgAkEQaiQAC0cBAn8jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARCkHCEDIAAoAgwiACABIAAoAgAoAhQRAgAgAxCmHAsgAkEQaiQACxUAIAEgAGsiAQRAIAIgACABELAbCwvQAQECfyMAQTBrIgEkACABIAFBKGpBtI8KEMAbKQIANwMQAkAgACABQRBqEMEbBEAgABCGHBogAUEgaiAAQQAQxhsgAEHfABDFG0UNASAAIAFBIGoQwhwhAgwBCyABIAFBGGpBt48KEMAbKQIANwMIIAAgAUEIahDBG0UNACABQSBqIABBABDGGyABQSBqEMcbDQAgAEHwABDFG0UNACAAEIYcGiABQSBqIABBABDGGyAAQd8AEMUbRQ0AIAAgAUEgahDCHCECCyABQTBqJAAgAgusEQEGfyMAQZAEayIBJAACQCAAQeYAEMUbRQ0AIAECf0EBIABBABDDGyIEQcwARg0AGiAEQf8BcSIDQfIARwRAQQEgA0HsAEYNARogA0HSAEcNAgtBAAs6AI8EIAAgACgCAEEBajYCACABQYAEahDaGyEDIAEgAUH4A2pBqJAKEMAbKQIANwPwAQJAIAAgAUHwAWoQwRsEQCABQfADakGP/gkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUHoA2pBq5AKEMAbKQIANwPoASAAIAFB6AFqEMEbBEAgAUHwA2pBkv4JEMAbGiABIAEpA/ADNwOABAwBCyABIAFB4ANqQa6QChDAGykCADcD4AEgACABQeABahDBGwRAIAFB8ANqQZT+CRDAGxogASABKQPwAzcDgAQMAQsgASABQdgDakGxkAoQwBspAgA3A9gBIAAgAUHYAWoQwRsEQCABQfADakGX/gkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUHQA2pBtJAKEMAbKQIANwPQASAAIAFB0AFqEMEbBEAgAUHwA2pBrv4JEMAbGiABIAEpA/ADNwOABAwBCyABIAFByANqQbeQChDAGykCADcDyAEgACABQcgBahDBGwRAIAFB8ANqQcH+CRDAGxogASABKQPwAzcDgAQMAQsgASABQcADakG6kAoQwBspAgA3A8ABIAAgAUHAAWoQwRsEQCABQfADakHG/gkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUG4A2pBvZAKEMAbKQIANwO4ASAAIAFBuAFqEMEbBEAgAUHwA2pByP4JEMAbGiABIAEpA/ADNwOABAwBCyABIAFBsANqQcCQChDAGykCADcDsAEgACABQbABahDBGwRAIAFB8ANqQcv+CRDAGxogASABKQPwAzcDgAQMAQsgASABQagDakHDkAoQwBspAgA3A6gBIAAgAUGoAWoQwRsEQCABQfADakHN/gkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUGgA2pBxpAKEMAbKQIANwOgASAAIAFBoAFqEMEbBEAgAUHwA2pB0P4JEMAbGiABIAEpA/ADNwOABAwBCyABIAFBmANqQcmQChDAGykCADcDmAEgACABQZgBahDBGwRAIAFB8ANqQdP+CRDAGxogASABKQPwAzcDgAQMAQsgASABQZADakHMkAoQwBspAgA3A5ABIAAgAUGQAWoQwRsEQCABQfADakHW/gkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUGIA2pBz5AKEMAbKQIANwOIASAAIAFBiAFqEMEbBEAgAUHwA2pB2P4JEMAbGiABIAEpA/ADNwOABAwBCyABIAFBgANqQdKQChDAGykCADcDgAEgACABQYABahDBGwRAIAFB8ANqQdv+CRDAGxogASABKQPwAzcDgAQMAQsgASABQfgCakHVkAoQwBspAgA3A3ggACABQfgAahDBGwRAIAFB8ANqQd7+CRDAGxogASABKQPwAzcDgAQMAQsgASABQfACakHYkAoQwBspAgA3A3AgACABQfAAahDBGwRAIAFB8ANqQeL+CRDAGxogASABKQPwAzcDgAQMAQsgASABQegCakHbkAoQwBspAgA3A2ggACABQegAahDBGwRAIAFB8ANqQeT+CRDAGxogASABKQPwAzcDgAQMAQsgASABQeACakHekAoQwBspAgA3A2AgACABQeAAahDBGwRAIAFB8ANqQeb+CRDAGxogASABKQPwAzcDgAQMAQsgASABQdgCakHhkAoQwBspAgA3A1ggACABQdgAahDBGwRAIAFB8ANqQb/+CRDAGxogASABKQPwAzcDgAQMAQsgASABQdACakHkkAoQwBspAgA3A1AgACABQdAAahDBGwRAIAFB8ANqQen+CRDAGxogASABKQPwAzcDgAQMAQsgASABQcgCakHnkAoQwBspAgA3A0ggACABQcgAahDBGwRAIAFB8ANqQe/+CRDAGxogASABKQPwAzcDgAQMAQsgASABQcACakHqkAoQwBspAgA3A0AgACABQUBrEMEbBEAgAUHwA2pB//4JEMAbGiABIAEpA/ADNwOABAwBCyABIAFBuAJqQe2QChDAGykCADcDOCAAIAFBOGoQwRsEQCABQfADakGC/wkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUGwAmpB8JAKEMAbKQIANwMwIAAgAUEwahDBGwRAIAFB8ANqQYT/CRDAGxogASABKQPwAzcDgAQMAQsgASABQagCakHzkAoQwBspAgA3AyggACABQShqEMEbBEAgAUHwA2pBi/8JEMAbGiABIAEpA/ADNwOABAwBCyABIAFBoAJqQfaQChDAGykCADcDICAAIAFBIGoQwRsEQCABQfADakGN/wkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUGYAmpB+ZAKEMAbKQIANwMYIAAgAUEYahDBGwRAIAFB8ANqQaf/CRDAGxogASABKQPwAzcDgAQMAQsgASABQZACakH8kAoQwBspAgA3AxAgACABQRBqEMEbBEAgAUHwA2pBqf8JEMAbGiABIAEpA/ADNwOABAwBCyABIAFBiAJqQf+QChDAGykCADcDCCAAIAFBCGoQwRsEQCABQfADakGs/wkQwBsaIAEgASkD8AM3A4AEDAELIAEgAUGAAmpBgpEKEMAbKQIANwMAIAAgARDBG0UNASABQfADakGv/wkQwBsaIAEgASkD8AM3A4AECyABIAAiBRD2GyIGNgLwAyABQQA2AvwBIAZFDQACQCAEQdIAR0EAIARB/wFxQcwARxsNACABIAUQ9hsiAjYC/AEgAg0AQQAhAgwBCwJAIAEtAI8ERQ0AIAJFDQAgAUHwA2ogAUH8AWoQwxwLIABBoANqIAFBjwRqIAMgAUHwA2ogAUH8AWoQiR0hAgsgAUGQBGokACACC1sBA38jAEEQayICJAAgAiAAIgQQ9hsiAzYCDAJ/AkAgA0UNACACIAQQ9hsiAzYCCCADRQ0AIABBoANqIAJBDGogASACQQhqEJAdDAELQQALIQAgAkEQaiQAIAALPAECfyMAQRBrIgIkACACIAAQ9hsiAzYCDCADBH8gAEGgA2ogASACQQxqEJQdBUEACyEAIAJBEGokACAAC/wBAQZ/IwBBMGsiASQAIAEgAUEoakGQlgoQwBspAgA3AwgCQCAAIAFBCGoQwRtFDQAgAUEYaiAAQYQDakEAEKQcIQIgASAAIgQQyRsiAzYCJCACEKYcIANFDQAgAEHfABDFGwRAIABBCGoiAxD2ASEGA0AgAEHFABDFG0UEQCABIAQQ9hsiAjYCGCACRQ0DIAMgAUEYahDYGwwBCwsgAUEYaiAAIAYQ2RsgACABQSRqIAFBGGoQxhwhBQwBCyABIAQQ9hsiAjYCFCACRQ0AIAFBGGogACABQRRqIAFBGGoQ+hsgACABQSRqIAFBGGoQxhwhBQsgAUEwaiQAIAULHwAgAEGgA2pBEBD8GyABKAIAIAItAAAgAy0AABCeHQunBAEFfyMAQUBqIgEkACABQQA2AjwgASABQTBqQfeXChDAGykCADcDEAJAIAAgAUEQahDBGwRAIAEgACIDEMccIgI2AjwgAkUNASAAQQAQwxtByQBGBEAgASADQQAQ6RsiAjYCLCACRQ0CIAEgACABQTxqIAFBLGoQ6hs2AjwLA0AgAEHFABDFG0UEQCABIAMQyBwiAjYCLCACRQ0DIAEgACABQTxqIAFBLGoQyRw2AjwMAQsLIAEgAxDKHCICNgIsIAJFDQEgACABQTxqIAFBLGoQyRwhBAwBCyABIAFBIGpBjP4JEMAbKQIANwMIIAAgAUEIahDBGyEFIAEgAUEYakH7lwoQwBspAgA3AwAgACABEMEbRQRAIAEgABDKHCIENgI8IARFDQEgBUEBcw0BIAAgAUE8ahDLHCEEDAELAkAgAEEAEMMbQTBrQQlNBEAgACEDA0AgASADEMgcIgI2AiwgAkUNAwJAIAEoAjwEQCABIAAgAUE8aiABQSxqEMkcNgI8DAELIAUEQCABIAAgAUEsahDLHDYCPAwBCyABIAI2AjwLIABBxQAQxRtFDQALDAELIAEgACIDEMccIgI2AjwgAkUNASAAQQAQwxtByQBHDQAgASADQQAQ6RsiAjYCLCACRQ0BIAEgACABQTxqIAFBLGoQ6hs2AjwLIAEgAxDKHCICNgIsIAJFDQAgACABQTxqIAFBLGoQyRwhBAsgAUFAayQAIAQLEQAgAEGgA2ogASACIAMQzBwL3gIBA38jAEEQayIBJAACfwJAAkAgAEEAEMMbQeQARw0AIABBARDDGyICQdgARwRAIAJB+ABHBEAgAkHpAEcNAiAAIAAoAgBBAmo2AgAgASAAIgMQmhwiAjYCDCACRQ0DIAEgAxC3HCICNgIIIAJFDQMgAUEAOgAEIAAgAUEMaiABQQhqIAFBBGoQzRwMBAsgACAAKAIAQQJqNgIAIAEgACIDEPYbIgI2AgwgAkUNAiABIAMQtxwiAjYCCCACRQ0CIAFBAToABCAAIAFBDGogAUEIaiABQQRqEM0cDAMLIAAgACgCAEECajYCACABIAAiAxD2GyICNgIMIAJFDQEgASADEPYbIgI2AgggAkUNASABIAMQtxwiAjYCBCACRQ0BIABBoANqQRQQ/BsgAUEMaigCACABQQhqKAIAIAFBBGooAgAQsR0MAgsgABD2GwwBC0EACyEAIAFBEGokACAACw8AIABBoANqIAEgAhDPHAusAwEGfyMAQfAAayIBJAAgASABQeAAakGM/gkQwBspAgA3AyAgASAAIAFBIGoQwRs6AG8gASAAQQEQwxtB4QBGOgBfIAEgAUHQAGpB4KUKEMAbKQIANwMYAkAgACABQRhqEMEbRQRAIAEgAUHIAGpB46UKEMAbKQIANwMQIAAgAUEQahDBG0UNAQsgAEEIaiIEEPYBIQICQANAIABB3wAQxRtFBEAgASAAEPYbIgM2AkAgA0UNAiAEIAFBQGsQ2BsMAQsLIAFBQGsgACACENkbIAEgACIFEMkbIgM2AjxBACECIANFDQEgASABQTBqQealChDAGykCADcDCCAAIAFBCGoQwRsEQCAEEPYBIQYDQCAAQcUAEMUbRQRAIAEgBRD2GyIDNgIoIANFDQQgBCABQShqENgbDAELCyABQShqIAAgBhDZGyAAIAFBQGsgAUE8aiABQShqIAFB7wBqIAFB3wBqENAcIQIMAgsgAEHFABDFG0UNASAAIAFBQGsgAUE8aiABQShqENobIAFB7wBqIAFB3wBqENAcIQIMAQtBACECCyABQfAAaiQAIAILFQAgAEGgA2pByP8JIAFBiv4JELwcCzYAIABBoANqQQwQ/BshACABKAIAIQEgAEHAAEEBQQFBARCAHCAAIAE2AgggAEGkqwo2AgAgAAtiAQF/IwBBIGsiBCQAIABBHBD8GyEAIARBGGogARDAGyEBIAIoAgAhAiAEQRBqIAMQwBshAyAEIAEpAgA3AwggBCADKQIANwMAIAAgBEEIaiACIAQQuR0hAyAEQSBqJAAgAwtMAQJ/IwBBEGsiAiQAIAJBCGogAEEBEMYbAkAgAkEIahDHGw0AIABBxQAQxRtFDQAgAEGgA2ogASACQQhqEN8cIQMLIAJBEGokACADCzkAIABBoANqQQwQ/BshACABKAIAQQBHIQEgAEHBAEEBQQFBARCAHCAAIAE6AAggAEHwgQo2AgAgAAuWAQEFfyMAQRBrIgIkAAJ/QQAgABDEG0EJSQ0AGiACQQhqIAAoAgAiASABQQhqEJAZIgMoAgAhASADKAIEIQQCQANAIAEgBEYNASABLAAAIQUgAUEBaiEBIAUQoBcNAAtBAAwBCyAAIAAoAgBBCGo2AgBBACAAQcUAEMUbRQ0AGiAAQaADaiADEOQcCyEBIAJBEGokACABC5YBAQV/IwBBEGsiAiQAAn9BACAAEMQbQRFJDQAaIAJBCGogACgCACIBIAFBEGoQkBkiAygCACEBIAMoAgQhBAJAA0AgASAERg0BIAEsAAAhBSABQQFqIQEgBRCgFw0AC0EADAELIAAgACgCAEEQajYCAEEAIABBxQAQxRtFDQAaIABBoANqIAMQ5hwLIQEgAkEQaiQAIAELlgEBBX8jAEEQayICJAACf0EAIAAQxBtBIUkNABogAkEIaiAAKAIAIgEgAUEgahCQGSIDKAIAIQEgAygCBCEEAkADQCABIARGDQEgASwAACEFIAFBAWohASAFEKAXDQALQQAMAQsgACAAKAIAQSBqNgIAQQAgAEHFABDFG0UNABogAEGgA2ogAxDoHAshASACQRBqJAAgAQsNACAAQaADaiABEIcdCxwBAX8gACgCACECIAAgASgCADYCACABIAI2AgALUAEBfyMAQRBrIgQkACAAQRgQ/BshACAEQQhqIAEQwBshASADKAIAIQMgAigCACECIAQgASkCADcDACAAIAQgAiADEJcdIQIgBEEQaiQAIAILRgIBfwF+IwBBEGsiAyQAIABBFBD8GyEAIAEoAgAhASADIAIpAgAiBDcDACADIAQ3AwggACABIAMQmR0hAiADQRBqJAAgAgsPACAAQaADaiABIAIQmx0LgQEBAn8jAEEQayICJAACQAJAIABBABDDGyIBQcQARwRAIAFB/wFxQdQARw0BIAIgABDoGyIBNgIMIAFFDQIgAEGUAWogAkEMahDYGwwCCyACIAAQ4RsiATYCCCABRQ0BIABBlAFqIAJBCGoQ2BsMAQsgABDsGyEBCyACQRBqJAAg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IwBBEGsiAiQAIAIgATYCDCAAKAIAIgAgAUECdGpBjANqIgEgASgCACIBQQFqNgIAIAIgATYCCCACIABBoANqQRAQ/BsgAkEMaigCACACQQhqKAIAEPIcIgE2AgQgAEHMAmoQkxwoAgAgAkEEahDYGyACQRBqJAAgAQttAgF/A34jAEEwayIEJAAgAEEgEPwbIQAgBCABKQIAIgU3AyggBCACKQIAIgY3AyAgBCADKQIAIgc3AxggBCAFNwMQIAQgBjcDCCAEIAc3AwAgACAEQRBqIARBCGogBBCBHSEDIARBMGokACADC2wCAX8BfiMAQTBrIgIkACACIAJBKGpBuIcKEMAbKQIANwMQIAEgAkEQahCCHCACIAApAggiAzcDCCACIAM3AyAgASACQQhqEIIcIAIgAkEYakHBhwoQwBspAgA3AwAgASACEIIcIAJBMGokAAsxACAAQQwQ/BshACABKAIAIQEgAEEcQQBBAUEBEIAcIAAgATYCCCAAQeCICjYCACAAC0YCAX8BfiMAQRBrIgMkACAAQRQQ/BshACABKAIAIQEgAyACKQIAIgQ3AwAgAyAENwMIIAAgASADEPwcIQIgA0EQaiQAIAILMQAgAEEMEPwbIQAgASgCACEBIABBH0EAQQFBARCAHCAAIAE2AgggAEHwiwo2AgAgAAsoACAAQRtBAUEBQQEQgBwgACACNgIMIAAgATYCCCAAQdyHCjYCACAAC3oBAX8jAEEgayICJAACQCACAn8CQAJAAkAgACgCCA4DAAECBAsgAkEYakHMiAoQwBsMAgsgAkEQakHPiAoQwBsMAQsgAkEIakHSiAoQwBsLKQIANwMAIAEgAhCCHAsgACgCDCIABEAgASAAQQFrrRD0HAsgAkEgaiQAC3gBAn8jAEEwayICJAACQCABUARAIABBMBC9GwwBCyACQRBqEPUcIQMDQCABUEUEQCADQQFrIgMgASABQgqAIgFCCn59p0EwcjoAAAwBCwsgAiACQQhqIAMgAkEQahD1HBCQGSkCADcDACAAIAIQ9hwLIAJBMGokAAsHACAAQRVqCzACAX8BfiMAQRBrIgIkACACIAEpAgAiAzcDACACIAM3AwggACACEIIcIAJBEGokAAstACMAQRBrIgAkACAAIABBCGpBzIkKEMAbKQIANwMAIAEgABCCHCAAQRBqJAALDAAgACgCCCABELwbCygAIABBHUEAQQFBARCAHCAAIAI2AgwgACABNgIIIABB4IkKNgIAIAALUQECfyMAQRBrIgIkACAAKAIMIgMgASADKAIAKAIQEQIAIAAoAgwgARClHEUEQCACIAJBCGpB0IoKEMAbKQIANwMAIAEgAhCCHAsgAkEQaiQACyAAIAAoAgggARC8GyAAKAIMIgAgASAAKAIAKAIUEQIACysAIABBHkEAQQFBARCAHCAAIAE2AgggAEHcigo2AgAgACACKQIANwIMIAALVwEBfyMAQSBrIgIkACACIAJBGGpBzIsKEMAbKQIANwMIIAEgAkEIahCCHCAAQQxqIAEQ/hwgAiACQRBqQdaLChDAGykCADcDACABIAIQghwgAkEgaiQAC40BAQV/IwBBEGsiAiQAQQEhAwNAIAAoAgQgBEcEQCABKAIEIQUgA0EBcUUEQCACIAJBCGpB4osKEMAbKQIANwMAIAEgAhCCHAsgASgCBCEGIAAoAgAgBEECdGooAgAgARC8GyAEQQFqIQQgBiABKAIERgR/IAEgBRCRCyADBUEACyEDDAELCyACQRBqJAALQwEBfyMAQRBrIgIkACAAKAIIIgAgASAAKAIAKAIQEQIAIAIgAkEIakHcjAoQwBspAgA3AwAgASACEIIcIAJBEGokAAsWACAAKAIIIgAgASAAKAIAKAIUEQIACzgAIABBLUEBQQFBARCAHCAAQeiMCjYCACAAIAEpAgA3AgggACACKQIANwIQIAAgAykCADcCGCAAC3MCAX8BfiMAQTBrIgIkACACIAJBKGpBzI0KEMAbKQIANwMQIAEgAkEQahCCHCACIAApAhgiAzcDCCACIAM3AyAgASACQQhqEIIcIAIgAkEYakHBhwoQwBspAgA3AwAgASACEIIcIAAgARCDHSACQTBqJAALqAEBAn8jAEFAaiICJAAgAEEIaiIDENocRQRAIAIgAkE4akHi/gkQwBspAgA3AxggASACQRhqEIIcIAMgARD+HCACIAJBMGpB1v4JEMAbKQIANwMQIAEgAkEQahCCHAsgAiACQShqQeSBChDAGykCADcDCCABIAJBCGoQghwgAEEQaiABEP4cIAIgAkEgakGK/gkQwBspAgA3AwAgASACEIIcIAJBQGskAAtkAQF/IwBBIGsiAiQAIAIgAkEYakG8jgoQwBspAgA3AwggASACQQhqEIIcIAAoAggiAC0ABEEtRgRAIAAgARCDHQsgAiACQRBqQb+OChDAGykCADcDACABIAIQghwgAkEgaiQACywAIABBxABBAUEBQQEQgBwgACABNgIIIABB0I4KNgIAIAAgAikCADcCDCAAC3YCAX8BfiMAQTBrIgIkACACIAJBKGpB5IEKEMAbKQIANwMQIAEgAkEQahCCHCAAKAIIIAEQvBsgAiACQSBqQYr+CRDAGykCADcDCCABIAJBCGoQghwgAiAAKQIMIgM3AwAgAiADNwMYIAEgAhCCHCACQTBqJAALVAIBfwF+IwBBEGsiAiQAIABBEBD8GyEAIAIgASkCACIDNwMAIAIgAzcDCCAAQTtBAUEBQQEQgBwgAEHEjwo2AgAgACACKQIANwIIIAJBEGokACAAC04CAX8BfiMAQSBrIgIkACACIAJBGGpBtI8KEMAbKQIANwMIIAEgAkEIahCCHCACIAApAggiAzcDACACIAM3AxAgASACEIIcIAJBIGokAAtYAgF/AX4jAEEQayIFJAAgAEEcEPwbIQAgAS0AACEBIAUgAikCACIGNwMIIAQoAgAhBCADKAIAIQMgBSAGNwMAIAAgASAFIAMgBBCKHSEDIAVBEGokACADCz8BAX4gAEE+QQFBAUEBEIAcIAAgBDYCDCAAIAM2AgggAEGQkQo2AgAgAikCACEFIAAgAToAGCAAIAU3AhAgAAvRAgICfwF+IwBB8ABrIgIkACACIAA2AmwgAiABNgJoIAFBKBC9GwJAIAAtABgEQCAAKAIMIgMEQCADIAEQvBsgAUEgEL0bIAIgACkCECIENwMwIAIgBDcDYCABIAJBMGoQghwgAUEgEL0bCyACIAJB2ABqQeyRChDAGykCADcDKCABIAJBKGoQghwgAiAAKQIQIgQ3AyAgAiAENwNQIAEgAkEgahCCHCABQSAQvRsgAkHoAGoQjB0MAQsgAkHoAGoQjB0gAUEgEL0bIAIgACkCECIENwMYIAIgBDcDSCABIAJBGGoQghwgAiACQUBrQfGRChDAGykCADcDECABIAJBEGoQghwgACgCDEUNACABQSAQvRsgAiAAKQIQIgQ3AwggAiAENwM4IAEgAkEIahCCHCABQSAQvRsgACgCDCABELwbCyABQSkQvRsgAkHwAGokAAtBAQJ/IwBBEGsiASQAIAAoAgQhAiAAKAIAQSgQvRsgASACKAIIEI0dIAAoAgAQvBsgACgCAEEpEL0bIAFBEGokAAshACAAQSJBAUEBQQEQgBwgACABNgIIIABBgJIKNgIAIAAL3wEBBX8jAEFAaiICJAAgAkEwaiABQQxqEI8dIQUgAkEgaiABQRBqEI8dIQYgASgCBCEEIAAoAgggARC8GwJAAkACQAJAIAEoAhAiA0EBag4CAgABCyABIAQQkQsMAgsgA0EBIANBAUsbIQRBASEDA0AgAyAERg0CIAIgAkEQakHiiwoQwBspAgA3AwAgASACEIIcIAEgAzYCDCAAKAIIIAEQvBsgA0EBaiEDDAALAAsgAiACQRhqQdyMChDAGykCADcDCCABIAJBCGoQghwLIAYQ3BwgBRDcHCACQUBrJAALSQEBfyMAQRBrIgIkACACQX82AgwgACABNgIAIAEoAgAhASAAQQE6AAggACABNgIEIAAoAgAgAkEMaigCADYCACACQRBqJAAgAAtPAgF/AX4jAEEQayIEJAAgAEEYEPwbIQAgASgCACEBIAQgAikCACIFNwMIIAMoAgAhAyAEIAU3AwAgACABIAQgAxCRHSEDIARBEGokACADCzgBAX4gAEEvQQFBAUEBEIAcIAAgATYCCCAAQfSSCjYCACACKQIAIQQgACADNgIUIAAgBDcCDCAAC7ECAgJ/AX4jAEGAAWsiAiQAIABBDGoiAyACQfgAakHW/gkQwBsQkx0EQCACIAJB8ABqQeSBChDAGykCADcDOCABIAJBOGoQghwLIAIgAkHoAGpB5IEKEMAbKQIANwMwIAEgAkEwahCCHCAAKAIIIAEQvBsgAiACQeAAakHUkwoQwBspAgA3AyggASACQShqEIIcIAIgACkCDCIENwMgIAIgBDcDWCABIAJBIGoQghwgAiACQdAAakHXkwoQwBspAgA3AxggASACQRhqEIIcIAAoAhQgARC8GyACIAJByABqQYr+CRDAGykCADcDECABIAJBEGoQghwgAyACQfgAakHW/gkQwBsQkx0EQCACIAJBQGtBiv4JEMAbKQIANwMIIAEgAkEIahCCHAsgAkGAAWokAAslACAAEMQbIAEQxBtGBH8gACgCACAAKAIEIAEoAgAQ7hsFQQALC0YCAX8BfiMAQRBrIgMkACAAQRQQ/BshACADIAEpAgAiBDcDCCACKAIAIQIgAyAENwMAIAAgAyACEJUdIQIgA0EQaiQAIAILMQEBfiAAQTpBAUEBQQEQgBwgAEHkkwo2AgAgASkCACEDIAAgAjYCECAAIAM3AgggAAt2AgF/AX4jAEEwayICJAAgAiAAKQIIIgM3AxAgAiADNwMoIAEgAkEQahCCHCACIAJBIGpB5IEKEMAbKQIANwMIIAEgAkEIahCCHCAAKAIQIAEQvBsgAiACQRhqQYr+CRDAGykCADcDACABIAIQghwgAkEwaiQACzgBAX4gAEE1QQFBAUEBEIAcIABBzJQKNgIAIAEpAgAhBCAAIAM2AhQgACACNgIQIAAgBDcCCCAAC7IBAgJ/AX4jAEFAaiICJAAgAiAAKQIIIgQ3AxggAiAENwM4IAEgAkEYahCCHCACIAJBMGpB4v4JEMAbKQIANwMQIAEgAkEQahCCHCAAKAIQIgMgASADKAIAKAIQEQIAIAIgAkEoakGolQoQwBspAgA3AwggASACQQhqEIIcIAAoAhQiACABIAAoAgAoAhARAgAgAiACQSBqQYr+CRDAGykCADcDACABIAIQghwgAkFAayQACysAIABBN0EBQQFBARCAHCAAIAE2AgggAEG0lQo2AgAgACACKQIANwIMIAALYQEBfyMAQSBrIgIkACAAKAIIIAEQvBsgAiACQRhqQeSBChDAGykCADcDCCABIAJBCGoQghwgAEEMaiABEP4cIAIgAkEQakGK/gkQwBspAgA3AwAgASACEIIcIAJBIGokAAtGAgF/AX4jAEEQayIDJAAgAEEUEPwbIQAgASgCACEBIAMgAikCACIENwMAIAMgBDcDCCAAIAEgAxCcHSECIANBEGokACACCysAIABBPEEBQQFBARCAHCAAIAE2AgggAEGclgo2AgAgACACKQIANwIMIAALfwEBfyMAQTBrIgIkACACIAJBKGpB5IEKEMAbKQIANwMQIAEgAkEQahCCHCAAKAIIIAEQvBsgAiACQSBqQYCXChDAGykCADcDCCABIAJBCGoQghwgAEEMaiABEP4cIAIgAkEYakGK/gkQwBspAgA3AwAgASACEIIcIAJBMGokAAsvACAAQTlBAUEBQQEQgBwgACADOgANIAAgAjoADCAAIAE2AgggAEGMlwo2AgAgAAuFAQEBfyMAQTBrIgIkACAALQAMBEAgAiACQShqQYD9CRDAGykCADcDECABIAJBEGoQghwLIAIgAkEgakHslwoQwBspAgA3AwggASACQQhqEIIcIAAtAA0EQCACIAJBGGpB85cKEMAbKQIANwMAIAEgAhCCHAsgACgCCCABELwbIAJBMGokAAtYAQJ/IwBBEGsiAiQAIAAhASACAn8gAEEAEMMbQTBrQQlNBEAgARDIHAwBCyABEMccCyIBNgIMIAEEfyAAQaADaiACQQxqEKQdBUEACyEAIAJBEGokACAACz0CAX8BfiMAQRBrIgIkACAAQRAQ/BshACACIAEpAgAiAzcDACACIAM3AwggACACEJwcIQAgAkEQaiQAIAALKAAgAEEWQQFBAUEBEIAcIAAgAjYCDCAAIAE2AgggAEGomAo2AgAgAAs1ACAAQaADakEMEPwbIQAgASgCACEBIABBBEEBQQFBARCAHCAAIAE2AgggAEHsnQo2AgAgAAsxACAAQQwQ/BshACABKAIAIQEgAEErQQFBAUEBEIAcIAAgATYCCCAAQZyZCjYCACAAC0MBAX8jAEEQayICJAAgAiACQQhqQbD+CRDAGykCADcDACABIAIQghwgACgCCCIAIAEgACgCACgCEBECACACQRBqJAALMQAgAEEMEPwbIQAgASgCACEBIABBE0EBQQFBARCAHCAAIAE2AgggAEHsngo2AgAgAAs5AQF/IwBBEGsiAiQAIAIgAkEIakHYngoQwBspAgA3AwAgASACEIIcIAAoAgggARC8GyACQRBqJAALOQEBfyMAQRBrIgIkACACIAJBCGpB0J8KEMAbKQIANwMAIAEgAhCCHCAAKAIIIAEQvBsgAkEQaiQACzkBAX8jAEEQayICJAAgAiACQQhqQYD9CRDAGykCADcDACABIAIQghwgACgCCCABELwbIAJBEGokAAsWACAAIAEoAggiASABKAIAKAIYEQIACzgBAX4gAEEzQQFBAUEBEIAcIAAgATYCCCAAQdSgCjYCACACKQIAIQQgACADNgIUIAAgBDcCDCAAC0QCAX8BfiMAQRBrIgIkACAAKAIIIAEQvBsgAiAAKQIMIgM3AwAgAiADNwMIIAEgAhCCHCAAKAIUIAEQvBsgAkEQaiQACygAIABBMEEBQQFBARCAHCAAIAI2AgwgACABNgIIIABBvKEKNgIAIAALfwEBfyMAQTBrIgIkACACIAJBKGpB5IEKEMAbKQIANwMQIAEgAkEQahCCHCAAKAIIIAEQvBsgAiACQSBqQaSiChDAGykCADcDCCABIAJBCGoQghwgACgCDCABELwbIAIgAkEYakGnogoQwBspAgA3AwAgASACEIIcIAJBMGokAAswACAAQckAQQFBAUEBEIAcIAAgAzoAECAAIAI2AgwgACABNgIIIABBtKIKNgIAIAALjAEBAn8jAEEQayICJAACQCAALQAQBEAgAUHbABC9GyAAKAIIIAEQvBsgAUHdABC9GwwBCyABQS4QvRsgACgCCCABELwbCyAAKAIMIgMtAARByQBrQf8BcUECTwR/IAIgAkEIakGUowoQwBspAgA3AwAgASACEIIcIAAoAgwFIAMLIAEQvBsgAkEQaiQACzAAIABBygBBAUEBQQEQgBwgACADNgIQIAAgAjYCDCAAIAE2AgggAEGgowo2AgAgAAuWAQECfyMAQSBrIgIkACABQdsAEL0bIAAoAgggARC8GyACIAJBGGpBhKQKEMAbKQIANwMIIAEgAkEIahCCHCAAKAIMIAEQvBsgAUHdABC9GyAAKAIQIgMtAARByQBrQf8BcUECTwR/IAIgAkEQakGUowoQwBspAgA3AwAgASACEIIcIAAoAhAFIAMLIAEQvBsgAkEgaiQACysAIABBPUEBQQFBARCAHCAAIAE2AgggAEGUpAo2AgAgACACKQIANwIMIAALLwEBfyAAKAIIIgIEQCACIAEQvBsLIAFB+wAQvRsgAEEMaiABEP4cIAFB/QAQvRsLKwAgAEExQQFBAUEBEIAcIAAgATYCCCAAQYClCjYCACAAIAIpAgA3AgwgAAtwAQF/IwBBIGsiBiQAIABBIBD8GyEAIAYgASkCADcDGCACKAIAIQIgBiADKQIANwMQIAQtAAAhBCAFLQAAIQUgBiAGKQMYNwMIIAYgBikDEDcDACAAIAZBCGogAiAGIAQgBRC3HSEFIAZBIGokACAFC00BAX4gAEE4QQFBAUEBEIAcIABB9KUKNgIAIAEpAgAhBiAAIAI2AhAgACAGNwIIIAMpAgAhBiAAIAU6AB0gACAEOgAcIAAgBjcCFCAAC7UCAQJ/IwBB8ABrIgIkACAALQAcBEAgAiACQegAakHQpgoQwBspAgA3AzAgASACQTBqEIIcCyACIAJB4ABqQdymChDAGykCADcDKCABIAJBKGoQghwgAC0AHQRAIAIgAkHYAGpBvI4KEMAbKQIANwMgIAEgAkEgahCCHAsgAUEgEL0bIABBCGoiAxDaHEUEQCACIAJB0ABqQeSBChDAGykCADcDGCABIAJBGGoQghwgAyABEP4cIAIgAkHIAGpBiv4JEMAbKQIANwMQIAEgAkEQahCCHAsgACgCECABELwbIABBFGoiABDaHEUEQCACIAJBQGtB5IEKEMAbKQIANwMIIAEgAkEIahCCHCAAIAEQ/hwgAiACQThqQYr+CRDAGykCADcDACABIAIQghwLIAJB8ABqJAALOwEBfiAAQTRBAUEBQQEQgBwgAEHopgo2AgAgASkCACEEIAAgAjYCECAAIAQ3AgggACADKQIANwIUIAALVwIBfwF+IwBBIGsiAiQAIAIgACkCCCIDNwMIIAIgAzcDGCABIAJBCGoQghwgACgCECABELwbIAIgACkCFCIDNwMAIAIgAzcDECABIAIQghwgAkEgaiQACy8AIABBMkEBQQFBARCAHCAAIAM2AhAgACACNgIMIAAgATYCCCAAQdSnCjYCACAAC6cBAQF/IwBBQGoiAiQAIAIgAkE4akHkgQoQwBspAgA3AxggASACQRhqEIIcIAAoAgggARC8GyACIAJBMGpBuKgKEMAbKQIANwMQIAEgAkEQahCCHCAAKAIMIAEQvBsgAiACQShqQb6oChDAGykCADcDCCABIAJBCGoQghwgACgCECABELwbIAIgAkEgakGK/gkQwBspAgA3AwAgASACEIIcIAJBQGskAAtfAQF/IwBBMGsiAiQAIAIgAkEoakG0qQoQwBspAgA3AwggASACQQhqEIIcIAJBGGogACgCCBCNHSABEI4dIAIgAkEQakGK/gkQwBspAgA3AwAgASACEIIcIAJBMGokAAsMACAAQQhqIAEQ/hwLOQEBfyMAQRBrIgIkACACIAJBCGpBlKsKEMAbKQIANwMAIAEgAhCCHCAAKAIIIAEQvBsgAkEQaiQAC1cBAX8jAEEgayICJAAgAiACQRhqQYSsChDAGykCADcDCCABIAJBCGoQ9hwgACgCCCABELwbIAIgAkEQakGK/gkQwBspAgA3AwAgASACEPYcIAJBIGokAAsxACAAQQwQ/BshACABKAIAIQEgAEEoQQFBAUEBEIAcIAAgATYCCCAAQZisCjYCACAAC54BAQF/IwBBQGoiAiQAAkAgAgJ/AkACQAJAAkACQAJAIAAoAggOBgABAgMEBQcLIAJBOGpBiK0KEMAbDAULIAJBMGpBl60KEMAbDAQLIAJBKGpBqa0KEMAbDAMLIAJBIGpB8K0KEMAbDAILIAJBGGpBoq4KEMAbDAELIAJBEGpB1K4KEMAbCykCADcDCCABIAJBCGoQghwLIAJBQGskAAsYACAAIAEoAghBAnRB+MoKaigCABDAGxoLLwAgAEEqQQFBAUEBEIAcIAAgAzYCECAAIAI6AAwgACABNgIIIABB1K8KNgIAIAALYgEBfyMAQSBrIgIkACAALQAMBEAgAiACQRhqQbD+CRDAGykCADcDCCABIAJBCGoQghwLIAJBEGogACgCCCIAIAAoAgAoAhgRAgAgAiACKQMQNwMAIAEgAhCCHCACQSBqJAALRgIBfwF+IwBBEGsiAyQAIABBFBD8GyEAIAEoAgAhASADIAIpAgAiBDcDACADIAQ3AwggACABIAMQxx0hAiADQRBqJAAgAgs0ACAAQQggAS0ABSABLQAGIAEtAAcQgBwgACABNgIIIABBwLAKNgIAIAAgAikCADcCDCAAC4ABAgJ/AX4jAEEwayICJAAgACgCCCIDIAEgAygCACgCEBECACACIAJBKGpBoLEKEMAbKQIANwMQIAEgAkEQahCCHCACIAApAgwiBDcDCCACIAQ3AyAgASACQQhqEIIcIAIgAkEYakGnogoQwBspAgA3AwAgASACEIIcIAJBMGokAAtUAgF/AX4jAEEQayICJAAgAEEQEPwbIQAgAiABKQIAIgM3AwAgAiADNwMIIABBLkEBQQFBARCAHCAAQbSxCjYCACAAIAIpAgA3AgggAkEQaiQAIAALHAAgAUHbABC9GyAAQQhqIAEQ/hwgAUHdABC9GwsoACAAQRhBAUEBQQEQgBwgACACNgIMIAAgATYCCCAAQbiyCjYCACAAC54BAQF/IwBBQGoiAiQAAkAgAgJ/AkACQAJAAkACQAJAIAAoAggOBgABAgMEBQcLIAJBOGpBiK0KEMAbDAULIAJBMGpBl60KEMAbDAQLIAJBKGpBiLQKEMAbDAMLIAJBIGpBlLQKEMAbDAILIAJBGGpBobQKEMAbDAELIAJBEGpBrrQKEMAbCykCADcDCCABIAJBCGoQghwLIAJBQGskAAsYACAAIAEoAghBAnRBkMsKaigCABDAGxoLIQEBfyAAIABBHGo2AgggACAAQQxqIgE2AgQgACABNgIACz0CAX8BfiMAQRBrIgIkACAAQRAQ/BshACACIAEpAgAiAzcDACACIAM3AwggACACENEdIQAgAkEQaiQAIAALVAIBfwF+IwBBEGsiAiQAIABBEBD8GyEAIAIgASkCACIDNwMAIAIgAzcDCCAAQSNBAUEBQQEQgBwgAEHQtQo2AgAgACACKQIANwIIIAJBEGokACAAC4MBAQF+IABBIEEBQQFBARCAHCAAQeS0CjYCACABKQIAIQIgAEECOgAHIAAgAjcCCCAAQYIEOwAFIABBAUECIABBCGoiASgCACABENIdENMdGzoABiABKAIAIAEQ0h0Q1B0EQCAAQQE6AAcLIAEoAgAgARDSHRDVHQRAIABBAToABQsgAAsQACAAKAIAIAAoAgRBAnRqCywBAn8DQCAAIAFGIgJFBEAgACgCACEDIABBBGohACADLQAGQQFGDQELCyACCywBAn8DQCAAIAFGIgJFBEAgACgCACEDIABBBGohACADLQAHQQFGDQELCyACCywBAn8DQCAAIAFGIgJFBEAgACgCACEDIABBBGohACADLQAFQQFGDQELCyACCy8BAX8gACABENcdIAEoAgwiAiAAQQhqIgAoAgRJBH8gACACENgdIAEQpRwFQQALCyIAIAEoAhBBf0YEQCAAKAIMIQAgAUEANgIMIAEgADYCEAsLEAAgACgCACABQQJ0aigCAAsvAQF/IAAgARDXHSABKAIMIgIgAEEIaiIAKAIESQR/IAAgAhDYHSABEKgcBUEACwsvAQF/IAAgARDXHSABKAIMIgIgAEEIaiIAKAIESQR/IAAgAhDYHSABEKocBUEACws5AQJ/IAAgARDXHSABKAIMIgMgAEEIaiICKAIESQR/IAIgAxDYHSIAIAEgACgCACgCDBEDAAUgAAsLNgEBfyAAIAEQ1x0gASgCDCICIABBCGoiACgCBEkEQCAAIAIQ2B0iACABIAAoAgAoAhARAgALCzYBAX8gACABENcdIAEoAgwiAiAAQQhqIgAoAgRJBEAgACACENgdIgAgASAAKAIAKAIUEQIACwuAAQEBfyMAQTBrIgIkACACIAJBKGpB4v4JEMAbKQIANwMQIAEgAkEQahCCHCAAQQhqIAEQ/hwgARDfHUE+RgRAIAIgAkEgakHQigoQwBspAgA3AwggASACQQhqEIIcCyACIAJBGGpB1v4JEMAbKQIANwMAIAEgAhCCHCACQTBqJAALKAEBfwJ/QQAgACgCBCIBRQ0AGiABIAAoAgBqQQFrLQAAC0EYdEEYdQsoACAAQSVBAUEBQQEQgBwgACACNgIMIAAgATYCCCAAQby2CjYCACAACxYAIAAoAgggARC8GyAAKAIMIAEQvBsLMQAgAEEMEPwbIQAgASgCACEBIABBJ0EBQQFBARCAHCAAIAE2AgggAEG0two2AgAgAAs5AQF/IwBBEGsiAiQAIAIgAkEIakGcuAoQwBspAgA3AwAgASACEIIcIAAoAgggARC8GyACQRBqJAALVAIBfwF+IwBBEGsiAiQAIABBEBD8GyEAIAIgASkCACIDNwMAIAIgAzcDCCAAQSFBAUEBQQEQgBwgAEGsuAo2AgAgACACKQIANwIIIAJBEGokACAAC0EBAX8jAEEQayICJAAgAiACQQhqQYS6ChDAGykCADcDACABIAIQghwgAEEIaiABEP4cIAFB3QAQvRsgAkEQaiQAC00BAX4gAEESQQBBAUEAEIAcIAAgAjYCDCAAIAE2AgggAEGcugo2AgAgAykCACEHIAAgBjoAICAAIAU2AhwgACAENgIYIAAgBzcCECAAC2EBAn8jAEEQayICJAACQCAAKAIIIgNFDQAgAyABIAMoAgAoAhARAgAgACgCCCABEKUcDQAgAiACQQhqQdCKChDAGykCADcDACABIAIQghwLIAAoAgwgARC8GyACQRBqJAAL1wIBAn8jAEHwAGsiAiQAIAIgAkHoAGpB5IEKEMAbKQIANwMwIAEgAkEwahCCHCAAQRBqIAEQ/hwgAiACQeAAakGK/gkQwBspAgA3AyggASACQShqEIIcIAAoAggiAwRAIAMgASADKAIAKAIUEQIACwJ/IAAoAhwiA0EBcQRAIAIgAkHYAGpBhLsKEMAbKQIANwMgIAEgAkEgahCCHCAAKAIcIQMLIANBAnELBH8gAiACQdAAakGLuwoQwBspAgA3AxggASACQRhqEIIcIAAoAhwFIAMLQQRxBEAgAiACQcgAakGVuwoQwBspAgA3AxAgASACQRBqEIIcCwJAIAICfwJAAkAgAC0AIEEBaw4CAAEDCyACQUBrQZ+7ChDAGwwBCyACQThqQaK7ChDAGwspAgA3AwggASACQQhqEIIcCyAAKAIYIgAEQCAAIAEQvBsLIAJB8ABqJAALKwAgAEEBQQFBAUEBEIAcIAAgATYCCCAAQbC7CjYCACAAIAIpAgA3AgwgAAt2AgF/AX4jAEEwayICJAAgACgCCCABELwbIAIgAkEoakHXkwoQwBspAgA3AxAgASACQRBqEIIcIAIgACkCDCIDNwMIIAIgAzcDICABIAJBCGoQghwgAiACQRhqQYr+CRDAGykCADcDACABIAIQghwgAkEwaiQACxoAIABBoANqQRAQ/BsgASgCACACKAIAEIUeCzAAIABBDBD8GyIAQQsgASgCACIBLQAFQQFBARCAHCAAIAE2AgggAEGoyAo2AgAgAAtDAQF/IwBBEGsiAyQAIABBFBD8GyEAIAEoAgAhASADIANBCGogAhDAGykCADcDACAAIAEgAxCYHiECIANBEGokACACCzEAIABBDBD8GyEAIAEoAgAhASAAQRBBAUEBQQEQgBwgACABNgIIIABBmL4KNgIAIAALVAIBfwF+IwBBEGsiAiQAIABBEBD8GyEAIAIgASkCACIDNwMAIAIgAzcDCCAAQRFBAUEBQQEQgBwgAEGQvwo2AgAgACACKQIANwIIIAJBEGokACAAC2ECAX8BfiMAQRBrIgYkACAAQSAQ/BshACABKAIAIQEgBiACKQIAIgc3AwggBSgCACEFIAQtAAAhBCADKAIAIQMgBiAHNwMAIAAgASAGIAMgBCAFEPMdIQMgBkEQaiQAIAMLVwEBfyMAQSBrIgIkACACIAJBGGpB/L4KEMAbKQIANwMIIAEgAkEIahCCHCAAKAIIIAEQvBsgAiACQRBqQYr+CRDAGykCADcDACABIAIQghwgAkEgaiQAC0ABAX8jAEEQayICJAAgAiACQQhqQfy/ChDAGykCADcDACABIAIQghwgAEEIaiABEP4cIAFBKRC9GyACQRBqJAALRgEBfiAAQQ9BAEEBQQAQgBwgACABNgIIIABBjMAKNgIAIAIpAgAhBiAAIAU2AhwgACAEOgAYIAAgAzYCFCAAIAY3AgwgAAtDAQF/IwBBEGsiAiQAIAAoAggiACABIAAoAgAoAhARAgAgAiACQQhqQdCKChDAGykCADcDACABIAIQghwgAkEQaiQAC9oCAQJ/IwBB8ABrIgIkACACIAJB6ABqQeSBChDAGykCADcDMCABIAJBMGoQghwgAEEMaiABEP4cIAIgAkHgAGpBiv4JEMAbKQIANwMoIAEgAkEoahCCHCAAKAIIIgMgASADKAIAKAIUEQIAAn8gACgCFCIDQQFxBEAgAiACQdgAakGEuwoQwBspAgA3AyAgASACQSBqEIIcIAAoAhQhAwsgA0ECcQsEfyACIAJB0ABqQYu7ChDAGykCADcDGCABIAJBGGoQghwgACgCFAUgAwtBBHEEQCACIAJByABqQZW7ChDAGykCADcDECABIAJBEGoQghwLAkAgAgJ/AkACQCAALQAYQQFrDgIAAQMLIAJBQGtBn7sKEMAbDAELIAJBOGpBorsKEMAbCykCADcDCCABIAJBCGoQghwLIAAoAhwEQCABQSAQvRsgACgCHCABELwbCyACQfAAaiQAC0YCAX8BfiMAQRBrIgMkACAAQRQQ/BshACABKAIAIQEgAyACKQIAIgQ3AwAgAyAENwMIIAAgASADEPgdIQIgA0EQaiQAIAILRgIBfwF+IwBBEGsiAyQAIABBFBD8GyEAIAEoAgAhASADIAIpAgAiBDcDACADIAQ3AwggACABIAMQ+h0hAiADQRBqJAAgAgsrACAAQQpBAUEBQQEQgBwgACABNgIIIABBhMEKNgIAIAAgAikCADcCDCAAC3YCAX8BfiMAQTBrIgIkACAAKAIIIAEQvBsgAiACQShqQeL+CRDAGykCADcDECABIAJBEGoQghwgAiAAKQIMIgM3AwggAiADNwMgIAEgAkEIahCCHCACIAJBGGpB1v4JEMAbKQIANwMAIAEgAhCCHCACQTBqJAALKwAgAEECQQFBAUEBEIAcIAAgATYCCCAAQfDBCjYCACAAIAIpAgA3AgwgAAtYAgF/AX4jAEEgayICJAAgACgCCCABELwbIAIgAkEYakHQigoQwBspAgA3AwggASACQQhqEIIcIAIgACkCDCIDNwMAIAIgAzcDECABIAIQghwgAkEgaiQACzEAIABBAyABLQAFIAEtAAYgAS0ABxCAHCAAIAE2AgwgACACNgIIIABB4MIKNgIAIAALDAAgACgCDCABEKUcCwwAIAAoAgwgARCoHAsMACAAKAIMIAEQqhwLHwEBfyAAKAIMIgIgASACKAIAKAIQEQIAIAAgARCBHguYAQECfyMAQTBrIgIkAAJ/IAAoAggiA0EBcQRAIAIgAkEoakGEuwoQwBspAgA3AxAgASACQRBqEIIcIAAoAgghAwsgA0ECcQsEfyACIAJBIGpBi7sKEMAbKQIANwMIIAEgAkEIahCCHCAAKAIIBSADC0EEcQRAIAIgAkEYakGVuwoQwBspAgA3AwAgASACEIIcCyACQTBqJAALFgAgACgCDCIAIAEgACgCACgCFBECAAsxACAAQQwQ/BshACABKAIAIQEgAEEaQQFBAUEBEIAcIAAgATYCCCAAQcjDCjYCACAAC1cBAX8jAEEgayICJAAgAiACQRhqQazEChDAGykCADcDCCABIAJBCGoQghwgACgCCCABELwbIAIgAkEQakGnogoQwBspAgA3AwAgASACEIIcIAJBIGokAAsoACAAQRlBAUEBQQEQgBwgACACNgIMIAAgATYCCCAAQcTECjYCACAAC2gBAX8jAEEgayICJAAgACgCCCABELwbIAIgAkEYakGkxQoQwBspAgA3AwggASACQQhqEIIcIAAoAgwiAARAIAAgARC8GwsgAiACQRBqQaeiChDAGykCADcDACABIAIQghwgAkEgaiQACygAIABBDkEAQQBBARCAHCAAIAI2AgwgACABNgIIIABBuMUKNgIAIAALFgAgACgCCCIAIAEgACgCACgCEBECAAucAQECfyMAQTBrIgIkACABEN8dQd0ARwRAIAIgAkEoakHQigoQwBspAgA3AxAgASACQRBqEIIcCyACIAJBIGpBmMYKEMAbKQIANwMIIAEgAkEIahCCHCAAKAIMIgMEQCADIAEQvBsLIAIgAkEYakGnogoQwBspAgA3AwAgASACEIIcIAAoAggiACABIAAoAgAoAhQRAgAgAkEwaiQACysAIABBDSACLQAFQQFBARCAHCAAIAI2AgwgACABNgIIIABBpMYKNgIAIAALnQEBAn8jAEEwayICJAAgACgCDCIDIAEgAygCACgCEBECACACAn8CQCAAKAIMIAEQqBxFBEAgACgCDCABEKocRQ0BCyACQShqQeSBChDAGwwBCyACQSBqQdCKChDAGwspAgA3AxAgASACQRBqEIIcIAAoAgggARC8GyACIAJBGGpBjMcKEMAbKQIANwMIIAEgAkEIahCCHCACQTBqJAALYQEBfyMAQRBrIgIkAAJAIAAoAgwgARCoHEUEQCAAKAIMIAEQqhxFDQELIAIgAkEIakGK/gkQwBspAgA3AwAgASACEIIcCyAAKAIMIgAgASAAKAIAKAIUEQIAIAJBEGokAAtGAgF/AX4jAEEQayIDJAAgAEEUEPwbIQAgAyABKQIAIgQ3AwggAigCACECIAMgBDcDACAAIAMgAhCOHiECIANBEGokACACCzEBAX4gAEEGQQFBAUEBEIAcIABBtMcKNgIAIAEpAgAhAyAAIAI2AhAgACADNwIIIAALQQIBfwF+IwBBEGsiAiQAIAIgACkCCCIDNwMAIAIgAzcDCCABIAIQghwgAUEgEL0bIAAoAhAgARC8GyACQRBqJAALDAAgACgCCCABEKUcC6YCAgJ/AX4jAEHgAGsiAiQAIAICfwJAAn8gACgCCCIDLQAEQQpGBEAgAxCSHg0CIAAoAgghAwsgAwsgASADKAIAKAIQEQIAIAAoAgggARCoHARAIAIgAkHYAGpB0IoKEMAbKQIANwMoIAEgAkEoahCCHAsCQCAAKAIIIAEQqBxFBEAgACgCCCABEKocRQ0BCyACIAJB0ABqQeSBChDAGykCADcDICABIAJBIGoQghwLIAJByABqQb/+CRDAGwwBCyAAKAIIIQAgAiACQUBrQYjJChDAGykCADcDGCABIAJBGGoQghwgAiAAKQIMIgQ3AxAgAiAENwM4IAEgAkEQahCCHCACQTBqQdb+CRDAGwspAgA3AwggASACQQhqEIIcIAJB4ABqJAALQwECfyMAQRBrIgEkACAAKAIIIgAtAARBB0YEQCABQQhqIAAQkhwgAUEIaiABQYzJChDAGxCTHSECCyABQRBqJAAgAgt+AQJ/IwBBEGsiAiQAAkACQCAAKAIIIgMtAARBCkYEfyADEJIeDQIgACgCCAUgAwsgARCoHEUEQCAAKAIIIAEQqhxFDQELIAIgAkEIakGK/gkQwBspAgA3AwAgASACEIIcCyAAKAIIIgAgASAAKAIAKAIUEQIACyACQRBqJAALMgAgAEEMIAEtAAVBAUEBEIAcIABBADoAECAAIAI2AgwgACABNgIIIABBoMkKNgIAIAAL3wEBAn8jAEFAaiICJAAgAC0AEEUEQCACQThqIABBEGpBARCkHCEDIAJBMGogACABEJYeIAIoAjQiACABIAAoAgAoAhARAgAgAigCNCABEKgcBEAgAiACQShqQdCKChDAGykCADcDECABIAJBEGoQghwLAkAgAigCNCABEKgcRQRAIAIoAjQgARCqHEUNAQsgAiACQSBqQeSBChDAGykCADcDCCABIAJBCGoQghwLIAIgAkEYakGP/glBkv4JIAIoAjAbEMAbKQIANwMAIAEgAhCCHCADEKYcCyACQUBrJAALbQEBfyAAIAFBDGooAgA2AgAgACABQQhqKAIANgIEIAAoAgQhAQNAIAEgAiABKAIAKAIMEQMAIgMtAARBDEYEQCAAIAMoAggiATYCBCAAIANBDGoiAyAAIAMoAgAgACgCAEgbKAIANgIADAELCwuMAQECfyMAQSBrIgIkACAALQAQRQRAIAJBGGogAEEQakEBEKQcIQMgAkEQaiAAIAEQlh4CQCACKAIUIAEQqBxFBEAgAigCFCABEKocRQ0BCyACIAJBCGpBiv4JEMAbKQIANwMAIAEgAhCCHAsgAigCFCIAIAEgACgCACgCFBECACADEKYcCyACQSBqJAALKwAgAEEFQQFBAUEBEIAcIAAgATYCCCAAQYzKCjYCACAAIAIpAgA3AgwgAAtEAgJ/AX4jAEEQayICJAAgACgCCCIDIAEgAygCACgCEBECACACIAApAgwiBDcDACACIAQ3AwggASACEIIcIAJBEGokAAsEACMACwYAIAAkAAsQACMAIABrQXBxIgAkACAACx8AQfCqCygCAEUEQEH0qgsgATYCAEHwqgsgADYCAAsLGQAgASACIAOtIAStQiCGhCAFIAYgABEsAAsWAQF+IAEgABEdACICQiCIpxAsIAKnCxMAIAEgAq0gA61CIIaEIAARJgALIgEBfiABIAKtIAOtQiCGhCAEIAARHgAiBUIgiKcQLCAFpwsZACABIAIgAyAEIAWtIAatQiCGhCAAEScACyMAIAEgAiADIAQgBa0gBq1CIIaEIAetIAitQiCGhCAAETgACyUAIAEgAiADIAQgBSAGrSAHrUIghoQgCK0gCa1CIIaEIAARNwALEwAgACABpyABQiCIpyACIAMQLQsLm6oKhAEAQYAIC7COAXB1c2gAeAB5AHdpZHRoAGhlaWdodABJbnRWZWN0b3IARmxvYXRWZWN0b3IARG91YmxlVmVjdG9yAFBvaW50VmVjdG9yAE1hdFZlY3RvcgBSZWN0VmVjdG9yAEtleVBvaW50VmVjdG9yAERNYXRjaFZlY3RvcgBETWF0Y2hWZWN0b3JWZWN0b3IATWF0AGV5ZQBvbmVzAHplcm9zAHJvd3MAY29scwBtYXRTaXplAHN0ZXAAZGF0YQBkYXRhOFMAZGF0YTE2VQBkYXRhMTZTAGRhdGEzMlMAZGF0YTMyRgBkYXRhNjRGAGVsZW1TaXplAGVsZW1TaXplMQBjaGFubmVscwBjb252ZXJ0VG8AdG90YWwAcm93AGNyZWF0ZQByb3dSYW5nZQBjb3B5VG8AdHlwZQBlbXB0eQBjb2xSYW5nZQBzdGVwMQBjbG9uZQBkZXB0aABjb2wAZG90AG11bABpbnYAdAByb2kAZGlhZwBpc0NvbnRpbnVvdXMAc2V0VG8Ac2l6ZQBwdHIAdWNoYXJQdHIAY2hhclB0cgBzaG9ydFB0cgB1c2hvcnRQdHIAaW50UHRyAGZsb2F0UHRyAGRvdWJsZVB0cgBjaGFyQXQAdWNoYXJBdABzaG9ydEF0AHVzaG9ydEF0AGludEF0AGZsb2F0QXQAZG91YmxlQXQAUmFuZ2UAc3RhcnQAZW5kAFRlcm1Dcml0ZXJpYQBtYXhDb3VudABlcHNpbG9uACN0eXBlAFJlY3QAUmVjdDJmAFJvdGF0ZWRSZWN0AGNlbnRlcgBhbmdsZQByb3RhdGVkUmVjdFBvaW50cwByb3RhdGVkUmVjdEJvdW5kaW5nUmVjdAByb3RhdGVkUmVjdEJvdW5kaW5nUmVjdDJmAEtleVBvaW50AGNsYXNzX2lkAG9jdGF2ZQBwdAByZXNwb25zZQBETWF0Y2gAcXVlcnlJZHgAdHJhaW5JZHgAaW1nSWR4AGRpc3RhbmNlAFNjYWxhcgBNaW5NYXhMb2MAbWluVmFsAG1heFZhbABtaW5Mb2MAbWF4TG9jAENpcmNsZQByYWRpdXMATW9tZW50cwBtMDAAbTEwAG0wMQBtMjAAbTExAG0wMgBtMzAAbTIxAG0xMgBtMDMAbXUyMABtdTExAG11MDIAbXUzMABtdTIxAG11MTIAbXUwMwBudTIwAG51MTEAbnUwMgBudTMwAG51MjEAbnUxMgBudTAzAEV4Y2VwdGlvbgBjb2RlAG1zZwBleGNlcHRpb25Gcm9tUHRyAG1pbkVuY2xvc2luZ0NpcmNsZQBmbG9vZEZpbGwAbWluTWF4TG9jAG1vcnBob2xvZ3lEZWZhdWx0Qm9yZGVyVmFsdWUAQ1ZfTUFUX0RFUFRIAENhbVNoaWZ0AG1lYW5TaGlmdABUcmFja2VyAGluaXQAdXBkYXRlAGdldEJ1aWxkSW5mb3JtYXRpb24AQ1ZfOFVDMQBDVl84VUMyAENWXzhVQzMAQ1ZfOFVDNABDVl84U0MxAENWXzhTQzIAQ1ZfOFNDMwBDVl84U0M0AENWXzE2VUMxAENWXzE2VUMyAENWXzE2VUMzAENWXzE2VUM0AENWXzE2U0MxAENWXzE2U0MyAENWXzE2U0MzAENWXzE2U0M0AENWXzMyU0MxAENWXzMyU0MyAENWXzMyU0MzAENWXzMyU0M0AENWXzMyRkMxAENWXzMyRkMyAENWXzMyRkMzAENWXzMyRkM0AENWXzY0RkMxAENWXzY0RkMyAENWXzY0RkMzAENWXzY0RkM0AENWXzhVAENWXzhTAENWXzE2VQBDVl8xNlMAQ1ZfMzJTAENWXzMyRgBDVl82NEYASU5UX01JTgBJTlRfTUFYAFJvZHJpZ3VlcwBTVkRlY29tcABzb2x2ZVBuUABBQ0NFU1NfRkFTVABBQ0NFU1NfTUFTSwBBQ0NFU1NfUkVBRABBQ0NFU1NfUlcAQUNDRVNTX1dSSVRFAEFEQVBUSVZFX1RIUkVTSF9HQVVTU0lBTl9DAEFEQVBUSVZFX1RIUkVTSF9NRUFOX0MAQUtBWkVfREVTQ1JJUFRPUl9LQVpFAEFLQVpFX0RFU0NSSVBUT1JfS0FaRV9VUFJJR0hUAEFLQVpFX0RFU0NSSVBUT1JfTUxEQgBBS0FaRV9ERVNDUklQVE9SX01MREJfVVBSSUdIVABBZ2FzdEZlYXR1cmVEZXRlY3Rvcl9BR0FTVF81XzgAQWdhc3RGZWF0dXJlRGV0ZWN0b3JfQUdBU1RfN18xMmQAQWdhc3RGZWF0dXJlRGV0ZWN0b3JfQUdBU1RfN18xMnMAQWdhc3RGZWF0dXJlRGV0ZWN0b3JfTk9OTUFYX1NVUFBSRVNTSU9OAEFnYXN0RmVhdHVyZURldGVjdG9yX09BU1RfOV8xNgBBZ2FzdEZlYXR1cmVEZXRlY3Rvcl9USFJFU0hPTEQAQk9SREVSX0NPTlNUQU5UAEJPUkRFUl9ERUZBVUxUAEJPUkRFUl9JU09MQVRFRABCT1JERVJfUkVGTEVDVABCT1JERVJfUkVGTEVDVDEwMQBCT1JERVJfUkVGTEVDVF8xMDEAQk9SREVSX1JFUExJQ0FURQBCT1JERVJfVFJBTlNQQVJFTlQAQk9SREVSX1dSQVAAQ0FMSUJfQ0JfQUNDVVJBQ1kAQ0FMSUJfQ0JfQURBUFRJVkVfVEhSRVNIAENBTElCX0NCX0FTWU1NRVRSSUNfR1JJRABDQUxJQl9DQl9DTFVTVEVSSU5HAENBTElCX0NCX0VYSEFVU1RJVkUAQ0FMSUJfQ0JfRkFTVF9DSEVDSwBDQUxJQl9DQl9GSUxURVJfUVVBRFMAQ0FMSUJfQ0JfTEFSR0VSAENBTElCX0NCX01BUktFUgBDQUxJQl9DQl9OT1JNQUxJWkVfSU1BR0UAQ0FMSUJfQ0JfU1lNTUVUUklDX0dSSUQAQ0FMSUJfRklYX0FTUEVDVF9SQVRJTwBDQUxJQl9GSVhfRk9DQUxfTEVOR1RIAENBTElCX0ZJWF9JTlRSSU5TSUMAQ0FMSUJfRklYX0sxAENBTElCX0ZJWF9LMgBDQUxJQl9GSVhfSzMAQ0FMSUJfRklYX0s0AENBTElCX0ZJWF9LNQBDQUxJQl9GSVhfSzYAQ0FMSUJfRklYX1BSSU5DSVBBTF9QT0lOVABDQUxJQl9GSVhfUzFfUzJfUzNfUzQAQ0FMSUJfRklYX1RBTkdFTlRfRElTVABDQUxJQl9GSVhfVEFVWF9UQVVZAENBTElCX0hBTkRfRVlFX0FORFJFRkYAQ0FMSUJfSEFORF9FWUVfREFOSUlMSURJUwBDQUxJQl9IQU5EX0VZRV9IT1JBVUQAQ0FMSUJfSEFORF9FWUVfUEFSSwBDQUxJQl9IQU5EX0VZRV9UU0FJAENBTElCX05JTlRSSU5TSUMAQ0FMSUJfUkFUSU9OQUxfTU9ERUwAQ0FMSUJfUk9CT1RfV09STERfSEFORF9FWUVfTEkAQ0FMSUJfUk9CT1RfV09STERfSEFORF9FWUVfU0hBSABDQUxJQl9TQU1FX0ZPQ0FMX0xFTkdUSABDQUxJQl9USElOX1BSSVNNX01PREVMAENBTElCX1RJTFRFRF9NT0RFTABDQUxJQl9VU0VfRVhUUklOU0lDX0dVRVNTAENBTElCX1VTRV9JTlRSSU5TSUNfR1VFU1MAQ0FMSUJfVVNFX0xVAENBTElCX1VTRV9RUgBDQUxJQl9aRVJPX0RJU1BBUklUWQBDQUxJQl9aRVJPX1RBTkdFTlRfRElTVABDQVNDQURFX0RPX0NBTk5ZX1BSVU5JTkcAQ0FTQ0FERV9ET19ST1VHSF9TRUFSQ0gAQ0FTQ0FERV9GSU5EX0JJR0dFU1RfT0JKRUNUAENBU0NBREVfU0NBTEVfSU1BR0UAQ0NMX0JCRFQAQ0NMX0JPTEVMTEkAQ0NMX0RFRkFVTFQAQ0NMX0dSQU5BAENDTF9TQVVGAENDTF9TUEFHSEVUVEkAQ0NMX1dVAENDX1NUQVRfQVJFQQBDQ19TVEFUX0hFSUdIVABDQ19TVEFUX0xFRlQAQ0NfU1RBVF9NQVgAQ0NfU1RBVF9UT1AAQ0NfU1RBVF9XSURUSABDSEFJTl9BUFBST1hfTk9ORQBDSEFJTl9BUFBST1hfU0lNUExFAENIQUlOX0FQUFJPWF9UQzg5X0tDT1MAQ0hBSU5fQVBQUk9YX1RDODlfTDEAQ01QX0VRAENNUF9HRQBDTVBfR1QAQ01QX0xFAENNUF9MVABDTVBfTkUAQ09MT1JNQVBfQVVUVU1OAENPTE9STUFQX0JPTkUAQ09MT1JNQVBfQ0lWSURJUwBDT0xPUk1BUF9DT09MAENPTE9STUFQX0RFRVBHUkVFTgBDT0xPUk1BUF9IT1QAQ09MT1JNQVBfSFNWAENPTE9STUFQX0lORkVSTk8AQ09MT1JNQVBfSkVUAENPTE9STUFQX01BR01BAENPTE9STUFQX09DRUFOAENPTE9STUFQX1BBUlVMQQBDT0xPUk1BUF9QSU5LAENPTE9STUFQX1BMQVNNQQBDT0xPUk1BUF9SQUlOQk9XAENPTE9STUFQX1NQUklORwBDT0xPUk1BUF9TVU1NRVIAQ09MT1JNQVBfVFVSQk8AQ09MT1JNQVBfVFdJTElHSFQAQ09MT1JNQVBfVFdJTElHSFRfU0hJRlRFRABDT0xPUk1BUF9WSVJJRElTAENPTE9STUFQX1dJTlRFUgBDT0xPUl9CR1IyQkdSNTU1AENPTE9SX0JHUjJCR1I1NjUAQ09MT1JfQkdSMkJHUkEAQ09MT1JfQkdSMkdSQVkAQ09MT1JfQkdSMkhMUwBDT0xPUl9CR1IySExTX0ZVTEwAQ09MT1JfQkdSMkhTVgBDT0xPUl9CR1IySFNWX0ZVTEwAQ09MT1JfQkdSMkxhYgBDT0xPUl9CR1IyTHV2AENPTE9SX0JHUjJSR0IAQ09MT1JfQkdSMlJHQkEAQ09MT1JfQkdSMlhZWgBDT0xPUl9CR1IyWUNyQ2IAQ09MT1JfQkdSMllVVgBDT0xPUl9CR1IyWVVWX0k0MjAAQ09MT1JfQkdSMllVVl9JWVVWAENPTE9SX0JHUjJZVVZfWVYxMgBDT0xPUl9CR1I1NTUyQkdSAENPTE9SX0JHUjU1NTJCR1JBAENPTE9SX0JHUjU1NTJHUkFZAENPTE9SX0JHUjU1NTJSR0IAQ09MT1JfQkdSNTU1MlJHQkEAQ09MT1JfQkdSNTY1MkJHUgBDT0xPUl9CR1I1NjUyQkdSQQBDT0xPUl9CR1I1NjUyR1JBWQBDT0xPUl9CR1I1NjUyUkdCAENPTE9SX0JHUjU2NTJSR0JBAENPTE9SX0JHUkEyQkdSAENPTE9SX0JHUkEyQkdSNTU1AENPTE9SX0JHUkEyQkdSNTY1AENPTE9SX0JHUkEyR1JBWQBDT0xPUl9CR1JBMlJHQgBDT0xPUl9CR1JBMlJHQkEAQ09MT1JfQkdSQTJZVVZfSTQyMABDT0xPUl9CR1JBMllVVl9JWVVWAENPTE9SX0JHUkEyWVVWX1lWMTIAQ09MT1JfQmF5ZXJCRzJCR1IAQ09MT1JfQmF5ZXJCRzJCR1JBAENPTE9SX0JheWVyQkcyQkdSX0VBAENPTE9SX0JheWVyQkcyQkdSX1ZORwBDT0xPUl9CYXllckJHMkdSQVkAQ09MT1JfQmF5ZXJCRzJSR0IAQ09MT1JfQmF5ZXJCRzJSR0JBAENPTE9SX0JheWVyQkcyUkdCX0VBAENPTE9SX0JheWVyQkcyUkdCX1ZORwBDT0xPUl9CYXllckJHR1IyQkdSAENPTE9SX0JheWVyQkdHUjJCR1JBAENPTE9SX0JheWVyQkdHUjJCR1JfRUEAQ09MT1JfQmF5ZXJCR0dSMkJHUl9WTkcAQ09MT1JfQmF5ZXJCR0dSMkdSQVkAQ09MT1JfQmF5ZXJCR0dSMlJHQgBDT0xPUl9CYXllckJHR1IyUkdCQQBDT0xPUl9CYXllckJHR1IyUkdCX0VBAENPTE9SX0JheWVyQkdHUjJSR0JfVk5HAENPTE9SX0JheWVyR0IyQkdSAENPTE9SX0JheWVyR0IyQkdSQQBDT0xPUl9CYXllckdCMkJHUl9FQQBDT0xPUl9CYXllckdCMkJHUl9WTkcAQ09MT1JfQmF5ZXJHQjJHUkFZAENPTE9SX0JheWVyR0IyUkdCAENPTE9SX0JheWVyR0IyUkdCQQBDT0xPUl9CYXllckdCMlJHQl9FQQBDT0xPUl9CYXllckdCMlJHQl9WTkcAQ09MT1JfQmF5ZXJHQlJHMkJHUgBDT0xPUl9CYXllckdCUkcyQkdSQQBDT0xPUl9CYXllckdCUkcyQkdSX0VBAENPTE9SX0JheWVyR0JSRzJCR1JfVk5HAENPTE9SX0JheWVyR0JSRzJHUkFZAENPTE9SX0JheWVyR0JSRzJSR0IAQ09MT1JfQmF5ZXJHQlJHMlJHQkEAQ09MT1JfQmF5ZXJHQlJHMlJHQl9FQQBDT0xPUl9CYXllckdCUkcyUkdCX1ZORwBDT0xPUl9CYXllckdSMkJHUgBDT0xPUl9CYXllckdSMkJHUkEAQ09MT1JfQmF5ZXJHUjJCR1JfRUEAQ09MT1JfQmF5ZXJHUjJCR1JfVk5HAENPTE9SX0JheWVyR1IyR1JBWQBDT0xPUl9CYXllckdSMlJHQgBDT0xPUl9CYXllckdSMlJHQkEAQ09MT1JfQmF5ZXJHUjJSR0JfRUEAQ09MT1JfQmF5ZXJHUjJSR0JfVk5HAENPTE9SX0JheWVyR1JCRzJCR1IAQ09MT1JfQmF5ZXJHUkJHMkJHUkEAQ09MT1JfQmF5ZXJHUkJHMkJHUl9FQQBDT0xPUl9CYXllckdSQkcyQkdSX1ZORwBDT0xPUl9CYXllckdSQkcyR1JBWQBDT0xPUl9CYXllckdSQkcyUkdCAENPTE9SX0JheWVyR1JCRzJSR0JBAENPTE9SX0JheWVyR1JCRzJSR0JfRUEAQ09MT1JfQmF5ZXJHUkJHMlJHQl9WTkcAQ09MT1JfQmF5ZXJSRzJCR1IAQ09MT1JfQmF5ZXJSRzJCR1JBAENPTE9SX0JheWVyUkcyQkdSX0VBAENPTE9SX0JheWVyUkcyQkdSX1ZORwBDT0xPUl9CYXllclJHMkdSQVkAQ09MT1JfQmF5ZXJSRzJSR0IAQ09MT1JfQmF5ZXJSRzJSR0JBAENPTE9SX0JheWVyUkcyUkdCX0VBAENPTE9SX0JheWVyUkcyUkdCX1ZORwBDT0xPUl9CYXllclJHR0IyQkdSAENPTE9SX0JheWVyUkdHQjJCR1JBAENPTE9SX0JheWVyUkdHQjJCR1JfRUEAQ09MT1JfQmF5ZXJSR0dCMkJHUl9WTkcAQ09MT1JfQmF5ZXJSR0dCMkdSQVkAQ09MT1JfQmF5ZXJSR0dCMlJHQgBDT0xPUl9CYXllclJHR0IyUkdCQQBDT0xPUl9CYXllclJHR0IyUkdCX0VBAENPTE9SX0JheWVyUkdHQjJSR0JfVk5HAENPTE9SX0NPTE9SQ1ZUX01BWABDT0xPUl9HUkFZMkJHUgBDT0xPUl9HUkFZMkJHUjU1NQBDT0xPUl9HUkFZMkJHUjU2NQBDT0xPUl9HUkFZMkJHUkEAQ09MT1JfR1JBWTJSR0IAQ09MT1JfR1JBWTJSR0JBAENPTE9SX0hMUzJCR1IAQ09MT1JfSExTMkJHUl9GVUxMAENPTE9SX0hMUzJSR0IAQ09MT1JfSExTMlJHQl9GVUxMAENPTE9SX0hTVjJCR1IAQ09MT1JfSFNWMkJHUl9GVUxMAENPTE9SX0hTVjJSR0IAQ09MT1JfSFNWMlJHQl9GVUxMAENPTE9SX0xCR1IyTGFiAENPTE9SX0xCR1IyTHV2AENPTE9SX0xSR0IyTGFiAENPTE9SX0xSR0IyTHV2AENPTE9SX0xhYjJCR1IAQ09MT1JfTGFiMkxCR1IAQ09MT1JfTGFiMkxSR0IAQ09MT1JfTGFiMlJHQgBDT0xPUl9MdXYyQkdSAENPTE9SX0x1djJMQkdSAENPTE9SX0x1djJMUkdCAENPTE9SX0x1djJSR0IAQ09MT1JfUkdCMkJHUgBDT0xPUl9SR0IyQkdSNTU1AENPTE9SX1JHQjJCR1I1NjUAQ09MT1JfUkdCMkJHUkEAQ09MT1JfUkdCMkdSQVkAQ09MT1JfUkdCMkhMUwBDT0xPUl9SR0IySExTX0ZVTEwAQ09MT1JfUkdCMkhTVgBDT0xPUl9SR0IySFNWX0ZVTEwAQ09MT1JfUkdCMkxhYgBDT0xPUl9SR0IyTHV2AENPTE9SX1JHQjJSR0JBAENPTE9SX1JHQjJYWVoAQ09MT1JfUkdCMllDckNiAENPTE9SX1JHQjJZVVYAQ09MT1JfUkdCMllVVl9JNDIwAENPTE9SX1JHQjJZVVZfSVlVVgBDT0xPUl9SR0IyWVVWX1lWMTIAQ09MT1JfUkdCQTJCR1IAQ09MT1JfUkdCQTJCR1I1NTUAQ09MT1JfUkdCQTJCR1I1NjUAQ09MT1JfUkdCQTJCR1JBAENPTE9SX1JHQkEyR1JBWQBDT0xPUl9SR0JBMlJHQgBDT0xPUl9SR0JBMllVVl9JNDIwAENPTE9SX1JHQkEyWVVWX0lZVVYAQ09MT1JfUkdCQTJZVVZfWVYxMgBDT0xPUl9SR0JBMm1SR0JBAENPTE9SX1hZWjJCR1IAQ09MT1JfWFlaMlJHQgBDT0xPUl9ZQ3JDYjJCR1IAQ09MT1JfWUNyQ2IyUkdCAENPTE9SX1lVVjJCR1IAQ09MT1JfWVVWMkJHUkFfSTQyMABDT0xPUl9ZVVYyQkdSQV9JWVVWAENPTE9SX1lVVjJCR1JBX05WMTIAQ09MT1JfWVVWMkJHUkFfTlYyMQBDT0xPUl9ZVVYyQkdSQV9VWU5WAENPTE9SX1lVVjJCR1JBX1VZVlkAQ09MT1JfWVVWMkJHUkFfWTQyMgBDT0xPUl9ZVVYyQkdSQV9ZVU5WAENPTE9SX1lVVjJCR1JBX1lVWTIAQ09MT1JfWVVWMkJHUkFfWVVZVgBDT0xPUl9ZVVYyQkdSQV9ZVjEyAENPTE9SX1lVVjJCR1JBX1lWWVUAQ09MT1JfWVVWMkJHUl9JNDIwAENPTE9SX1lVVjJCR1JfSVlVVgBDT0xPUl9ZVVYyQkdSX05WMTIAQ09MT1JfWVVWMkJHUl9OVjIxAENPTE9SX1lVVjJCR1JfVVlOVgBDT0xPUl9ZVVYyQkdSX1VZVlkAQ09MT1JfWVVWMkJHUl9ZNDIyAENPTE9SX1lVVjJCR1JfWVVOVgBDT0xPUl9ZVVYyQkdSX1lVWTIAQ09MT1JfWVVWMkJHUl9ZVVlWAENPTE9SX1lVVjJCR1JfWVYxMgBDT0xPUl9ZVVYyQkdSX1lWWVUAQ09MT1JfWVVWMkdSQVlfNDIwAENPTE9SX1lVVjJHUkFZX0k0MjAAQ09MT1JfWVVWMkdSQVlfSVlVVgBDT0xPUl9ZVVYyR1JBWV9OVjEyAENPTE9SX1lVVjJHUkFZX05WMjEAQ09MT1JfWVVWMkdSQVlfVVlOVgBDT0xPUl9ZVVYyR1JBWV9VWVZZAENPTE9SX1lVVjJHUkFZX1k0MjIAQ09MT1JfWVVWMkdSQVlfWVVOVgBDT0xPUl9ZVVYyR1JBWV9ZVVkyAENPTE9SX1lVVjJHUkFZX1lVWVYAQ09MT1JfWVVWMkdSQVlfWVYxMgBDT0xPUl9ZVVYyR1JBWV9ZVllVAENPTE9SX1lVVjJSR0IAQ09MT1JfWVVWMlJHQkFfSTQyMABDT0xPUl9ZVVYyUkdCQV9JWVVWAENPTE9SX1lVVjJSR0JBX05WMTIAQ09MT1JfWVVWMlJHQkFfTlYyMQBDT0xPUl9ZVVYyUkdCQV9VWU5WAENPTE9SX1lVVjJSR0JBX1VZVlkAQ09MT1JfWVVWMlJHQkFfWTQyMgBDT0xPUl9ZVVYyUkdCQV9ZVU5WAENPTE9SX1lVVjJSR0JBX1lVWTIAQ09MT1JfWVVWMlJHQkFfWVVZVgBDT0xPUl9ZVVYyUkdCQV9ZVjEyAENPTE9SX1lVVjJSR0JBX1lWWVUAQ09MT1JfWVVWMlJHQl9JNDIwAENPTE9SX1lVVjJSR0JfSVlVVgBDT0xPUl9ZVVYyUkdCX05WMTIAQ09MT1JfWVVWMlJHQl9OVjIxAENPTE9SX1lVVjJSR0JfVVlOVgBDT0xPUl9ZVVYyUkdCX1VZVlkAQ09MT1JfWVVWMlJHQl9ZNDIyAENPTE9SX1lVVjJSR0JfWVVOVgBDT0xPUl9ZVVYyUkdCX1lVWTIAQ09MT1JfWVVWMlJHQl9ZVVlWAENPTE9SX1lVVjJSR0JfWVYxMgBDT0xPUl9ZVVYyUkdCX1lWWVUAQ09MT1JfWVVWNDIwcDJCR1IAQ09MT1JfWVVWNDIwcDJCR1JBAENPTE9SX1lVVjQyMHAyR1JBWQBDT0xPUl9ZVVY0MjBwMlJHQgBDT0xPUl9ZVVY0MjBwMlJHQkEAQ09MT1JfWVVWNDIwc3AyQkdSAENPTE9SX1lVVjQyMHNwMkJHUkEAQ09MT1JfWVVWNDIwc3AyR1JBWQBDT0xPUl9ZVVY0MjBzcDJSR0IAQ09MT1JfWVVWNDIwc3AyUkdCQQBDT0xPUl9tUkdCQTJSR0JBAENPTlRPVVJTX01BVENIX0kxAENPTlRPVVJTX01BVENIX0kyAENPTlRPVVJTX01BVENIX0kzAENPVkFSX0NPTFMAQ09WQVJfTk9STUFMAENPVkFSX1JPV1MAQ09WQVJfU0NBTEUAQ09WQVJfU0NSQU1CTEVEAENPVkFSX1VTRV9BVkcAQ2lyY2xlc0dyaWRGaW5kZXJQYXJhbWV0ZXJzX0FTWU1NRVRSSUNfR1JJRABDaXJjbGVzR3JpZEZpbmRlclBhcmFtZXRlcnNfU1lNTUVUUklDX0dSSUQARENUX0lOVkVSU0UARENUX1JPV1MAREVDT01QX0NIT0xFU0tZAERFQ09NUF9FSUcAREVDT01QX0xVAERFQ09NUF9OT1JNQUwAREVDT01QX1FSAERFQ09NUF9TVkQAREZUX0NPTVBMRVhfSU5QVVQAREZUX0NPTVBMRVhfT1VUUFVUAERGVF9JTlZFUlNFAERGVF9SRUFMX09VVFBVVABERlRfUk9XUwBERlRfU0NBTEUARElTT3B0aWNhbEZsb3dfUFJFU0VUX0ZBU1QARElTT3B0aWNhbEZsb3dfUFJFU0VUX01FRElVTQBESVNPcHRpY2FsRmxvd19QUkVTRVRfVUxUUkFGQVNUAERJU1RfQwBESVNUX0ZBSVIARElTVF9IVUJFUgBESVNUX0wxAERJU1RfTDEyAERJU1RfTDIARElTVF9MQUJFTF9DQ09NUABESVNUX0xBQkVMX1BJWEVMAERJU1RfTUFTS18zAERJU1RfTUFTS181AERJU1RfTUFTS19QUkVDSVNFAERJU1RfVVNFUgBESVNUX1dFTFNDSABEZXNjcmlwdG9yTWF0Y2hlcl9CUlVURUZPUkNFAERlc2NyaXB0b3JNYXRjaGVyX0JSVVRFRk9SQ0VfSEFNTUlORwBEZXNjcmlwdG9yTWF0Y2hlcl9CUlVURUZPUkNFX0hBTU1JTkdMVVQARGVzY3JpcHRvck1hdGNoZXJfQlJVVEVGT1JDRV9MMQBEZXNjcmlwdG9yTWF0Y2hlcl9CUlVURUZPUkNFX1NMMgBEZXNjcmlwdG9yTWF0Y2hlcl9GTEFOTkJBU0VEAERyYXdNYXRjaGVzRmxhZ3NfREVGQVVMVABEcmF3TWF0Y2hlc0ZsYWdzX0RSQVdfT1ZFUl9PVVRJTUcARHJhd01hdGNoZXNGbGFnc19EUkFXX1JJQ0hfS0VZUE9JTlRTAERyYXdNYXRjaGVzRmxhZ3NfTk9UX0RSQVdfU0lOR0xFX1BPSU5UUwBGSUxMRUQARklMVEVSX1NDSEFSUgBGTE9PREZJTExfRklYRURfUkFOR0UARkxPT0RGSUxMX01BU0tfT05MWQBGTV83UE9JTlQARk1fOFBPSU5UAEZNX0xNRURTAEZNX1JBTlNBQwBGT05UX0hFUlNIRVlfQ09NUExFWABGT05UX0hFUlNIRVlfQ09NUExFWF9TTUFMTABGT05UX0hFUlNIRVlfRFVQTEVYAEZPTlRfSEVSU0hFWV9QTEFJTgBGT05UX0hFUlNIRVlfU0NSSVBUX0NPTVBMRVgARk9OVF9IRVJTSEVZX1NDUklQVF9TSU1QTEVYAEZPTlRfSEVSU0hFWV9TSU1QTEVYAEZPTlRfSEVSU0hFWV9UUklQTEVYAEZPTlRfSVRBTElDAEZhY2VSZWNvZ25pemVyU0ZfRlJfQ09TSU5FAEZhY2VSZWNvZ25pemVyU0ZfRlJfTk9STV9MMgBGYXN0RmVhdHVyZURldGVjdG9yX0ZBU1RfTgBGYXN0RmVhdHVyZURldGVjdG9yX05PTk1BWF9TVVBQUkVTU0lPTgBGYXN0RmVhdHVyZURldGVjdG9yX1RIUkVTSE9MRABGYXN0RmVhdHVyZURldGVjdG9yX1RZUEVfNV84AEZhc3RGZWF0dXJlRGV0ZWN0b3JfVFlQRV83XzEyAEZhc3RGZWF0dXJlRGV0ZWN0b3JfVFlQRV85XzE2AEZpbGVOb2RlX0VNUFRZAEZpbGVOb2RlX0ZMT0FUAEZpbGVOb2RlX0ZMT1cARmlsZU5vZGVfSU5UAEZpbGVOb2RlX01BUABGaWxlTm9kZV9OQU1FRABGaWxlTm9kZV9OT05FAEZpbGVOb2RlX1JFQUwARmlsZU5vZGVfU0VRAEZpbGVOb2RlX1NUUgBGaWxlTm9kZV9TVFJJTkcARmlsZU5vZGVfVFlQRV9NQVNLAEZpbGVOb2RlX1VOSUZPUk0ARmlsZVN0b3JhZ2VfQVBQRU5EAEZpbGVTdG9yYWdlX0JBU0U2NABGaWxlU3RvcmFnZV9GT1JNQVRfQVVUTwBGaWxlU3RvcmFnZV9GT1JNQVRfSlNPTgBGaWxlU3RvcmFnZV9GT1JNQVRfTUFTSwBGaWxlU3RvcmFnZV9GT1JNQVRfWE1MAEZpbGVTdG9yYWdlX0ZPUk1BVF9ZQU1MAEZpbGVTdG9yYWdlX0lOU0lERV9NQVAARmlsZVN0b3JhZ2VfTUVNT1JZAEZpbGVTdG9yYWdlX05BTUVfRVhQRUNURUQARmlsZVN0b3JhZ2VfUkVBRABGaWxlU3RvcmFnZV9VTkRFRklORUQARmlsZVN0b3JhZ2VfVkFMVUVfRVhQRUNURUQARmlsZVN0b3JhZ2VfV1JJVEUARmlsZVN0b3JhZ2VfV1JJVEVfQkFTRTY0AEZvcm1hdHRlcl9GTVRfQwBGb3JtYXR0ZXJfRk1UX0NTVgBGb3JtYXR0ZXJfRk1UX0RFRkFVTFQARm9ybWF0dGVyX0ZNVF9NQVRMQUIARm9ybWF0dGVyX0ZNVF9OVU1QWQBGb3JtYXR0ZXJfRk1UX1BZVEhPTgBHQ19CR0QAR0NfRVZBTABHQ19FVkFMX0ZSRUVaRV9NT0RFTABHQ19GR0QAR0NfSU5JVF9XSVRIX01BU0sAR0NfSU5JVF9XSVRIX1JFQ1QAR0NfUFJfQkdEAEdDX1BSX0ZHRABHRU1NXzFfVABHRU1NXzJfVABHRU1NXzNfVABISVNUQ01QX0JIQVRUQUNIQVJZWUEASElTVENNUF9DSElTUVIASElTVENNUF9DSElTUVJfQUxUAEhJU1RDTVBfQ09SUkVMAEhJU1RDTVBfSEVMTElOR0VSAEhJU1RDTVBfSU5URVJTRUNUAEhJU1RDTVBfS0xfRElWAEhPR0Rlc2NyaXB0b3JfREVGQVVMVF9OTEVWRUxTAEhPR0Rlc2NyaXB0b3JfREVTQ1JfRk9STUFUX0NPTF9CWV9DT0wASE9HRGVzY3JpcHRvcl9ERVNDUl9GT1JNQVRfUk9XX0JZX1JPVwBIT0dEZXNjcmlwdG9yX0wySHlzAEhPVUdIX0dSQURJRU5UAEhPVUdIX0dSQURJRU5UX0FMVABIT1VHSF9NVUxUSV9TQ0FMRQBIT1VHSF9QUk9CQUJJTElTVElDAEhPVUdIX1NUQU5EQVJEAElOUEFJTlRfTlMASU5QQUlOVF9URUxFQQBJTlRFUlNFQ1RfRlVMTABJTlRFUlNFQ1RfTk9ORQBJTlRFUlNFQ1RfUEFSVElBTABJTlRFUl9BUkVBAElOVEVSX0JJVFMASU5URVJfQklUUzIASU5URVJfQ1VCSUMASU5URVJfTEFOQ1pPUzQASU5URVJfTElORUFSAElOVEVSX0xJTkVBUl9FWEFDVABJTlRFUl9NQVgASU5URVJfTkVBUkVTVABJTlRFUl9ORUFSRVNUX0VYQUNUAElOVEVSX1RBQl9TSVpFAElOVEVSX1RBQl9TSVpFMgBLQVpFX0RJRkZfQ0hBUkJPTk5JRVIAS0FaRV9ESUZGX1BNX0cxAEtBWkVfRElGRl9QTV9HMgBLQVpFX0RJRkZfV0VJQ0tFUlQAS01FQU5TX1BQX0NFTlRFUlMAS01FQU5TX1JBTkRPTV9DRU5URVJTAEtNRUFOU19VU0VfSU5JVElBTF9MQUJFTFMATERSX1NJWkUATElORV80AExJTkVfOABMSU5FX0FBAExNRURTAExPQ0FMX09QVElNX0dDAExPQ0FMX09QVElNX0lOTkVSX0FORF9JVEVSX0xPAExPQ0FMX09QVElNX0lOTkVSX0xPAExPQ0FMX09QVElNX05VTEwATE9DQUxfT1BUSU1fU0lHTUEATFNEX1JFRklORV9BRFYATFNEX1JFRklORV9OT05FAExTRF9SRUZJTkVfU1REAE1BUktFUl9DUk9TUwBNQVJLRVJfRElBTU9ORABNQVJLRVJfU1FVQVJFAE1BUktFUl9TVEFSAE1BUktFUl9USUxURURfQ1JPU1MATUFSS0VSX1RSSUFOR0xFX0RPV04ATUFSS0VSX1RSSUFOR0xFX1VQAE1JWEVEX0NMT05FAE1PTk9DSFJPTUVfVFJBTlNGRVIATU9SUEhfQkxBQ0tIQVQATU9SUEhfQ0xPU0UATU9SUEhfQ1JPU1MATU9SUEhfRElMQVRFAE1PUlBIX0VMTElQU0UATU9SUEhfRVJPREUATU9SUEhfR1JBRElFTlQATU9SUEhfSElUTUlTUwBNT1JQSF9PUEVOAE1PUlBIX1JFQ1QATU9SUEhfVE9QSEFUAE1PVElPTl9BRkZJTkUATU9USU9OX0VVQ0xJREVBTgBNT1RJT05fSE9NT0dSQVBIWQBNT1RJT05fVFJBTlNMQVRJT04ATWF0X0FVVE9fU1RFUABNYXRfQ09OVElOVU9VU19GTEFHAE1hdF9ERVBUSF9NQVNLAE1hdF9NQUdJQ19NQVNLAE1hdF9NQUdJQ19WQUwATWF0X1NVQk1BVFJJWF9GTEFHAE1hdF9UWVBFX01BU0sATkVJR0hfRkxBTk5fS05OAE5FSUdIX0ZMQU5OX1JBRElVUwBORUlHSF9HUklEAE5PUk1BTF9DTE9ORQBOT1JNQ09OVl9GSUxURVIATk9STV9IQU1NSU5HAE5PUk1fSEFNTUlORzIATk9STV9JTkYATk9STV9MMQBOT1JNX0wyAE5PUk1fTDJTUVIATk9STV9NSU5NQVgATk9STV9SRUxBVElWRQBOT1JNX1RZUEVfTUFTSwBPUFRGTE9XX0ZBUk5FQkFDS19HQVVTU0lBTgBPUFRGTE9XX0xLX0dFVF9NSU5fRUlHRU5WQUxTAE9QVEZMT1dfVVNFX0lOSVRJQUxfRkxPVwBPUkJfRkFTVF9TQ09SRQBPUkJfSEFSUklTX1NDT1JFAFBDQV9EQVRBX0FTX0NPTABQQ0FfREFUQV9BU19ST1cAUENBX1VTRV9BVkcAUFJPSl9TUEhFUklDQUxfRVFSRUNUAFBST0pfU1BIRVJJQ0FMX09SVEhPAFBhcmFtX0FMR09SSVRITQBQYXJhbV9CT09MRUFOAFBhcmFtX0ZMT0FUAFBhcmFtX0lOVABQYXJhbV9NQVQAUGFyYW1fTUFUX1ZFQ1RPUgBQYXJhbV9SRUFMAFBhcmFtX1NDQUxBUgBQYXJhbV9TVFJJTkcAUGFyYW1fVUNIQVIAUGFyYW1fVUlOVDY0AFBhcmFtX1VOU0lHTkVEX0lOVABRUkNvZGVFbmNvZGVyX0NPUlJFQ1RfTEVWRUxfSABRUkNvZGVFbmNvZGVyX0NPUlJFQ1RfTEVWRUxfTABRUkNvZGVFbmNvZGVyX0NPUlJFQ1RfTEVWRUxfTQBRUkNvZGVFbmNvZGVyX0NPUlJFQ1RfTEVWRUxfUQBRUkNvZGVFbmNvZGVyX0VDSV9VVEY4AFFSQ29kZUVuY29kZXJfTU9ERV9BTFBIQU5VTUVSSUMAUVJDb2RlRW5jb2Rlcl9NT0RFX0FVVE8AUVJDb2RlRW5jb2Rlcl9NT0RFX0JZVEUAUVJDb2RlRW5jb2Rlcl9NT0RFX0VDSQBRUkNvZGVFbmNvZGVyX01PREVfS0FOSkkAUVJDb2RlRW5jb2Rlcl9NT0RFX05VTUVSSUMAUVJDb2RlRW5jb2Rlcl9NT0RFX1NUUlVDVFVSRURfQVBQRU5EAFFVQVRfQVNTVU1FX05PVF9VTklUAFFVQVRfQVNTVU1FX1VOSVQAUXVhdEVudW1fRVVMRVJfQU5HTEVTX01BWF9WQUxVRQBRdWF0RW51bV9FWFRfWFlYAFF1YXRFbnVtX0VYVF9YWVoAUXVhdEVudW1fRVhUX1haWABRdWF0RW51bV9FWFRfWFpZAFF1YXRFbnVtX0VYVF9ZWFkAUXVhdEVudW1fRVhUX1lYWgBRdWF0RW51bV9FWFRfWVpYAFF1YXRFbnVtX0VYVF9ZWlkAUXVhdEVudW1fRVhUX1pYWQBRdWF0RW51bV9FWFRfWlhaAFF1YXRFbnVtX0VYVF9aWVgAUXVhdEVudW1fRVhUX1pZWgBRdWF0RW51bV9JTlRfWFlYAFF1YXRFbnVtX0lOVF9YWVoAUXVhdEVudW1fSU5UX1haWABRdWF0RW51bV9JTlRfWFpZAFF1YXRFbnVtX0lOVF9ZWFkAUXVhdEVudW1fSU5UX1lYWgBRdWF0RW51bV9JTlRfWVpYAFF1YXRFbnVtX0lOVF9ZWlkAUXVhdEVudW1fSU5UX1pYWQBRdWF0RW51bV9JTlRfWlhaAFF1YXRFbnVtX0lOVF9aWVgAUXVhdEVudW1fSU5UX1pZWgBSQU5TQUMAUkVDVVJTX0ZJTFRFUgBSRURVQ0VfQVZHAFJFRFVDRV9NQVgAUkVEVUNFX01JTgBSRURVQ0VfU1VNAFJFVFJfQ0NPTVAAUkVUUl9FWFRFUk5BTABSRVRSX0ZMT09ERklMTABSRVRSX0xJU1QAUkVUUl9UUkVFAFJITwBSTkdfTk9STUFMAFJOR19VTklGT1JNAFJPVEFURV8xODAAUk9UQVRFXzkwX0NMT0NLV0lTRQBST1RBVEVfOTBfQ09VTlRFUkNMT0NLV0lTRQBTQU1QTElOR19OQVBTQUMAU0FNUExJTkdfUFJPR1JFU1NJVkVfTkFQU0FDAFNBTVBMSU5HX1BST1NBQwBTQU1QTElOR19VTklGT1JNAFNDT1JFX01FVEhPRF9MTUVEUwBTQ09SRV9NRVRIT0RfTUFHU0FDAFNDT1JFX01FVEhPRF9NU0FDAFNDT1JFX01FVEhPRF9SQU5TQUMAU09MVkVMUF9NVUxUSQBTT0xWRUxQX1NJTkdMRQBTT0xWRUxQX1VOQk9VTkRFRABTT0xWRUxQX1VORkVBU0lCTEUAU09MVkVQTlBfQVAzUABTT0xWRVBOUF9ETFMAU09MVkVQTlBfRVBOUABTT0xWRVBOUF9JUFBFAFNPTFZFUE5QX0lQUEVfU1FVQVJFAFNPTFZFUE5QX0lURVJBVElWRQBTT0xWRVBOUF9NQVhfQ09VTlQAU09MVkVQTlBfUDNQAFNPTFZFUE5QX1NRUE5QAFNPTFZFUE5QX1VQTlAAU09SVF9BU0NFTkRJTkcAU09SVF9ERVNDRU5ESU5HAFNPUlRfRVZFUllfQ09MVU1OAFNPUlRfRVZFUllfUk9XAFNWRF9GVUxMX1VWAFNWRF9NT0RJRllfQQBTVkRfTk9fVVYAU3BhcnNlTWF0X0hBU0hfQklUAFNwYXJzZU1hdF9IQVNIX1NDQUxFAFNwYXJzZU1hdF9NQUdJQ19WQUwAU3BhcnNlTWF0X01BWF9ESU0AU3RlcmVvQk1fUFJFRklMVEVSX05PUk1BTElaRURfUkVTUE9OU0UAU3RlcmVvQk1fUFJFRklMVEVSX1hTT0JFTABTdGVyZW9NYXRjaGVyX0RJU1BfU0NBTEUAU3RlcmVvTWF0Y2hlcl9ESVNQX1NISUZUAFN0ZXJlb1NHQk1fTU9ERV9ISABTdGVyZW9TR0JNX01PREVfSEg0AFN0ZXJlb1NHQk1fTU9ERV9TR0JNAFN0ZXJlb1NHQk1fTU9ERV9TR0JNXzNXQVkAU3ViZGl2MkRfTkVYVF9BUk9VTkRfRFNUAFN1YmRpdjJEX05FWFRfQVJPVU5EX0xFRlQAU3ViZGl2MkRfTkVYVF9BUk9VTkRfT1JHAFN1YmRpdjJEX05FWFRfQVJPVU5EX1JJR0hUAFN1YmRpdjJEX1BSRVZfQVJPVU5EX0RTVABTdWJkaXYyRF9QUkVWX0FST1VORF9MRUZUAFN1YmRpdjJEX1BSRVZfQVJPVU5EX09SRwBTdWJkaXYyRF9QUkVWX0FST1VORF9SSUdIVABTdWJkaXYyRF9QVExPQ19FUlJPUgBTdWJkaXYyRF9QVExPQ19JTlNJREUAU3ViZGl2MkRfUFRMT0NfT05fRURHRQBTdWJkaXYyRF9QVExPQ19PVVRTSURFX1JFQ1QAU3ViZGl2MkRfUFRMT0NfVkVSVEVYAFRIUkVTSF9CSU5BUlkAVEhSRVNIX0JJTkFSWV9JTlYAVEhSRVNIX01BU0sAVEhSRVNIX09UU1UAVEhSRVNIX1RPWkVSTwBUSFJFU0hfVE9aRVJPX0lOVgBUSFJFU0hfVFJJQU5HTEUAVEhSRVNIX1RSVU5DAFRNX0NDT0VGRgBUTV9DQ09FRkZfTk9STUVEAFRNX0NDT1JSAFRNX0NDT1JSX05PUk1FRABUTV9TUURJRkYAVE1fU1FESUZGX05PUk1FRABUZXJtQ3JpdGVyaWFfQ09VTlQAVGVybUNyaXRlcmlhX0VQUwBUZXJtQ3JpdGVyaWFfTUFYX0lURVIAVU1hdERhdGFfQVNZTkNfQ0xFQU5VUABVTWF0RGF0YV9DT1BZX09OX01BUABVTWF0RGF0YV9ERVZJQ0VfQ09QWV9PQlNPTEVURQBVTWF0RGF0YV9ERVZJQ0VfTUVNX01BUFBFRABVTWF0RGF0YV9IT1NUX0NPUFlfT0JTT0xFVEUAVU1hdERhdGFfVEVNUF9DT1BJRURfVU1BVABVTWF0RGF0YV9URU1QX1VNQVQAVU1hdERhdGFfVVNFUl9BTExPQ0FURUQAVU1hdF9BVVRPX1NURVAAVU1hdF9DT05USU5VT1VTX0ZMQUcAVU1hdF9ERVBUSF9NQVNLAFVNYXRfTUFHSUNfTUFTSwBVTWF0X01BR0lDX1ZBTABVTWF0X1NVQk1BVFJJWF9GTEFHAFVNYXRfVFlQRV9NQVNLAFVTQUNfQUNDVVJBVEUAVVNBQ19ERUZBVUxUAFVTQUNfRkFTVABVU0FDX0ZNXzhQVFMAVVNBQ19NQUdTQUMAVVNBQ19QQVJBTExFTABVU0FDX1BST1NBQwBVU0FHRV9BTExPQ0FURV9ERVZJQ0VfTUVNT1JZAFVTQUdFX0FMTE9DQVRFX0hPU1RfTUVNT1JZAFVTQUdFX0FMTE9DQVRFX1NIQVJFRF9NRU1PUlkAVVNBR0VfREVGQVVMVABXQVJQX0ZJTExfT1VUTElFUlMAV0FSUF9JTlZFUlNFX01BUABXQVJQX1BPTEFSX0xJTkVBUgBXQVJQX1BPTEFSX0xPRwBfSW5wdXRBcnJheV9DVURBX0dQVV9NQVQAX0lucHV0QXJyYXlfQ1VEQV9IT1NUX01FTQBfSW5wdXRBcnJheV9FWFBSAF9JbnB1dEFycmF5X0ZJWEVEX1NJWkUAX0lucHV0QXJyYXlfRklYRURfVFlQRQBfSW5wdXRBcnJheV9LSU5EX01BU0sAX0lucHV0QXJyYXlfS0lORF9TSElGVABfSW5wdXRBcnJheV9NQVQAX0lucHV0QXJyYXlfTUFUWABfSW5wdXRBcnJheV9OT05FAF9JbnB1dEFycmF5X09QRU5HTF9CVUZGRVIAX0lucHV0QXJyYXlfU1REX0FSUkFZAF9JbnB1dEFycmF5X1NURF9BUlJBWV9NQVQAX0lucHV0QXJyYXlfU1REX0JPT0xfVkVDVE9SAF9JbnB1dEFycmF5X1NURF9WRUNUT1IAX0lucHV0QXJyYXlfU1REX1ZFQ1RPUl9DVURBX0dQVV9NQVQAX0lucHV0QXJyYXlfU1REX1ZFQ1RPUl9NQVQAX0lucHV0QXJyYXlfU1REX1ZFQ1RPUl9VTUFUAF9JbnB1dEFycmF5X1NURF9WRUNUT1JfVkVDVE9SAF9JbnB1dEFycmF5X1VNQVQAX091dHB1dEFycmF5X0RFUFRIX01BU0tfMTZGAF9PdXRwdXRBcnJheV9ERVBUSF9NQVNLXzE2UwBfT3V0cHV0QXJyYXlfREVQVEhfTUFTS18xNlUAX091dHB1dEFycmF5X0RFUFRIX01BU0tfMzJGAF9PdXRwdXRBcnJheV9ERVBUSF9NQVNLXzMyUwBfT3V0cHV0QXJyYXlfREVQVEhfTUFTS182NEYAX091dHB1dEFycmF5X0RFUFRIX01BU0tfOFMAX091dHB1dEFycmF5X0RFUFRIX01BU0tfOFUAX091dHB1dEFycmF5X0RFUFRIX01BU0tfQUxMAF9PdXRwdXRBcnJheV9ERVBUSF9NQVNLX0FMTF8xNkYAX091dHB1dEFycmF5X0RFUFRIX01BU0tfQUxMX0JVVF84UwBfT3V0cHV0QXJyYXlfREVQVEhfTUFTS19GTFQAX19VTUFUX1VTQUdFX0ZMQUdTXzMyQklUAEJhZEFsaWduAEJhZEFscGhhQ2hhbm5lbABCYWRDT0kAQmFkQ2FsbEJhY2sAQmFkRGF0YVB0cgBCYWREZXB0aABCYWRJbWFnZVNpemUAQmFkTW9kZWxPckNoU2VxAEJhZE51bUNoYW5uZWwxVQBCYWROdW1DaGFubmVscwBCYWRPZmZzZXQAQmFkT3JkZXIAQmFkT3JpZ2luAEJhZFJPSVNpemUAQmFkU3RlcABCYWRUaWxlU2l6ZQBHcHVBcGlDYWxsRXJyb3IAR3B1Tm90U3VwcG9ydGVkAEhlYWRlcklzTnVsbABNYXNrSXNUaWxlZABPcGVuQ0xBcGlDYWxsRXJyb3IAT3BlbkNMRG91YmxlTm90U3VwcG9ydGVkAE9wZW5DTEluaXRFcnJvcgBPcGVuQ0xOb0FNREJsYXNGZnQAT3BlbkdsQXBpQ2FsbEVycm9yAE9wZW5HbE5vdFN1cHBvcnRlZABTdHNBc3NlcnQAU3RzQXV0b1RyYWNlAFN0c0JhY2tUcmFjZQBTdHNCYWRBcmcAU3RzQmFkRmxhZwBTdHNCYWRGdW5jAFN0c0JhZE1hc2sAU3RzQmFkTWVtQmxvY2sAU3RzQmFkUG9pbnQAU3RzQmFkU2l6ZQBTdHNEaXZCeVplcm8AU3RzRXJyb3IAU3RzRmlsdGVyT2Zmc2V0RXJyAFN0c0ZpbHRlclN0cnVjdENvbnRlbnRFcnIAU3RzSW5wbGFjZU5vdFN1cHBvcnRlZABTdHNJbnRlcm5hbABTdHNLZXJuZWxTdHJ1Y3RDb250ZW50RXJyAFN0c05vQ29udgBTdHNOb01lbQBTdHNOb3RJbXBsZW1lbnRlZABTdHNOdWxsUHRyAFN0c09iamVjdE5vdEZvdW5kAFN0c09rAFN0c091dE9mUmFuZ2UAU3RzUGFyc2VFcnJvcgBTdHNVbm1hdGNoZWRGb3JtYXRzAFN0c1VubWF0Y2hlZFNpemVzAFN0c1Vuc3VwcG9ydGVkRm9ybWF0AFN0c1ZlY0xlbmd0aEVycgBURVNUX0NVU1RPTQBURVNUX0VRAFRFU1RfR0UAVEVTVF9HVABURVNUX0xFAFRFU1RfTFQAVEVTVF9ORQBUcmFja2VyU2FtcGxlckNTQ19NT0RFX0RFVEVDVABUcmFja2VyU2FtcGxlckNTQ19NT0RFX0lOSVRfTkVHAFRyYWNrZXJTYW1wbGVyQ1NDX01PREVfSU5JVF9QT1MAVHJhY2tlclNhbXBsZXJDU0NfTU9ERV9UUkFDS19ORUcAVHJhY2tlclNhbXBsZXJDU0NfTU9ERV9UUkFDS19QT1MARE5OX0JBQ0tFTkRfQ1VEQQBETk5fQkFDS0VORF9ERUZBVUxUAEROTl9CQUNLRU5EX0hBTElERQBETk5fQkFDS0VORF9JTkZFUkVOQ0VfRU5HSU5FAEROTl9CQUNLRU5EX09QRU5DVgBETk5fQkFDS0VORF9WS0NPTQBETk5fQkFDS0VORF9XRUJOTgBETk5fVEFSR0VUX0NQVQBETk5fVEFSR0VUX0NVREEARE5OX1RBUkdFVF9DVURBX0ZQMTYARE5OX1RBUkdFVF9GUEdBAEROTl9UQVJHRVRfSERETABETk5fVEFSR0VUX01ZUklBRABETk5fVEFSR0VUX09QRU5DTABETk5fVEFSR0VUX09QRU5DTF9GUDE2AEROTl9UQVJHRVRfVlVMS0FOAFNvZnROTVNNZXRob2RfU09GVE5NU19HQVVTU0lBTgBTb2Z0Tk1TTWV0aG9kX1NPRlROTVNfTElORUFSAENBTElCX0NIRUNLX0NPTkQAQ0FMSUJfRklYX1NLRVcAQ0FMSUJfUkVDT01QVVRFX0VYVFJJTlNJQwBFTlVNX0xPR19MRVZFTF9GT1JDRV9JTlQATE9HX0xFVkVMX0RFQlVHAExPR19MRVZFTF9FUlJPUgBMT0dfTEVWRUxfRkFUQUwATE9HX0xFVkVMX0lORk8ATE9HX0xFVkVMX1NJTEVOVABMT0dfTEVWRUxfVkVSQk9TRQBMT0dfTEVWRUxfV0FSTklORwAAHGkCAHxpAgAcaQIAoGkCABxpAgDoSAAATjJjdjZQb2ludF9JZkVFABRqAgDYSAAAHGkCAAxJAABOMmN2MTFSb3RhdGVkUmVjdEUAABRqAgD4SAAAHGkCACxJAABOMmN2NVJlY3RfSWlFRQAAFGoCABxJAAAcaQIAfGkCABxpAgA0aQIAcHVzaF9iYWNrAHJlc2l6ZQBnZXQAc2V0AGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUATlN0M19fMjZ2ZWN0b3JJaU5TXzlhbGxvY2F0b3JJaUVFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlpTlNfOWFsbG9jYXRvcklpRUVFRQBOU3QzX18yMjBfX3ZlY3Rvcl9iYXNlX2NvbW1vbklMYjFFRUUAAAAUagIA8UkAAJhqAgDFSQAAAAAAAAEAAAAYSgAAAAAAAJhqAgChSQAAAAAAAAEAAAAgSgAAAAAAAFBOU3QzX18yNnZlY3RvcklpTlNfOWFsbG9jYXRvcklpRUVFRQAAAAD0agIAUEoAAAAAAAA4SgAAUEtOU3QzX18yNnZlY3RvcklpTlNfOWFsbG9jYXRvcklpRUVFRQAAAPRqAgCISgAAAQAAADhKAABpaQB2AHZpAHhKAAAcaQIAeEoAAHxpAgB2aWlpAAAAABxpAgB4SgAAoGkCAHxpAgB2aWlpaQAAAKBpAgCwSgAAaWlpACRLAAA4SgAAoGkCAE4xMGVtc2NyaXB0ZW4zdmFsRQAAFGoCABBLAABpaWlpAEHAlgELswg0aQIAOEoAAKBpAgB8aQIAaWlpaWkATlN0M19fMjZ2ZWN0b3JJZk5TXzlhbGxvY2F0b3JJZkVFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlmTlNfOWFsbG9jYXRvcklmRUVFRQAAAJhqAgB6SwAAAAAAAAEAAAAYSgAAAAAAAJhqAgBWSwAAAAAAAAEAAACoSwAAAAAAAFBOU3QzX18yNnZlY3RvcklmTlNfOWFsbG9jYXRvcklmRUVFRQAAAAD0agIA2EsAAAAAAADASwAAUEtOU3QzX18yNnZlY3RvcklmTlNfOWFsbG9jYXRvcklmRUVFRQAAAPRqAgAQTAAAAQAAAMBLAAAATAAAHGkCAABMAACsaQIAdmlpZgAAAAAcaQIAAEwAAKBpAgCsaQIAdmlpaWYAAACgaQIAOEwAACRLAADASwAAoGkCAAAAAAA0aQIAwEsAAKBpAgCsaQIAaWlpaWYATlN0M19fMjZ2ZWN0b3JJZE5TXzlhbGxvY2F0b3JJZEVFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlkTlNfOWFsbG9jYXRvcklkRUVFRQAAAJhqAgDKTAAAAAAAAAEAAAAYSgAAAAAAAJhqAgCmTAAAAAAAAAEAAAD4TAAAAAAAAFBOU3QzX18yNnZlY3RvcklkTlNfOWFsbG9jYXRvcklkRUVFRQAAAAD0agIAKE0AAAAAAAAQTQAAUEtOU3QzX18yNnZlY3RvcklkTlNfOWFsbG9jYXRvcklkRUVFRQAAAPRqAgBgTQAAAQAAABBNAABQTQAAHGkCAFBNAAC4aQIAdmlpZAAAAAAcaQIAUE0AAKBpAgC4aQIAdmlpaWQAAACgaQIAiE0AACRLAAAQTQAAoGkCAAAAAAA0aQIAEE0AAKBpAgC4aQIAaWlpaWQATlN0M19fMjZ2ZWN0b3JJTjJjdjZQb2ludF9JaUVFTlNfOWFsbG9jYXRvcklTM19FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTjJjdjZQb2ludF9JaUVFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAmGoCACpOAAAAAAAAAQAAABhKAAAAAAAAmGoCAPZNAAAAAAAAAQAAAGhOAAAAAAAAUE5TdDNfXzI2dmVjdG9ySU4yY3Y2UG9pbnRfSWlFRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAAAD0agIAmE4AAAAAAACATgAAUEtOU3QzX18yNnZlY3RvcklOMmN2NlBvaW50X0lpRUVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAD0agIA4E4AAAEAAACATgAA0E4AABxpAgDQTgAASE8AAE4yY3Y2UG9pbnRfSWlFRQAUagIAOE8AABxpAgDQTgAAoGkCAEhPAACgaQIAGE8AACRLAACATgAAoGkCAEGAnwELxgI0aQIAgE4AAKBpAgBITwAATlN0M19fMjZ2ZWN0b3JJTjJjdjNNYXRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTjJjdjNNYXRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAJhqAgC+TwAAAAAAAAEAAAAYSgAAAAAAAJhqAgCQTwAAAAAAAAEAAAD0TwAAAAAAAFBOU3QzX18yNnZlY3RvcklOMmN2M01hdEVOU185YWxsb2NhdG9ySVMyX0VFRUUAAPRqAgAkUAAAAAAAAAxQAABQS05TdDNfXzI2dmVjdG9ySU4yY3YzTWF0RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQD0agIAZFAAAAEAAAAMUAAAVFAAABxpAgBUUAAAwFAAAE4yY3YzTWF0RQAAABRqAgC0UABB0KEBCyMcaQIAVFAAAKBpAgDAUAAAoGkCAJRQAAAkSwAADFAAAKBpAgBBgKIBC/MCNGkCAAxQAACgaQIAwFAAAE5TdDNfXzI2dmVjdG9ySU4yY3Y1UmVjdF9JaUVFTlNfOWFsbG9jYXRvcklTM19FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTjJjdjVSZWN0X0lpRUVOU185YWxsb2NhdG9ySVMzX0VFRUUAAACYagIAQ1EAAAAAAAABAAAAGEoAAAAAAACYagIAEFEAAAAAAAABAAAAgFEAAAAAAABQTlN0M19fMjZ2ZWN0b3JJTjJjdjVSZWN0X0lpRUVOU185YWxsb2NhdG9ySVMzX0VFRUUA9GoCALBRAAAAAAAAmFEAAFBLTlN0M19fMjZ2ZWN0b3JJTjJjdjVSZWN0X0lpRUVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAA9GoCAPRRAAABAAAAmFEAAORRAAAcaQIA5FEAACxJAAAAAAAAHGkCAORRAACgaQIALEkAAKBpAgAsUgAAJEsAAJhRAACgaQIAQYClAQviAjRpAgCYUQAAoGkCACxJAABOU3QzX18yNnZlY3RvcklOMmN2OEtleVBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSU4yY3Y4S2V5UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAmGoCAMNSAAAAAAAAAQAAABhKAAAAAAAAmGoCAJBSAAAAAAAAAQAAAABTAAAAAAAAUE5TdDNfXzI2dmVjdG9ySU4yY3Y4S2V5UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAPRqAgAwUwAAAAAAABhTAABQS05TdDNfXzI2dmVjdG9ySU4yY3Y4S2V5UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAAPRqAgB0UwAAAQAAABhTAABkUwAAHGkCAGRTAADcUwAATjJjdjhLZXlQb2ludEUAABRqAgDMUwBB8KcBCyMcaQIAZFMAAKBpAgDcUwAAoGkCAKxTAAAkSwAAGFMAAKBpAgBBoKgBC4MDNGkCABhTAACgaQIA3FMAAE5TdDNfXzI2dmVjdG9ySU4yY3Y2RE1hdGNoRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSU4yY3Y2RE1hdGNoRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAAJhqAgBhVAAAAAAAAAEAAAAYSgAAAAAAAJhqAgAwVAAAAAAAAAEAAACcVAAAAAAAAFBOU3QzX18yNnZlY3RvcklOMmN2NkRNYXRjaEVOU185YWxsb2NhdG9ySVMyX0VFRUUAAAD0agIAzFQAAAAAAAC0VAAAUEtOU3QzX18yNnZlY3RvcklOMmN2NkRNYXRjaEVO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Yy9tb2R1bGVzL2NvcmUvc3JjL2FsbG9jLmNwcAAvc3JjL21vZHVsZXMvY29yZS9zcmMvYXJyYXkuY3BwAE5vbi1wb3NpdGl2ZSB3aWR0aCBvciBoZWlnaHQAY3ZDcmVhdGVNYXRIZWFkZXIASW52YWxpZCBtYXRyaXggdHlwZQAAY3ZJbml0TWF0SGVhZGVyAE5vbi1wb3NpdGl2ZSBjb2xzIG9yIHJvd3MAY3ZSZWxlYXNlTWF0AEJhZCBDdk1hdCBoZWFkZXIAY3ZDbG9uZU1hdABJbnZhbGlkIHNwYXJzZSBtYXRyaXggaGVhZGVyAGN2SW5pdFNwYXJzZU1hdEl0ZXJhdG9yAE5VTEwgaXRlcmF0b3IgcG9pbnRlcgBEYXRhIGlzIGFscmVhZHkgYWxsb2NhdGVkAGN2Q3JlYXRlRGF0YQBUb28gYmlnIGJ1ZmZlciBpcyBhbGxvY2F0ZWQAT3ZlcmZsb3cgZm9yIGltYWdlU2l6ZQB1bnJlY29nbml6ZWQgb3IgdW5zdXBwb3J0ZWQgYXJyYXkgdHlwZQBPbmx5IGNvbnRpbnVvdXMgbkQgYXJyYXlzIGFyZSBzdXBwb3J0ZWQgaGVyZQBjdkdldENvbHMATlVMTCBhcnJheSBwb2ludGVyIGlzIHBhc3NlZABjdkdldE1hdABUaGUgbWF0cml4IGhhcyBOVUxMIGRhdGEgcG9pbnRlcgBUaGUgaW1hZ2UgaGFzIE5VTEwgZGF0YSBwb2ludGVyAEltYWdlcyB3aXRoIHBsYW5hciBkYXRhIGxheW91dCBzaG91bGQgYmUgdXNlZCB3aXRoIENPSSBzZWxlY3RlZABUaGUgaW1hZ2UgaXMgaW50ZXJsZWF2ZWQgYW5kIGhhcyBvdmVyIENWX0NOX01BWCBjaGFubmVscwBQaXhlbCBvcmRlciBzaG91bGQgYmUgdXNlZCB3aXRoIGNvaSA9PSAwAElucHV0IGFycmF5IGhhcyBOVUxMIGRhdGEgcG9pbnRlcgBVbnJlY29nbml6ZWQgb3IgdW5zdXBwb3J0ZWQgYXJyYXkgdHlwZQBUaGUgdG90YWwgbnVtYmVyIG9mIG1hdHJpeCBlbGVtZW50cyBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBuZXcgbnVtYmVyIG9mIHJvd3MAY3ZSZXNoYXBlAENPSSBpcyBub3Qgc3VwcG9ydGVkAFRoZSBtYXRyaXggaXMgbm90IGNvbnRpbnVvdXMsIHRodXMgaXRzIG51bWJlciBvZiByb3dzIGNhbiBub3QgYmUgY2hhbmdlZABCYWQgbmV3IG51bWJlciBvZiByb3dzAFRoZSB0b3RhbCB3aWR0aCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBuZXcgbnVtYmVyIG9mIGNoYW5uZWxzAGN2R2V0SW1hZ2VDT0kAc3JjICYmIG5zcmNzID4gMCAmJiBkc3QgJiYgbmRzdHMgPiAwICYmIGZyb21UbyAmJiBucGFpcnMgPiAwAG1peENoYW5uZWxzAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9jaGFubmVscy5jcHAAaiA8IG5zcmNzICYmIHNyY1tqXS5kZXB0aCgpID09IGRlcHRoAGkxID49IDAgJiYgaiA8IG5kc3RzICYmIGRzdFtqXS5kZXB0aCgpID09IGRlcHRoAEGQ2AELmiFDAgAAQwIAAEQCAABEAgAARQIAAEUCAABGAgAAAAAAAGNuIDw9IDQAc2NhbGFyVG9SYXdEYXRhAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9jb3B5LmNwcAAAY3Z0Rm4AY29udmVydEFuZFVucm9sbFNjYWxhcgBzY24gPT0gMQBjaGFubmVscygpID09IENWX01BVF9DTihkdHlwZSkAY29weVRvAGRzdC51ICE9IE5VTEwAZGltcyA+IDAgJiYgZGltcyA8IENWX01BWF9ESU0A/GwAAEhsAABmAQAABQAAAGdsAAAobQAAMW0AAHZvaWQgY3Y6Ok1hdDo6Y29weVRvKGN2OjpPdXRwdXRBcnJheSkgY29uc3QAc3oud2lkdGgAMABtYXNrLmRlcHRoKCkgPT0gQ1ZfOFUgJiYgKG1jbiA9PSAxIHx8IG1jbiA9PSBjbikAc2l6ZSgpID09IG1hc2suc2l6ZSgpAHN6IDw9IHNpemVvZihzY2FsYXIpAG9wZXJhdG9yPQBjaGVja1NjYWxhcih2YWx1ZSwgdHlwZSgpLCBfdmFsdWUua2luZCgpLCBfSW5wdXRBcnJheTo6TUFUICkAc2V0VG8AbWFzay5lbXB0eSgpIHx8IChtYXNrLmRlcHRoKCkgPT0gQ1ZfOFUgJiYgKG1jbiA9PSAxIHx8IG1jbiA9PSBjbikgJiYgc2l6ZSA9PSBtYXNrLnNpemUpAF9zcmMuZ2V0T2JqKCkgIT0gX2RzdC5nZXRPYmooKQByZXBlYXQAX3NyYy5kaW1zKCkgPD0gMgBueSA+IDAgJiYgbnggPiAwAG1hc2thcnIgPT0gMABjdkNvcHkAc3JjLmRlcHRoKCkgPT0gZHN0LmRlcHRoKCkgJiYgc3JjLnNpemUgPT0gZHN0LnNpemUAKGNvaTEgIT0gMCB8fCBzcmMuY2hhbm5lbHMoKSA9PSAxKSAmJiAoY29pMiAhPSAwIHx8IGRzdC5jaGFubmVscygpID09IDEpAHNyYy5jaGFubmVscygpID09IGRzdC5jaGFubmVscygpAAAvc3JjL21vZHVsZXMvY29yZS9zcmMvZGF0YXN0cnVjdHMuY3BwAGN2UmVzdG9yZU1lbVN0b3JhZ2VQb3MATlVMTCBzdG9yYWdlIHBvaW50ZXIAY3ZNZW1TdG9yYWdlQWxsb2MAVG9vIGxhcmdlIG1lbW9yeSBibG9jayBpcyByZXF1ZXN0ZWQAc3RvcmFnZS0+ZnJlZV9zcGFjZSAlIENWX1NUUlVDVF9BTElHTiA9PSAwAHJlcXVlc3RlZCBzaXplIGlzIG5lZ2F0aXZlIG9yIHRvbyBiaWcAKHNpemVfdClwdHIgJSBDVl9TVFJVQ1RfQUxJR04gPT0gMABjdlNldFNlcUJsb2NrU2l6ZQBTdG9yYWdlIGJsb2NrIHNpemUgaXMgdG9vIHNtYWxsIHRvIGZpdCB0aGUgc2VxdWVuY2UgZWxlbWVudHMAY3ZDdnRTZXFUb0FycmF5AGN2U2V0U2VxUmVhZGVyUG9zAE5VTEwgc2VxdWVuY2UgcG9pbnRlcgBudW1iZXIgb2YgcmVtb3ZlZCBlbGVtZW50cyBpcyBuZWdhdGl2ZQBjdlNlcVBvcE11bHRpAGRlbHRhID4gMABjdkNsZWFyU2VxAGN2U2V0QWRkAGNvdW50IDw9IENWX1NFVF9FTEVNX0lEWF9NQVNLKzEAaWN2R29OZXh0TWVtQmxvY2sAcGFyZW50LT5ib3R0b20gPT0gYmxvY2sAaWN2R3Jvd1NlcQBUaGUgc2VxdWVuY2UgaGFzIE5VTEwgc3RvcmFnZSBwb2ludGVyAHN0b3JhZ2UtPmZyZWVfc3BhY2UgPj0gZGVsdGEAYmxvY2stPmNvdW50ICUgc2VxLT5lbGVtX3NpemUgPT0gMCAmJiBibG9jay0+Y291bnQgPiAwAHNlcS0+Zmlyc3QtPnN0YXJ0X2luZGV4ID09IDAAKGluX2Zyb250X29mID8gYmxvY2sgOiBibG9jay0+cHJldiktPmNvdW50ID09IDAAaWN2RnJlZVNlcUJsb2NrAHNlcS0+cHRyID09IGJsb2NrLT5kYXRhAGJsb2NrLT5jb3VudCA+IDAgJiYgYmxvY2stPmNvdW50ICUgc2VxLT5lbGVtX3NpemUgPT0gMAAvc3JjL21vZHVsZXMvY29yZS9zcmMvbGFwYWNrLmNwcAAhbWF0LmVtcHR5KCkAZGV0ZXJtaW5hbnQAbWF0LnJvd3MgPT0gbWF0LmNvbHMgJiYgKHR5cGUgPT0gQ1ZfMzJGIHx8IHR5cGUgPT0gQ1ZfNjRGKQB0eXBlID09IENWXzMyRiB8fCB0eXBlID09IENWXzY0RgBpbnZlcnQAbSA9PSBuAG1ldGhvZCA9PSBERUNPTVBfTFUgfHwgbWV0aG9kID09IERFQ09NUF9DSE9MRVNLWQBuID09IDEAdHlwZSA9PSBfc3JjMi50eXBlKCkgJiYgKHR5cGUgPT0gQ1ZfMzJGIHx8IHR5cGUgPT0gQ1ZfNjRGKQBzb2x2ZQC4cwAAf3IAAEgEAAAAAAAA/XMAACJ0AAApdAAAYm9vbCBjdjo6c29sdmUoY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXksIGludCkAVW5zdXBwb3J0ZWQgbWV0aG9kLCBzZWUgI0RlY29tcFR5cGVzAG1ldGhvZABtZXRob2QgPT0gREVDT01QX0xVIHx8IG1ldGhvZCA9PSBERUNPTVBfU1ZEIHx8IG1ldGhvZCA9PSBERUNPTVBfRUlHIHx8IG1ldGhvZCA9PSBERUNPTVBfQ0hPTEVTS1kgfHwgbWV0aG9kID09IERFQ09NUF9RUgAobWV0aG9kICE9IERFQ09NUF9MVSAmJiBtZXRob2QgIT0gREVDT01QX0NIT0xFU0tZKSB8fCBpc19ub3JtYWwgfHwgc3JjLnJvd3MgPT0gc3JjLmNvbHMAc3JjLnJvd3MgPT0gMQBUaGUgZnVuY3Rpb24gY2FuIG5vdCBzb2x2ZSB1bmRlci1kZXRlcm1pbmVkIGxpbmVhciBzeXN0ZW1zAHNyYy5yb3dzID09IHNyYy5jb2xzAGVpZ2VuAHcudHlwZSgpID09IHUudHlwZSgpICYmIHUudHlwZSgpID09IHZ0LnR5cGUoKSAmJiB1LmRhdGEgJiYgdnQuZGF0YSAmJiB3LmRhdGEAYmFja1N1YnN0AHUuY29scyA+PSBubSAmJiB2dC5yb3dzID49IG5tICYmICh3LnNpemUoKSA9PSBTaXplKG5tLCAxKSB8fCB3LnNpemUoKSA9PSBTaXplKDEsIG5tKSB8fCB3LnNpemUoKSA9PSBTaXplKHZ0LnJvd3MsIHUuY29scykpAHJocy5kYXRhID09IDAgfHwgKHJocy50eXBlKCkgPT0gdHlwZSAmJiByaHMucm93cyA9PSBtKQAAcm93cyA9PSBtYXQtPmNvbHMAY3ZEZXQAc3JjLnR5cGUoKSA9PSBkc3QudHlwZSgpICYmIHNyYy5yb3dzID09IGRzdC5jb2xzICYmIHNyYy5jb2xzID09IGRzdC5yb3dzAGN2SW52ZXJ0AEEudHlwZSgpID09IHgudHlwZSgpICYmIEEuY29scyA9PSB4LnJvd3MgJiYgeC5jb2xzID09IGIuY29scwBjdlNvbHZlAHcudHlwZSgpID09IHR5cGUgJiYgKHcuc2l6ZSgpID09IGN2OjpTaXplKG5tLDEpIHx8IHcuc2l6ZSgpID09IGN2OjpTaXplKDEsIG5tKSB8fCB3LnNpemUoKSA9PSBjdjo6U2l6ZShubSwgbm0pIHx8IHcuc2l6ZSgpID09IGN2OjpTaXplKG4sIG0pKQBjdlNWRAB1LnR5cGUoKSA9PSB0eXBlAHYudHlwZSgpID09IHR5cGUAdS5zaXplKCkgPT0gc3ZkLnUuc2l6ZSgpAHYuc2l6ZSgpID09IHN2ZC52dC5zaXplKCkAX1NWRGNvbXB1dGUAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL2FyaXRobS5zaW1kLmhwcABjbXBvcCA9PSBDTVBfTkUAY21wX2xvb3Bfbm9zaW1kAGNtcF9sb29wAG9wID09IENNUF9MVCB8fCBvcCA9PSBDTVBfTEUgfHwgb3AgPT0gQ01QX0VRIHx8IG9wID09IENNUF9ORSB8fCBvcCA9PSBDTVBfR0UgfHwgb3AgPT0gQ01QX0dUAGNvbXBhcmUAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL2FyaXRobS5jcHAAX3NyYzEuZW1wdHkoKSA9PSBfc3JjMi5lbXB0eSgpAFRoZSBvcGVyYXRpb24gaXMgbmVpdGhlciAnYXJyYXkgb3AgYXJyYXknICh3aGVyZSBhcnJheXMgaGF2ZSB0aGUgc2FtZSBzaXplIGFuZCB0aGUgc2FtZSB0eXBlKSwgbm9yICdhcnJheSBvcCBzY2FsYXInLCBub3IgJ3NjYWxhciBvcCBhcnJheScAVW5zdXBwb3J0ZWQgZGVwdGggdmFsdWUgQ1ZfMTZGAGZ1bmMAY3Z0Rm4Ac3JjMS5zaXplID09IGRzdC5zaXplICYmIHNyYzEuY2hhbm5lbHMoKSA9PSBkc3QuY2hhbm5lbHMoKQBjdlN1YgBiaW5hcnlfb3AAVGhlIG9wZXJhdGlvbiBpcyBuZWl0aGVyICdhcnJheSBvcCBhcnJheScgKHdoZXJlIGFycmF5cyBoYXZlIHRoZSBzYW1lIHNpemUgYW5kIHR5cGUpLCBub3IgJ2FycmF5IG9wIHNjYWxhcicsIG5vciAnc2NhbGFyIG9wIGFycmF5JwBwc3JjMS0+c2FtZVNpemUoKnBzcmMyKSAmJiB0eXBlMSA9PSB0eXBlMgAobXR5cGUgPT0gQ1ZfOFUgfHwgbXR5cGUgPT0gQ1ZfOFMpICYmIF9tYXNrLnNhbWVTaXplKCpwc3JjMSkAVGhlIG9wZXJhdGlvbiBpcyBuZWl0aGVyICdhcnJheSBvcCBhcnJheScgKHdoZXJlIGFycmF5cyBoYXZlIHRoZSBzYW1lIHNpemUgYW5kIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyksIG5vciAnYXJyYXkgb3Agc2NhbGFyJywgbm9yICdzY2FsYXIgb3AgYXJyYXknAGFyaXRobV9vcAB0eXBlMiA9PSBDVl82NEYgJiYgKHN6Mi5oZWlnaHQgPT0gMSB8fCBzejIuaGVpZ2h0ID09IDQpAFdoZW4gdGhlIGlucHV0IGFycmF5cyBpbiBhZGQvc3VidHJhY3QvbXVsdGlwbHkvZGl2aWRlIGZ1bmN0aW9ucyBoYXZlIGRpZmZlcmVudCB0eXBlcywgdGhlIG91dHB1dCBhcnJheSB0eXBlIG11c3QgYmUgZXhwbGljaXRseSBzcGVjaWZpZWQAKG10eXBlID09IENWXzhVQzEgfHwgbXR5cGUgPT0gQ1ZfOFNDMSkgJiYgX21hc2suc2FtZVNpemUoKnBzcmMxKQCVAgAAlgIAAJcCAACYAgAAmQIAAJoCAACbAgBBvvkBCwJgwABBzvkBCxrgwAAAAAAAAODBAAAA4P//78f////////v/wBB9fkBC9UI4G9AAAAAAADAX0AAAAAA4P/vQAAAAADA/99AAADA////30EAAADg///vR////////+9/AAAAAAAAAAAEAAAAAQAAAAIAAAAwICYmICJOb3Qgc3VwcG9ydGVkIgAvc3JjL21vZHVsZXMvY29yZS9zcmMvbWF0bXVsLnNpbWQuaHBwAGdldFNjYWxlQWRkRnVuYwBmdW5jICYmICJOb3Qgc3VwcG9ydGVkIgBnZXRNdWxUcmFuc3Bvc2VkRnVuYwAvc3JjL21vZHVsZXMvY29yZS9zcmMvbWF0bXVsLmRpc3BhdGNoLmNwcAB0eXBlID09IEIudHlwZSgpAGdlbW0AKHR5cGUgPT0gKCgoNSkgJiAoKDEgPDwgMykgLSAxKSkgKyAoKCgxKS0xKSA8PCAzKSkgfHwgdHlwZSA9PSAoKCg2KSAmICgoMSA8PCAzKSAtIDEpKSArICgoKDEpLTEpIDw8IDMpKSB8fCB0eXBlID09ICgoKDUpICYgKCgxIDw8IDMpIC0gMSkpICsgKCgoMiktMSkgPDwgMykpIHx8IHR5cGUgPT0gKCgoNikgJiAoKDEgPDwgMykgLSAxKSkgKyAoKCgyKS0xKSA8PCAzKSkpAGFfc2l6ZS53aWR0aCA9PSBsZW4AYV9zaXplLmhlaWdodCA9PSBsZW4AQy50eXBlKCkgPT0gdHlwZQAoKChmbGFncyZHRU1NXzNfVCkgPT0gMCAmJiBDLnJvd3MgPT0gZF9zaXplLmhlaWdodCAmJiBDLmNvbHMgPT0gZF9zaXplLndpZHRoKSB8fCAoKGZsYWdzJkdFTU1fM19UKSAhPSAwICYmIEMucm93cyA9PSBkX3NpemUud2lkdGggJiYgQy5jb2xzID09IGRfc2l6ZS5oZWlnaHQpKQB0eXBlID09IENWXzY0RkMyAGZ1bmMgIT0gMAB0eXBlID09IF9zcmMyLnR5cGUoKQBzY2FsZUFkZABzcmMxLnNpemUgPT0gc3JjMi5zaXplAHNyYy5jaGFubmVscygpID09IDEAbXVsVHJhbnNwb3NlZABkZWx0YS5jaGFubmVscygpID09IDEAKGRlbHRhLnJvd3MgPT0gc3JjLnJvd3MgfHwgZGVsdGEucm93cyA9PSAxKQAoZGVsdGEuY29scyA9PSBzcmMuY29scyB8fCBkZWx0YS5jb2xzID09IDEpAABtYXQudHlwZSgpID09IHR5cGUoKQBkb3QAbWF0LnNpemUgPT0gc2l6ZQAoRC5yb3dzID09ICgoZmxhZ3MgJiAxKSA9PSAwID8gQS5yb3dzIDogQS5jb2xzKSkAY3ZHRU1NAChELmNvbHMgPT0gKChmbGFncyAmIDIpID09IDAgPyBCLmNvbHMgOiBCLnJvd3MpKQBELnR5cGUoKSA9PSBBLnR5cGUoKQAAAAAAAAAAvAIAAL0CAAC+AgAAvwIAAMACAADBAgAAwgIAQYCDAguILGdlbW1JbXBsADAAR0VNTV9UcmFuc3Bvc2VCbG9jawBkZWx0YV9jb2xzID09IDEATXVsVHJhbnNwb3NlZFIAc3pbaV0gPD0gKHNpemVfdClJTlRfTUFYAGRvd25sb2FkAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9tYXRyaXguY3BwAHVwbG9hZABjb3B5ADAgPD0gX2RpbXMgJiYgX2RpbXMgPD0gQ1ZfTUFYX0RJTQBzZXRTaXplAHMgPj0gMABTdGVwICV6dSBmb3IgZGltZW5zaW9uICVkIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBlc3oxICV6dQBUaGUgdG90YWwgbWF0cml4IHNpemUgZG9lcyBub3QgZml0IHRvICJzaXplX3QiIHR5cGUAdG90YWwoKSA9PSAwIHx8IGRhdGEgIT0gTlVMTABNYXQAX3N0ZXAgPj0gbWluc3RlcABTdGVwIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBlc3oxAAAAAByDAADggQAA0gEAAAUAAABIgwAASYMAAE+DAABjdjo6TWF0OjpNYXQoY3Y6OlNpemUsIGludCwgdm9pZCAqLCBzaXplX3QpAABfc3RlcABtaW5zdGVwAG0uc3RlcC5wICE9IG0uc3RlcC5idWYAb3BlcmF0b3I9ADAgPD0gZCAmJiBkIDw9IENWX01BWF9ESU0gJiYgX3NpemVzAGNyZWF0ZQB1ICE9IDAAc3RlcFtkaW1zLTFdID09IChzaXplX3QpQ1ZfRUxFTV9TSVpFKGZsYWdzKQBtLmRpbXMgPj0gMgAwIDw9IF9yb3dSYW5nZS5zdGFydCAmJiBfcm93UmFuZ2Uuc3RhcnQgPD0gX3Jvd1JhbmdlLmVuZCAmJiBfcm93UmFuZ2UuZW5kIDw9IG0ucm93cwAwIDw9IF9jb2xSYW5nZS5zdGFydCAmJiBfY29sUmFuZ2Uuc3RhcnQgPD0gX2NvbFJhbmdlLmVuZCAmJiBfY29sUmFuZ2UuZW5kIDw9IG0uY29scwBtLmRpbXMgPD0gMgAwIDw9IHJvaS54ICYmIDAgPD0gcm9pLndpZHRoICYmIHJvaS54ICsgcm9pLndpZHRoIDw9IG0uY29scyAmJiAwIDw9IHJvaS55ICYmIDAgPD0gcm9pLmhlaWdodCAmJiByb2kueSArIHJvaS5oZWlnaHQgPD0gbS5yb3dzAHJhbmdlcwByID09IFJhbmdlOjphbGwoKSB8fCAoMCA8PSByLnN0YXJ0ICYmIHIuc3RhcnQgPCByLmVuZCAmJiByLmVuZCA8PSBtLnNpemVbaV0pAGRpbXMgPD0gMgBkaWFnAGRpbXMgPD0gMiAmJiBzdGVwWzBdID4gMABsb2NhdGVST0kAYWRqdXN0Uk9JAHJlc2hhcGUAVGhlIG1hdHJpeCBpcyBub3QgY29udGludW91cywgdGh1cyBpdHMgbnVtYmVyIG9mIHJvd3MgY2FuIG5vdCBiZSBjaGFuZ2VkAEJhZCBuZXcgbnVtYmVyIG9mIHJvd3MAVGhlIHRvdGFsIG51bWJlciBvZiBtYXRyaXggZWxlbWVudHMgaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgbmV3IG51bWJlciBvZiByb3dzAFRoZSB0b3RhbCB3aWR0aCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBuZXcgbnVtYmVyIG9mIGNoYW5uZWxzAF9jbiA+PSAwICYmIF9uZXduZGltcyA+IDAgJiYgX25ld25kaW1zIDw9IENWX01BWF9ESU0gJiYgX25ld3N6AF9jbiA8PSBDVl9DTl9NQVgAX25ld3N6W2ldID49IDAAQ29weSBkaW1lbnNpb24gKHdoaWNoIGhhcyB6ZXJvIHNpemUpIGlzIG5vdCBwcmVzZW50IGluIHNvdXJjZSBtYXRyaXgAUmVxdWVzdGVkIGFuZCBzb3VyY2UgbWF0cmljZXMgaGF2ZSBkaWZmZXJlbnQgY291bnQgb2YgZWxlbWVudHMAUmVzaGFwaW5nIG9mIG4tZGltZW5zaW9uYWwgbm9uLWNvbnRpbnVvdXMgbWF0cmljZXMgaXMgbm90IHN1cHBvcnRlZCB5ZXQA4IcAAOCBAAAXBQAAAwAAAEiDAAARiAAAGYgAAGN2OjpTaXplIGN2OjpnZXRDb250aW51b3VzU2l6ZTJEKGN2OjpNYXQgJiwgaW50KQBtMS5kaW1zADIAADiIAADggQAAHQUAAAMAAABIgwAAEYgAABmIAABjdjo6U2l6ZSBjdjo6Z2V0Q29udGludW91c1NpemUyRChjdjo6TWF0ICYsIGN2OjpNYXQgJiwgaW50KQA4iAAA4IEAAB4FAAADAAAASIMAAJCIAAAZiAAAbTIuZGltcwA4iAAA4IEAACMFAAABAAAASIMAALSIAAC9iAAAdG90YWxfc3oAbTIudG90YWwoKQBpc19tMV92ZWN0b3IAZ2V0Q29udGludW91c1NpemUyRABpc19tMl92ZWN0b3IAbTEuY29scyA9PSBtMi5jb2xzICYmIG0xLnJvd3MgPT0gbTIucm93cwAAPIkAAOCBAAA3BQAAAwAAAEiDAAARiAAAGYgAAGN2OjpTaXplIGN2OjpnZXRDb250aW51b3VzU2l6ZTJEKGN2OjpNYXQgJiwgY3Y6Ok1hdCAmLCBjdjo6TWF0ICYsIGludCkAADyJAADggQAAOAUAAAMAAABIgwAAkIgAABmIAAA8iQAA4IEAADkFAAADAAAASIMAALyJAAAZiAAAbTMuZGltcwA8iQAA4IEAAD4FAAABAAAASIMAALSIAAC9iAAAPIkAAOCBAAA/BQAAAQAAAEiDAAC0iAAA/IkAAG0zLnRvdGFsKCkAaXNfbTNfdmVjdG9yAG0xLmNvbHMgPT0gbTIuY29scyAmJiBtMS5yb3dzID09IG0yLnJvd3MgJiYgbTEuY29scyA9PSBtMy5jb2xzICYmIG0xLnJvd3MgPT0gbTMucm93cwBOMmN2MTJNYXRBbGxvY2F0b3JFAAAAABRqAgBpigAAAAAAAPCKAADDAgAAxAIAAMUCAADGAgAAxwIAAMgCAABOMmN2MjVEdW1teUJ1ZmZlclBvb2xDb250cm9sbGVyRQBOMmN2MjBCdWZmZXJQb29sQ29udHJvbGxlckUAAAAAFGoCAMmKAAA8agIAqIoAAOiKAAAAAAAASIsAAMkCAADKAgAAywIAAMwCAADNAgAAzgIAAM8CAADQAgAA0QIAANICAADTAgAATjJjdjE1U3RkTWF0QWxsb2NhdG9yRQAAPGoCADCLAACAigAAdG90YWwgPD0gc3RlcFtpXQBhbGxvY2F0ZQB1LT51cmVmY291bnQgPT0gMABkZWFsbG9jYXRlAHUtPnJlZmNvdW50ID09IDAAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL21hdHJpeF9jLmNwcABDT0kgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZnVuY3Rpb24AY3ZhcnJUb01hdAB0b3RhbCA+IDAgJiYgQ1ZfRUxFTV9TSVpFKHNlcS0+ZmxhZ3MpID09IGVzegBVbmtub3duIGFycmF5IHR5cGUAQ1ZfSVNfSU1BR0UoYXJyKQBleHRyYWN0SW1hZ2VDT0kAMCA8PSBjb2kgJiYgY29pIDwgbWF0LmNoYW5uZWxzKCkAc3JjLnJvd3MgPT0gZHN0LmNvbHMgJiYgc3JjLmNvbHMgPT0gZHN0LnJvd3MgJiYgc3JjLnR5cGUoKSA9PSBkc3QudHlwZSgpAGN2VHJhbnNwb3NlAHNyY0Euc2l6ZSgpID09IGRzdC5zaXplKCkgJiYgc3JjQS50eXBlKCkgPT0gZHN0LnR5cGUoKQBjdkNyb3NzUHJvZHVjdABpbWctPmRhdGFPcmRlciA9PSBJUExfREFUQV9PUkRFUl9QSVhFTABpcGxJbWFnZVRvTWF0AGltZy0+ZGF0YU9yZGVyID09IElQTF9EQVRBX09SREVSX1BJWEVMIHx8IGltZy0+cm9pLT5jb2kgIT0gMABnbG9iYWwAJWRAJTAuM2YAJWRAJWxsdQAlZABbRkFUQUw6AF0gAFtFUlJPUjoAWyBXQVJOOgBbIElORk86AFtERUJVRzoAIAAoACkgAE9QRU5DVl9MT0dfTEVWRUwAAE9QRU5DVl9MT0dfVElNRVNUQU1QAE9QRU5D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KXZ2LnNpemUoKQAwIDw9IGkgJiYgaSA8IChpbnQpdi5zaXplKCkAMCA8PSBpICYmIGkgPCBzei5oZWlnaHQAWW91IHNob3VsZCBleHBsaWNpdGx5IGNhbGwgbWFwSG9zdC91bm1hcEhvc3QgbWV0aG9kcyBmb3Igb2dsOjpCdWZmZXIgb2JqZWN0AFlvdSBzaG91bGQgZXhwbGljaXRseSBjYWxsIGRvd25sb2FkIG1ldGhvZCBmb3IgY3VkYTo6R3B1TWF0IG9iamVjdABVbmtub3duL3Vuc3VwcG9ydGVkIGFycmF5IHR5cGUAZ2V0VU1hdABnZXRNYXRWZWN0b3IAZ2V0VU1hdFZlY3RvcgBDVURBIHN1cHBvcnQgaXMgbm90IGVuYWJsZWQgaW4gdGhpcyBPcGVuQ1YgYnVpbGQgKG1pc3NpbmcgSEFWRV9DVURBKQBzaXplAGkgPCAoaW50KXZ2LnNpemUoKQBpIDwgc3ouaGVpZ2h0AHNpemVuZAComgAA0pgAADcCAAADAAAA1poAAOSaAADsmgAAaW50IGN2OjpfSW5wdXRBcnJheTo6c2l6ZW5kKGludCAqLCBpbnQpIGNvbnN0AE5vdCBzdXBwb3J0ZWQAZGltcyhpKQAyAGRpbXMAKGZsYWdzICYgRklYRURfVFlQRSkgIT0gMAB0eXBlAGVtcHR5AGkgPj0gMCAmJiAoc2l6ZV90KWkgPCB2di5zaXplKCkAaXNDb250aW51b3VzAGkgPj0gMCAmJiBpIDwgc3ouaGVpZ2h0AABjb3B5VG8AIWZpeGVkU2l6ZSgpIHx8ICgoTWF0KilvYmopLT5zaXplLm9wZXJhdG9yKCkoKSA9PSBfc3oAY3JlYXRlACFmaXhlZFR5cGUoKSB8fCAoKE1hdCopb2JqKS0+dHlwZSgpID09IG10eXBlACFmaXhlZFNpemUoKSB8fCAoKFVNYXQqKW9iaiktPnNpemUub3BlcmF0b3IoKSgpID09IF9zegAhZml4ZWRUeXBlKCkgfHwgKChVTWF0KilvYmopLT50eXBlKCkgPT0gbXR5cGUAIWZpeGVkU2l6ZSgpIHx8ICgoY3VkYTo6R3B1TWF0KilvYmopLT5zaXplKCkgPT0gX3N6ACFmaXhlZFR5cGUoKSB8fCAoKGN1ZGE6OkdwdU1hdCopb2JqKS0+dHlwZSgpID09IG10eXBlACFmaXhlZFNpemUoKSB8fCAoKG9nbDo6QnVmZmVyKilvYmopLT5zaXplKCkgPT0gX3N6ACFmaXhlZFR5cGUoKSB8fCAoKG9nbDo6QnVmZmVyKilvYmopLT50eXBlKCkgPT0gbXR5cGUAT3BlbkdMIHN1cHBvcnQgaXMgbm90IGVuYWJsZWQgaW4gdGhpcyBPcGVuQ1YgYnVpbGQgKG1pc3NpbmcgSEFWRV9PUEVOR0wpACFmaXhlZFNpemUoKSB8fCAoKGN1ZGE6Okhvc3RNZW0qKW9iaiktPnNpemUoKSA9PSBfc3oAIWZpeGVkVHlwZSgpIHx8ICgoY3VkYTo6SG9zdE1lbSopb2JqKS0+dHlwZSgpID09IG10eXBlACFmaXhlZFNpemUoKSB8fCAoKE1hdCopb2JqKS0+c2l6ZS5vcGVyYXRvcigpKCkgPT0gU2l6ZShfY29scywgX3Jvd3MpACFmaXhlZFNpemUoKSB8fCAoKFVNYXQqKW9iaiktPnNpemUub3BlcmF0b3IoKSgpID09IFNpemUoX2NvbHMsIF9yb3dzKQAhZml4ZWRTaXplKCkgfHwgKChjdWRhOjpHcHVNYXQqKW9iaiktPnNpemUoKSA9PSBTaXplKF9jb2xzLCBfcm93cykAIWZpeGVkU2l6ZSgpIHx8ICgob2dsOjpCdWZmZXIqKW9iaiktPnNpemUoKSA9PSBTaXplKF9jb2xzLCBfcm93cykAIWZpeGVkU2l6ZSgpIHx8ICgoY3VkYTo6SG9zdE1lbSopb2JqKS0+c2l6ZSgpID09IFNpemUoX2NvbHMsIF9yb3dzKQAhKG0uZW1wdHkoKSAmJiBmaXhlZFR5cGUoKSAmJiBmaXhlZFNpemUoKSkgJiYgIkNhbid0IHJlYWxsb2NhdGUgZW1wdHkgTWF0IHdpdGggbG9ja2VkIGxheW91dCAocHJvYmFibHkgZHVlIHRvIG1pc3VzZWQgJ2NvbnN0JyBtb2RpZmllcikiALSfAADSmAAAFAUAAAEAAAAToAAAZKAAAG2gAAB2b2lkIGN2OjpfT3V0cHV0QXJyYXk6OmNyZWF0ZShpbnQsIGNvbnN0IGludCAqLCBpbnQsIGludCwgYm9vbCwgX091dHB1dEFycmF5OjpEZXB0aE1hc2spIGNvbnN0AENhbid0IHJlYWxsb2NhdGUgTWF0IHdpdGggbG9ja2VkIHR5cGUgKHByb2JhYmx5IGR1ZSB0byBtaXN1c2VkICdjb25zdCcgbW9kaWZpZXIpAG0udHlwZSgpAENWX01BVF9UWVBFKG10eXBlKQC0nwAA0pgAABgFAAABAAAAnKAAAO2gAAD0oAAAQ2FuJ3QgcmVhbGxvY2F0ZSBNYXQgd2l0aCBsb2NrZWQgc2l6ZSAocHJvYmFibHkgZHVlIHRvIG1pc3VzZWQgJ2NvbnN0JyBtb2RpZmllcikAbS5kaW1zAGQAAAC0nwAA0pgAABoFAAABAAAAnKAAABShAAAeoQAAbS5zaXplW2pdAHNpemVzW2pdACEobS5lbXB0eSgpICYmIGZpeGVkVHlwZSgpICYmIGZpeGVkU2l6ZSgpKSAmJiAiQ2FuJ3QgcmVhbGxvY2F0ZSBlbXB0eSBVTWF0IHdpdGggbG9ja2VkIGxheW91dCAocHJvYmFibHkgZHVlIHRvIG1pc3VzZWQgJ2NvbnN0JyBtb2RpZmllcikiAAAAALSfAADSmAAAMgUAAAEAAADQoQAAZKAAAG2gAABDYW4ndCByZWFsbG9jYXRlIFVNYXQgd2l0aCBsb2NrZWQgdHlwZSAocHJvYmFibHkgZHVlIHRvIG1pc3VzZWQgJ2NvbnN0JyBtb2RpZmllcikAAAC0nwAA0pgAADYFAAABAAAAQKIAAO2gAAD0oAAAQ2FuJ3QgcmVhbGxvY2F0ZSBVTWF0IHdpdGggbG9ja2VkIHNpemUgKHByb2JhYmx5IGR1ZSB0byBtaXN1c2VkICdjb25zdCcgbW9kaWZpZXIpAAAAtJ8AANKYAAA4BQAAAQAAAECiAAAUoQAAHqEAAG10eXBlID09IHR5cGUwIHx8IChDVl9NQVRfQ04obXR5cGUpID09IDEgJiYgKCgxIDw8IHR5cGUwKSAmIGZpeGVkRGVwdGhNYXNrKSAhPSAwKQAAALSfAADSmAAAQwUAAAMAAABdmwAA9KAAAOyaAAC0nwAA0pgAAEkFAAAAAAAAXZsAADyjAABLowAAcmVxdWVzdGVkX3NpemUAc3RkOjptYXgocmVxdWVzdGVkX3NpemUud2lkdGgsIHJlcXVlc3RlZF9zaXplLmhlaWdodCkgPT0gdG90YWxfMWQAAAAAtJ8AANKYAABPBQAAAQAAAF2bAAA8owAArKMAAHN6AAC0nwAA0pgAAFUFAAAAAAAAXZsAADyjAADMowAAKHJlcXVlc3RlZF9zaXplID09IHN6IHx8IChyZXF1ZXN0ZWRfc2l6ZS5oZWlnaHQgPT0gc3oud2lkdGggJiYgcmVxdWVzdGVkX3NpemUud2lkdGggPT0gc3ouaGVpZ2h0KSkAZCA9PSAyICYmIChzaXplc1swXSA9PSAxIHx8IHNpemVzWzFdID09IDEgfHwgc2l6ZXNbMF0qc2l6ZXNbMV0gPT0gMCkAIWZpeGVkU2l6ZSgpIHx8IGxlbiA9PSB2di5zaXplKCkAbXR5cGUgPT0gdHlwZTAgfHwgKENWX01BVF9DTihtdHlwZSkgPT0gQ1ZfTUFUX0NOKHR5cGUwKSAmJiAoKDEgPDwgdHlwZTApICYgZml4ZWREZXB0aE1hc2spICE9IDApACFmaXhlZFNpemUoKSB8fCBsZW4gPT0gKChzdGQ6OnZlY3Rvcjx1Y2hhcj4qKXYpLT5zaXplKCkgLyBlc3oAVmVjdG9ycyB3aXRoIGVsZW1lbnQgc2l6ZSAlZCBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlLCBtb2RpZnkgT3V0cHV0QXJyYXk6OmNyZWF0ZSgpCgBjcmVhdGUoKSBjYWxsZWQgZm9yIHRoZSBtaXNzaW5nIG91dHB1dCBhcnJheQAhZml4ZWRTaXplKCkgfHwgbGVuID09IGxlbjAAdltqXS5lbXB0eSgpAGkgPCAoaW50KXYuc2l6ZSgpACFmaXhlZFR5cGUoKSAmJiAhZml4ZWRTaXplKCkAQ1ZfTUFUX1RZUEUobXR5cGUpID09IG0udHlwZSgpAG0uZGltcyA9PSBkAG0uc2l6ZVtqXSA9PSBzaXplc1tqXQBsZW4gPT0gbGVuMAAhZml4ZWRTaXplKCkAcmVsZWFzZQBrID09IE1BVABnZXRNYXRSZWYAayA9PSBTVERfVkVDVE9SX01BVCB8fCBrID09IFNURF9BUlJBWV9NQVQAc2V0VG8AYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAoY24gPT0gMSAmJiAoX21hc2suZW1wdHkoKSB8fCBfbWFzay50eXBlKCkgPT0gQ1ZfOFUpKSB8fCAoY24gPiAxICYmIF9tYXNrLmVtcHR5KCkgJiYgIW1pbklkeCAmJiAhbWF4SWR4KQBtaW5NYXhJZHgAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL21pbm1heC5jcHAAZnVuYyAhPSAwAF9pbWcuZGltcygpIDw9IDIAbWluTWF4TG9jAEHAzwIL3SgtAwAALgMAAC8DAAAwAwAAMQMAADIDAAAzAwAAAAAAAAABAQIBAgIDAQICAwIDAwQBAgIDAgMDBAIDAwQDBAQFAQICAwIDAwQCAwMEAwQEBQIDAwQDBAQFAwQEBQQFBQYBAgIDAgMDBAIDAwQDBAQFAgMDBAMEBAUDBAQFBAUFBgIDAwQDBAQFAwQEBQQFBQYDBAQFBAUFBgQFBQYFBgYHAQICAwIDAwQCAwMEAwQEBQIDAwQDBAQFAwQEBQQFBQYCAwMEAwQEBQMEBAUEBQUGAwQEBQQFBQYEBQUGBQYGBwIDAwQDBAQFAwQEBQQFBQYDBAQFBAUFBgQFBQYFBgYHAwQEBQQFBQYEBQUGBQYGBwQFBQYFBgYHBQYGBwYHBwgAAQEBAQICAgECAgIBAgICAQICAgIDAwMCAwMDAgMDAwECAgICAwMDAgMDAwIDAwMBAgICAgMDAwIDAwMCAwMDAQICAgIDAwMCAwMDAgMDAwIDAwMDBAQEAwQEBAMEBAQCAwMDAwQEBAMEBAQDBAQEAgMDAwMEBAQDBAQEAwQEBAECAgICAwMDAgMDAwIDAwMCAwMDAwQEBAMEBAQDBAQEAgMDAwMEBAQDBAQEAwQEBAIDAwMDBAQEAwQEBAMEBAQBAgICAgMDAwIDAwMCAwMDAgMDAwMEBAQDBAQEAwQEBAIDAwMDBAQEAwQEBAMEBAQCAwMDAwQEBAMEBAQDBAQEAAEBAQEBAQEBAQEBAQEBAQECAgICAgICAgICAgICAgIBAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAgECAgICAgICAgICAgICAgIBAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAgECAgICAgICAgICAgICAgIBAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAgECAgICAgICAgICAgICAgIBAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAgECAgICAgICAgICAgICAgIBAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAm5vcm1UeXBlID09IE5PUk1fSU5GIHx8IG5vcm1UeXBlID09IE5PUk1fTDEgfHwgbm9ybVR5cGUgPT0gTk9STV9MMiB8fCBub3JtVHlwZSA9PSBOT1JNX0wyU1FSIHx8ICgobm9ybVR5cGUgPT0gTk9STV9IQU1NSU5HIHx8IG5vcm1UeXBlID09IE5PUk1fSEFNTUlORzIpICYmIF9zcmMudHlwZSgpID09IENWXzhVKQBub3JtAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9ub3JtLmNwcABtYXNrLmVtcHR5KCkgfHwgbWFzay50eXBlKCkgPT0gQ1ZfOFUAZnVuYyAhPSAwAAAAAASsAACXqwAAxwIAAAQAAAA5rAAAOqwAAEqsAABkb3VibGUgY3Y6Om5vcm0oY3Y6OklucHV0QXJyYXksIGludCwgY3Y6OklucHV0QXJyYXkpAAAoc2l6ZV90KWl0LnNpemUAKHNpemVfdClJTlRfTUFYAAAAeKwAAJerAAA5BAAAAQAAAL2sAADRrAAA3qwAAGRvdWJsZSBjdjo6bm9ybShjdjo6SW5wdXRBcnJheSwgY3Y6OklucHV0QXJyYXksIGludCwgY3Y6OklucHV0QXJyYXkpAElucHV0IHR5cGUgbWlzbWF0Y2gAX3NyYzEudHlwZSgpAF9zcmMyLnR5cGUoKQBfc3JjMS5zYW1lU2l6ZShfc3JjMikAbm9ybVR5cGUgPT0gTk9STV9JTkYgfHwgbm9ybVR5cGUgPT0gTk9STV9MMSB8fCBub3JtVHlwZSA9PSBOT1JNX0wyIHx8IG5vcm1UeXBlID09IE5PUk1fTDJTUVIgfHwgKChub3JtVHlwZSA9PSBOT1JNX0hBTU1JTkcgfHwgbm9ybVR5cGUgPT0gTk9STV9IQU1NSU5HMikgJiYgc3JjMS50eXBlKCkgPT0gQ1ZfOFUpAAB4rAAAl6sAAKUEAAAEAAAAOawAADqsAABKrAAANAMAADUDAAA2AwAANwMAADgDAAA5AwAAOgMAAAAAAAA7AwAAPAMAAD0DAAA+AwAAPwMAAEADAABBAwAAAAAAAEIDAABDAwAARAMAAEUDAABGAwAARwMAAEgDAAAAAAAASQMAAEoDAABLAwAATAMAAE0DAABOAwAATwMAAAAAAABQAwAAUQMAAFIDAABTAwAAVAMAAFUDAABWAwAAAAAAAFcDAABYAwAAWQMAAFoDAABbAwAAXAMAAF0DAAAAAAAATjJjdjE2UGFyYWxsZWxMb29wQm9keUUAFGoCAJCuAAAAAAAA9K4AAF8DAABgAwAAYQMAAE4yY3YxMl9HTE9CQUxfX05fMTIzUGFyYWxsZWxMb29wQm9keVdyYXBwZXJFAAAAADxqAgDErgAAqK4AAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9wYXJhbGxlbC9wYXJhbGxlbC5jcHAAY29yZShwYXJhbGxlbCk6IEJ1aWx0aW4gYmFja2VuZHMoACk6IAAvc3JjL21vZHVsZXMvY29yZS9zcmMvcGFyYWxsZWwvcmVnaXN0cnlfcGFyYWxsZWwuaW1wbC5ocHAAUGFyYWxsZWxCYWNrZW5kUmVnaXN0cnkAY29yZShwYXJhbGxlbCk6IFVwZGF0ZWQgYmFja2VuZHMgcHJpb3JpdGllczogAE9QRU5DVl9QQVJBTExFTF9QUklPUklUWV8lcwBjb3JlKHBhcmFsbGVsKTogRGlzYWJsZSBiYWNrZW5kOiAAY29yZShwYXJhbGxlbCk6IEF2YWlsYWJsZSBiYWNrZW5kcygAY29yZShwYXJhbGxlbCk6IEVuYWJsZWQgYmFja2VuZHMoACwgc29ydGVkIGJ5IHByaW9yaXR5KTogAE4vQQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplADsgAE9QRU5DVl9QQVJBTExFTF9QUklPUklUWV9MSVNUAGNvcmUocGFyYWxsZWwpOiBDb25maWd1cmVkIHByaW9yaXR5IGxpc3QgKE9QRU5DVl9QQVJBTExFTF9QUklPUklUWV9MSVNUKTogAHJlYWRQcmlvcml0eVNldHRpbmdzAGNvcmUocGFyYWxsZWwpOiBOZXcgYmFja2VuZCBwcmlvcml0eTogJwAnID0+IABjb3JlKHBhcmFsbGVsKTogQWRkaW5nIHBhcmFsbGVsIGJhY2tlbmQgKHBsdWdpbik6ICcAJwBjb3JlKHBhcmFsbGVsKTogSW5pdGlhbGl6aW5nIHBhcmFsbGVsIGJhY2tlbmQuLi4AY3JlYXRlRGVmYXVsdFBhcmFsbGVsRm9yQVBJAE9QRU5DVl9QQVJBTExFTF9CQUNLRU5EAABjb3JlKHBhcmFsbGVsKTogcmVxdWVzdGVkIGJhY2tlbmQgbmFtZTogAGNyZWF0ZVBhcmFsbGVsRm9yQVBJAGNvcmUocGFyYWxsZWwpOiB0cnlpbmcgYmFja2VuZDogACAocHJpb3JpdHk9ACkAY29yZShwYXJhbGxlbCk6IGZhY3RvcnkgaXMgbm90IGF2YWlsYWJsZSAocGx1Z2lucyByZXF1aXJlIGZpbGVzeXN0ZW0gc3VwcG9ydCk6IABjb3JlKHBhcmFsbGVsKTogdXNpbmcgYmFja2VuZDogAGNvcmUocGFyYWxsZWwpOiBmYWxsYmFjayBvbiBidWlsdGluIGNvZGUAY29yZShwYXJhbGxlbCk6IHVua25vd24gYmFja2VuZDogAAAlZC4wACVkLgAlLjE2ZQAuTmFuAC0uSW5mAC5JbmYAZm10X3BhaXJzICE9IDAgJiYgbWF4X2xlbiA+IDAAZGVjb2RlRm9ybWF0AC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9wZXJzaXN0ZW5jZS5jcHAASW52YWxpZCBkYXRhIHR5cGUgc3BlY2lmaWNhdGlvbgBUb28gbG9uZyBkYXRhIHR5cGUgc3BlY2lmaWNhdGlvbgAAAAAAANC/AABnAwAAaAMAAGkDAABqAwAAawMAAGwDAABtAwAAbgMAAG8DAABwAwAAcQMAAHIDAABzAwAAdAMAAHUDAAB2AwAAdwMAAHgDAAB5AwAAegMAAHsDAAB8AwAAfQMAAH4DAAB/AwAAgAMAAIEDAACCAwAAPC9vcGVuY3Zfc3RvcmFnZT4KAH0KAGJhc2U2NABOVUxMIG9yIGVtcHR5IGZpbGVuYW1lAG9wZW4ARmlsZVN0b3JhZ2U6OkFQUEVORCBhbmQgRmlsZVN0b3JhZ2U6Ok1FTU9SWSBhcmUgbm90IGN1cnJlbnRseSBjb21wYXRpYmxlAEFwcGVuZGluZyBkYXRhIHRvIGNvbXByZXNzZWQgZmlsZSBpcyBub3QgaW1wbGVtZW50ZWQAcnQAd3QAYSt0AC5negAueG1sAC54bWwuZ3oALmpzb24ALmpzb24uZ3oAVVRGLTE2AFVURi0xNiBYTUwgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZCEgVXNlIDgtYml0IGVuY29kaW5nCgBzdHJsZW4oZW5jb2RpbmcpIDwgMTAwMAA8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSIlcyI/PgoAPD94bWwgdmVyc2lvbj0iMS4wIj8+CgA8b3BlbmN2X3N0b3JhZ2U+CgAAAAAAPC9vcGVuY3Zfc3RvcmFnZT4AQ291bGQgbm90IGZpbmQgPC9vcGVuY3Zfc3RvcmFnZT4gaW4gdGhlIGVuZCBvZiBmaWxlLgoAcit0AGZpbGUgIT0gMAAgPCEtLSByZXN1bWVkIC0tPgAKACVZQU1MOjEuMAotLS0KAC4uLgotLS0KAGZtdCA9PSBGaWxlU3RvcmFnZTo6Rk9STUFUX0pTT04AewoAQ291bGQgbm90IGZpbmQgJ30nIGluIHRoZSBlbmQgb2YgZmlsZS4KACVZQU1MADw/eG1sAGJ1ZgBJbnB1dCBmaWxlIGlzIGludmFsaWQAVW5zdXBwb3J0ZWQgZmlsZSBzdG9yYWdlIGZvcm1hdAAhZnNfZGF0YV9wdHJzLmVtcHR5KCkAd3JpdGVfbW9kZQBwdXRzAFRoZSBzdG9yYWdlIGlzIG5vdCBvcGVuZWQAZ2V0c0Zyb21GaWxlAG1heENvdW50IDwgTUFYX0JMT0NLX1NJWkUAZ2V0cwB3cml0dGVuX2xlbiA8PSAoaW50KSBidWZmZXIuc2l6ZSgpAHJlc2l6ZVdyaXRlQnVmZmVyAGVuZFdyaXRlU3RydWN0ACF3cml0ZV9zdGFjay5lbXB0eSgpAHN0YXJ0V3JpdGVTdHJ1Y3RfaGVscGVyAFNvbWUgY29sbGVjdGlvbiB0eXBlOiBGaWxlTm9kZTo6U0VRIG9yIEZpbGVOb2RlOjpNQVAgbXVzdCBiZSBzcGVjaWZpZWQAdHlwZV9pZABiaW5hcnkAbXVzdCBzZXQgJ3N0cnVjdF9mbGFncyB8PSBDVl9OT0RFX1NFUScgaWYgdXNpbmcgQmFzZTY0LgBzdGFydFdyaXRlU3RydWN0AGZ1bmN0aW9uICdjdlN0YXJ0V3JpdGVTdHJ1Y3QnIGNhbGxzIGNhbm5vdCBiZSBuZXN0ZWQgaWYgdXNpbmcgQmFzZTY0LgBBdCB0aGUgZW5kIG9mIHRoZSBvdXRwdXQgQmFzZTY0LCBgY3ZFbmRXcml0ZVN0cnVjdGAgaXMgbmVlZGVkLgB3cml0ZQBVbnN1cHBvcnRlZCB0eXBlAFVuZXhwZWN0ZWQgZXJyb3IsIHVuYWJsZSB0byBkZXRlcm1pbmUgdGhlIEJhc2U2NCBzdGF0ZS4AVW5leHBlY3RlZCBlcnJvciwgdW5hYmxlIHRvIHN3aXRjaCB0byB0aGlzIHN0YXRlLgAiJGJhc2U2NCQAc3dpdGNoX3RvX0Jhc2U2NF9zdGF0ZQAiAGlzX3dyaXRlX3N0cnVjdF9kZWxheWVkID09IGZhbHNlAG1ha2Vfd3JpdGVfc3RydWN0X2RlbGF5ZWQAcHRyID49IGJ1ZmZlcnN0YXJ0ICYmIHB0ciA8PSBidWZmZXJFbmQoKQBzZXRCdWZmZXJQdHIAZ2V0Q3VycmVudFN0cnVjdABwcm9jZXNzU3BlY2lhbERvdWJsZQBCYWQgZm9ybWF0IG9mIGZsb2F0aW5nLXBvaW50IGNvbnN0YW50AHR5cGUgPT0gRmlsZU5vZGU6OlNFUSB8fCB0eXBlID09IEZpbGVOb2RlOjpNQVAAY29udmVydFRvQ29sbGVjdGlvbgB0eXBlID09IEZpbGVOb2RlOjpTRVEAVGhlIG5vZGUgb2YgdHlwZSAlZCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGNvbGxlY3Rpb24AYmxvY2tJZHggPT0gZnNfZGF0YV9wdHJzLnNpemUoKSAtIDEAcmVzZXJ2ZU5vZGVTcGFjZQBvZnMgPD0gZnNfZGF0YV9ibGtzeltibG9ja0lkeF0AZnJlZVNwYWNlT2ZzIDw9IGZzX2RhdGFfYmxrc3pbYmxvY2tJZHhdAHB0ciA+PSBmc19kYXRhX3B0cnNbYmxvY2tJZHhdICYmIHB0ciA8PSBibG9ja0VuZABfAGFkZE5vZGUATWFwIGVsZW1lbnQgc2hvdWxkIGhhdmUgYSBuYW1lAFNlcXVlbmNlIGVsZW1lbnQgc2hvdWxkIG5vdCBoYXZlIG5hbWUgKHVzZSA8Xz48L18+KQBvZnMgPT0gZnNfZGF0YV9ibGtzeltibG9ja0lkeF0Abm9ybWFsaXplTm9kZU9mcwBBy/gCC1A+AAAAPzQ1Njc4OTo7PD0AAAAAAAAAAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkAAAAAAAAaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMwBBoPoCC9EIb2ZzIDw9IHN6AHJlYWRNb3JlACFwYXJzZXIuZW1wdHkoKSAmJiBwdHIAIWJhc2U2NGRlY29kZXIuZW5kT2ZTdHJlYW0oKQBwYXJzZUJhc2U2NAAlcyglZCk6ICVzAGJsb2NrSWR4IDwgZnNfZGF0YV9wdHJzLnNpemUoKQBnZXROb2RlUHRyAG9mcyA8IGZzX2RhdGFfYmxrc3pbYmxvY2tJZHhdAAAAAAAAAPC/AACDAwAAhAMAAIUDAACGAwAAhwMAAIgDAABFeHRyYSBjbG9zaW5nICclYycAb3BlcmF0b3I8PABUaGUgY2xvc2luZyAnJWMnIGRvZXMgbm90IG1hdGNoIHRoZSBvcGVuaW5nICclYycAIWZzX2ltcGwtPndyaXRlX3N0YWNrLmVtcHR5KCkASW5jb3JyZWN0IGVsZW1lbnQgbmFtZSAlczsgc2hvdWxkIHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IgJ18nAEludmFsaWQgZnMuc3RhdGUAaXNNYXAoKQBvcGVyYXRvcltdAGtleTIgPCBmcy0+c3RyX2hhc2hfZGF0YS5zaXplKCkAaXNTZXEoKQAwIDw9IGkgJiYgaSA8IHN6AHRwID09IFNUUklORyB8fCB0cCA9PSBTRVEgfHwgdHAgPT0gTUFQAHJhd1NpemUAcCAhPSAwAHNldFZhbHVlAGN1cnJlbnRfdHlwZSA9PSBOT05FIHx8IGN1cnJlbnRfdHlwZSA9PSB0eXBlAE9ubHkgc2NhbGFyIHR5cGVzIGNhbiBiZSBkeW5hbWljYWxseSBhc3NpZ25lZCB0byBhIGZpbGUgbm9kZQBOMmN2MTVGaWxlU3RvcmFnZV9BUElFAAAUagIAmL8AAE4yY3YxMUZpbGVTdG9yYWdlNEltcGxFADxqAgC4vwAAsL8AAE4yY3YxMUZpbGVTdG9yYWdlRQAAFGoCANy/AAB1Y3dzaWZkaABzeW1ib2xUb1R5cGUAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAAAC8wAAAiQMAAIoDAACLAwAAjAMAAI0DAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOU182dmVjdG9ySWhOU185YWxsb2NhdG9ySWhFRUVFTlMyX0lTNF9FRUVFAAAAPGoCAHDAAADEZQIAAAAAADDBAACOAwAAjwMAAJADAACMAwAAkQMAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3YxMUZpbGVTdG9yYWdlNEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAA8agIA5MAAAMRlAgAvc3JjL21vZHVsZXMvY29yZS9zcmMvcGVyc2lzdGVuY2VfYmFzZTY0X2VuY29kaW5nLmNwcABBgIMDC5YvQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLwBmcy53cml0ZV9tb2RlAEJhc2U2NFdyaXRlcgBCYXNlNjRDb250ZXh0RW1pdHRlcgAAAAAAAAAAWMIAAJIDAACTAwAAlAMAAIwDAACVAwAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjExSlNPTkVtaXR0ZXJFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAPGoCABDCAADEZQIAAAAAAMzCAACWAwAAlwMAAJgDAACZAwAAmgMAAJsDAACcAwAAnQMAAJ4DAACfAwAATjJjdjExSlNPTkVtaXR0ZXJFAE4yY3YxOEZpbGVTdG9yYWdlRW1pdHRlckUAAAAAFGoCAKfCAAA8agIAlMIAAMTCAABTb21lIGNvbGxlY3Rpb24gdHlwZSAtIEZpbGVOb2RlOjpTRVEgb3IgRmlsZU5vZGU6Ok1BUCwgbXVzdCBiZSBzcGVjaWZpZWQAc3RhcnRXcml0ZVN0cnVjdAAvc3JjL21vZHVsZXMvY29yZS9zcmMvcGVyc2lzdGVuY2VfanNvbi5jcHAAYmluYXJ5AE51bGwgc3RyaW5nIHBvaW50ZXIAd3JpdGUAVGhlIHdyaXR0ZW4gc3RyaW5nIGlzIHRvbyBsb25nAEF0IHByZXNlbnQsIG91dHB1dCBCYXNlNjQgZGF0YSBvbmx5LgB3cml0ZVNjYWxhcgBUaGUga2V5IGlzIGFuIGVtcHR5AFRoZSBrZXkgaXMgdG9vIGxvbmcAQW4gYXR0ZW1wdCB0byBhZGQgZWxlbWVudCB3aXRob3V0IGEga2V5IHRvIGEgbWFwLCBvciBhZGQgZWxlbWVudCB3aXRoIGtleSB0byBzZXF1ZW5jZQBLZXkgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIG9yIF8AS2V5IG5hbWVzIG1heSBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgW2EtekEtWjAtOV0sICctJywgJ18nIGFuZCAnICcATnVsbCBjb21tZW50AHdyaXRlQ29tbWVudAAuLi4KAC0tLQoAAAAAAABIxQAAoAMAAKEDAACiAwAAjAMAAKMDAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2MTBKU09OUGFyc2VyRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAAAA8agIAAMUAAMRlAgAAAAAAoMUAAKQDAAClAwAApgMAAKcDAABOMmN2MTBKU09OUGFyc2VyRQBOMmN2MTdGaWxlU3RvcmFnZVBhcnNlckUAABRqAgB+xQAAPGoCAGzFAACYxQAAcGFyc2UASW52YWxpZCBpbnB1dABsZWZ0LWJyYWNlIG9mIHRvcCBsZXZlbCBpcyBtaXNzaW5nAHNraXBTcGFjZXMATm90IHN1cHBvcnRlZCBlc2NhcGUgY2hhcmFjdGVyAEludmFsaWQgY2hhcmFjdGVyIGluIHRoZSBzdHJlYW0AcHRyAEFib3J0IGF0IHBhcnNlIHRpbWUAcGFyc2VNYXAAcHRyIGlzIE5VTEwAJ3snIC0gbGVmdC1icmFjZSBvZiBtYXAgaXMgbWlzc2luZwBVbmV4cGVjdGVkIGNoYXJhY3RlcgAnfScgLSByaWdodC1icmFjZSBvZiBtYXAgaXMgbWlzc2luZwBwYXJzZUtleQBLZXkgbXVzdCBzdGFydCB3aXRoICciJwBPcGVuQ1YgcGVyc2lzdGVuY2UgZG9lc24ndCBzdXBwb3J0IHZlcnkgbG9uZyBsaW5lcwBLZXkgbXVzdCBlbmQgd2l0aCAnIicAS2V5IGlzIGVtcHR5AE1pc3NpbmcgJzonIGJldHdlZW4ga2V5IGFuZCB2YWx1ZQBwYXJzZVZhbHVlAEludmFsaWQgdmFsdWUgaW5wdXQAVW5leHBlY3RlZCBFbmQtT2YtRmlsZQAnIicgLSByaWdodC1xdW90ZSBvZiBzdHJpbmcgaXMgbWlzc2luZwBzdHJpbmcgaXMgdG9vIGxvbmcAJ1x1WFhYWCcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQASW52YWxpZCBlc2NhcGUgY2hhcmFjdGVyAEludmFsaWQgbnVtZXJpYyB2YWx1ZSAoaW5jb25zaXN0ZW50IGV4cGxpY2l0IHR5cGUgc3BlY2lmaWNhdGlvbj8pAFZhbHVlICdudWxsJyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGFyc2VyAGZhbHNlAFVucmVjb2duaXplZCB2YWx1ZQBwYXJzZVNlcQAnWycgLSBsZWZ0LWJyYWNlIG9mIHNlcSBpcyBtaXNzaW5nACddJyAtIHJpZ2h0LWJyYWNlIG9mIHNlcSBpcyBtaXNzaW5nAGdldEJhc2U2NFJvdwBVbmV4cGVjdGVkIGVuZCBvZiBsaW5lAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAAAAAKDJAACoAwAAqQMAAKoDAACMAwAAqwMAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3YxMFhNTEVtaXR0ZXJFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAADxqAgBYyQAAxGUCAAAAAADwyQAAlgMAAKwDAACtAwAArgMAAK8DAACwAwAAsQMAALIDAACzAwAAtAMAAE4yY3YxMFhNTEVtaXR0ZXJFAAAAPGoCANzJAADEwgAAdHlwZV9pZABBbiBhdHRlbXB0IHRvIGFkZCBlbGVtZW50IHdpdGhvdXQgYSBrZXkgdG8gYSBtYXAsIG9yIGFkZCBlbGVtZW50IHdpdGgga2V5IHRvIHNlcXVlbmNlAHdyaXRlVGFnAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9wZXJzaXN0ZW5jZV94bWwuY3BwAF8AQSBzaW5nbGUgXyBpcyBhIHJlc2VydmVkIHRhZyBuYW1lAENsb3NpbmcgdGFnIHNob3VsZCBub3QgaW5jbHVkZSBhbnkgYXR0cmlidXRlcwBLZXkgc2hvdWxkIHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IgXwBLZXkgbmFtZSBtYXkgb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIFthLXpBLVowLTldLCAnLScgYW5kICdfJwBuYXR0ciAlIDIgPT0gMABsZW4wID4gMABOdWxsIHN0cmluZyBwb2ludGVyAHdyaXRlAFRoZSB3cml0dGVuIHN0cmluZyBpcyB0b28gbG9uZwBhbXAAI3glMDJ4AEF0IHByZXNlbnQsIG91dHB1dCBCYXNlNjQgZGF0YSBvbmx5LgB3cml0ZVNjYWxhcgBlbGVtZW50cyB3aXRoIGtleXMgY2FuIG5vdCBiZSB3cml0dGVuIHRvIHNlcXVlbmNlAE51bGwgY29tbWVudAB3cml0ZUNvbW1lbnQALS0ARG91YmxlIGh5cGhlbiAnLS0nIGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjb21tZW50cwA8IS0tICVzIC0tPgA8IS0tAAo8IS0tIG5leHQgc3RyZWFtIC0tPgoAAAAAAOTMAAC1AwAAtgMAALcDAACMAwAAuAMAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y5WE1MUGFyc2VyRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAPGoCAKDMAADEZQIAAAAAABjNAACkAwAAuQMAALoDAAC7AwAATjJjdjlYTUxQYXJzZXJFADxqAgAIzQAAmMUAAGZzICE9IDAAcGFyc2UASW52YWxpZCBpbnB1dAA8P3htbABWYWxpZCBYTUwgc2hvdWxkIHN0YXJ0IHdpdGggJzw/eG1sIC4uLj8+JwBvcGVuY3Zfc3RvcmFnZQA8b3BlbmN2X3N0b3JhZ2U+IHRhZyBpcyBtaXNzaW5nADwvb3BlbmN2X3N0b3JhZ2U+IHRhZyBpcyBtaXNzaW5nAGZzLT5lb2YoKQBza2lwU3BhY2VzAENvbW1lbnRzIGFyZSBub3QgYWxsb3dlZCBoZXJlAEludmFsaWQgY2hhcmFjdGVyIGluIHRoZSBzdHJlYW0AcGFyc2VUYWcASW52YWxpZCB0YWcgaW5wdXQAVW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbQBUYWcgc2hvdWxkIHN0YXJ0IHdpdGggJzwnAE9wZW5DViBwZXJzaXN0ZW5jZSBkb2Vzbid0IHN1cHBvcnQgdmVyeSBsb25nIGxpbmVzAHB0clsxXSAhPSAnLScgfHwgcHRyWzJdICE9ICctJwBVbmtub3duIHRhZyB0eXBlAE5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IgdW5kZXJzY29yZQBDbG9zaW5nIHRhZyBzaG91bGQgbm90IGNvbnRhaW4gYW55IGF0dHJpYnV0ZXMASW52YWxpZCBhdHRyaWJ1dGUAQXR0cmlidXRlIG5hbWUgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5ICc9JwBBdHRyaWJ1dGUgdmFsdWUgc2hvdWxkIGJlIHB1dCBpbnRvIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzAFVuZXhwZWN0ZWQgZW5kIG9mIGxpbmUAdHlwZV9uYW1lLmVtcHR5KCkASW52YWxpZCBjbG9zaW5nIHRhZyBmb3IgPD94bWwgLi4uAFRoZXJlIHNob3VsZCBiZSBzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMAcGFyc2VWYWx1ZQBEaXJlY3RpdmUgdGFncyBhcmUgbm90IGFsbG93ZWQgaGVyZQBFbXB0eSB0YWdzIGFyZSBub3Qgc3VwcG9ydGVkAHRhZ190eXBlID09IENWX1hNTF9PUEVOSU5HX1RBRwBzdHIAbWFwAHNlcQBiaW5hcnkATWlzbWF0Y2hlZCBjbG9zaW5nIHRhZwBUaGVyZSBzaG91bGQgYmUgc3BhY2UgYmV0d2VlbiBsaXRlcmFscwBJbnZhbGlkIG51bWVyaWMgdmFsdWUgKGluY29uc2lzdGVudCBleHBsaWNpdCB0eXBlIHNwZWNpZmljYXRpb24/KQBMaXRlcmFsICIgaXMgbm90IGFsbG93ZWQgd2l0aGluIGEgc3RyaW5nLiBVc2UgJnF1b3Q7AENsb3NpbmcgIiBpcyBleHBlY3RlZABMaXRlcmFsICcgb3IgPiBhcmUgbm90IGFsbG93ZWQuIFVzZSAmYXBvczsgb3IgJmd0OwBJbnZhbGlkIG51bWVyaWMgdmFsdWUgaW4gdGhlIHN0cmluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiB0aGUgc3ltYm9sIGVudGl0eSBuYW1lAHN0cmluZyBpcyB0b28gbG9uZwBUb28gbG9uZyBzdHJpbmcgbGl0ZXJhbABnZXRCYXNlNjRSb3cAAAAAAAAAeNIAALwDAAC9AwAAvgMAAIwDAAC/AwAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjExWUFNTEVtaXR0ZXJFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAPGoCADDSAADEZQIAAAAAAMjSAACWAwAAwAMAAMEDAADCAwAAwwMAAMQDAADFAwAAxgMAAMcDAADIAwAATjJjdjExWUFNTEVtaXR0ZXJFAAA8agIAtNIAAMTCAABTb21lIGNvbGxlY3Rpb24gdHlwZSAtIEZpbGVOb2RlOjpTRVEgb3IgRmlsZU5vZGU6Ok1BUCwgbXVzdCBiZSBzcGVjaWZpZWQAc3RhcnRXcml0ZVN0cnVjdAAvc3JjL21vZHVsZXMvY29yZS9zcmMvcGVyc2lzdGVuY2VfeW1sLmNwcABiaW5hcnkAISFiaW5hcnkgfAAhISVzICVjACEhJXMATnVsbCBzdHJpbmcgcG9pbnRlcgB3cml0ZQBUaGUgd3JpdHRlbiBzdHJpbmcgaXMgdG9vIGxvbmcAeCUwMngAQXQgcHJlc2VudCwgb3V0cHV0IEJhc2U2NCBkYXRhIG9ubHkuAHdyaXRlU2NhbGFyAEFuIGF0dGVtcHQgdG8gYWRkIGVsZW1lbnQgd2l0aG91dCBhIGtleSB0byBhIG1hcCwgb3IgYWRkIGVsZW1lbnQgd2l0aCBrZXkgdG8gc2VxdWVuY2UAVGhlIGtleSBpcyBhbiBlbXB0eQBUaGUga2V5IGlzIHRvbyBsb25nAEtleSBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IgXwBLZXkgbmFtZXMgbWF5IG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBbYS16QS1aMC05XSwgJy0nLCAnXycgYW5kICcgJwBOdWxsIGNvbW1lbnQAd3JpdGVDb21tZW50AC4uLgoALS0tCgAAAAAAYNUAAMkDAADKAwAAywMAAIwDAADMAwAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjEwWUFNTFBhcnNlckVOU185YWxsb2NhdG9ySVMyX0VFRUUAAAAAPGoCABjVAADEZQIAAAAAAJjVAACkAwAAzQMAAM4DAADPAwAATjJjdjEwWUFNTFBhcnNlckUAAAA8agIAhNUAAJjFAABwYXJzZQBJbnZhbGlkIGlucHV0ACVZQU1MAFVuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiAoaXQgbXVzdCBiZSAxLngpAC0tLQBUaGUgWUFNTCBzdHJlYW1zIG11c3Qgc3RhcnQgd2l0aCAnLS0tJywgZXhjZXB0IHRoZSBmaXJzdCBvbmUASW52YWxpZCBvciB1bnN1cHBvcnRlZCBzeW50YXgALi4uAE9ubHkgY29sbGVjdGlvbnMgYXMgWUFNTCBzdHJlYW1zIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBwYXJzZXIAc2tpcFNwYWNlcwBJbmNvcnJlY3QgaW5kZW50YXRpb24AVG9vIGxvbmcgc3RyaW5nIG9yIGEgbGFzdCBzdHJpbmcgdy9vIG5ld2xpbmUAVGFicyBhcmUgcHJvaGliaXRlZCBpbiBZQU1MIQBJbnZhbGlkIGNoYXJhY3RlcgBwYXJzZVZhbHVlADx0YWc6eWFtbC5vcmcsMjAwMjoARW1wdHkgdHlwZSBuYW1lAHN0cgBpbnQAc2VxAG1hcABmbG9hdABJbnZhbGlkIG51bWVyaWMgdmFsdWUgKGluY29uc2lzdGVudCBleHBsaWNpdCB0eXBlIHNwZWNpZmljYXRpb24/KQBPcGVuQ1YgcGVyc2lzdGVuY2UgZG9lc24ndCBzdXBwb3J0IHZlcnkgbG9uZyBsaW5lcwBUb28gbG9uZyBzdHJpbmcgbGl0ZXJhbABUaGUgd3JvbmcgY2xvc2luZyBicmFja2V0AE1pc3NpbmcgLCBiZXR3ZWVuIHRoZSBlbGVtZW50cwBDb21wbGV4IGtleXMgYXJlIG5vdCBzdXBwb3J0ZWQATXVsdGktbGluZSB0ZXh0IGxpdGVyYWxzIGFyZSBub3Qgc3VwcG9ydGVkAEJsb2NrIHNlcXVlbmNlIGVsZW1lbnRzIG11c3QgYmUgcHJlY2VkZWQgd2l0aCAnLScAcGFyc2VLZXkAS2V5IG1heSBub3Qgc3RhcnQgd2l0aCAnLScATWlzc2luZyAnOicAQW4gZW1wdHkga2V5AGdldEJhc2U2NFJvdwBVbmV4cGVjdGVkIGVuZCBvZiBsaW5lAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9yYW5kLmNwcABmdW5jICE9IDAAQaSyAwse0AMAANEDAADSAwAA0wMAAAAAAADUAwAAAAAAANUDAEHQsgMLAtYDAEHgsgMLAtcDAEGAswMLAtgDAEGgswMLQNkDAABkc3QuZWxlbVNpemUoKSA8PSAzMgByYW5kU2h1ZmZsZQBfYXJyLmRpbXMgPD0gMgByYW5kU2h1ZmZsZV8AQfCzAwv6OtoDAADbAwAA3AMAAN0DAADeAwAA3wMAAOADAAAAAAAAT1BFTkNWX0RVTVBfRVJST1JTAAAAAAAA1O0AAOMDAADmAwAA5wMAAD4gAE9wZW5DViglcykgJXM6JWQ6IGVycm9yOiAoJWQ6JXMpIGluIGZ1bmN0aW9uICclcycKJXMANC41LjUtZGV2AE9wZW5DViglcykgJXM6JWQ6IGVycm9yOiAoJWQ6JXMpICVzIGluIGZ1bmN0aW9uICclcycKAE9wZW5DViglcykgJXM6JWQ6IGVycm9yOiAoJWQ6JXMpICVzJXMAAAoACkdlbmVyYWwgY29uZmlndXJhdGlvbiBmb3IgT3BlbkNWIDQuNS41LWRldiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgVmVyc2lvbiBjb250cm9sOiAgICAgICAgICAgICAgIDQuNS41LTIwLWdhMTE0M2M0ZWEwLWRpcnR5CgogIFBsYXRmb3JtOgogICAgVGltZXN0YW1wOiAgICAgICAgICAgICAgICAgICAyMDIyLTAxLTExVDAzOjE1OjQxWgogICAgSG9zdDogICAgICAgICAgICAgICAgICAgICAgICBMaW51eCA0LjkuOTMtbGludXhraXQtYXVmcyB4ODZfNjQKICAgIFRhcmdldDogICAgICAgICAgICAgICAgICAgICAgRW1zY3JpcHRlbiAxIHg4NgogICAgQ01ha2U6ICAgICAgICAgICAgICAgICAgICAgICAzLjEzLjQKICAgIENNYWtlIGdlbmVyYXRvcjogICAgICAgICAgICAgVW5peCBNYWtlZmlsZXMKICAgIENNYWtlIGJ1aWxkIHRvb2w6ICAgICAgICAgICAgL3Vzci9iaW4vbWFrZQogICAgQ29uZmlndXJhdGlvbjogICAgICAgICAgICAgICBSZWxlYXNlCgogIENQVS9IVyBmZWF0dXJlczoKICAgIEJhc2VsaW5lOgoKICBDL0MrKzoKICAgIEJ1aWx0IGFzIGR5bmFtaWMgbGlicz86ICAgICAgTk8KICAgIEMrKyBzdGFuZGFyZDogICAgICAgICAgICAgICAgMTEKICAgIEMrKyBDb21waWxlcjogICAgICAgICAgICAgICAgL2Vtc2RrL3Vwc3RyZWFtL2Vtc2NyaXB0ZW4vZW0rKyAgKHZlciAxMi4wLjApCiAgICBDKysgZmxhZ3MgKFJlbGVhc2UpOiAgICAgICAgIC1zIFVTRV9QVEhSRUFEUz0wICAgIC1mc2lnbmVkLWNoYXIgLVcgLVdhbGwgLVdlcnJvcj1yZXR1cm4tdHlwZSAtV2Vycm9yPW5vbi12aXJ0dWFsLWR0b3IgLVdlcnJvcj1hZGRyZXNzIC1XZXJyb3I9c2VxdWVuY2UtcG9pbnQgLVdmb3JtYXQgLVdlcnJvcj1mb3JtYXQtc2VjdXJpdHkgLVdtaXNzaW5nLWRlY2xhcmF0aW9ucyAtV21pc3NpbmctcHJvdG90eXBlcyAtV3N0cmljdC1wcm90b3R5cGVzIC1XdW5kZWYgLVdpbml0LXNlbGYgLVdwb2ludGVyLWFyaXRoIC1Xc2hhZG93IC1Xc2lnbi1wcm9tbyAtV3VuaW5pdGlhbGl6ZWQgLVdpbmNvbnNpc3RlbnQtbWlzc2luZy1vdmVycmlkZSAtV25vLWRlbGV0ZS1ub24tdmlydHVhbC1kdG9yIC1Xbm8tdW5uYW1lZC10eXBlLXRlbXBsYXRlLWFyZ3MgLVduby1jb21tZW50IC1Xbm8tZGVwcmVjYXRlZC1lbnVtLWVudW0tY29udmVyc2lvbiAtV25vLWRlcHJlY2F0ZWQtYW5vbi1lbnVtLWVudW0tY29udmVyc2lvbiAtZmRpYWdub3N0aWNzLXNob3ctb3B0aW9uIC1RdW51c2VkLWFyZ3VtZW50cyAtZmZ1bmN0aW9uLXNlY3Rpb25zIC1mZGF0YS1zZWN0aW9ucyAgLWZ2aXNpYmlsaXR5PWhpZGRlbiAtZnZpc2liaWxpdHktaW5saW5lcy1oaWRkZW4gLUROREVCVUcgLU8yICAtRE5ERUJVRwogICAgQysrIGZsYWdzIChEZWJ1Zyk6ICAgICAgICAgICAtcyBVU0VfUFRIUkVBRFM9MCAgICAtZnNpZ25lZC1jaGFyIC1XIC1XYWxsIC1XZXJyb3I9cmV0dXJuLXR5cGUgLVdlcnJvcj1ub24tdmlydHVhbC1kdG9yIC1XZXJyb3I9YWRkcmVzcyAtV2Vycm9yPXNlcXVlbmNlLXBvaW50IC1XZm9ybWF0IC1XZXJyb3I9Zm9ybWF0LXNlY3VyaXR5IC1XbWlzc2luZy1kZWNsYXJhdGlvbnMgLVdtaXNzaW5nLXByb3RvdHlwZXMgLVdzdHJpY3QtcHJvdG90eXBlcyAtV3VuZGVmIC1XaW5pdC1zZWxmIC1XcG9pbnRlci1hcml0aCAtV3NoYWRvdyAtV3NpZ24tcHJvbW8gLVd1bmluaXRpYWxpemVkIC1XaW5jb25zaXN0ZW50LW1pc3Npbmctb3ZlcnJpZGUgLVduby1kZWxldGUtbm9uLXZpcnR1YWwtZHRvciAtV25vLXVubmFtZWQtdHlwZS10ZW1wbGF0ZS1hcmdzIC1Xbm8tY29tbWVudCAtV25vLWRlcHJlY2F0ZWQtZW51bS1lbnVtLWNvbnZlcnNpb24gLVduby1kZXByZWNhdGVkLWFub24tZW51bS1lbnVtLWNvbnZlcnNpb24gLWZkaWFnbm9zdGljcy1zaG93LW9wdGlvbiAtUXVudXNlZC1hcmd1bWVudHMgLWZmdW5jdGlvbi1zZWN0aW9ucyAtZmRhdGEtc2VjdGlvbnMgIC1mdmlzaWJpbGl0eT1oaWRkZW4gLWZ2aXNpYmlsaXR5LWlubGluZXMtaGlkZGVuIC1nICAtTzAgLURERUJVRyAtRF9ERUJVRwogICAgQyBDb21waWxlcjogICAgICAgICAgICAgICAgICAvZW1zZGsvdXBzdHJlYW0vZW1zY3JpcHRlbi9lbWNjCiAgICBDIGZsYWdzIChSZWxlYXNlKTogICAgICAgICAgIC1zIFVTRV9QVEhSRUFEUz0wICAgIC1mc2lnbmVkLWNoYXIgLVcgLVdhbGwgLVdlcnJvcj1yZXR1cm4tdHlwZSAtV2Vycm9yPW5vbi12aXJ0dWFsLWR0b3IgLVdlcnJvcj1hZGRyZXNzIC1XZXJyb3I9c2VxdWVuY2UtcG9pbnQgLVdmb3JtYXQgLVdlcnJvcj1mb3JtYXQtc2VjdXJpdHkgLVdtaXNzaW5nLWRlY2xhcmF0aW9ucyAtV21pc3NpbmctcHJvdG90eXBlcyAtV3N0cmljdC1wcm90b3R5cGVzIC1XdW5kZWYgLVdpbml0LXNlbGYgLVdwb2ludGVyLWFyaXRoIC1Xc2hhZG93IC1Xc2lnbi1wcm9tbyAtV3VuaW5pdGlhbGl6ZWQgLVdpbmNvbnNpc3RlbnQtbWlzc2luZy1vdmVycmlkZSAtV25vLWRlbGV0ZS1ub24tdmlydHVhbC1kdG9yIC1Xbm8tdW5uYW1lZC10eXBlLXRlbXBsYXRlLWFyZ3MgLVduby1jb21tZW50IC1Xbm8tZGVwcmVjYXRlZC1lbnVtLWVudW0tY29udmVyc2lvbiAtV25vLWRlcHJlY2F0ZWQtYW5vbi1lbnVtLWVudW0tY29udmVyc2lvbiAtZmRpYWdub3N0aWNzLXNob3ctb3B0aW9uIC1RdW51c2VkLWFyZ3VtZW50cyAtZmZ1bmN0aW9uLXNlY3Rpb25zIC1mZGF0YS1zZWN0aW9ucyAgLWZ2aXNpYmlsaXR5PWhpZGRlbiAtZnZpc2liaWxpdHktaW5saW5lcy1oaWRkZW4gLUROREVCVUcgLU8yICAtRE5ERUJVRwogICAgQyBmbGFncyAoRGVidWcpOiAgICAgICAgICAgICAtcyBVU0VfUFRIUkVBRFM9MCAgICAtZnNpZ25lZC1jaGFyIC1XIC1XYWxsIC1XZXJyb3I9cmV0dXJuLXR5cGUgLVdlcnJvcj1ub24tdmlydHVhbC1kdG9yIC1XZXJyb3I9YWRkcmVzcyAtV2Vycm9yPXNlcXVlbmNlLXBvaW50IC1XZm9ybWF0IC1XZXJyb3I9Zm9ybWF0LXNlY3VyaXR5IC1XbWlzc2luZy1kZWNsYXJhdGlvbnMgLVdtaXNzaW5nLXByb3RvdHlwZXMgLVdzdHJpY3QtcHJvdG90eXBlcyAtV3VuZGVmIC1XaW5pdC1zZWxmIC1XcG9pbnRlci1hcml0aCAtV3NoYWRvdyAtV3NpZ24tcHJvbW8gLVd1bmluaXRpYWxpemVkIC1XaW5jb25zaXN0ZW50LW1pc3Npbmctb3ZlcnJpZGUgLVduby1kZWxldGUtbm9uLXZpcnR1YWwtZHRvciAtV25vLXVubmFtZWQtdHlwZS10ZW1wbGF0ZS1hcmdzIC1Xbm8tY29tbWVudCAtV25vLWRlcHJlY2F0ZWQtZW51bS1lbnVtLWNvbnZlcnNpb24gLVduby1kZXByZWNhdGVkLWFub24tZW51bS1lbnVtLWNvbnZlcnNpb24gLWZkaWFnbm9zdGljcy1zaG93LW9wdGlvbiAtUXVudXNlZC1hcmd1bWVudHMgLWZmdW5jdGlvbi1zZWN0aW9ucyAtZmRhdGEtc2VjdGlvbnMgIC1mdmlzaWJpbGl0eT1oaWRkZW4gLWZ2aXNpYmlsaXR5LWlubGluZXMtaGlkZGVuIC1nICAtTzAgLURERUJVRyAtRF9ERUJVRwogICAgTGlua2VyIGZsYWdzIChSZWxlYXNlKTogICAgICAtV2wsLS1nYy1zZWN0aW9ucyAtTzIgCiAgICBMaW5rZXIgZmxhZ3MgKERlYnVnKTogICAgICAgIC1XbCwtLWdjLXNlY3Rpb25zICAKICAgIGNjYWNoZTogICAgICAgICAgICAgICAgICAgICAgTk8KICAgIFByZWNvbXBpbGVkIGhlYWRlcnM6ICAgICAgICAgTk8KICAgIEV4dHJhIGRlcGVuZGVuY2llczoKICAgIDNyZHBhcnR5IGRlcGVuZGVuY2llczogICAgICAgemxpYiBsaWJwcm90b2J1ZiBxdWlyYwoKICBPcGVuQ1YgbW9kdWxlczoKICAgIFRvIGJlIGJ1aWx0OiAgICAgICAgICAgICAgICAgY2FsaWIzZCBjb3JlIGRubiBmZWF0dXJlczJkIGZsYW5uIGltZ3Byb2MganMgb2JqZGV0ZWN0IHBob3RvIHZpZGVvCiAgICBEaXNhYmxlZDogICAgICAgICAgICAgICAgICAgIGhpZ2hndWkgaW1nY29kZWNzIG1sIHN0aXRjaGluZyB2aWRlb2lvIHdvcmxkCiAgICBEaXNhYmxlZCBieSBkZXBlbmRlbmN5OiAgICAgIHRzCiAgICBVbmF2YWlsYWJsZTogICAgICAgICAgICAgICAgIGdhcGkgamF2YSBweXRob24yIHB5dGhvbjMKICAgIEFwcGxpY2F0aW9uczogICAgICAgICAgICAgICAgZXhhbXBsZXMKICAgIERvY3VtZW50YXRpb246ICAgICAgICAgICAgICAganMKICAgIE5vbi1mcmVlIGFsZ29yaXRobXM6ICAgICAgICAgTk8KCiAgR1VJOiAKCiAgTWVkaWEgSS9POiAKICAgIFpMaWI6ICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGQgKHZlciAxLjIuMTEpCiAgICBKUEVHIDIwMDA6ICAgICAgICAgICAgICAgICAgIGJ1aWxkICh2ZXIgMi40LjApCiAgICBIRFI6ICAgICAgICAgICAgICAgICAgICAgICAgIFlFUwogICAgU1VOUkFTVEVSOiAgICAgICAgICAgICAgICAgICBZRVMKICAgIFBYTTogICAgICAgICAgICAgICAgICAgICAgICAgWUVTCiAgICBQRk06ICAgICAgICAgICAgICAgICAgICAgICAgIFlFUwoKICBWaWRlbyBJL086CgogIFBhcmFsbGVsIGZyYW1ld29yazogICAgICAgICAgICBub25lCgogIE90aGVyIHRoaXJkLXBhcnR5IGxpYnJhcmllczoKICAgIFZBOiAgICAgICAgICAgICAgICAgICAgICAgICAgTk8KICAgIEN1c3RvbSBIQUw6ICAgICAgICAgICAgICAgICAgTk8KICAgIFByb3RvYnVmOiAgICAgICAgICAgICAgICAgICAgYnVpbGQgKDMuMTkuMSkKCiAgUHl0aG9uIChmb3IgYnVpbGQpOiAgICAgICAgICAgIC91c3IvYmluL3B5dGhvbjMKCiAgSW5zdGFsbCB0bzogICAgICAgICAgICAgICAgICAgIC91c3IvbG9jYWwKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgBsZW4gPj0gMCAmJiAiQ2hlY2sgZm9ybWF0IHN0cmluZyBmb3IgZXJyb3JzIgBmb3JtYXQAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL3N5c3RlbS5jcHAATjJjdjlFeGNlcHRpb25FAAA8agIAw+0AABRnAgBObyBFcnJvcgBCYWNrdHJhY2UAVW5zcGVjaWZpZWQgZXJyb3IASW50ZXJuYWwgZXJyb3IASW5zdWZmaWNpZW50IG1lbW9yeQBCYWQgYXJndW1lbnQASXRlcmF0aW9ucyBkbyBub3QgY29udmVyZ2UAQXV0b3RyYWNlIGNhbGwASW5jb3JyZWN0IHNpemUgb2YgaW5wdXQgYXJyYXkATnVsbCBwb2ludGVyAERpdmlzaW9uIGJ5IHplcm8gb2NjdXJyZWQASW1hZ2Ugc3RlcCBpcyB3cm9uZwBJbnBsYWNlIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkAFJlcXVlc3RlZCBvYmplY3Qgd2FzIG5vdCBmb3VuZABJbnB1dCBpbWFnZSBkZXB0aCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGZ1bmN0aW9uAEZvcm1hdHMgb2YgaW5wdXQgYXJndW1lbnRzIGRvIG5vdCBtYXRjaABTaXplcyBvZiBpbnB1dCBhcmd1bWVudHMgZG8gbm90IG1hdGNoAE9uZSBvZiB0aGUgYXJndW1lbnRzJyB2YWx1ZXMgaXMgb3V0IG9mIHJhbmdlAFVuc3VwcG9ydGVkIGZvcm1hdCBvciBjb21iaW5hdGlvbiBvZiBmb3JtYXRzAElucHV0IENPSSBpcyBub3Qgc3VwcG9ydGVkAEJhZCBudW1iZXIgb2YgY2hhbm5lbHMAQmFkIGZsYWcgKHBhcmFtZXRlciBvciBzdHJ1Y3R1cmUgZmllbGQpAEJhZCBwYXJhbWV0ZXIgb2YgdHlwZSBDdlBvaW50AEJhZCB0eXBlIG9mIG1hc2sgYXJndW1lbnQAUGFyc2luZyBlcnJvcgBUaGUgZnVuY3Rpb24vZmVhdHVyZSBpcyBub3QgaW1wbGVtZW50ZWQATWVtb3J5IGJsb2NrIGhhcyBiZWVuIGNvcnJ1cHRlZABBc3NlcnRpb24gZmFpbGVkAE5vIENVREEgc3VwcG9ydABHcHUgQVBJIGNhbGwATm8gT3BlbkdMIHN1cHBvcnQAT3BlbkdMIEFQSSBjYWxsAFVua25vd24gJXMgY29kZSAlZABzdGF0dXMAZXJyb3IAcHRocmVhZF9rZXlfY3JlYXRlKCZ0bHNLZXksIG9wZW5jdl90bHNfZGVzdHJ1Y3RvcikgPT0gMABUbHNBYnN0cmFjdGlvbgBPcGVuQ1YgRVJST1I6IFRsc0Fic3RyYWN0aW9uOjp+VGxzQWJzdHJhY3Rpb24oKTogcHRocmVhZF9rZXlfZGVsZXRlKCkgY2FsbCBmYWlsZWQKAHB0aHJlYWRfc2V0c3BlY2lmaWModGxzS2V5LCBwRGF0YSkgPT0gMABzZXREYXRhAAAAAAAAjPIAAOgDAADpAwAA6gMAAOoDAABrZXlfID09IC0xAH5UTFNEYXRhQ29udGFpbmVyAGtleV8gIT0gLTEgJiYgIkNhbid0IGZldGNoIGRhdGEgZnJvbSB0ZXJtaW5hdGVkIFRMUyBjb250YWluZXIuIgBnZXREYXRhAE4yY3YxNlRMU0RhdGFDb250YWluZXJFAAAAABRqAgBx8gAAT1BFTkNWX0RVTVBfQ09ORklHAApPcGVuQ1YgYnVpbGQgY29uZmlndXJhdGlvbiBpczoKJXMKAE1NWABTU0UAU1NFMgBTU0UzAFNTU0UzAFNTRTQuMQBTU0U0LjIAUE9QQ05UAEZQMTYAQVZYAEFWWDIARk1BMwBBVlg1MTJGAEFWWDUxMkJXAEFWWDUxMkNEAEFWWDUxMkRRAEFWWDUxMkVSAEFWWDUxMklGTUEAQVZYNTEyUEYAQVZYNTEyVkJNSQBBVlg1MTJWTABBVlg1MTJWQk1JMgBBVlg1MTJWTk5JAEFWWDUxMkJJVEFMRwBBVlg1MTJWUE9QQ05URFEAQVZYNTEyNFZOTklXAEFWWDUxMjRGTUFQUwBORU9OAFZTWABWU1gzAENQVV9NU0EAUklTQ1ZWAEFWWDUxMi1DT01NT04AQVZYNTEyLVNLWABBVlg1MTItS05MAEFWWDUxMi1LTk0AQVZYNTEyLUNOTABBVlg1MTItQ0xYAEFWWDUxMi1JQ0wAUlZWAE9QRU5DVl9DUFVfRElTQUJMRQBmZWF0dXJlLnNpemUoKSA+IDAAcmVhZFNldHRpbmdzAE9QRU5DVjogVHJ5aW5nIHRvIGRpc2FibGUgYmFzZWxpbmUgQ1BVIGZlYXR1cmU6ICclcycuVGhpcyBoYXMgdmVyeSBsaW1pdGVkIGVmZmVjdCwgYmVjYXVzZSBjb2RlIG9wdGltaXphdGlvbnMgZm9yIHRoaXMgZmVhdHVyZSBhcmUgZXhlY3V0ZWQgdW5jb25kaXRpb25hbGx5IGluIHRoZSBtb3N0IGNhc2VzLgoAT1BFTkNWOiBUcnlpbmcgdG8gZGlzYWJsZSB1bmF2YWlsYWJsZSBDUFUgZmVhdHVyZSBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybTogJyVzJy4KAE9QRU5DVjogVHJ5aW5nIHRvIGRpc2FibGUgdW5r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FkMAABdDAAAYQwAAGUMAABpDAAAbQwAAHEMAAB1DAAAeQwAAH0MAACBDAAAhQwAAIkMAACNDAAAkQwAAJUMAACZDAAAnQwAAKEMAAClDAAAqQwAAK0MAACxDAAAtQwAALkMAAC9DAAAwQwAAMUMAADJDAAAzQwAANEMAADVDAAA2QwAAN0MAADhDAAA5QwAAOkMAADtDAAA8QwAAPUMAAD5DAAA/QwAAQEMAAEFDAABCQwAAQ0MAAERDAABFQwAARkMAAEdDAABIQwAASUMAAEpDAABLQwAATEMAAE1DAABOQwAAT0MAAFBDAABRQwAAUkMAAFNDAABUQwAAVUMAAFZDAABXQwAAWEMAAFlDAABaQwAAW0MAAFxDAABdQwAAXkMAAF9DAABgQwAAYUMAAGJDAABjQwAAZEMAAGVDAABmQwAAZ0MAAGhDAABpQwAAakMAAGtDAABsQwAAbUMAAG5DAABvQwAAcEMAAHFDAAByQwAAc0MAAHRDAAB1QwAAdkMAAHdDAAB4QwAAeUMAAHpDAAB7QwAAfEMAAH1DAAB+QwAAf0MAQaH+Awv2GQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////bWFwY291bnQgPT0gMAB+VU1hdERhdGEAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL3VtYXRyaXguY3BwADAgPD0gX2RpbXMgJiYgX2RpbXMgPD0gQ1ZfTUFYX0RJTQBzZXRTaXplAHMgPj0gMABUaGUgdG90YWwgbWF0cml4IHNpemUgZG9lcyBub3QgZml0IHRvICJzaXplX3QiIHR5cGUAZGF0YSA9PSBkYXRhc3RhcnQAZ2V0VU1hdABhbGxvY2F0ZWQAMCA8PSBkICYmIGQgPD0gQ1ZfTUFYX0RJTSAmJiBfc2l6ZXMAY3JlYXRlAHUgIT0gMABzdGVwW2RpbXMtMV0gPT0gKHNpemVfdClDVl9FTEVNX1NJWkUoZmxhZ3MpAG0uZGltcyA+PSAyAFVNYXQAMCA8PSBfcm93UmFuZ2Uuc3RhcnQgJiYgX3Jvd1JhbmdlLnN0YXJ0IDw9IF9yb3dSYW5nZS5lbmQgJiYgX3Jvd1JhbmdlLmVuZCA8PSBtLnJvd3MAMCA8PSBfY29sUmFuZ2Uuc3RhcnQgJiYgX2NvbFJhbmdlLnN0YXJ0IDw9IF9jb2xSYW5nZS5lbmQgJiYgX2NvbFJhbmdlLmVuZCA8PSBtLmNvbHMAbS5kaW1zIDw9IDIAMCA8PSByb2kueCAmJiAwIDw9IHJvaS53aWR0aCAmJiByb2kueCArIHJvaS53aWR0aCA8PSBtLmNvbHMgJiYgMCA8PSByb2kueSAmJiAwIDw9IHJvaS5oZWlnaHQgJiYgcm9pLnkgKyByb2kuaGVpZ2h0IDw9IG0ucm93cwByYW5nZXMAciA9PSBSYW5nZTo6YWxsKCkgfHwgKDAgPD0gci5zdGFydCAmJiByLnN0YXJ0IDwgci5lbmQgJiYgci5lbmQgPD0gbS5zaXplW2ldKQB1LT5kYXRhICE9IDAgJiYgIkVycm9yIG1hcHBpbmcgb2YgVU1hdCB0byBob3N0IG1lbW9yeS4iAGdldE1hdABjaGFubmVscygpID09IENWX01BVF9DTihkdHlwZSkAY29weVRvAGRzdC51AAAAAAAAhAQBAPQDAAD1AwAA9gMAAPcDAABOMmN2N1RMU0RhdGFJTlNfMThVTWF0RGF0YUF1dG9Mb2NrZXJFRUUAmGoCAFwEAQAAAAAAAQAAAIzyAAAAAAAAdXNhZ2VfY291bnQgPT0gMABsb2NrAHVzYWdlX2NvdW50ID09IDEAcmVsZWFzZQBnbG9iYWwAREVCVUcARElTQUJMRQBESVNBQkxFRABFUlJPUgBGQVRBTABJTkZPAE9GRgBTSUxFTlQAVkVSQk9TRQBXQVJOAFdBUk5JTkcAV0FSTklOR1MAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBnbG9iYWwAZnVsbE5hbWVSZXN1bHQubV9maW5kQ3Jvc3NSZWZlcmVuY2VzAGludGVybmFsX2FwcGx5TmFtZVBhcnRDb25maWdUb1NwZWNpZmljVGFnAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy91dGlscy9sb2d0YWdtYW5hZ2VyLmNwcABuYW1lUGFydFJlc3VsdC5tX2ZpbmRDcm9zc1JlZmVyZW5jZXMAaW50ZXJuYWxfYXBwbHlOYW1lUGFydENvbmZpZ1RvTWF0Y2hpbmdUYWdzAHNjb3BlICE9IE1hdGNoaW5nU2NvcGU6OkZ1bGwAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAFAcBAPgDAAD5AwAA+gMAAIwDAAD7AwAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjV1dGlsczdsb2dnaW5nMThMb2dUYWdDb25maWdQYXJzZXJFTlNfOWFsbG9jYXRvcklTNF9FRUVFAAA8agIAuAYBAMRlAgBOdW1iZXIgb2YgY2hhbm5lbHMgaW4gaW5wdXQgaW1hZ2UgbXVzdCBiZSAxIG9yIDMAZmxvb2RGaWxsAC9zcmMvbW9kdWxlcy9pbWdwcm9jL3NyYy9mbG9vZGZpbGwuY3BwAENvbm5lY3Rpdml0eSBtdXN0IGJlIDQsIDAoPTQpIG9yIDgAbG9fZGlmZiBhbmQgdXBfZGlmZiBtdXN0IGJlIG5vbi1uZWdhdGl2ZQBTZWVkIHBvaW50IGlzIG91dHNpZGUgb2YgaW1hZ2UAAG1hc2sucm93cyA9PSBzaXplLmhlaWdodCsyICYmIG1hc2suY29scyA9PSBzaXplLndpZHRoKzIAbWFzay50eXBlKCkgPT0gQ1ZfOFUAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBJbnZhbGlkIGltYWdlIHR5cGUgKG11c3QgYmUgc2luZ2xlLWNoYW5uZWwpAG1vbWVudHMAL3NyYy9tb2R1bGVzL2ltZ3Byb2Mvc3JjL21vbWVudHMuY3BwAABjb250b3VyLmRlcHRoKCkgPT0gQ1ZfMzJTIHx8IGNvbnRvdXIuZGVwdGgoKSA9PSBDVl8zMkYAY29udG91ck1vbWVudHMAAP0DAAD+AwAA/QMAAP8DAAAABAAATjJjdjlGb3JtYXR0ZWRFABRqAgA0CQEATjJjdjlGb3JtYXR0ZXJFABRqAgBMCQEAAAAAAMwJAQAJBAAACgQAAAsEAACMAwAADAQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3YxNkRlZmF1bHRGb3JtYXR0ZXJFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAA8agIAgAkBAMRlAgAAAAAAOAoBAA0EAAAOBAAADwQAABAEAAARBAAAEgQAABMEAABOMmN2MTZEZWZhdWx0Rm9ybWF0dGVyRQBOMmN2MTNGb3JtYXR0ZXJCYXNlRQAAAAA8agIAFAoBAFwJAQA8agIA/AkBACwKAQBbAF0AAAAAAKwKAQAUBAAAFQQAABYEAACMAwAAFwQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3YxM0Zvcm1hdHRlZEltcGxFTlNfOWFsbG9jYXRvcklTMl9FRUVFADxqAgBkCgEAxGUCAAAAAAAkCwEAGAQAABkEAAAaBAAAGwQAAG0uZGltcyA8PSAyAEZvcm1hdHRlZEltcGwAL3NyYy9tb2R1bGVzL2NvcmUvc3JjL291dC5jcHAAJSUuJWRnAE4yY3YxM0Zvcm1hdHRlZEltcGxFADxqAgAPCwEARAkBACUzZAAlZAAKKDosIDosICVkKSA9IAoAKDosIDosICVkKSA9IAoAAAAAAAAAwAsBABwEAAAdBAAAHgQAAIwDAAAfBAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjE1TWF0bGFiRm9ybWF0dGVyRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAADxqAgB0CwEAxGUCAAAAAAAIDAEADQQAACAEAAAhBAAAEAQAABEEAAASBAAAEwQAAE4yY3YxNU1hdGxhYkZvcm1hdHRlckUAADxqAgDwCwEALAoBAAAAOwBBoJgEC6spgAwBACIEAAAjBAAAJAQAAIwDAAAlBAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjEyQ1NWRm9ybWF0dGVyRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAPGoCADgMAQDEZQIAAAAAAMQMAQANBAAAJgQAACcEAAAQBAAAEQQAABIEAAATBAAATjJjdjEyQ1NWRm9ybWF0dGVyRQA8agIAsAwBACwKAQAAAAAAOA0BACgEAAApBAAAKgQAAIwDAAArBAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjE1UHl0aG9uRm9ybWF0dGVyRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAADxqAgDsDAEAxGUCAAAAAACADQEADQQAACwEAAAtBAAAEAQAABEEAAASBAAAEwQAAE4yY3YxNVB5dGhvbkZvcm1hdHRlckUAADxqAgBoDQEALAoBAAAAAAD0DQEALgQAAC8EAAAwBAAAjAMAADEEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2MTROdW1weUZvcm1hdHRlckVOU185YWxsb2NhdG9ySVMyX0VFRUUAAAAAPGoCAKgNAQDEZQIAAAAAADwOAQANBAAAMgQAADMEAAAQBAAAEQQAABIEAAATBAAATjJjdjE0TnVtcHlGb3JtYXR0ZXJFAAAAPGoCACQOAQAsCgEAdWludDgAaW50OAB1aW50MTYAaW50MTYAaW50MzIAZmxvYXQzMgBmbG9hdDY0AGZsb2F0MTYAW10sW11hcnJheShbAF0sIGR0eXBlPSclcycpAAAAAAAAAAAPAQA0BAAANQQAADYEAACMAwAANwQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3YxMENGb3JtYXR0ZXJFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAADxqAgC4DgEAxGUCAAAAAABEDwEADQQAADgEAAA5BAAAEAQAABEEAAASBAAAEwQAAE4yY3YxMENGb3JtYXR0ZXJFAAAAPGoCADAPAQAsCgEAAAAsAAB7AH0AL3NyYy9tb2R1bGVzL2NvcmUvc3JjL21hdGhmdW5jcy5jcHAAcHQgPT0gTlVMTABjaGVja1JhbmdlAHRoZSB2YWx1ZSBhdCAoJWQsICVkKT0lcyBpcyBvdXQgb2YgcmFuZ2UgWyVmLCAlZikAY3R5cGUgPT0gQ1ZfMzJGIHx8IGN0eXBlID09IENWXzY0RgBzb2x2ZUN1YmljAChjb2VmZnMuc2l6ZSgpID09IFNpemUobjAsIDEpIHx8IGNvZWZmcy5zaXplKCkgPT0gU2l6ZShuMCsxLCAxKSB8fCBjb2VmZnMuc2l6ZSgpID09IFNpemUoMSwgbjApIHx8IGNvZWZmcy5zaXplKCkgPT0gU2l6ZSgxLCBuMCsxKSkAY291bnQgPj0gMCAmJiAoZGVwdGggPT0gQ1ZfMzJGIHx8IGRlcHRoID09IENWXzMyUykAbWluRW5jbG9zaW5nQ2lyY2xlAC9zcmMvbW9kdWxlcy9pbWdwcm9jL3NyYy9zaGFwZWRlc2NyLmNwcAAvc3JjL21vZHVsZXMvY29yZS9zcmMvY29udmVydF9jLmNwcABzcmMuc2l6ZSA9PSBkc3Quc2l6ZSAmJiBzcmMuY2hhbm5lbHMoKSA9PSBkc3QuY2hhbm5lbHMoKQBjdkNvbnZlcnRTY2FsZQA/BAAAPwQAAEAEAABABAAAQQQAAEIEAABDBAAAAAAAAGNuID09IDEAY291bnROb25aZXJvAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9jb3VudF9ub25femVyby5kaXNwYXRjaC5jcHAAZnVuYyAhPSAwAG1hc2suZW1wdHkoKSB8fCBtYXNrLnR5cGUoKSA9PSBDVl84VQBtZWFuAC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9tZWFuLmRpc3BhdGNoLmNwcABjbiA8PSA0ICYmIGZ1bmMgIT0gMAAwIDwgY29pICYmIGNvaSA8PSA0AC9zcmMvbW9kdWxlcy9jb3JlL3NyYy9zdGF0X2MuY3BwAGN2QXZnAC9zcmMvbW9kdWxlcy9jYWxpYjNkL3NyYy9jYWxpYnJhdGlvbi5jcHAASW5wdXQgYXJndW1lbnQgaXMgbm90IGEgdmFsaWQgbWF0cml4AGN2Um9kcmlndWVzMgBUaGUgZmlyc3Qgb3V0cHV0IGFyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIG1hdHJpeABUaGUgbWF0cmljZXMgbXVzdCBoYXZlIDMyZiBvciA2NGYgZGF0YSB0eXBlAEFsbCB0aGUgbWF0cmljZXMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZQBKYWNvYmlhbiBpcyBub3QgYSB2YWxpZCBtYXRyaXgASmFjb2JpYW4gbXVzdCBoYXZlIDMyZkMxIG9yIDY0ZkMxIGRhdGF0eXBlAEphY29iaWFuIG11c3QgYmUgM3g5IG9yIDl4MwBJbnB1dCBtYXRyaXggbXVzdCBiZSAxeDMsIDN4MSBvciAzeDMAT3V0cHV0IG1hdHJpeCBtdXN0IGJlIDN4Mywgc2luZ2xlLWNoYW5uZWwgZmxvYXRpbmcgcG9pbnQgbWF0cml4AE91dHB1dCBtYXRyaXggbXVzdCBiZSAxeDMgb3IgM3gxAElucHV0IG1hdHJpeCBtdXN0IGJlIDF4MyBvciAzeDEgZm9yIGEgcm90YXRpb24gdmVjdG9yLCBvciAzeDMgZm9yIGEgcm90YXRpb24gbWF0cml4AENWX0lTX01BVChvYmplY3RQb2ludHMpICYmIENWX0lTX01BVChpbWFnZVBvaW50cykgJiYgQ1ZfSVNfTUFUKEEpICYmIENWX0lTX01BVChydmVjKSAmJiBDVl9JU19NQVQodHZlYykAY3ZGaW5kRXh0cmluc2ljQ2FtZXJhUGFyYW1zMgAoQ1ZfTUFUX0RFUFRIKHJ2ZWMtPnR5cGUpID09IENWXzY0RiB8fCBDVl9NQVRfREVQVEgocnZlYy0+dHlwZSkgPT0gQ1ZfMzJGKSAmJiAocnZlYy0+cm93cyA9PSAxIHx8IHJ2ZWMtPmNvbHMgPT0gMSkgJiYgcnZlYy0+cm93cypydmVjLT5jb2xzKkNWX01BVF9DTihydmVjLT50eXBlKSA9PSAzAChDVl9NQVRfREVQVEgodHZlYy0+dHlwZSkgPT0gQ1ZfNjRGIHx8IENWX01BVF9ERVBUSCh0dmVjLT50eXBlKSA9PSBDVl8zMkYpICYmICh0dmVjLT5yb3dzID09IDEgfHwgdHZlYy0+Y29scyA9PSAxKSAmJiB0dmVjLT5yb3dzKnR2ZWMtPmNvbHMqQ1ZfTUFUX0NOKHR2ZWMtPnR5cGUpID09IDMAKGNvdW50ID49IDQpIHx8IChjb3VudCA9PSAzICYmIHVzZUV4dHJpbnNpY0d1ZXNzKQAAAACsFgEAYxIBAJUEAAAFAAAAIRcBAH0XAQCDFwEAdm9pZCBjdkZpbmRFeHRyaW5zaWNDYW1lcmFQYXJhbXMyKGNvbnN0IEN2TWF0ICosIGNvbnN0IEN2TWF0ICosIGNvbnN0IEN2TWF0ICosIGNvbnN0IEN2TWF0ICosIEN2TWF0ICosIEN2TWF0ICosIGludCkARExUIGFsZ29yaXRobSBuZWVkcyBhdCBsZWFzdCA2IHBvaW50cyBmb3IgcG9zZSBlc3RpbWF0aW9uIGZyb20gM0QtMkQgcG9pbnQgY29ycmVzcG9uZGVuY2VzLgBjb3VudAA2AGZhYnMoc2MpID4gREJMX0VQU0lMT04AuBcBAGMSAQCXDQAAAAAAADQUAQD9FwEAAxgBAHZvaWQgY3Y6OlJvZHJpZ3Vlcyhjdjo6SW5wdXRBcnJheSwgY3Y6Ok91dHB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXkpAHNyY1N6AHNyY1N6ID09IFNpemUoMywgMSkgfHwgc3JjU3ogPT0gU2l6ZSgxLCAzKSB8fCAoc3JjU3ogPT0gU2l6ZSgxLCAxKSAmJiBzcmMuY2hhbm5lbHMoKSA9PSAzKSB8fCBzcmNTeiA9PSBTaXplKDMsIDMpAG5wb2ludHMgPj0gMCAmJiAoZGVwdGggPT0gQ1ZfMzJGIHx8IGRlcHRoID09IENWXzY0RikAcHJvamVjdFBvaW50cwBfaXBvaW50cy5uZWVkZWQoKQBPbmUgb2YgcmVxdWlyZWQgYXJndW1lbnRzIGlzIG5vdCBhIHZhbGlkIG1hdHJpeABjdlByb2plY3RQb2ludHMySW50ZXJuYWwASG9tb2dlbmVvdXMgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQAUm90YXRpb24gbXVzdCBiZSByZXByZXNlbnRlZCBieSAxeDMgb3IgM3gxIGZsb2F0aW5nLXBvaW50IHJvdGF0aW9uIHZlY3Rvciwgb3IgM3gzIHJvdGF0aW9uIG1hdHJpeABUcmFuc2xhdGlvbiB2ZWN0b3IgbXVzdCBiZSAxeDMgb3IgM3gxIGZsb2F0aW5nLXBvaW50IHZlY3RvcgBJbnRyaW5zaWMgcGFyYW1ldGVycyBtdXN0IGJlIDN4MyBmbG9hdGluZy1wb2ludCBtYXRyaXgAZHAvZHJvdCBtdXN0IGJlIDJOeDMgZmxvYXRpbmctcG9pbnQgbWF0cml4AGRwL2RUIG11c3QgYmUgMk54MyBmbG9hdGluZy1wb2ludCBtYXRyaXgAZHAvZGYgbXVzdCBiZSAyTngyIGZsb2F0aW5nLXBvaW50IG1hdHJpeABkcC9kYyBtdXN0IGJlIDJOeDIgZmxvYXRpbmctcG9pbnQgbWF0cml4AGRwL2RmIG11c3QgYmUgMk54MTQsIDJOeDEyLCAyTng4LCAyTng1LCAyTng0IG9yIDJOeDIgZmxvYXRpbmctcG9pbnQgbWF0cml4AGRpc3RDb2VmZnMgaXMgTlVMTCB3aGlsZSBkcGRrIGlzIG5vdABkcC9kbyBtdXN0IGJlIDJOeDNOIGZsb2F0aW5nLXBvaW50IG1hdHJpeABEaXN0b3J0aW9uIGNvZWZmaWNpZW50cyBtdXN0IGJlIDF4NCwgNHgxLCAxeDUsIDV4MSwgMXg4LCA4eDEsIDF4MTIsIDEyeDEsIDF4MTQgb3IgMTR4MSBmbG9hdGluZy1wb2ludCB2ZWN0b3IAAAAAAAA0HAEARAQAAEUEAABGBAAARwQAAEgEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQNUN2TWF0TjJjdjE0RGVmYXVsdERlbGV0ZXJJUzFfRUVOU185YWxsb2NhdG9ySVMxX0VFRUUAAAAAPGoCANwbAQDEZQIATjJjdjE0RGVmYXVsdERlbGV0ZXJJNUN2TWF0RUUAZGF0YSAmJiBkaW1zIDw9IDIgJiYgcm93cyA9PSBtICYmIGNvbHMgPT0gbiAmJiBjaGFubmVscygpID09IDEAb3BlcmF0b3IgTWF0eAAvc3JjL21vZHVsZXMvY29yZS9pbmNsdWRlL29wZW5jdjIvY29yZS9tYXQuaW5sLmhwcABfdy5kYXRhID09ICh1Y2hhciopJncudmFsWzBdICYmIF91LmRhdGEgPT0gKHVjaGFyKikmdS52YWxbMF0gJiYgX3Z0LmRhdGEgPT0gKHVjaGFyKikmdnQudmFsWzBdAGNvbXB1dGUAL3NyYy9tb2R1bGVzL2NvcmUvaW5jbHVkZS9vcGVuY3YyL2NvcmUvb3BlcmF0aW9ucy5ocHAAIWVyci5lbXB0eSgpAHVwZGF0ZQAvc3JjL21vZHVsZXMvY2FsaWIzZC9zcmMvY29tcGF0X3B0c2V0cmVnLmNwcABzdGF0ZSA9PSBDSEVDS19FUlIAZHN0LnJvd3MgPT0gZHN0MC5jb2xzICYmIGRzdC5jb2xzID09IGRzdDAucm93cwBjdkNvbnZlcnRQb2ludHNIb21vZ2VuZW91cwBkc3Quc2l6ZSgpID09IGRzdDAuc2l6ZSgpAFRoZSBpbnB1dCBhcnJheXMgc2hvdWxkIGJlIDJEIG9yIDNEIHBvaW50IHNldHMAZmluZEhvbW9ncmFwaHkAL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL2Z1bmRhbS5jcHAAVGhlIGlucHV0IGFycmF5cyBzaG91bGQgaGF2ZSBhdCBsZWFzdCA0IGNvcnJlc3BvbmRpbmcgcG9pbnQgc2V0cyB0byBjYWxjdWxhdGUgSG9tb2dyYXBoeQBzcmMuY2hlY2tWZWN0b3IoMikgPT0gZHN0LmNoZWNrVmVjdG9yKDIpAFVua25vd24gZXN0aW1hdGlvbiBtZXRob2QAbnBvaW50cyA+PSAwAGNvbnZlcnRQb2ludHNGcm9tSG9tb2dlbmVvdXMAbnBvaW50cyA+PSAwICYmIChkZXB0aCA9PSBDVl8zMlMgfHwgZGVwdGggPT0gQ1ZfMzJGIHx8IGRlcHRoID09IENWXzY0RikAZHN0LmlzQ29udGludW91cygpAABjb252ZXJ0UG9pbnRzVG9Ib21vZ2VuZW91cwAAAAAAAABIIAEASQQAAEoEAABLBAAAjAMAAEwEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2MjdIb21vZ3JhcGh5RXN0aW1hdG9yQ2FsbGJhY2tFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAAAPGoCAPAfAQDEZQIAAAAAAMAgAQBNBAAATgQAAE8EAABQBAAAUQQAAE4yY3YyN0hvbW9ncmFwaHlFc3RpbWF0b3JDYWxsYmFja0UATjJjdjE5UG9pbnRTZXRSZWdpc3RyYXRvcjhDYWxsYmFja0UAABRqAgCTIAEAPGoCAHAgAQC4IAEAQdTBBAuD6AEBAAAAAgAAAAEAAAACAAAAAwAAAAAAAAACAAAAAwAAAAAAAAABAAAAAwAAAAAAAABwIQEAUgQAAFMEAABUBAAAjAMAAFUEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2MjRIb21vZ3JhcGh5UmVmaW5lQ2FsbGJhY2tFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAA8agIAHCEBAMRlAgAAAAAA0CEBAFYEAABXBAAAWAQAAE4yY3YyNEhvbW9ncmFwaHlSZWZpbmVDYWxsYmFja0UATjJjdjhMTVNvbHZlcjhDYWxsYmFja0UAFGoCALAhAQA8agIAkCEBAMghAQBKLmlzQ29udGludW91cygpICYmIEouY29scyA9PSA4AGNvbXB1dGUAAAAAAFAiAQBZBAAAWgQAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAG15X29iamVjdABmb3JtYXQATjJjdjlBbGdvcml0aG1FAAAAABRqAgA9IgEATm8gZWxlbWVudCBuYW1lIGhhcyBiZWVuIGdpdmVuAG9wZXJhdG9yPDwAL3NyYy9tb2R1bGVzL2NvcmUvaW5jbHVkZS9vcGVuY3YyL2NvcmUvcGVyc2lzdGVuY2UuaHBwAAAAAAAAAAAgIwEAYQQAAGIEAABjBAAAjAMAAGQEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2MTJMTVNvbHZlckltcGxFTlNfOWFsbG9jYXRvcklTMl9FRUVFAAA8agIA2CIBAMRlAgAAAAAAkCMBAGUEAABmBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAZwQAAGgEAABpBAAATjJjdjEyTE1Tb2x2ZXJJbXBsRQBOMmN2OExNU29sdmVyRQAAPGoCAHQjAQBQIgEAPGoCAGAjAQCEIwEAKHBhcmFtMC5jb2xzID09IDEgfHwgcGFyYW0wLnJvd3MgPT0gMSkgJiYgKHB0eXBlID09IENWXzMyRiB8fCBwdHlwZSA9PSBDVl82NEYpAHJ1bgAvc3JjL21vZHVsZXMvY2FsaWIzZC9zcmMvbGV2bWFycS5jcHAAY2IAQS50eXBlKCkgPT0gQ1ZfNjRGICYmIEEucm93cyA9PSBseAAlYyUxMGQgJTEwZCAlMTUuNGUgJTE2LjRlICUxNy40ZSAlMTYuNGUgJTE3LjRlCgBpdGVycyA+IDAAc2V0TWF4SXRlcnMACWl0cgluZkoJCVNVTShyXjIpCQl4CQlkeAkJbAkJbGMAKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqAHRoZSBudW1iZXIgb2YgbW9kZWwgcG9pbnRzIHNob3VsZCBiZSBwb3NpdGl2ZQBSQU5TQUNVcGRhdGVOdW1JdGVycwAvc3JjL21vZHVsZXMvY2FsaWIzZC9zcmMvcHRzZXRyZWcuY3BwAAAAAAAA2CUBAGoEAABrBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAbAQAAG0EAABOMmN2MjVSQU5TQUNQb2ludFNldFJlZ2lzdHJhdG9yRQBOMmN2MTlQb2ludFNldFJlZ2lzdHJhdG9yRQA8agIAsSUBAFAiAQA8agIAkCUBAMwlAQBjYgBydW4AY29uZmlkZW5jZSA+IDAgJiYgY29uZmlkZW5jZSA8IDEAY291bnQgPj0gMCAmJiBjb3VudDIgPT0gY291bnQAKGJlc3RNYXNrLmNvbHMgPT0gMSB8fCBiZXN0TWFzay5yb3dzID09IDEpICYmIChpbnQpYmVzdE1hc2sudG90YWwoKSA9PSBjb3VudABtb2RlbC5yb3dzICUgbm1vZGVscyA9PSAwAChlc3oxICUgc2l6ZW9mKGludCkpID09IDAgJiYgKGVzejIgJSBzaXplb2YoaW50KSkgPT0gMABnZXRTdWJzZXQAY291bnQgPj0gbW9kZWxQb2ludHMgJiYgY291bnQgPT0gY291bnQyAGVyci5pc0NvbnRpbnVvdXMoKSAmJiBlcnIudHlwZSgpID09IENWXzMyRiAmJiBtYXNrLmlzQ29udGludW91cygpICYmIG1hc2sudHlwZSgpID09IENWXzhVAGZpbmRJbmxpZXJzAAAAAACwJwEAagQAAG4EAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAABsBAAAbwQAAE4yY3YyNExNZURTUG9pbnRTZXRSZWdpc3RyYXRvckUAPGoCAJAnAQDYJQEAKG1hc2suY29scyA9PSAxIHx8IG1hc2sucm93cyA9PSAxKSAmJiAoaW50KW1hc2sudG90YWwoKSA9PSBjb3VudABlcnJmLmlzQ29udGludW91cygpICYmIGVycmYudHlwZSgpID09IENWXzMyRiAmJiAoaW50KWVycmYudG90YWwoKSA9PSBjb3VudAAAAAAA1CgBAEQEAABwBAAAcQQAAHIEAABzBAAATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE4yY3YyNVJBTlNBQ1BvaW50U2V0UmVnaXN0cmF0b3JFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTMl9FRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAAADxqAgBkKAEAxGUCAE5TdDNfXzIxNGRlZmF1bHRfZGVsZXRlSU4yY3YyNVJBTlNBQ1BvaW50U2V0UmVnaXN0cmF0b3JFRUUAAAAAAACoKQEARAQAAHQEAAB1BAAAdgQAAHcEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQTjJjdjI0TE1lRFNQb2ludFNldFJlZ2lzdHJhdG9yRU5TXzE0ZGVmYXVsdF9kZWxldGVJUzJfRUVOU185YWxsb2NhdG9ySVMyX0VFRUUAAAAAPGoCADgpAQDEZQIATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjJjdjI0TE1lRFNQb2ludFNldFJlZ2lzdHJhdG9yRUVFAE9QRU5DVl9CVUZGRVJfQVJFQV9BTFdBWVNfU0FGRQB0b3RhbFNpemUgPiAwAGNvbW1pdAAvc3JjL21vZHVsZXMvY29yZS9zcmMvYnVmZmVyX2FyZWEuY3BwAG9uZUJ1ZiA9PSBOVUxMACFibG9ja3MuZW1wdHkoKQBwdHIgJiYgKnB0ciA9PSBOVUxMAEJsb2NrAHJlYWxfYWxsb2NhdGUAcmVpbnRlcnByZXRfY2FzdDxzaXplX3Q+KCpwdHIpICUgYWxpZ25tZW50ID09IDAAc3RhdGljX2Nhc3Q8dWNoYXIqPigqcHRyKSArIHR5cGVfc2l6ZSAqIGNvdW50IDw9IHN0YXRpY19jYXN0PHVjaGFyKj4ocmF3X21lbSkgKyB0eXBlX3NpemUgKiBhbGxvY2F0ZWRfY291bnQAcHRyICYmICpwdHIAZmFzdF9hbGxvY2F0ZQByZWludGVycHJldF9jYXN0PHNpemVfdD4oYnVmKSAlIGFsaWdubWVudCA9PSAwAGNsZWFudXAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAFCwBAHgEAAB5BAAAegQAAHsEAAB8BAAAfQQAAH4EAAB/BAAATjJjdjEzUkhPX0hFU1RfUkVGQ0UATjJjdjhSSE9fSEVTVEUAFGoCAP0rAQA8agIA6CsBAAwsAQBwdHIgPT0gTlVMTABhbGxvY2F0ZQAvc3JjL21vZHVsZXMvY29yZS9pbmNsdWRlL29wZW5jdjIvY29yZS91dGlscy9idWZmZXJfYXJlYS5wcml2YXRlLmhwcABjb3VudCA+IDAAYWxpZ25tZW50ID4gMABhbGlnbm1lbnQgJSBzaXplb2YoVCkgPT0gMAAoYWxpZ25tZW50ICYgKGFsaWdubWVudCAtIDEpKSA9PSAwAHB0ciAhPSBOVUxMAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAKAtAQBEBAAAgAQAAIEEAACCBAAAgwQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9wb2ludGVySVBOMmN2MTNSSE9fSEVTVF9SRUZDRU5TXzE0ZGVmYXVsdF9kZWxldGVJUzJfRUVOU185YWxsb2NhdG9ySVMyX0VFRUUAAAA8agIAPC0BAMRlAgBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlOMmN2MTNSSE9fSEVTVF9SRUZDRUVFAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAADwuAQCmLgEAVQAAAAAAAADILgEA+y4BAAMvAQB2b2lkIGN2OjpJUFBFOjpQb3NlU29sdmVyOjpzb2x2ZUdlbmVyaWMoY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXksIGN2OjpPdXRwdXRBcnJheSkAL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL2lwcGUuY3BwAFR5cGUgb2YgX29iamVjdFBvaW50cyBtdXN0IGJlIENWXzMyRkMzIG9yIENWXzY0RkMzAG9ialR5cGUAb2JqVHlwZSA9PSBDVl8zMkZDMyB8fCBvYmpUeXBlID09IENWXzY0RkMzAAAAPC4BAKYuAQBXAAAAAAAAAEwvAQCILwEAky8BAFR5cGUgb2YgX25vcm1hbGl6ZWRJbnB1dFBvaW50cyBtdXN0IGJlIENWXzMyRkMyIG9yIENWXzY0RkMyAHR5cGVfaW5wdXQAdHlwZV9pbnB1dCA9PSBDVl8zMkZDMiB8fCB0eXBlX2lucHV0ID09IENWXzY0RkMyAF9vYmplY3RQb2ludHMucm93cygpID09IDEgfHwgX29iamVjdFBvaW50cy5jb2xzKCkgPT0gMQBzb2x2ZUdlbmVyaWMAX29iamVjdFBvaW50cy5yb3dzKCkgPj0gNCB8fCBfb2JqZWN0UG9pbnRzLmNvbHMoKSA+PSA0AF9ub3JtYWxpemVkSW5wdXRQb2ludHMucm93cygpID09IDEgfHwgX25vcm1hbGl6ZWRJbnB1dFBvaW50cy5jb2xzKCkgPT0gMQBzdGF0aWNfY2FzdDxzaXplX3Q+KF9vYmplY3RQb2ludHMucm93cygpKSAqIHN0YXRpY19jYXN0PHNpemVfdD4oX29iamVjdFBvaW50cy5jb2xzKCkpID09IG4AX29iamVjdFBvaW50cy50eXBlKCkAFDEBAKYuAQAoAQAAAAAAAFgxAQB0MQEAfjEBAHZvaWQgY3Y6OklQUEU6OlBvc2VTb2x2ZXI6OnJvdDJ2ZWMoY3Y6OklucHV0QXJyYXksIGN2OjpPdXRwdXRBcnJheSkAVHlwZSBvZiBfUiBtdXN0IGJlIENWXzY0RkMxAF9SLnR5cGUoKQBfUi50eXBlKCkgPT0gQ1ZfNjRGQzEAX1Iucm93cygpID09IDMAcm90MnZlYwBfUi5jb2xzKCkgPT0gMwAAANgxAQCmLgEASwEAAAAAAABHMgEA4zABAG4yAQB2b2lkIGN2OjpJUFBFOjpQb3NlU29sdmVyOjpjb21wdXRlVHJhbnNsYXRpb24oY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6SW5wdXRBcnJheSwgY3Y6Ok91dHB1dEFycmF5KQBUeXBlIG9mIF9vYmplY3RQb2ludHMgbXVzdCBiZSBDVl82NEZDMgBfb2JqZWN0UG9pbnRzLnR5cGUoKSA9PSBDVl82NEZDMgAA2DEBAKYuAQBNAQAAAAAAAKwyAQDaMgEA9jIBAFR5cGUgb2YgX25vcm1hbGl6ZWRJbWdQb2ludHMgbXVzdCBiZSBDVl82NEZDMgBfbm9ybWFsaXplZEltZ1BvaW50cy50eXBlKCkAX25vcm1hbGl6ZWRJbWdQb2ludHMudHlwZSgpID09IENWXzY0RkMyAAAA2DEBAKYuAQBPAQAAAAAAAFgxAQB0MQEAfjEBAF9SLnJvd3MoKSA9PSAzICYmIF9SLmNvbHMoKSA9PSAzAGNvbXB1dGVUcmFuc2xhdGlvbgBfbm9ybWFsaXplZEltZ1BvaW50cy5yb3dzKCkgPT0gMSB8fCBfbm9ybWFsaXplZEltZ1BvaW50cy5jb2xzKCkgPT0gMQBuID09IHN0YXRpY19jYXN0PHNpemVfdD4oX29iamVjdFBvaW50cy5yb3dzKCkgKiBfb2JqZWN0UG9pbnRzLmNvbHMoKSkAY29tcHV0ZVJvdGF0aW9ucwBnYW1tYSBpcyB6ZXJvLgAAODQBAKYuAQACAgAAAAAAAJc0AQDKNAEA3zQBAHZvaWQgY3Y6OklQUEU6OlBvc2VTb2x2ZXI6OmhvbW9ncmFwaHlGcm9tU3F1YXJlUG9pbnRzKGN2OjpJbnB1dEFycmF5LCBkb3VibGUsIGN2OjpPdXRwdXRBcnJheSkAVHlwZSBvZiBfdGFyZ2V0UG9pbnRzIG11c3QgYmUgQ1ZfMzJGQzIgb3IgQ1ZfNjRGQzIAX3RhcmdldFBvaW50cy50eXBlKCkAX3RhcmdldFBvaW50cy50eXBlKCkgPT0gQ1ZfMzJGQzIgfHwgX3RhcmdldFBvaW50cy50eXBlKCkgPT0gQ1ZfNjRGQzIARGV0ZXJtaW5hbnQgaXMgemVybyEAaG9tb2dyYXBoeUZyb21TcXVhcmVQb2ludHMAcDUBAKYuAQBAAgAAAAAAAMguAQD7LgEAAy8BAHZvaWQgY3Y6OklQUEU6OlBvc2VTb2x2ZXI6Om1ha2VDYW5vbmljYWxPYmplY3RQb2ludHMoY3Y6OklucHV0QXJyYXksIGN2OjpPdXRwdXRBcnJheSwgY3Y6Ok91dHB1dEFycmF5KQBDYW5ub3QgdHJhbnNmb3JtIG9iamVjdCBwb2ludHMgdG8gdGhlIHBsYW5lIHo9MCEAbWFrZUNhbm9uaWNhbE9iamVjdFBvaW50cwBzMyAvIHMyIDwgSVBQRV9TTUFMTABjb21wdXRlT2JqZXh0U3BhY2VSU3ZEAERhdGEucm93cyA9PSAxIHx8IERhdGEuY29scyA9PSAxAG5vcm1hbGl6ZURhdGFJc290cm9waWMARGF0YS5jaGFubmVscygpID09IDIgfHwgRGF0YS5jaGFubmVscygpID09IDMAbnVtUG9pbnRzID49IDQAAADgNgEApi4BAG0DAAAAAAAAUTcBAJU3AQCeNwEAdm9pZCBjdjo6SG9tb2dyYXBoeUhPOjpub3JtYWxpemVEYXRhSXNvdHJvcGljKGN2OjpJbnB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXksIGN2OjpPdXRwdXRBcnJheSwgY3Y6Ok91dHB1dEFycmF5KQBUeXBlIG9mIF9EYXRhIG11c3QgYmUgb25lIG9mIENWXzMyRkMyLCBDVl8zMkZDMywgQ1ZfNjRGQzIsIENWXzY0RkMzAGRhdGFUeXBlAGRhdGFUeXBlID09IENWXzMyRkMyIHx8IGRhdGFUeXBlID09IENWXzMyRkMzIHx8IGRhdGFUeXBlID09IENWXzY0RkMyIHx8IGRhdGFUeXBlID09IENWXzY0RkMzAG4gPT0gRGF0YUIuY29scwBob21vZ3JhcGh5SE8AL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL3NvbHZlcG5wLmNwcABucG9pbnRzID09IHN0ZDo6bWF4KGlwb2ludHMuY2hlY2tWZWN0b3IoMiwgQ1ZfMzJGKSwgaXBvaW50cy5jaGVja1ZlY3RvcigyLCBDVl82NEYpKQBzb2x2ZVAzUABucG9pbnRzID09IDMgfHwgbnBvaW50cyA9PSA0AGZsYWdzID09IFNPTFZFUE5QX1AzUCB8fCBmbGFncyA9PSBTT0xWRVBOUF9BUDNQACggKG5wb2ludHMgPj0gNCkgfHwgKG5wb2ludHMgPT0gMyAmJiBmbGFncyA9PSBTT0xWRVBOUF9JVEVSQVRJVkUgJiYgdXNlRXh0cmluc2ljR3Vlc3MpIHx8IChucG9pbnRzID49IDMgJiYgZmxhZ3MgPT0gU09MVkVQTlBfU1FQTlApICkgJiYgbnBvaW50cyA9PSBzdGQ6Om1heChpcG9pbnRzLmNoZWNrVmVjdG9yKDIsIENWXzMyRiksIGlwb2ludHMuY2hlY2tWZWN0b3IoMiwgQ1ZfNjRGKSkAc29sdmVQblBHZW5lcmljACFfcnZlYy5lbXB0eSgpICYmICFfdHZlYy5lbXB0eSgpAChydHlwZSA9PSBDVl8zMkZDMSB8fCBydHlwZSA9PSBDVl82NEZDMSkgJiYgKHR0eXBlID09IENWXzMyRkMxIHx8IHR0eXBlID09IENWXzY0RkMxKQAocnNpemUgPT0gU2l6ZSgxLCAzKSB8fCByc2l6ZSA9PSBTaXplKDMsIDEpKSAmJiAodHNpemUgPT0gU2l6ZSgxLCAzKSB8fCB0c2l6ZSA9PSBTaXplKDMsIDEpKQBucG9pbnRzID09IDQAVGhlIGZsYWdzIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIFNPTFZFUE5QX0lURVJBVElWRSwgU09MVkVQTlBfUDNQLCBTT0xWRVBOUF9FUE5QLCBTT0xWRVBOUF9ETFMsIFNPTFZFUE5QX1VQTlAsIFNPTFZFUE5QX0FQM1AsIFNPTFZFUE5QX0lQUEUsIFNPTFZFUE5QX0lQUEVfU1FVQVJFIG9yIFNPTFZFUE5QX1NRUE5QAHZlY19ydmVjcy5zaXplKCkgPT0gdmVjX3R2ZWNzLnNpemUoKQAArDsBABg4AQBbBAAAAAAAAIE8AQC5PAEA0jwBAGludCBjdjo6c29sdmVQblBHZW5lcmljKGN2OjpJbnB1dEFycmF5LCBjdjo6SW5wdXRBcnJheSwgY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXlPZkFycmF5cywgY3Y6Ok91dHB1dEFycmF5T2ZBcnJheXMsIGJvb2wsIGN2OjpTb2x2ZVBuUE1ldGhvZCwgY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXkpAFR5cGUgb2YgcmVwcm9qZWN0aW9uRXJyb3IgbXVzdCBiZSBDVl8zMkZDMSBvciBDVl82NEZDMSEAcmVwcm9qZWN0aW9uRXJyb3IudHlwZSgpAHR5cGUgPT0gQ1ZfMzJGQzEgfHwgdHlwZSA9PSBDVl82NEZDMQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAC9zcmMvbW9kdWxlcy9jb3JlL2luY2x1ZGUvb3BlbmN2Mi9jb3JlL21hdC5pbmwuaHBwAERhdGFUeXBlPF9UcD46OmNoYW5uZWxzID09IG0uY2hhbm5lbHMoKSB8fCBtLmVtcHR5KCkAb3BlcmF0b3I9AAAAAMw9AQBAPgEAVgAAAAAAAABjPgEAlT4BAJ0+AQB2b2lkIGN2OjpzcXBucDo6UG9zZVNvbHZlcjo6c29sdmUoY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6T3V0cHV0QXJyYXlPZkFycmF5cywgY3Y6Ok91dHB1dEFycmF5T2ZBcnJheXMpAC9zcmMvbW9kdWxlcy9jYWxpYjNkL3NyYy9zcXBucC5jcHAAVHlwZSBvZiBvYmplY3RQb2ludHMgbXVzdCBiZSBDVl8zMkZDMyBvciBDVl82NEZDMwBvYmpUeXBlAG9ialR5cGUgPT0gQ1ZfMzJGQzMgfHwgb2JqVHlwZSA9PSBDVl82NEZDMwDMPQEAQD4BAFoAAAAAAAAA5D4BABU/AQAdPwEAVHlwZSBvZiBpbWFnZVBvaW50cyBtdXN0IGJlIENWXzMyRkMyIG9yIENWXzY0RkMyAGltZ1R5cGUAaW1nVHlwZSA9PSBDVl8zMkZDMiB8fCBpbWdUeXBlID09IENWXzY0RkMyAG9iamVjdFBvaW50cy5yb3dzKCkgPT0gMSB8fCBvYmplY3RQb2ludHMuY29scygpID09IDEAc29sdmUAb2JqZWN0UG9pbnRzLnJvd3MoKSA+PSAzIHx8IG9iamVjdFBvaW50cy5jb2xzKCkgPj0gMwBpbWFnZVBvaW50cy5yb3dzKCkgPT0gMSB8fCBpbWFnZVBvaW50cy5jb2xzKCkgPT0gMQBpbWFnZVBvaW50cy5yb3dzKCkgKiBpbWFnZVBvaW50cy5jb2xzKCkgPT0gb2JqZWN0UG9pbnRzLnJvd3MoKSAqIG9iamVjdFBvaW50cy5jb2xzKCkAcG9pbnRfY29vcmRpbmF0ZV92YXJpYW5jZSA+PSBQT0lOVF9WQVJJQU5DRV9USFJFU0hPTEQAY29tcHV0ZU9tZWdhAHNfKDApID49IDFlLTcAKytudW1fbnVsbF92ZWN0b3JzXyA8PSA2AGRhdGEgJiYgZGltcyA8PSAyICYmIChyb3dzID09IDEgfHwgY29scyA9PSAxKSAmJiByb3dzICsgY29scyAtIDEgPT0gbiAmJiBjaGFubmVscygpID09IDEAb3BlcmF0b3IgVmVjAC9zcmMvbW9kdWxlcy9jb3JlL2luY2x1ZGUvb3BlbmN2Mi9jb3JlL21hdC5pbmwuaHBwAGRhdGEgJiYgZGltcyA8PSAyICYmIHJvd3MgPT0gbSAmJiBjb2xzID09IG4gJiYgY2hhbm5lbHMoKSA9PSAxAG9wZXJhdG9yIE1hdHgAL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL3VuZGlzdG9ydC5kaXNwYXRjaC5jcHAAbnBvaW50cyA+PSAwICYmIHNyYy5pc0NvbnRpbnVvdXMoKSAmJiAoZGVwdGggPT0gQ1ZfMzJGIHx8IGRlcHRoID09IENWXzY0RikAdW5kaXN0b3J0UG9pbnRzAGNyaXRlcmlhLmlzVmFsaWQoKQBjdlVuZGlzdG9ydFBvaW50c0ludGVybmFsAENWX0lTX01BVChfc3JjKSAmJiBDVl9JU19NQVQoX2RzdCkgJiYgKF9zcmMtPnJvd3MgPT0gMSB8fCBfc3JjLT5jb2xzID09IDEpICYmIChfZHN0LT5yb3dzID09IDEgfHwgX2RzdC0+Y29scyA9PSAxKSAmJiBfc3JjLT5jb2xzICsgX3NyYy0+cm93cyAtIDEgPT0gX2RzdC0+cm93cyArIF9kc3QtPmNvbHMgLSAxICYmIChDVl9NQVRfVFlQRShfc3JjLT50eXBlKSA9PSBDVl8zMkZDMiB8fCBDVl9NQVRfVFlQRShfc3JjLT50eXBlKSA9PSBDVl82NEZDMikgJiYgKENWX01BVF9UWVBFKF9kc3QtPnR5cGUpID09IENWXzMyRkMyIHx8IENWX01BVF9UWVBFKF9kc3QtPnR5cGUpID09IENWXzY0RkMyKQBDVl9JU19NQVQoX2NhbWVyYU1hdHJpeCkgJiYgX2NhbWVyYU1hdHJpeC0+cm93cyA9PSAzICYmIF9jYW1lcmFNYXRyaXgtPmNvbHMgPT0gMwBDVl9JU19NQVQoX2Rpc3RDb2VmZnMpICYmIChfZGlzdENvZWZmcy0+cm93cyA9PSAxIHx8IF9kaXN0Q29lZmZzLT5jb2xzID09IDEpICYmIChfZGlzdENvZWZmcy0+cm93cypfZGlzdENvZWZmcy0+Y29scyA9PSA0IHx8IF9kaXN0Q29lZmZzLT5yb3dzKl9kaXN0Q29lZmZzLT5jb2xzID09IDUgfHwgX2Rpc3RDb2VmZnMtPnJvd3MqX2Rpc3RDb2VmZnMtPmNvbHMgPT0gOCB8fCBfZGlzdENvZWZmcy0+cm93cypfZGlzdENvZWZmcy0+Y29scyA9PSAxMiB8fCBfZGlzdENvZWZmcy0+cm93cypfZGlzdENvZWZmcy0+Y29scyA9PSAxNCkAQ1ZfSVNfTUFUKG1hdFIpICYmIG1hdFItPnJvd3MgPT0gMyAmJiBtYXRSLT5jb2xzID09IDMAQ1ZfSVNfTUFUKG1hdFApICYmIG1hdFAtPnJvd3MgPT0gMyAmJiAobWF0UC0+Y29scyA9PSAzIHx8IG1hdFAtPmNvbHMgPT0gNCkAAAAAAAxGAQCEBAAAhQQAAIYEAACMAwAAhwQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzIzSG9tb2dyYXBoeUVzdGltYXRvckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAA8agIAtEUBAMRlAgAAAAAA0EYBAIgEAACJBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAigQAAIsEAACMBAAAjQQAAI4EAACPBAAAkAQAAE4yY3Y0dXNhYzIzSG9tb2dyYXBoeUVzdGltYXRvckltcGxFAE4yY3Y0dXNhYzE5SG9tb2dyYXBoeUVzdGltYXRvckUATjJjdjR1c2FjOUVzdGltYXRvckUAAAAAPGoCAKBGAQBQIgEAPGoCAIBGAQC4RgEAPGoCAFxGAQDERgEAAAAAAFBHAQCRBAAAkgQAAJMEAACMAwAAlAQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzI0RnVuZGFtZW50YWxFc3RpbWF0b3JJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIA+EYBAMRlAgAAAAAA9EcBAJUEAACWBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAlwQAAJgEAACZBAAAmgQAAJsEAACcBAAAnQQAAE4yY3Y0dXNhYzI0RnVuZGFtZW50YWxFc3RpbWF0b3JJbXBsRQBOMmN2NHVzYWMyMEZ1bmRhbWVudGFsRXN0aW1hdG9yRQAAADxqAgDFRwEAuEYBADxqAgCgRwEA6EcBAAAAAAB0SAEAngQAAJ8EAACgBAAAjAMAAKEEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyMkVzc2VudGlhbEVzdGltYXRvckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCABxIAQDEZQIAAAAAABRJAQCiBAAAowQAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAKQEAAClBAAApgQAAKcEAACoBAAAqQQAAKoEAABOMmN2NHVzYWMyMkVzc2VudGlhbEVzdGltYXRvckltcGxFAE4yY3Y0dXNhYzE4RXNzZW50aWFsRXN0aW1hdG9yRQAAADxqAgDnSAEAuEYBADxqAgDESAEACEkBAAAAAACQSQEAqwQAAKwEAACtBAAAjAMAAK4EAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxOUFmZmluZUVzdGltYXRvckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAA8agIAPEkBAMRlAgAAAAAAKEoBAK8EAACwBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAsQQAALIEAACzBAAAtAQAALUEAAC2BAAAtwQAAE4yY3Y0dXNhYzE5QWZmaW5lRXN0aW1hdG9ySW1wbEUATjJjdjR1c2FjMTVBZmZpbmVFc3RpbWF0b3JFADxqAgAASgEAuEYBADxqAgDgSQEAHEoBAAAAAACgSgEAuAQAALkEAAC6BAAAjAMAALsEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxNlBuUEVzdGltYXRvckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFADxqAgBQSgEAxGUCAAAAAAA0SwEAvAQAAL0EAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAAC+BAAAvwQAAMAEAADBBAAAwgQAAMMEAADEBAAATjJjdjR1c2FjMTZQblBFc3RpbWF0b3JJbXBsRQBOMmN2NHVzYWMxMlBuUEVzdGltYXRvckUAAAA8agIADUsBALhGAQA8agIA8EoBAChLAQAAAAAAvEsBAMUEAADGBAAAxwQAAIwDAADIBAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMzBSZXByb2plY3Rpb25FcnJvclN5bW1ldHJpY0ltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCAFxLAQDEZQIAAAAAAHxMAQDJBAAAygQAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAMsEAADMBAAAzQQAAM4EAABOMmN2NHVzYWMzMFJlcHJvamVjdGlvbkVycm9yU3ltbWV0cmljSW1wbEUATjJjdjR1c2FjMjZSZXByb2plY3Rpb25FcnJvclN5bW1ldHJpY0UATjJjdjR1c2FjNUVycm9yRQAAPGoCAFJMAQBQIgEAPGoCACtMAQBkTAEAPGoCAABMAQBwTAEAIW1vZGVsLmVtcHR5KCkAc2V0TW9kZWxQYXJhbWV0ZXJzAC9zcmMvbW9kdWxlcy9jYWxpYjNkL3NyYy91c2FjL2VzdGltYXRvci5jcHAAAAD0TAEAqkwBAPIAAAABAAAAT00BAFBNAQBeTQEAdmlydHVhbCB2b2lkIGN2Ojp1c2FjOjpSZXByb2plY3Rpb25FcnJvclN5bW1ldHJpY0ltcGw6OnNldE1vZGVsUGFyYW1ldGVycyhjb25zdCBjdjo6TWF0ICYpAABtb2RlbC5kZXB0aCgpAENWXzY0RgAAAAD0TAEAqkwBAPoAAAABAAAAT00BAIRNAQBeTQEAbW9kZWxfaW52LmRlcHRoKCkAAAAAAAAAEE4BAM8EAADQBAAA0QQAAIwDAADSBAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjhSZXByb2plY3Rpb25FcnJvckZvcndhcmRJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIAtE0BAMRlAgAAAAAAsE4BANMEAADUBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAA1QQAANYEAADXBAAA2AQAAE4yY3Y0dXNhYzI4UmVwcm9qZWN0aW9uRXJyb3JGb3J3YXJkSW1wbEUATjJjdjR1c2FjMjRSZXByb2plY3Rpb25FcnJvckZvcndhcmRFAAAAPGoCAH1OAQBkTAEAPGoCAFROAQCkTgEA2E4BAKpMAQA2AQAAAQAAAE9NAQBQTQEAXk0BAHZpcnR1YWwgdm9pZCBjdjo6dXNhYzo6UmVwcm9qZWN0aW9uRXJyb3JGb3J3YXJkSW1wbDo6c2V0TW9kZWxQYXJhbWV0ZXJzKGNvbnN0IGN2OjpNYXQgJikAAAAAAAAAAKBPAQDZBAAA2gQAANsEAACMAwAA3AQAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzE2U2FtcHNvbkVycm9ySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAPGoCAFBPAQDEZQIAAAAAAChQAQDdBAAA3gQAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAN8EAADgBAAA4QQAAOIEAABOMmN2NHVzYWMxNlNhbXBzb25FcnJvckltcGxFAE4yY3Y0dXNhYzEyU2FtcHNvbkVycm9yRQAAADxqAgABUAEAZEwBADxqAgDkTwEAHFABAFBQAQCqTAEAbAEAAAEAAABPTQEAUE0BAF5NAQB2aXJ0dWFsIHZvaWQgY3Y6OnVzYWM6OlNhbXBzb25FcnJvckltcGw6OnNldE1vZGVsUGFyYW1ldGVycyhjb25zdCBjdjo6TWF0ICYpAAAAAAAAAAAcUQEA4wQAAOQEAADlBAAAjAMAAOYEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMzMFN5bW1ldHJpY0dlb21ldHJpY0Rpc3RhbmNlSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAA8agIAvFABAMRlAgAAAAAAwFEBAOcEAADoBAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAA6QQAAOoEAADrBAAA7AQAAE4yY3Y0dXNhYzMwU3ltbWV0cmljR2VvbWV0cmljRGlzdGFuY2VJbXBsRQBOMmN2NHVzYWMyNlN5bW1ldHJpY0dlb21ldHJpY0Rpc3RhbmNlRQAAADxqAgCLUQEAZEwBADxqAgBgUQEAtFEBAOhRAQCqTAEAswEAAAEAAABPTQEAUE0BAF5NAQB2aXJ0dWFsIHZvaWQgY3Y6OnVzYWM6OlN5bW1ldHJpY0dlb21ldHJpY0Rpc3RhbmNlSW1wbDo6c2V0TW9kZWxQYXJhbWV0ZXJzKGNvbnN0IGN2OjpNYXQgJikAAAAAAAC8UgEA7QQAAO4EAADvBAAAjAMAAPAEAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyOFJlcHJvamVjdGlvbkVycm9yUG1hdHJpeEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFADxqAgBgUgEAxGUCAAAAAABcUwEA8QQAAPIEAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAADzBAAA9AQAAPUEAAD2BAAATjJjdjR1c2FjMjhSZXByb2plY3Rpb25FcnJvclBtYXRyaXhJbXBsRQBOMmN2NHVzYWMyNFJlcHJvamVjdGlvbkVycm9yUG1hdHJpeEUAAAA8agIAKVMBAGRMAQA8agIAAFMBAFBTAQCEUwEAqkwBAPMBAAABAAAAT00BAFBNAQBeTQEAdmlydHVhbCB2b2lkIGN2Ojp1c2FjOjpSZXByb2plY3Rpb25FcnJvclBtYXRyaXhJbXBsOjpzZXRNb2RlbFBhcmFtZXRlcnMoY29uc3QgY3Y6Ok1hdCAmKQAAAAAAAAAAXFQBAPcEAAD4BAAA+QQAAIwDAAD6BAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMzBSZXByb2plY3Rpb25EaXN0YW5jZUFmZmluZUltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCAPxTAQDEZQIAAAAAAPxUAQD7BAAA/AQAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAP0EAAD+BAAA/wQAAAAFAABOMmN2NHVzYWMzMFJlcHJvamVjdGlvbkRpc3RhbmNlQWZmaW5lSW1wbEUATjJjdjR1c2FjMjNSZXByb2plY3Rpb25FcnJvckFmZmluZUUAADxqAgDLVAEAZEwBADxqAgCgVAEA8FQBACRVAQCqTAEAMgIAAAEAAABPTQEAUE0BAF5NAQB2aXJ0dWFsIHZvaWQgY3Y6OnVzYWM6OlJlcHJvamVjdGlvbkRpc3RhbmNlQWZmaW5lSW1wbDo6c2V0TW9kZWxQYXJhbWV0ZXJzKGNvbnN0IGN2OjpNYXQgJikAAAAAAADwVQEAAQUAAAIFAAADBQAAjAMAAAQFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxN05vcm1UcmFuc2Zvcm1JbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAAAA8agIAnFUBAMRlAgAAAAAAbFYBAFkEAAAFBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAABgUAAE4yY3Y0dXNhYzE3Tm9ybVRyYW5zZm9ybUltcGxFAE4yY3Y0dXNhYzEzTm9ybVRyYW5zZm9ybUUAPGoCAEZWAQBQIgEAPGoCAChWAQBgVgEAau+0kfhb/D+X5Adq9OvyPxjoHI5Rzu4/eA8/zFbj6T+9fAalHhzmP0klaRRqE+M/7paM61GT4D8RwUV/cvXcP/lNK4LQZtk/szpJKBhb1j9TKofBw7rTP55BfNzGc9E/xZ3YveDvzj95gyzgv3fLP3A1fRulbMg/8EpNuUq/xT9x/PtL92LDP7LZUuz4TME/7E3nW4Lovj9vLO2hMKK7P/dD7KvCubg/7K+zKtUjtj+wHKGMj9azP9KyCoBmybE/Xw7IXtPprz/8O8OhNKWsP3noBXWRuak/HAJmMe8cpz8LI8drh8akP/sXavqerqI/gSdmHmPOoD8//tKHlz+eP+IOXQEEO5s/6bdYQpSFmD9kypxq4RaWPxchHU5055M/qeZq86jwkT/Np9nBlSyQPxlibLDrK40/BeJKNSxQij/I8gcwib2HPzIxhuuDbIU/1j3GOmlWgz/YbIvhOnWBP0ugH0w3h38/IkS5ant5fD8A/7Efprh5P8FPj3v/PHc/yrkZKJv/dD/UvuCxQvpyPwAAAAAAAAAA/hAgMhEokj+9o2fKNFCoP5P141vWKLU/ewboUjjivj/OiJImmHjEP9va1LK1isk/Maxfr5KRzj+jMM13Ab/RPwbq5Ju/ItQ/wBck/Gpw1j+4/+ympKXYPykyVun3wNo/qJE3a6DB3D91nekPX6feP7cJq6EsOeA/39O97H8R4T8WLpDH/dzhPxRKEucOnOI/ScqdXCpP4z/Jt33i0PbjPxrzOSmJk+Q/xnpI8Nwl5T8kedvAVq7lP8iYfiqALeY/mxr/Z+Cj5j9LZUxY+xHnP3nlBbtQeOc/t9eSo1vX5z+eQx8Yki/oP/uF1tNkgeg/EndMJT/N6D95UVDjhhPpP2SKcHOcVOk/AXRR3tqQ6T+ilKvul8jpPy6+WVgk/Ok/OilY5csr6j/E7Pmm1VfqP7ny7CmEgOo/sBTpqxWm6j/b2B9SxMjqP8xasV/G6Oo/+e6Ra04G6z9RXWyViyHrPwVGJ7mpOus/R1HKoNFR6z/L8pE0KWfrPxNxD6nTeus/0Q4/q/GM6z9q77SR+Fv8P7f5yDTC1fY/Bec0keaf9D8n4frC2/ryPzEx8xCWovE/9GKclGJ88D+XEmccxvTuP/cPdc9+KO0/ZJ4O6OuI6z/undbwTQ7qP9s4Il3usug/DQBCKG9y5z/b2Nf1YEnmP1Qnifb/NOU/1hoEdwcz5D9C4FRck0HjP/2ZE4sKX+I/swzgNw+K4T+Bdz1Bc8HgP43IbV0vBOA/ruEanrii3j9kMpwpW1DdP3uMXWbaD9w/otuMpvDf2j/Pi7QJeb/ZPyNnb/5qrdg/LIs7i9ao1z9iqV414bDWP7yXgGbDxNU/aPLEOMbj1D+YzH6WQQ3UP8lgnJ6aQNM/oxn3QUJ90j/4RA4QtMLRP+oohit1ENE/WjYzYBNm0D9h/zOrSIbPP3/AZLOJTs4/H4fogDAkzT+eyZGqjwbMP4xH57cE9co/vLvPPffuyT9dh6MS2PPIPxdPtZYgA8g/q8TQDlIcxz/8tIoO9T7GP5tQivCYasU/oEM0W9OexD8NuFbQP9vDPxiXo0Z/H8M/YWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAA3FsBAAgFAAAJBQAACgUAAIwDAAALBQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMTdSYW5zYWNRdWFsaXR5SW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCAIhbAQDEZQIAAAAAAJRcAQAMBQAADQUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAA4FAAAPBQAAEAUAABEFAAASBQAAEwUAABQFAAAVBQAATjJjdjR1c2FjMTdSYW5zYWNRdWFsaXR5SW1wbEUATjJjdjR1c2FjMTNSYW5zYWNRdWFsaXR5RQBOMmN2NHVzYWM3UXVhbGl0eUUAADxqAgBoXAEAUCIBADxqAgBOXAEAfFwBADxqAgAwXAEAiFwBAGdldFNjb3JlKGVycm9ycykAZ2V0U2NvcmUAL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL3VzYWMvLi4vdXNhYy5ocHAAAAAAAFBdAQAWBQAAFwUAABgFAACMAwAAGQUAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzE1TXNhY1F1YWxpdHlJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAPGoCAABdAQDEZQIAAAAAAORdAQAaBQAAGwUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAABwFAAAPBQAAHQUAAB4FAAAfBQAAIAUAACEFAAAiBQAATjJjdjR1c2FjMTVNc2FjUXVhbGl0eUltcGxFAE4yY3Y0dXNhYzExTXNhY1F1YWxpdHlFADxqAgDAXQEAfFwBADxqAgCkXQEA2F0BAAAAAABgXgEAIwUAACQFAAAlBQAAjAMAACYFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxN01hZ3NhY1F1YWxpdHlJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAAAA8agIADF4BAMRlAgAAAAAA+F4BACcFAAAoBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAKQUAACoFAAArBQAALAUAAC0FAAAuBQAALwUAADAFAABOMmN2NHVzYWMxN01hZ3NhY1F1YWxpdHlJbXBsRQBOMmN2NHVzYWMxM01hZ3NhY1F1YWxpdHlFADxqAgDSXgEAfFwBADxqAgC0XgEA7F4BAAAAAABwXwEAMQUAADIFAAAzBQAAjAMAADQFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxNkxNZWRzUXVhbGl0eUltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFADxqAgAgXwEAxGUCAAAAAAAIYAEANQUAADYFAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAAA3BQAADwUAADgFAAA5BQAAOgUAADsFAAA8BQAAPQUAAE4yY3Y0dXNhYzE2TE1lZHNRdWFsaXR5SW1wbEUATjJjdjR1c2FjMTJMTWVkc1F1YWxpdHlFAAAAPGoCAOFfAQB8XAEAPGoCAMRfAQD8XwEAAAAAAIRgAQA+BQAAPwUAAEAFAACMAwAAQQUAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzE3TW9kZWxWZXJpZmllckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAADxqAgAwYAEAxGUCAAAAAAAUYQEAQgUAAEMFAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAABEBQAARQUAAEYFAABHBQAASAUAAEkFAABOMmN2NHVzYWMxN01vZGVsVmVyaWZpZXJJbXBsRQBOMmN2NHVzYWMxM01vZGVsVmVyaWZpZXJFADxqAgDuYAEAUCIBADxqAgDQYAEACGEBAAAAAACEYQEASgUAAEsFAABMBQAAjAMAAE0FAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWM4U1BSVEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAA8agIAPGEBAMRlAgAAAAAABGIBAE4FAABPBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAUAUAAFEFAABSBQAAUwUAAFQFAABVBQAAVgUAAE4yY3Y0dXNhYzhTUFJUSW1wbEUATjJjdjR1c2FjNFNQUlRFADxqAgDoYQEACGEBADxqAgDUYQEA+GEBAAAAAACQYgEAVwUAAFgFAABZBQAAjAMAAFoFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMzNEhvbW9ncmFwaHlNaW5pbWFsU29sdmVyNHB0c0dFTUltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCACxiAQDEZQIAAAAAAGBjAQBZBAAAWwUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAFwFAABdBQAAXgUAAF8FAABOMmN2NHVzYWMzNEhvbW9ncmFwaHlNaW5pbWFsU29sdmVyNHB0c0dFTUltcGxFAE4yY3Y0dXNhYzMwSG9tb2dyYXBoeU1pbmltYWxTb2x2ZXI0cHRzR0VNRQBOMmN2NHVzYWMxM01pbmltYWxTb2x2ZXJFADxqAgAuYwEAUCIBADxqAgADYwEASGMBADxqAgDUYgEAVGMBAAAAAADoYwEAYAUAAGEFAABiBQAAjAMAAGMFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMzMEhvbW9ncmFwaHlOb25NaW5pbWFsU29sdmVySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAA8agIAiGMBAMRlAgAAAAAAtGQBAGQFAABlBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAZgUAAGcFAABoBQAAaQUAAE4yY3Y0dXNhYzMwSG9tb2dyYXBoeU5vbk1pbmltYWxTb2x2ZXJJbXBsRQBOMmN2NHVzYWMyNkhvbW9ncmFwaHlOb25NaW5pbWFsU29sdmVyRQBOMmN2NHVzYWMxNk5vbk1pbmltYWxTb2x2ZXJFAAA8agIAfmQBAFAiAQA8agIAV2QBAJxkAQA8agIALGQBAKhkAQAAAAAANGUBAGoFAABrBQAAbAUAAIwDAABtBQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjNBZmZpbmVNaW5pbWFsU29sdmVySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAADxqAgDcZAEAxGUCAAAAAADIZQEAWQQAAG4FAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAABvBQAAcAUAAHEFAAByBQAATjJjdjR1c2FjMjNBZmZpbmVNaW5pbWFsU29sdmVySW1wbEUATjJjdjR1c2FjMTlBZmZpbmVNaW5pbWFsU29sdmVyRQA8agIAnGUBAEhjAQA8agIAeGUBALxlAQAAAAAATGYBAHMFAAB0BQAAdQUAAIwDAAB2BQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjZBZmZpbmVOb25NaW5pbWFsU29sdmVySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAA8agIA8GUBAMRlAgAAAAAA6GYBAFkEAAB3BQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAeAUAAHkFAAB6BQAAewUAAE4yY3Y0dXNhYzI2QWZmaW5lTm9uTWluaW1hbFNvbHZlckltcGxFAE4yY3Y0dXNhYzIyQWZmaW5lTm9uTWluaW1hbFNvbHZlckUAAAA8agIAt2YBAJxkAQA8agIAkGYBANxmAQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAAAAAAC0ZwEAfAUAAH0FAAB+BQAAjAMAAH8FAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMzMEVwaXBvbGFyR2VvbWV0cnlEZWdlbmVyYWN5SW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAA8agIAVGcBAMRlAgAAAAAAWGgBAFkEAACABQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAgQUAAIIFAACDBQAAhAUAAE4yY3Y0dXNhYzMwRXBpcG9sYXJHZW9tZXRyeURlZ2VuZXJhY3lJbXBsRQBOMmN2NHVzYWMyNkVwaXBvbGFyR2VvbWV0cnlEZWdlbmVyYWN5RQAAADxqAgAjaAEAIIMBADxqAgD4ZwEATGgBAGRhdGEgJiYgZGltcyA8PSAyICYmIChyb3dzID09IDEgfHwgY29scyA9PSAxKSAmJiByb3dzICsgY29scyAtIDEgPT0gbiAmJiBjaGFubmVscygpID09IDEAb3BlcmF0b3IgVmVjAC9zcmMvbW9kdWxlcy9jb3JlL2luY2x1ZGUvb3BlbmN2Mi9jb3JlL21hdC5pbmwuaHBwAAAAAAAAAAB0aQEAhQUAAIYFAACHBQAAjAMAAIgFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyNEhvbW9ncmFwaHlEZWdlbmVyYWN5SW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAPGoCABxpAQDEZQIAAAAAAAxqAQBZBAAAiQUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAIoFAACLBQAAgwUAAIwFAABOMmN2NHVzYWMyNEhvbW9ncmFwaHlEZWdlbmVyYWN5SW1wbEUATjJjdjR1c2FjMjBIb21vZ3JhcGh5RGVnZW5lcmFjeUUAAAA8agIA3WkBACCDAQA8agIAuGkBAABqAQAAAAAAkGoBAI0FAACOBQAAjwUAAIwDAACQBQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjVGdW5kYW1lbnRhbERlZ2VuZXJhY3lJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAAAA8agIANGoBAMRlAgAAAAAAKGsBAJEFAACSBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAgQUAAJMFAACUBQAAlQUAAE4yY3Y0dXNhYzI1RnVuZGFtZW50YWxEZWdlbmVyYWN5SW1wbEUATjJjdjR1c2FjMjFGdW5kYW1lbnRhbERlZ2VuZXJhY3lFADxqAgD6agEATGgBADxqAgDUagEAHGsBAAAAAACoawEAlgUAAJcFAACYBQAAjAMAAJkFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyM0Vzc2VudGlhbERlZ2VuZXJhY3lJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAPGoCAFBrAQDEZQIAAAAAADxsAQCaBQAAmwUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAIEFAACcBQAAgwUAAJ0FAABOMmN2NHVzYWMyM0Vzc2VudGlhbERlZ2VuZXJhY3lJbXBsRQBOMmN2NHVzYWMxOUVzc2VudGlhbERlZ2VuZXJhY3lFADxqAgAQbAEATGgBADxqAgDsawEAMGwBAAAAAADEbAEAngUAAJ8FAACgBQAAjAMAAKEFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMzMkZ1bmRhbWVudGFsTWluaW1hbFNvbHZlcjdwdHNJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIAZGwBAMRlAgAAAAAAbG0BAFkEAACiBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAowUAAKQFAAClBQAApgUAAE4yY3Y0dXNhYzMyRnVuZGFtZW50YWxNaW5pbWFsU29sdmVyN3B0c0ltcGxFAE4yY3Y0dXNhYzI4RnVuZGFtZW50YWxNaW5pbWFsU29sdmVyN3B0c0UAAAA8agIANW0BAEhjAQA8agIACG0BAGBtAQAAAAAA9G0BAKcFAACoBQAAqQUAAIwDAACqBQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMzJGdW5kYW1lbnRhbE1pbmltYWxTb2x2ZXI4cHRzSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAPGoCAJRtAQDEZQIAAAAAAJxuAQBZBAAAqwUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAKwFAACtBQAArgUAAK8FAABOMmN2NHVzYWMzMkZ1bmRhbWVudGFsTWluaW1hbFNvbHZlcjhwdHNJbXBsRQBOMmN2NHVzYWMyOEZ1bmRhbWVudGFsTWluaW1hbFNvbHZlcjhwdHNFAAAAPGoCAGVuAQBIYwEAPGoCADhuAQCQbgEAAAAAACRvAQCwBQAAsQUAALIFAACMAwAAswUAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzMxRnVuZGFtZW50YWxOb25NaW5pbWFsU29sdmVySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAADxqAgDEbgEAxGUCAAAAAADIbwEAtAUAALUFAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAAC2BQAAtwUAALgFAAC5BQAATjJjdjR1c2FjMzFGdW5kYW1lbnRhbE5vbk1pbmltYWxTb2x2ZXJJbXBsRQBOMmN2NHVzYWMyN0Z1bmRhbWVudGFsTm9uTWluaW1hbFNvbHZlckUAPGoCAJRvAQCcZAEAPGoCAGhvAQC8bwEAAAAAAFhwAQC6BQAAuwUAALwFAACMAwAAvQUAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzM5RXNzZW50aWFsTWluaW1hbFNvbHZlclN0ZXdlbml1czVwdHNJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAPGoCAPBvAQDEZQIAAAAAAAxxAQBZBAAAvgUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAL8FAADABQAAwQUAAMIFAABOMmN2NHVzYWMzOUVzc2VudGlhbE1pbmltYWxTb2x2ZXJTdGV3ZW5pdXM1cHRzSW1wbEUATjJjdjR1c2FjMzVFc3NlbnRpYWxNaW5pbWFsU29sdmVyU3Rld2VuaXVzNXB0c0UAPGoCANBwAQBIYwEAPGoCAJxwAQAAcQEAVG8gdXNlIGVzc2VudGlhbCBtYXRyaXggc29sdmVyIExBUEFDSyBvciBFaWdlbiBoYXMgdG8gYmUgaW5zdGFsbGVkIQBlc3RpbWF0ZQAvc3JjL21vZHVsZXMvY2FsaWIzZC9zcmMvdXNhYy9lc3NlbnRpYWxfc29sdmVyLmNwcAAAAAAAFHIBAMMFAADEBQAAxQUAAIwDAADGBQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjlFc3NlbnRpYWxOb25NaW5pbWFsU29sdmVySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCALRxAQDEZQIAAAAAALRyAQBZBAAAxwUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAMgFAADJBQAAygUAAMsFAABOMmN2NHVzYWMyOUVzc2VudGlhbE5vbk1pbmltYWxTb2x2ZXJJbXBsRQBOMmN2NHVzYWMyNUVzc2VudGlhbE5vbk1pbmltYWxTb2x2ZXJFADxqAgCCcgEAnGQBADxqAgBYcgEAqHIBAAAAAAAocwEAzAUAAM0FAADOBQAAjAMAAM8FAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxMERMU1BuUEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCANxyAQDEZQIAAAAAAKRzAQBZBAAA0AUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAANEFAADSBQAA0wUAANQFAABOMmN2NHVzYWMxMERMU1BuUEltcGxFAE4yY3Y0dXNhYzZETFNQblBFAAAAADxqAgCDcwEAnGQBADxqAgBscwEAmHMBAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAGh0AQDVBQAA1gUAANcFAACMAwAA2AUAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzI0UG5QTWluaW1hbFNvbHZlcjZQdHNJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIAEHQBAMRlAgAAAAAAAHUBAFkEAADZBQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAA2gUAANsFAADcBQAA3QUAAE4yY3Y0dXNhYzI0UG5QTWluaW1hbFNvbHZlcjZQdHNJbXBsRQBOMmN2NHVzYWMyMFBuUE1pbmltYWxTb2x2ZXI2UHRzRQAAADxqAgDRdAEASGMBADxqAgCsdAEA9HQBAAAAAACAdQEA3gUAAN8FAADgBQAAjAMAAOEFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyM1BuUE5vbk1pbmltYWxTb2x2ZXJJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAPGoCACh1AQDEZQIAAAAAABR2AQBZBAAA4gUAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAOMFAADkBQAA5QUAAOYFAABOMmN2NHVzYWMyM1BuUE5vbk1pbmltYWxTb2x2ZXJJbXBsRQBOMmN2NHVzYWMxOVBuUE5vbk1pbmltYWxTb2x2ZXJFADxqAgDodQEAnGQBADxqAgDEdQEACHYBAAAAAACMdgEA5wUAAOgFAADpBQAAjAMAAOoFAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxM1AzUFNvbHZlckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAADxqAgA8dgEAxGUCAAAAAAAMdwEAWQQAAOsFAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAADsBQAA7QUAAO4FAADvBQAATjJjdjR1c2FjMTNQM1BTb2x2ZXJJbXBsRQBOMmN2NHVzYWM5UDNQU29sdmVyRQAAPGoCAOp2AQBIYwEAPGoCANB2AQAAdwEAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAxHcBAPAFAADxBQAA8gUAAIwDAADzBQAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMTJHcmFwaEN1dEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFADxqAgB4dwEAxGUCAAAAAABkeAEA9AUAAPUFAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAAD2BQAA9wUAAE4yY3Y0dXNhYzEyR3JhcGhDdXRJbXBsRQBOMmN2NHVzYWM4R3JhcGhDdXRFAE4yY3Y0dXNhYzE3TG9jYWxPcHRpbWl6YXRpb25FAAA8agIALXgBAFAiAQA8agIAGXgBAEx4AQA8agIAAHgBAFh4AQBpPj0wICYmIGk8KGludCl2dGNzLnNpemUoKQBhZGRUZXJtV2VpZ2h0cwAvc3JjL21vZHVsZXMvaW1ncHJvYy9pbmNsdWRlL29wZW5jdjIvaW1ncHJvYy9kZXRhaWwvZ2NncmFwaC5ocHAAYWRkRWRnZXMAaj49MCAmJiBqPChpbnQpdnRjcy5zaXplKCkAdz49MCAmJiByZXZ3Pj0wAGkgIT0gagAhdnRjcy5lbXB0eSgpAG1heEZsb3cAIWVkZ2VzLmVtcHR5KCkAbWluV2VpZ2h0ID4gMABpblNvdXJjZVNlZ21lbnQAAAAAANh5AQD4BQAA+QUAAPoFAACMAwAA+wUAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzM1SW5uZXJJdGVyYXRpdmVMb2NhbE9wdGltaXphdGlvbkltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAA8agIAdHkBAMRlAgAAAAAAfHoBAPwFAAD9BQAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAA/gUAAP8FAABOMmN2NHVzYWMzNUlubmVySXRlcmF0aXZlTG9jYWxPcHRpbWl6YXRpb25JbXBsRQBOMmN2NHVzYWMzMUlubmVySXRlcmF0aXZlTG9jYWxPcHRpbWl6YXRpb25FADxqAgBEegEATHgBADxqAgAUegEAcHoBAAAAAAD4egEAAAYAAAEGAAACBgAAjAMAAAMGAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxOFNpZ21hQ29uc2Vuc3VzSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAA8agIApHoBAMRlAgAAAAAAfHsBAAQGAAAFBgAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAABgYAAAcGAABOMmN2NHVzYWMxOFNpZ21hQ29uc2Vuc3VzSW1wbEUATjJjdjR1c2FjMTRTaWdtYUNvbnNlbnN1c0UAAAA8agIAU3sBAEx4AQA8agIANHsBAHB7AQAAAAAAAHwBAAgGAAAJBgAACgYAAIwDAAALBgAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjVMZWFzdFNxdWFyZXNQb2xpc2hpbmdJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAAAA8agIApHsBAMRlAgAAAAAAuHwBAAwGAAANBgAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAADgYAAE4yY3Y0dXNhYzI1TGVhc3RTcXVhcmVzUG9saXNoaW5nSW1wbEUATjJjdjR1c2FjMjFMZWFzdFNxdWFyZXNQb2xpc2hpbmdFAE4yY3Y0dXNhYzE4RmluYWxNb2RlbFBvbGlzaGVyRQAAPGoCAIB8AQBQIgEAPGoCAF58AQCgfAEAPGoCADh8AQCsfAEASW5jb3JyZWN0IGZsYWcgZm9yIFVTQUMhAHNldFBhcmFtZXRlcnMAL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL3VzYWMvcmFuc2FjX3NvbHZlcnMuY3BwADh9AQDrfAEAIAMAAAEAAADzfQEAF34BADt+AQBib29sIGN2Ojp1c2FjOjpydW4oY29uc3QgUHRyPGNvbnN0IGN2Ojp1c2FjOjpNb2RlbD4gJiwgY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBpbnQsIFB0cjxjdjo6dXNhYzo6UmFuc2FjT3V0cHV0PiAmLCBjdjo6SW5wdXRBcnJheSwgY3Y6OklucHV0QXJyYXksIGN2OjpJbnB1dEFycmF5LCBjdjo6SW5wdXRBcnJheSkASW50cmluc2ljIG1hdHJpeCBtdXN0IG5vdCBiZSBlbXB0eSEAKGludCkoIUsxXy5lbXB0eSgpICYmICFLMl8uZW1wdHkoKSkAMQBHcmFwaCB0eXBlIGlzIG5vdCBpbXBsZW1lbnRlZCEAcnVuADh9AQDrfAEASQMAAAEAAAB8fgEAqn4BAL9+AQBQcm9ncmVzc2l2ZU5BUFNBQyBmb3IgUG5QIGlzIG5vdCBpbXBsZW1lbnRlZCEAKGludClwYXJhbXMtPmlzUG5QKCkAMABQcm9ncmVzc2l2ZSBOQVBTQUMgc2FtcGxlcjogQ2VsbCBudW1iZXIgaW4gbGF5ZXJzIG11c3QgYmUgaW4gZGVjcmVhc2luZyBvcmRlciEARXJyb3IgbWV0cmljIGlzIG5vdCBpbXBsZW1lbnRlZCEAU2NvcmUgaXMgbm90IGltZXBsZW1ldGVkIQBFc3RpbWF0b3Igbm90IGltcGxlbWVudGVkIQBTYW1wbGVyIGlzIG5vdCBpbXBsZW1lbnRlZCEAVmVyaWZpZXIgaXMgbm90IGltZXBsZW1lbnRlZCEATG9jYWwgT3B0aW1pemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCEAAOR/AQDrfAEAigEAAAUAAABlgAEAgIABAIyAAQBhdXRvIGN2Ojp1c2FjOjptZXJnZVBvaW50cyhjdjo6SW5wdXRBcnJheSwgY3Y6OklucHV0QXJyYXksIGN2OjpNYXQgJiwgYm9vbCk6Oihhbm9ueW1vdXMgY2xhc3MpOjpvcGVyYXRvcigpKGN2OjpNYXQgJiwgaW50KSBjb25zdABJbnZhbGlkIGRpbWVuc2lvbiBvZiBwb2ludABwb2ludHMuY29scwBwdF9kaW0AYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAABSBAQAQBgAAEQYAABIGAABOMmN2MjlQYXJhbGxlbExvb3BCb2R5TGFtYmRhV3JhcHBlckUAAAAAPGoCAOyAAQCorgAAAAAAAACCAQATBgAAFAYAABUGAAAWBgAAFwYAABgGAAAZBgAAGgYAABsGAABOU3QzX18yMTBfX2Z1bmN0aW9uNl9fZnVuY0laTjJjdjR1c2FjNlJhbnNhYzNydW5FUk5TMl8zUHRySU5TM18xMlJhbnNhY091dHB1dEVFRUVVbFJLTlMyXzVSYW5nZUVFX05TXzlhbGxvY2F0b3JJU0NfRUVGdlNCX0VFRQBOU3QzX18yMTBfX2Z1bmN0aW9uNl9fYmFzZUlGdlJLTjJjdjVSYW5nZUVFRUUAFGoCAMqBAQA8agIATIEBAPiBAQBaTjJjdjR1c2FjNlJhbnNhYzNydW5FUk5TXzNQdHJJTlMwXzEyUmFuc2FjT3V0cHV0RUVFRVVsUktOU181UmFuZ2VFRV8AAAAUagIADIIBAAAAAADEggEAHAYAAB0GAAAeBgAAjAMAAB8GAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMxMERlZ2VuZXJhY3lFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCAHiCAQDEZQIAAAAAACCDAQBZBAAAIAYAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAIEFAACLBQAAgwUAACEGAABOMmN2NHVzYWMxMERlZ2VuZXJhY3lFAAA8agIACIMBAFAiAQAAAAAAmIMBACIGAAAjBgAAJAYAAIwDAAAlBgAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMTZSYW5zYWNPdXRwdXRJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIASIMBAMRlAgAAAAAAPIQBACYGAAAnBgAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAKAYAACkGAAAqBgAAKwYAACwGAAAtBgAALgYAAC8GAAAwBgAAMQYAADIGAABOMmN2NHVzYWMxNlJhbnNhY091dHB1dEltcGxFAE4yY3Y0dXNhYzEyUmFuc2FjT3V0cHV0RQAAADxqAgAVhAEAUCIBADxqAgD4gwEAMIQBAAAAAACshAEAMwYAADQGAAA1BgAAjAMAADYGAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWM5TW9kZWxJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIAZIQBAMRlAgAAAAAAJIYBADcGAAA4BgAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAOQYAADoGAAA7BgAAPAYAAD0GAAA+BgAAPwYAAEAGAABBBgAAQgYAAEMGAABEBgAARQYAAEYGAABHBgAASAYAAEkGAABKBgAASwYAAEwGAABNBgAATgYAAE8GAABQBgAAUQYAAFIGAABTBgAAVAYAAFUGAABWBgAAVwYAAFgGAABZBgAAWgYAAFsGAABcBgAAXQYAAF4GAABfBgAAYAYAAGEGAABiBgAAYwYAAGQGAABlBgAAZgYAAGcGAABoBgAAaQYAAGoGAABrBgAAbAYAAG0GAABuBgAAbwYAAHAGAABxBgAARXN0aW1hdG9yIGhhcyBub3QgaW1wbGVtZW50ZWQgeWV0IQBNb2RlbEltcGwATjJjdjR1c2FjOU1vZGVsSW1wbEUATjJjdjR1c2FjNU1vZGVsRQAAPGoCAAaGAQBQIgEAPGoCAPGFAQAYhgEATjJjdjR1c2FjN1NhbXBsZXJFAAA8agIAMIYBAFAiAQBOMmN2NHVzYWMxM1Byb3NhY1NhbXBsZXJFAAAAPGoCAFCGAQBEhgEAAAAAAOiGAQByBgAAcwYAAHQGAACMAwAAdQYAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzE4VW5pZm9ybVNhbXBsZXJJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAADxqAgCUhgEAxGUCAAAAAABwhwEAdgYAAHcGAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAAB4BgAAeQYAAHoGAABOMmN2NHVzYWMxOFVuaWZvcm1TYW1wbGVySW1wbEUATjJjdjR1c2FjMTRVbmlmb3JtU2FtcGxlckUAAAA8agIAR4cBAESGAQA8agIAKIcBAGSHAQBzYW1wbGVfc2l6ZSA8PSBwb2ludHNfc2l6ZV8Ac2V0UG9pbnRzU2l6ZQAvc3JjL21vZHVsZXMvY2FsaWIzZC9zcmMvdXNhYy9zYW1wbGVyLmNwcABzYW1wbGVfc2l6ZV8gPD0gcG9pbnRzX3NpemVfAHNldE5ld1BvaW50c1NpemUAAAAAAAAAcIgBAHsGAAB8BgAAfQYAAIwDAAB+BgAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMTdQcm9zYWNTYW1wbGVySW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCAByIAQDEZQIAAAAAAOyIAQB/BgAAgAYAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAIEGAACCBgAAgwYAAIQGAACFBgAAhgYAAFByb3NhY1NhbXBsZXJJbXBsAE4yY3Y0dXNhYzE3UHJvc2FjU2FtcGxlckltcGxFADxqAgDOiAEAbIYBAENoYW5naW5nIHBvaW50cyBzaXplIGluIFBST1NBQyByZXF1aXJlcyB0byBjaGFuZ2UgYWxzbyB0ZXJtaW5hdGlvbiBjcml0ZXJpYSEgVXNlIFBST1NBQyBzaW1wbGVyIHZlcnNpb24AAAAAANSJAQCHBgAAiAYAAIkGAACMAwAAigYAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzIxUHJvZ3Jlc3NpdmVOYXBzYWNJbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAAAA8agIAfIkBAMRlAgAAAAAAeIoBAIsGAACMBgAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAjQYAAI4GAACPBgAAUHJvZ3Jlc3NpdmVOYXBzYWNJbXBsAE4yY3Y0dXNhYzIxUHJvZ3Jlc3NpdmVOYXBzYWNJbXBsRQBOMmN2NHVzYWMxN1Byb2dyZXNzaXZlTmFwc2FjRQAAADxqAgBMigEARIYBADxqAgAqigEAbIoBAENoYW5naW5nIHBvaW50cyBzaXplIHJlcXVpcmVzIGNoYW5naW5nIG5laWdoYm9yaG9vZCBncmFwaCEgWW91IG11c3QgcmVpbml0aWFsaXplIFAtTkFQU0FDIQAAAAAAAFCLAQCQBgAAkQYAAJIGAACMAwAAkwYAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzE3TmFwc2FjU2FtcGxlckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAADxqAgD8igEAxGUCAAAAAAAEjAEAlAYAAJUGAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAACWBgAAlwYAAJgGAABwb2ludHNfc2l6ZV8gPj0gc2FtcGxlX3NpemVfAE5hcHNhY1NhbXBsZXJJbXBsAE4yY3Y0dXNhYzE3TmFwc2FjU2FtcGxlckltcGxFAE4yY3Y0dXNhYzEzTmFwc2FjU2FtcGxlckUAADxqAgDdiwEARIYBADxqAgC/iwEA+IsBAENoYW5naW5nIHBvaW50cyBzaXplIHJlcXVpcmVzIGNoYW5naW5nIG5laWdoYm9yaG9vZCBncmFwaCEgWW91IG11c3QgcmVpbml0aWFsaXplIE5BUFNBQyEAAAAAAAAAAOiMAQCZBgAAmgYAAJsGAACMAwAAnAYAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzMxU3RhbmRhcmRUZXJtaW5hdGlvbkNyaXRlcmlhSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAADxqAgCIjAEAxGUCAAAAAACwjQEAWQQAAJ0GAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAACeBgAAnwYAAE4yY3Y0dXNhYzMxU3RhbmRhcmRUZXJtaW5hdGlvbkNyaXRlcmlhSW1wbEUATjJjdjR1c2FjMjdTdGFuZGFyZFRlcm1pbmF0aW9uQ3JpdGVyaWFFAE4yY3Y0dXNhYzE5VGVybWluYXRpb25Dcml0ZXJpYUUAPGoCAHiNAQBQIgEAPGoCAFCNAQCYjQEAPGoCACSNAQCkjQEAAAAAACyOAQCgBgAAoQYAAKIGAACMAwAAowYAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzE5U1BSVFRlcm1pbmF0aW9uSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAADxqAgDYjQEAxGUCAAAAAACwjgEAWQQAAKQGAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAAClBgAApgYAAE4yY3Y0dXNhYzE5U1BSVFRlcm1pbmF0aW9uSW1wbEUATjJjdjR1c2FjMTVTUFJUVGVybWluYXRpb25FADxqAgCIjgEAmI0BADxqAgBojgEApI4BAAAAAAA0jwEApwYAAKgGAACpBgAAjAMAAKoGAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyNlNQUlRQTmFwc2FjVGVybWluYXRpb25JbXBsRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQAAADxqAgDYjgEAxGUCAAAAAADIjwEAqwYAAKwGAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAACtBgAArgYAAE4yY3Y0dXNhYzI2U1BSVFBOYXBzYWNUZXJtaW5hdGlvbkltcGxFAE4yY3Y0dXNhYzIyU1BSVFBOYXBzYWNUZXJtaW5hdGlvbkUAAAA8agIAl48BAJiNAQA8agIAcI8BALyPAQAAAAAAUJABAK8GAACwBgAAsQYAAIwDAACyBgAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjR1c2FjMjlQcm9zYWNUZXJtaW5hdGlvbkNyaXRlcmlhSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCAPCPAQDEZQIAAAAAAOiQAQCzBgAAtAYAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAALUGAAC2BgAATjJjdjR1c2FjMjlQcm9zYWNUZXJtaW5hdGlvbkNyaXRlcmlhSW1wbEUATjJjdjR1c2FjMjVQcm9zYWNUZXJtaW5hdGlvbkNyaXRlcmlhRQA8agIAtpABAJiNAQA8agIAjJABANyQAQBhbGdvcml0aG0AdHJlZXMAYnJhbmNoaW5nAGl0ZXJhdGlvbnMAY2VudGVyc19pbml0AHRhcmdldF9wcmVjaXNpb24AYnVpbGRfd2VpZ2h0AG1lbW9yeV93ZWlnaHQAc2FtcGxlX2ZyYWN0aW9uAGxlYWZfc2l6ZQB0YWJsZV9udW1iZXIAbXVsdGlfcHJvYmVfbGV2ZWwAY2hlY2tzAGVwcwBzb3J0ZWQAZXhwbG9yZV9hbGxfdHJlZXMAAAAAAADMkwEA3QYAAN4GAADfBgAA4AYAAOEGAADiBgAA4wYAAOQGAABVbmtub3duL3Vuc3VwcG9ydGVkIGRpc3RhbmNlIHR5cGUAYnVpbGQAL3NyYy9tb2R1bGVzL2ZsYW5uL3NyYy9taW5pZmxhbm4uY3BwAHJlbGVhc2UAa25uU2VhcmNoAG1heFJlc3VsdHMgPiAwAHJhZGl1c1NlYXJjaABMU0ggaW5kZXggZG9lcyBub3Qgc3VwcG9ydCByYWRpdXNTZWFyY2ggb3BlcmF0aW9uAHdiAENhbiBub3Qgb3BlbiBmaWxlICVzIGZvciB3cml0aW5nIEZMQU5OIGluZGV4CgBzYXZlAHJiAFJlYWRpbmcgRkxBTk4gaW5kZXggZXJyb3I6IHRoZSBzYXZlZCBkYXRhIHNpemUgKCVkLCAlZCkgb3IgdHlwZSAoJWQpIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBwYXNzZWQgb25lICglZCwgJWQpLCAlZAoAUmVhZGluZyBGTEFOTiBpbmRleCBlcnJvcjogdW5zdXBwb3J0ZWQgZmVhdHVyZSB0eXBlICVkIGZvciB0aGUgaW5kZXggdHlwZSAlZAoAUmVhZGluZyBGTEFOTiBpbmRleCBlcnJvcjogdW5zdXBwb3J0ZWQgZGlzdGFuY2UgdHlwZSAlZAoATjJjdjVmbGFubjVJbmRleEUAABRqAgC5kwEASW52YWxpZCBpbmRleCBmaWxlLCBjYW5ub3QgcmVhZABON2N2Zmxhbm4xNEZMQU5ORXhjZXB0aW9uRQAAPGoCAPSTAQDU7QAARkxBTk5fSU5ERVgASW52YWxpZCBpbmRleCBmaWxlLCB3cm9uZyBzaWduYXR1cmUAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9nZW5lcmFsLmgAAAAAAAAQlAEA4wMAAOUGAADnAwAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBB4KkGC9MZuJUBAOYGAADnBgAA6AYAAOkGAADqBgAA6wYAAOwGAADtBgAA7gYAAO8GAADwBgAATjdjdmZsYW5uN2FueWltcGwxNGJpZ19hbnlfcG9saWN5SU5TMF85ZW1wdHlfYW55RUVFAE43Y3ZmbGFubjdhbnlpbXBsMjF0eXBlZF9iYXNlX2FueV9wb2xpY3lJTlMwXzllbXB0eV9hbnlFRUUATjdjdmZsYW5uN2FueWltcGwxNWJhc2VfYW55X3BvbGljeUUAABRqAgB/lQEAPGoCAESVAQCklQEAPGoCABCVAQCslQEATjdjdmZsYW5uN2FueWltcGw5ZW1wdHlfYW55RQAAAAAUagIAxJUBAFtlbXB0eV9hbnldAAAAAACQlgEA8QYAAPIGAADzBgAA9AYAAPUGAAD2BgAA9wYAAPgGAAD5BgAA7wYAAPoGAABON2N2Zmxhbm43YW55aW1wbDE2c21hbGxfYW55X3BvbGljeUlpRUUATjdjdmZsYW5uN2FueWltcGwyMXR5cGVkX2Jhc2VfYW55X3BvbGljeUlpRUUAAAAAPGoCAFSWAQCklQEAPGoCACyWAQCElgEAAAAAADSXAQD7BgAA/AYAAP0GAAD+BgAA/wYAAAAHAAABBwAAAgcAAAMHAADvBgAABAcAAE43Y3ZmbGFubjdhbnlpbXBsMTZzbWFsbF9hbnlfcG9saWN5SWZFRQBON2N2Zmxhbm43YW55aW1wbDIxdHlwZWRfYmFzZV9hbnlfcG9saWN5SWZFRQAAAAA8agIA+JYBAKSVAQA8agIA0JYBACiXAQAAAAAA2JcBAAUHAAAGBwAABwcAAAgHAAAJBwAACgcAAAsHAAAMBwAADQcAAO8GAAAOBwAATjdjdmZsYW5uN2FueWltcGwxNnNtYWxsX2FueV9wb2xpY3lJYkVFAE43Y3ZmbGFubjdhbnlpbXBsMjF0eXBlZF9iYXNlX2FueV9wb2xpY3lJYkVFAAAAADxqAgCclwEApJUBADxqAgB0lwEAzJcBAAAAAACkmAEADwcAABAHAAARBwAAEgcAABMHAAAUBwAAFQcAABYHAAAXBwAA7wYAABgHAABON2N2Zmxhbm43YW55aW1wbDE0YmlnX2FueV9wb2xpY3lJTlNfMTdmbGFubl9hbGdvcml0aG1fdEVFRQBON2N2Zmxhbm43YW55aW1wbDIxdHlwZWRfYmFzZV9hbnlfcG9saWN5SU5TXzE3Zmxhbm5fYWxnb3JpdGhtX3RFRUUAADxqAgBUmAEApJUBADxqAgAYmAEAmJgBAE43Y3ZmbGFubjE3Zmxhbm5fYWxnb3JpdGhtX3RFAAAAyGkCALCYAQAAAAAAoJkBABkHAAAaBwAAGwcAABwHAAAdBwAAHgcAAB8HAAAgBwAAIQcAAO8GAAAiBwAATjdjdmZsYW5uN2FueWltcGwxNGJpZ19hbnlfcG9saWN5SU5TXzIwZmxhbm5fY2VudGVyc19pbml0X3RFRUUATjdjdmZsYW5uN2FueWltcGwyMXR5cGVkX2Jhc2VfYW55X3BvbGljeUlOU18yMGZsYW5uX2NlbnRlcnNfaW5pdF90RUVFAAAAADxqAgBLmQEApJUBADxqAgAMmQEAlJkBAE43Y3ZmbGFubjIwZmxhbm5fY2VudGVyc19pbml0X3RFAAAAAMhpAgCsmQEAAAAAAOyaAQAjBwAAJAcAACUHAAAmBwAAJwcAACgHAAApBwAAKgcAACsHAADvBgAALAcAAE43Y3ZmbGFubjdhbnlpbXBsMTRiaWdfYW55X3BvbGljeUlOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TMl8xMWNoYXJfdHJhaXRzSWNFRU5TMl85YWxsb2NhdG9ySWNFRUVFRUUATjdjdmZsYW5uN2FueWltcGwyMXR5cGVkX2Jhc2VfYW55X3BvbGljeUlOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TMl8xMWNoYXJfdHJhaXRzSWNFRU5TMl85YWxsb2NhdG9ySWNFRUVFRUUAAAAAPGoCAHGaAQCklQEAPGoCAAyaAQDgmgEATjdjdmZsYW5uN2FueWltcGwxMmJhZF9hbnlfY2FzdEUAAAAAFGoCAPiaAQAAAAAAuJsBAC0HAAAuBwAALwcAADAHAAAxBwAAMgcAADMHAAA0BwAANQcAAO8GAAA2BwAATjdjdmZsYW5uN2FueWltcGwxNGJpZ19hbnlfcG9saWN5SWRFRQBON2N2Zmxhbm43YW55aW1wbDIxdHlwZWRfYmFzZV9hbnlfcG9saWN5SWRFRQAAPGoCAH6bAQCklQEAPGoCAFibAQCsmwEAdHlwZT0lZAoAYnVpbGRJbmRleF8AT25seSBjb250aW51b3VzIGFycmF5cyBhcmUgc3VwcG9ydGVkAAAAAAAAAIycAQA3BwAAOAcAADkHAAA6BwAAOwcAADwHAAA9BwAAPgcAAD8HAABABwAAQQcAAEIHAABDBwAATjdjdmZsYW5uNUluZGV4SU5TXzEwSGFtbWluZ0xVVEVFRQBON2N2Zmxhbm43Tk5JbmRleElOU18xMEhhbW1pbmdMVVRFRUUAFGoCAF+cAQA8agIAPJwBAIScAQBxdWVyaWVzLmNvbHMgPT0gdmVjbGVuKCkAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9ubl9pbmRleC5oAGluZGljZXMucm93cyA+PSBxdWVyaWVzLnJvd3MAZGlzdHMucm93cyA+PSBxdWVyaWVzLnJvd3MAaW50KGluZGljZXMuY29scykgPj0ga25uAGludChkaXN0cy5jb2xzKSA+PSBrbm4AAAAAAAAAAOidAQBEBwAARQcAAEYHAABHBwAASAcAAEkHAABKBwAASwcAAE43Y3ZmbGFubjE4S05OVW5pcXVlUmVzdWx0U2V0SWlFRQBON2N2Zmxhbm4xNVVuaXF1ZVJlc3VsdFNldElpRUUATjdjdmZsYW5uOVJlc3VsdFNldElpRUUAAAAAFGoCALmdAQA8agIAmp0BANSdAQA8agIAeJ0BANydAQAAAAAA3J0BAEQHAABMBwAARgcAAOoDAABIBwAA6gMAAEoHAABLBwAASSBjYW4gb25seSBzZWFyY2ggb25lIGZlYXR1cmUgYXQgYSB0aW1lIGZvciByYW5nZSBzZWFyY2gKAHF1ZXJ5LmNvbHMgPT0gdmVjbGVuKCkAaW5kaWNlcy5jb2xzID09IGRpc3RzLmNvbHMAAAAAANieAQBEBwAATQcAAE4HAABPBwAAUAcAAFEHAABKBwAASwcAAE43Y3ZmbGFubjIxUmFkaXVzVW5pcXVlUmVzdWx0U2V0SWlFRQAAAAA8agIAsJ4BANydAQBNaXNzaW5nIHBhcmFtZXRlciAnACcgaW4gdGhlIHBhcmFtZXRlcnMgZ2l2ZW4ARGF0YXR5cGUgb2Ygc2F2ZWQgaW5kZXggaXMgZGlmZmVyZW50IHRoYW4gb2YgdGhlIG9uZSB0byBiZSBjcmVhdGVkLgBUaGUgaW5kZXggc2F2ZWQgYmVsb25ncyB0byBhIGRpZmZlcmVudCBkYXRhc2V0AFVua25vd24gaW5kZXggdHlwZQAAAAAAAKABAFIHAABTBwAAVAcAAFUHAABWBwAAVwcAAFgHAABZBwAAWgcAAFsHAABcBwAAXQcAAF4HAABON2N2Zmxhbm4xMUxpbmVhckluZGV4SU5TXzEwSGFtbWluZ0xVVEVFRQAAADxqAgDUnwEAhJwBAAAAAAAAAQECAQICAwECAgMCAwMEAQICAwIDAwQCAwMEAwQEBQECAgMCAwMEAgMDBAMEBAUCAwMEAwQEBQMEBAUEBQUGAQICAwIDAwQCAwMEAwQEBQIDAwQDBAQFAwQEBQQFBQYCAwMEAwQEBQMEBAUEBQUGAwQEBQQFBQYEBQUGBQYGBwECAgMCAwMEAgMDBAMEBAUCAwMEAwQEBQMEBAUEBQUGAgMDBAMEBAUDBAQFBAUFBgMEBAUEBQUGBAUFBgUGBgcCAwMEAwQEBQMEBAUEBQUGAwQEBQQFBQYEBQUGBQYGBwMEBAUEBQUGBAUFBgUGBgcEBQUGBQYGBwUGBgcGBwcIAAAAAKihAQBfBwAAYAcAAGEHAABVBwAAVgcAAGIHAABjBwAAZAcAAGUHAABmBwAAZwcAAGgHAABpBwAAVW5rbm93biBhbGdvcml0aG0gZm9yIGNob29zaW5nIGluaXRpYWwgY2VudGVycy4ATjdjdmZsYW5uMTFLTWVhbnNJbmRleElOU18xMEhhbW1pbmdMVVRFRUUAAAA8agIAfKEBAIScAQBBwcMGC8ZOAQECAQICAwECAgMCAwMEAQICAwIDAwQCAwMEAwQEBQECAgMCAwMEAgMDBAMEBAUCAwMEAwQEBQMEBAUEBQUGAQICAwIDAwQCAwMEAwQEBQIDAwQDBAQFAwQEBQQFBQYCAwMEAwQEBQMEBAUEBQUGAwQEBQQFBQYEBQUGBQYGBwECAgMCAwMEAgMDBAMEBAUCAwMEAwQEBQMEBAUEBQUGAgMDBAMEBAUDBAQFBAUFBgMEBAUEBQUGBAUFBgUGBgcCAwMEAwQEBQMEBAUEBQUGAwQEBQQFBQYEBQUGBQYGBwMEBAUEBQUGBAUFBgUGBgcEBQUGBQYGBwUGBgcGBwcIQnJhbmNoaW5nIGZhY3RvciBtdXN0IGJlIGF0IGxlYXN0IDIARmFpbGVkIHRvIGFsbG9jYXRlIG1lbW9yeS4KAAABAQIBAgIDAQICAwIDAwQBAgIDAgMDBAIDAwQDBAQFAQICAwIDAwQCAwMEAwQEBQIDAwQDBAQFAwQEBQQFBQYBAgIDAgMDBAIDAwQDBAQFAgMDBAMEBAUDBAQFBAUFBgIDAwQDBAQFAwQEBQQFBQYDBAQFBAUFBgQFBQYFBgYHAQICAwIDAwQCAwMEAwQEBQIDAwQDBAQFAwQEBQQFBQYCAwMEAwQEBQMEBAUEBQUGAwQEBQQFBQYEBQUGBQYGBwIDAwQDBAQFAwQEBQQFBQYDBAQFBAUFBgQFBQYFBgYHAwQEBQQFBQYEBQUGBQYGBwQFBQYFBgYHBQYGBwYHBwgAAAAAXKQBAF8DAABqBwAAawcAAE43Y3ZmbGFubjExS01lYW5zSW5kZXhJTlNfMTBIYW1taW5nTFVURUUyMktNZWFuc0Rpc3RhbmNlQ29tcHV0ZXJJUFBoRUUAADxqAgAUpAEAqK4AAENhbm5vdCByZWFkIGZyb20gZmlsZQByZXN1bHQuZnVsbCgpAGZpbmROZWlnaGJvcnMAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9rbWVhbnNfaW5kZXguaAAAAPCkAQAMpgEA0AAAAAEAAAA8pgEAa6YBAJKmAQBzdGF0aWMgY3Y6OlB0cjxIZWFwPFQ+PiBjdmZsYW5uOjpIZWFwPGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpLTWVhbnNJbmRleDxjdmZsYW5uOjpIYW1taW5nTFVUPjo6S01lYW5zTm9kZSAqLCBpbnQ+Pjo6Z2V0UG9vbGVkSW5zdGFuY2UoY29uc3QgSGFzaGFibGVUICYsIGNvbnN0IGludCwgaW50KSBbVCA9IGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpLTWVhbnNJbmRleDxjdmZsYW5uOjpIYW1taW5nTFVUPjo6S01lYW5zTm9kZSAqLCBpbnQ+LCBIYXNoYWJsZVQgPSBpbnRdAC9zcmMvbW9kdWxlcy9mbGFubi9pbmNsdWRlL29wZW5jdjIvZmxhbm4vaGVhcC5oAEZhaWxlZCB0byBpbnNlcnQgdGhlIGhlYXAgaW50byBpdHMgbWVtb3J5IHBvb2wAc3RhdGljX2Nhc3Q8aW50PihlbXBsYWNlUmVzdWx0LnNlY29uZCkAMQDwpAEADKYBANUAAAABAAAAsKYBAPKmAQCSpgEAQ2Fubm90IG1vZGlmeSBhIGhlYXAgdGhhdCBpcyBjdXJyZW50bHkgYWNjZXNzZWQgYnkgYW5vdGhlciBjYWxsZXIAaGVhcEl0LT5zZWNvbmQuaGVhcFB0ci51c2VfY291bnQoKQBjbGVhbnVwSXQgIT0gaGVhcEl0AGdldFBvb2xlZEluc3RhbmNlAAAAAAAA6KcBAGwHAABtBwAAbgcAAIwDAABvBwAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjdjdmZsYW5uNEhlYXBJTlMxXzEyQnJhbmNoU3RydWN0SVBOUzFfMTFLTWVhbnNJbmRleElOUzFfMTBIYW1taW5nTFVURUUxMEtNZWFuc05vZGVFaUVFRUVOU185YWxsb2NhdG9ySVNBX0VFRUUAAAAAPGoCAFinAQDEZQIAAAAAAGyoAQBwBwAAcQcAAHIHAABVBwAAVgcAAHMHAAB0BwAAdQcAAHYHAAB3BwAAeAcAAHkHAAB6BwAATjdjdmZsYW5uMjdIaWVyYXJjaGljYWxDbHVzdGVyaW5nSW5kZXhJTlNfMTBIYW1taW5nTFVURUVFAAAAPGoCADCoAQCEnAEAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9oaWVyYXJjaGljYWxfY2x1c3RlcmluZ19pbmRleC5oAAAAAOCoAQAMpgEA0AAAAAEAAAA8pgEAa6YBAJKmAQBzdGF0aWMgY3Y6OlB0cjxIZWFwPFQ+PiBjdmZsYW5uOjpIZWFwPGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpIaWVyYXJjaGljYWxDbHVzdGVyaW5nSW5kZXg8Y3ZmbGFubjo6SGFtbWluZ0xVVD46Ok5vZGUgKiwgaW50Pj46OmdldFBvb2xlZEluc3RhbmNlKGNvbnN0IEhhc2hhYmxlVCAmLCBjb25zdCBpbnQsIGludCkgW1QgPSBjdmZsYW5uOjpCcmFuY2hTdHJ1Y3Q8Y3ZmbGFubjo6SGllcmFyY2hpY2FsQ2x1c3RlcmluZ0luZGV4PGN2Zmxhbm46OkhhbW1pbmdMVVQ+OjpOb2RlICosIGludD4sIEhhc2hhYmxlVCA9IGludF0A4KgBAAymAQDVAAAAAQAAALCmAQDypgEAkqYBAAAAAADgqgEAewcAAHwHAAB9BwAAjAMAAH4HAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlON2N2Zmxhbm40SGVhcElOUzFfMTJCcmFuY2hTdHJ1Y3RJUE5TMV8yN0hpZXJhcmNoaWNhbENsdXN0ZXJpbmdJbmRleElOUzFfMTBIYW1taW5nTFVURUU0Tm9kZUVpRUVFRU5TXzlhbGxvY2F0b3JJU0FfRUVFRQAAADxqAgBIqgEAxGUCAAAAAABQqwEAfwcAAIAHAACBBwAAggcAAFYHAACDBwAAhAcAAIUHAACGBwAAhwcAAIgHAACJBwAAigcAAE43Y3ZmbGFubjhMc2hJbmRleElOU18xMEhhbW1pbmdMVVRFRUUAAAA8agIAKKsBAIScAQBJbnZhbGlkIGtleV9zaXplICg9JWQpLiBWYWxpZCB2YWx1ZXMgZm9yIHlvdXIgc3lzdGVtIGFyZSAlZCA8PSBrZXlfc2l6ZSA8ICVkLgBpbml0aWFsaXplAC9zcmMvbW9kdWxlcy9mbGFubi9pbmNsdWRlL29wZW5jdjIvZmxhbm4vbHNoX3RhYmxlLmgAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9sc2hfaW5kZXguaAAAAAAAAKCsAQCLBwAAjAcAAI0HAACOBwAAjwcAAJAHAACRBwAAkgcAAJMHAACUBwAAlQcAAJYHAACXBwAATjdjdmZsYW5uNUluZGV4SU5TXzJMMklmRUVFRQBON2N2Zmxhbm43Tk5JbmRleElOU18yTDJJZkVFRUUAFGoCAHmsAQA8agIAXKwBAJisAQAAAAAARK0BAJgHAACZBwAAmgcAAJsHAACcBwAAnQcAAJ4HAACfBwAATjdjdmZsYW5uMThLTk5VbmlxdWVSZXN1bHRTZXRJZkVFAE43Y3ZmbGFubjE1VW5pcXVlUmVzdWx0U2V0SWZFRQBON2N2Zmxhbm45UmVzdWx0U2V0SWZFRQAAAAAUagIAFa0BADxqAgD2rAEAMK0BADxqAgDUrAEAOK0BAAAAAAA4rQEAmAcAAKAHAACaBwAA6gMAAJwHAADqAwAAngcAAJ8HAAAAAAAAyK0BAJgHAAChBwAAogcAAKMHAACkBwAApQcAAJ4HAACfBwAATjdjdmZsYW5uMjFSYWRpdXNVbmlxdWVSZXN1bHRTZXRJZkVFAAAAADxqAgCgrQEAOK0BAAAAAAA0rgEApgcAAKcHAACoBwAAqQcAAKoHAACrBwAArAcAAK0HAACuBwAArwcAALAHAACxBwAAsgcAAE43Y3ZmbGFubjExTGluZWFySW5kZXhJTlNfMkwySWZFRUVFADxqAgAQrgEAmKwBAAAAAADArgEAswcAALQHAAC1BwAAtgcAAKoHAAC3BwAAuAcAALkHAAC6BwAAuwcAALwHAAC9BwAAvgcAAGRpbQBsZWFmX21heF9zaXplAHJlb3JkZXIATjdjdmZsYW5uMTdLRFRyZWVTaW5nbGVJbmRleElOU18yTDJJZkVFRUUAPGoCAJauAQCYrAEAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9rZHRyZWVfc2luZ2xlX2luZGV4LmgAAAAAAABMrwEAvwcAAMAHAADBBwAAwgcAAMMHAABON2N2Zmxhbm4xOEtOTlNpbXBsZVJlc3VsdFNldElmRUUAAAA8agIAKK8BADCtAQAAAAAAuK8BAMQHAADFBwAAxgcAAKkHAACqBwAAxwcAAMgHAADJBwAAygcAAMsHAADMBwAAzQcAAM4HAABON2N2Zmxhbm4xMUtEVHJlZUluZGV4SU5TXzJMMklmRUVFRQA8agIAlK8BAJisAQAAAAAAoLABAM8HAADQBwAA0QcAANIHAADTBwAA1AcAANUHAADWBwAA1wcAAO8GAADYBwAATjdjdmZsYW5uN2FueWltcGwxNnNtYWxsX2FueV9wb2xpY3lJUFBOU18xMUtEVHJlZUluZGV4SU5TXzJMMklmRUVFNE5vZGVFRUUATjdjdmZsYW5uN2FueWltcGwyMXR5cGVkX2Jhc2VfYW55X3BvbGljeUlQUE5TXzExS0RUcmVlSW5kZXhJTlNfMkwySWZFRUU0Tm9kZUVFRQAAPGoCAEOwAQCklQEAPGoCAPivAQCUsAEAUFBON2N2Zmxhbm4xMUtEVHJlZUluZGV4SU5TXzJMMklmRUVFNE5vZGVFAFBON2N2Zmxhbm4xMUtEVHJlZUluZGV4SU5TXzJMMklmRUVFNE5vZGVFAE43Y3ZmbGFubjExS0RUcmVlSW5kZXhJTlNfMkwySWZFRUU0Tm9kZUUAAAAUagIAAbEBAPRqAgDXsAEAAAAAACyxAQD0agIArLABAAAAAAA0sQEASXQgZG9lc24ndCBtYWtlIGFueSBzZW5zZSB0byB1c2UgbW9yZSB0aGFuIG9uZSB0cmVlIGZvciBleGFjdCBzZWFyY2gAZ2V0RXhhY3ROZWlnaGJvcnMAL3NyYy9tb2R1bGVzL2ZsYW5uL2luY2x1ZGUvb3BlbmN2Mi9mbGFubi9rZHRyZWVfaW5kZXguaABnZXROZWlnaGJvcnMADLIBAAymAQDQAAAAAQAAADymAQBrpgEAkqYBAHN0YXRpYyBjdjo6UHRyPEhlYXA8VD4+IGN2Zmxhbm46OkhlYXA8Y3ZmbGFubjo6QnJhbmNoU3RydWN0PGN2Zmxhbm46OktEVHJlZUluZGV4PGN2Zmxhbm46OkwyPGZsb2F0Pj46Ok5vZGUgKiwgZmxvYXQ+Pjo6Z2V0UG9vbGVkSW5zdGFuY2UoY29uc3QgSGFzaGFibGVUICYsIGNvbnN0IGludCwgaW50KSBbVCA9IGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpLRFRyZWVJbmRleDxjdmZsYW5uOjpMMjxmbG9hdD4+OjpOb2RlICosIGZsb2F0PiwgSGFzaGFibGVUID0gaW50XQAAAAyyAQAMpgEA1QAAAAEAAACwpgEA8qYBAJKmAQAAAAAA2LMBANkHAADaBwAA2wcAAIwDAADcBwAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjdjdmZsYW5uNEhlYXBJTlMxXzEyQnJhbmNoU3RydWN0SVBOUzFfMTFLRFRyZWVJbmRleElOUzFfMkwySWZFRUU0Tm9kZUVmRUVFRU5TXzlhbGxvY2F0b3JJU0JfRUVFRQA8agIAWLMBAMRlAgAAAAAARLQBAN0HAADeBwAA3wcAAKkHAACqBwAA4AcAAOEHAADiBwAA4wcAAOQHAADlBwAA5gcAAOcHAABON2N2Zmxhbm4xMUtNZWFuc0luZGV4SU5TXzJMMklmRUVFRQA8agIAILQBAJisAQAAAAAAsLQBAF8DAADoBwAA6QcAAE43Y3ZmbGFubjExS01lYW5zSW5kZXhJTlNfMkwySWZFRUUyMktNZWFuc0Rpc3RhbmNlQ29tcHV0ZXJJTlNfNk1hdHJpeElkRUVFRQA8agIAZLQBAKiuAADYtAEADKYBANAAAAABAAAAPKYBAGumAQCSpgEAc3RhdGljIGN2OjpQdHI8SGVhcDxUPj4gY3ZmbGFubjo6SGVhcDxjdmZsYW5uOjpCcmFuY2hTdHJ1Y3Q8Y3ZmbGFubjo6S01lYW5zSW5kZXg8Y3ZmbGFubjo6TDI8ZmxvYXQ+Pjo6S01lYW5zTm9kZSAqLCBmbG9hdD4+OjpnZXRQb29sZWRJbnN0YW5jZShjb25zdCBIYXNoYWJsZVQgJiwgY29uc3QgaW50LCBpbnQpIFtUID0gY3ZmbGFubjo6QnJhbmNoU3RydWN0PGN2Zmxhbm46OktNZWFuc0luZGV4PGN2Zmxhbm46OkwyPGZsb2F0Pj46OktNZWFuc05vZGUgKiwgZmxvYXQ+LCBIYXNoYWJsZVQgPSBpbnRdAAAA2LQBAAymAQDVAAAAAQAAALCmAQDypgEAkqYBAAAAAAC4tgEA6gcAAOsHAADsBwAAjAMAAO0HAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlON2N2Zmxhbm40SGVhcElOUzFfMTJCcmFuY2hTdHJ1Y3RJUE5TMV8xMUtNZWFuc0luZGV4SU5TMV8yTDJJZkVFRTEwS01lYW5zTm9kZUVmRUVFRU5TXzlhbGxvY2F0b3JJU0JfRUVFRQAAPGoCADC2AQDEZQIAAAAAACi3AQDuBwAA7wcAAPAHAACpBwAAqgcAAPEHAADyBwAA8wcAAPQHAAD1BwAA9gcAAPcHAAD4BwAATjdjdmZsYW5uMTRDb21wb3NpdGVJbmRleElOU18yTDJJZkVFRUUAADxqAgAAtwEAmKwBAEJ1aWxkaW5nIGttZWFucyB0cmVlLi4uCgBCdWlsZGluZyBrZHRyZWUgdHJlZS4uLgoAAAAAAAAAzLcBAPkHAAD6BwAA+wcAAKkHAACqBwAA/AcAAP0HAAD+BwAA/wcAAAAIAAABCAAAAggAAAMIAABON2N2Zmxhbm4xNEF1dG90dW5lZEluZGV4SU5TXzJMMklmRUVFRQAAPGoCAKS3AQCYrAEALS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoAQXV0b3R1bmVkIHBhcmFtZXRlcnM6CgAlcwBTZWFyY2ggcGFyYW1ldGVyczoKAEVudGVyaW5nIGF1dG90dW5pbmcsIGRhdGFzZXQgc2l6ZTogJWQsIHNhbXBsZVNpemU6ICVkLCB0ZXN0U2FtcGxlU2l6ZTogJWQsIHRhcmdldCBwcmVjaXNpb246ICVnCgBDaG9vc2luZyBsaW5lYXIsIGRhdGFzZXQgdG9vIHNtYWxsCgBDb21wdXRpbmcgZ3JvdW5kIHRydXRoLi4uIAoAQXV0b3R1bmluZyBwYXJhbWV0ZXJzLi4uCgBLTUVBTlMsIFN0ZXAgMTogRXhwbG9yaW5nIHBhcmFtZXRlciBzcGFjZQoAS01lYW5zVHJlZSB1c2luZyBwYXJhbXM6IG1heF9pdGVyYXRpb25zPSVkLCBicmFuY2hpbmc9JWQKAEtNZWFuc1RyZWUgYnVpbGRUaW1lPSVnLCBzZWFyY2hUaW1lPSVnLCBidWlsZF93ZWlnaHQ9JWcKACAgTm9kZXMgIFByZWNpc2lvbiglKSAgIFRpbWUocykgICBUaW1lL3ZlYyhtcykgIE1lYW4gZGlzdAoALS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgBHb3QgYXMgY2xvc2UgYXMgSSBjYW4KAFN0YXJ0IGxpbmVhciBlc3RpbWF0aW9uCgBObyBuZWVkIGZvciBsaW5lYXIgZXN0aW1hdGlvbgoAbWF0Y2hlcy5jb2xzPSVkLCBubj0lZAoAR3JvdW5kIHRydXRoIGlzIG5vdCBjb21wdXRlZCBmb3IgYXMgbWFueSBuZWlnaGJvcnMgYXMgcmVxdWVzdGVkACU4ZCAlMTAuNGcgJTEwLjVnICUxMC41ZyAlMTAuNWcKAAAAAAAADLsBAL8HAAAECAAABQgAAAYIAAAHCAAATjdjdmZsYW5uMTJLTk5SZXN1bHRTZXRJZkVFADxqAgDwugEAMK0BAEtELVRSRUUsIFN0ZXAgMTogRXhwbG9yaW5nIHBhcmFtZXRlciBzcGFjZQoAS0RUcmVlIHVzaW5nIHBhcmFtczogdHJlZXM9JWQKAEtEVHJlZSBidWlsZFRpbWU9JWcsIHNlYXJjaFRpbWU9JWcKACA6IABiZXN0SW5kZXhfICE9IE5VTEwgJiYgIlJlcXVpcmVzIGEgdmFsaWQgaW5kZXgiAGVzdGltYXRlU2VhcmNoUGFyYW1zAC9zcmMvbW9kdWxlcy9mbGFubi9pbmNsdWRlL29wZW5jdjIvZmxhbm4vYXV0b3R1bmVkX2luZGV4LmgAQ29tcHV0aW5nIGdyb3VuZCB0cnV0aAoARXN0aW1hdGluZyBudW1iZXIgb2YgY2hlY2tzCgBLTWVhbnMgYWxnb3JpdGhtLCBlc3RpbWF0aW5nIGNsdXN0ZXIgYm9yZGVyIGZhY3RvcgoAT3B0aW11bSBjYl9pbmRleDogJWcKAFJlcXVpcmVkIG51bWJlciBvZiBjaGVja3M6ICVkIAoAAAAAAAAAABy9AQAICAAACQgAAAoIAACpBwAAqgcAAAsIAAAMCAAADQgAAA4IAAAPCAAAEAgAABEIAAASCAAATjdjdmZsYW5uMjdIaWVyYXJjaGljYWxDbHVzdGVyaW5nSW5kZXhJTlNfMkwySWZFRUVFADxqAgDovAEAmKwBAES9AQAMpgEA0AAAAAEAAAA8pgEAa6YBAJKmAQBzdGF0aWMgY3Y6OlB0cjxIZWFwPFQ+PiBjdmZsYW5uOjpIZWFwPGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpIaWVyYXJjaGljYWxDbHVzdGVyaW5nSW5kZXg8Y3ZmbGFubjo6TDI8ZmxvYXQ+Pjo6Tm9kZSAqLCBmbG9hdD4+OjpnZXRQb29sZWRJbnN0YW5jZShjb25zdCBIYXNoYWJsZVQgJiwgY29uc3QgaW50LCBpbnQpIFtUID0gY3ZmbGFubjo6QnJhbmNoU3RydWN0PGN2Zmxhbm46OkhpZXJhcmNoaWNhbENsdXN0ZXJpbmdJbmRleDxjdmZsYW5uOjpMMjxmbG9hdD4+OjpOb2RlICosIGZsb2F0PiwgSGFzaGFibGVUID0gaW50XQAAAES9AQAMpgEA1QAAAAEAAACwpgEA8qYBAJKmAQAAAAAAQL8BABMIAAAUCAAAFQgAAIwDAAAWCAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjdjdmZsYW5uNEhlYXBJTlMxXzEyQnJhbmNoU3RydWN0SVBOUzFfMjdIaWVyYXJjaGljYWxDbHVzdGVyaW5nSW5kZXhJTlMxXzJMMklmRUVFNE5vZGVFZkVFRUVOU185YWxsb2NhdG9ySVNCX0VFRUUAPGoCALC+AQDEZQIAAAAAAKi/AQAXCAAAGAgAABkIAAAaCAAAqgcAABsIAAAcCAAAHQgAAB4IAAAfCAAAIAgAACEIAAAiCAAATjdjdmZsYW5uOExzaEluZGV4SU5TXzJMMklmRUVFRQA8agIAiL8BAJisAQBMU0ggaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGF0IHR5cGUATHNoVGFibGUAZ2V0S2V5AAAAAAAAAABswAEAIwgAACQIAAAlCAAAJggAACcIAAAoCAAAKQgAACoIAAArCAAALAgAAC0IAAAuCAAALwgAAE43Y3ZmbGFubjVJbmRleElOU18yTDFJZkVFRUUATjdjdmZsYW5uN05OSW5kZXhJTlNfMkwxSWZFRUVFABRqAgBFwAEAPGoCACjAAQBkwAEAAAAAANjAAQAwCAAAMQgAADIIAAAzCAAANAgAADUIAAA2CAAANwgAADgIAAA5CAAAOggAADsIAAA8CAAATjdjdmZsYW5uMTFMaW5lYXJJbmRleElOU18yTDFJZkVFRUUAPGoCALTAAQBkwAEAAAAAAEzBAQA9CAAAPggAAD8IAABACAAANAgAAEEIAABCCAAAQwgAAEQIAABFCAAARggAAEcIAABICAAATjdjdmZsYW5uMTdLRFRyZWVTaW5nbGVJbmRleElOU18yTDFJZkVFRUUAAAA8agIAIMEBAGTAAQAAAAAAuMEBAEkIAABKCAAASwgAADMIAAA0CAAATAgAAE0IAABOCAAATwgAAFAIAABRCAAAUggAAFMIAABON2N2Zmxhbm4xMUtEVHJlZUluZGV4SU5TXzJMMUlmRUVFRQA8agIAlMEBAGTAAQAAAAAAoMIBAFQIAABVCAAAVggAAFcIAABYCAAAWQgAAFoIAABbCAAAXAgAAO8GAABdCAAATjdjdmZsYW5uN2FueWltcGwxNnNtYWxsX2FueV9wb2xpY3lJUFBOU18xMUtEVHJlZUluZGV4SU5TXzJMMUlmRUVFNE5vZGVFRUUATjdjdmZsYW5uN2FueWltcGwyMXR5cGVkX2Jhc2VfYW55X3BvbGljeUlQUE5TXzExS0RUcmVlSW5kZXhJTlNfMkwxSWZFRUU0Tm9kZUVFRQAAPGoCAEPCAQCklQEAPGoCAPjBAQCUwgEAUFBON2N2Zmxhbm4xMUtEVHJlZUluZGV4SU5TXzJMMUlmRUVFNE5vZGVFAFBON2N2Zmxhbm4xMUtEVHJlZUluZGV4SU5TXzJMMUlmRUVFNE5vZGVFAE43Y3ZmbGFubjExS0RUcmVlSW5kZXhJTlNfMkwxSWZFRUU0Tm9kZUUAAAAUagIAAcMBAPRqAgDXwgEAAAAAACzDAQD0agIArMIBAAAAAAA0wwEAcMMBAAymAQDQAAAAAQAAADymAQBrpgEAkqYBAHN0YXRpYyBjdjo6UHRyPEhlYXA8VD4+IGN2Zmxhbm46OkhlYXA8Y3ZmbGFubjo6QnJhbmNoU3RydWN0PGN2Zmxhbm46OktEVHJlZUluZGV4PGN2Zmxhbm46OkwxPGZsb2F0Pj46Ok5vZGUgKiwgZmxvYXQ+Pjo6Z2V0UG9vbGVkSW5zdGFuY2UoY29uc3QgSGFzaGFibGVUICYsIGNvbnN0IGludCwgaW50KSBbVCA9IGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpLRFRyZWVJbmRleDxjdmZsYW5uOjpMMTxmbG9hdD4+OjpOb2RlICosIGZsb2F0PiwgSGFzaGFibGVUID0gaW50XQAAAHDDAQAMpgEA1QAAAAEAAACwpgEA8qYBAJKmAQAAAAAAPMUBAF4IAABfCAAAYAgAAIwDAABhCAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjdjdmZsYW5uNEhlYXBJTlMxXzEyQnJhbmNoU3RydWN0SVBOUzFfMTFLRFRyZWVJbmRleElOUzFfMkwxSWZFRUU0Tm9kZUVmRUVFRU5TXzlhbGxvY2F0b3JJU0JfRUVFRQA8agIAvMQBAMRlAgAAAAAAqMUBAGIIAABjCAAAZAgAADMIAAA0CAAAZQgAAGYIAABnCAAAaAgAAGkIAABqCAAAawgAAGwIAABON2N2Zmxhbm4xMUtNZWFuc0luZGV4SU5TXzJMMUlmRUVFRQA8agIAhMUBAGTAAQAAAAAAFMYBAF8DAABtCAAAbggAAE43Y3ZmbGFubjExS01lYW5zSW5kZXhJTlNfMkwxSWZFRUUyMktNZWFuc0Rpc3RhbmNlQ29tcHV0ZXJJTlNfNk1hdHJpeElkRUVFRQA8agIAyMUBAKiuAAA8xgEADKYBANAAAAABAAAAPKYBAGumAQCSpgEAc3RhdGljIGN2OjpQdHI8SGVhcDxUPj4gY3ZmbGFubjo6SGVhcDxjdmZsYW5uOjpCcmFuY2hTdHJ1Y3Q8Y3ZmbGFubjo6S01lYW5zSW5kZXg8Y3ZmbGFubjo6TDE8ZmxvYXQ+Pjo6S01lYW5zTm9kZSAqLCBmbG9hdD4+OjpnZXRQb29sZWRJbnN0YW5jZShjb25zdCBIYXNoYWJsZVQgJiwgY29uc3QgaW50LCBpbnQpIFtUID0gY3ZmbGFubjo6QnJhbmNoU3RydWN0PGN2Zmxhbm46OktNZWFuc0luZGV4PGN2Zmxhbm46OkwxPGZsb2F0Pj46OktNZWFuc05vZGUgKiwgZmxvYXQ+LCBIYXNoYWJsZVQgPSBpbnRdAAAAPMYBAAymAQDVAAAAAQAAALCmAQDypgEAkqYBAAAAAAAcyAEAbwgAAHAIAABxCAAAjAMAAHIIAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlON2N2Zmxhbm40SGVhcElOUzFfMTJCcmFuY2hTdHJ1Y3RJUE5TMV8xMUtNZWFuc0luZGV4SU5TMV8yTDFJZkVFRTEwS01lYW5zTm9kZUVmRUVFRU5TXzlhbGxvY2F0b3JJU0JfRUVFRQAAPGoCAJTHAQDEZQIAAAAAAIzIAQBzCAAAdAgAAHUIAAAzCAAANAgAAHYIAAB3CAAAeAgAAHkIAAB6CAAAewgAAHwIAAB9CAAATjdjdmZsYW5uMTRDb21wb3NpdGVJbmRleElOU18yTDFJZkVFRUUAADxqAgBkyAEAZMABAAAAAAD8yAEAfggAAH8IAACACAAAMwgAADQIAACBCAAAgggAAIMIAACECAAAhQgAAIYIAACHCAAAiAgAAE43Y3ZmbGFubjE0QXV0b3R1bmVkSW5kZXhJTlNfMkwxSWZFRUVFAAA8agIA1MgBAGTAAQBBkJIHCyIBAAAABQAAAAoAAAAPAAAAEAAAACAAAABAAAAAgAAAAAABAEHAkgcLyQgBAAAABAAAAAgAAAAQAAAAIAAAAAAAAADEyQEAiQgAAIoIAACLCAAAMwgAADQIAACMCAAAjQgAAI4IAACPCAAAkAgAAJEIAACSCAAAkwgAAE43Y3ZmbGFubjI3SGllcmFyY2hpY2FsQ2x1c3RlcmluZ0luZGV4SU5TXzJMMUlmRUVFRQA8agIAkMkBAGTAAQDsyQEADKYBANAAAAABAAAAPKYBAGumAQCSpgEAc3RhdGljIGN2OjpQdHI8SGVhcDxUPj4gY3ZmbGFubjo6SGVhcDxjdmZsYW5uOjpCcmFuY2hTdHJ1Y3Q8Y3ZmbGFubjo6SGllcmFyY2hpY2FsQ2x1c3RlcmluZ0luZGV4PGN2Zmxhbm46OkwxPGZsb2F0Pj46Ok5vZGUgKiwgZmxvYXQ+Pjo6Z2V0UG9vbGVkSW5zdGFuY2UoY29uc3QgSGFzaGFibGVUICYsIGNvbnN0IGludCwgaW50KSBbVCA9IGN2Zmxhbm46OkJyYW5jaFN0cnVjdDxjdmZsYW5uOjpIaWVyYXJjaGljYWxDbHVzdGVyaW5nSW5kZXg8Y3ZmbGFubjo6TDE8ZmxvYXQ+Pjo6Tm9kZSAqLCBmbG9hdD4sIEhhc2hhYmxlVCA9IGludF0AAADsyQEADKYBANUAAAABAAAAsKYBAPKmAQCSpgEAAAAAAOjLAQCUCAAAlQgAAJYIAACMAwAAlwgAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU43Y3ZmbGFubjRIZWFwSU5TMV8xMkJyYW5jaFN0cnVjdElQTlMxXzI3SGllcmFyY2hpY2FsQ2x1c3RlcmluZ0luZGV4SU5TMV8yTDFJZkVFRTROb2RlRWZFRUVFTlNfOWFsbG9jYXRvcklTQl9FRUVFADxqAgBYywEAxGUCAAAAAABQzAEAmAgAAJkIAACaCAAAmwgAADQIAACcCAAAnQgAAJ4IAACfCAAAoAgAAKEIAACiCAAAowgAAE43Y3ZmbGFubjhMc2hJbmRleElOU18yTDFJZkVFRUUAPGoCADDMAQBkwAEAKHNpemVfdClrbm4gPD0gaW5kZXhfLT5zaXplKCkAcnVuS25uU2VhcmNoXwBxdWVyeS50eXBlKCkgPT0gdHlwZSAmJiBpbmRpY2VzLnR5cGUoKSA9PSBDVl8zMlMgJiYgZGlzdHMudHlwZSgpID09IGR0eXBlAHF1ZXJ5LmlzQ29udGludW91cygpICYmIGluZGljZXMuaXNDb250aW51b3VzKCkgJiYgZGlzdHMuaXNDb250aW51b3VzKCkAcnVuUmFkaXVzU2VhcmNoXwAxLjYuMTAARGF0YVR5cGU8RWxlbWVudFR5cGU+Ojp0eXBlID09IGRhdGEudHlwZSgpICYmIGRhdGEuaXNDb250aW51b3VzKCkAbG9hZEluZGV4XwAAAAEAAAADAAAABABBlJsHCwECAEGgmwcL82QFAAAAAAAAAIjSAQCkCAAApQgAAKYIAABpbWFnZUNvdW50ID4gMABzZXQAL3NyYy9tb2R1bGVzL2ZlYXR1cmVzMmQvc3JjL21hdGNoZXJzLmNwcABkaW0gPiAwAGRlc2NyaXB0b3JzW2ldLmNvbHMgPT0gZGltICYmIGRlc2NyaXB0b3JzW2ldLnR5cGUoKSA9PSB0eXBlAChnbG9iYWxEZXNjSWR4Pj0wKSAmJiAoZ2xvYmFsRGVzY0lkeCA8IHNpemUoKSkAZ2V0TG9jYWxJZHgAAAAAAABM0gEApwgAAKgIAACpCAAAqggAAKsIAACsCAAAXwQAAGAEAACtCAAA6gMAAK4IAADqAwAA6gMAAOoDAABfZGVzY3JpcHRvcnMuaXNVTWF0KCkgfHwgX2Rlc2NyaXB0b3JzLmlzVU1hdFZlY3RvcigpIHx8IF9kZXNjcmlwdG9ycy5pc01hdCgpIHx8IF9kZXNjcmlwdG9ycy5pc01hdFZlY3RvcigpAGFkZABtYXNrcy5zaXplKCkgPT0gaW1hZ2VDb3VudABjaGVja01hc2tzAG1hc2tzW2ldLnR5cGUoKSA9PSBDVl84VUMxICYmIG1hc2tzW2ldLnJvd3MgPT0gcXVlcnlEZXNjcmlwdG9yc0NvdW50ICYmIG1hc2tzW2ldLmNvbHMgPT0gcm93cwBtYXhEaXN0YW5jZSA+IHN0ZDo6bnVtZXJpY19saW1pdHM8ZmxvYXQ+OjplcHNpbG9uKCkAcmFkaXVzTWF0Y2gAAAAAAACs0gEArwgAALAIAACxCAAAsggAALMIAACsCAAAXwQAAGAEAAC0CAAAtQgAALYIAAC3CAAAuAgAALkIAABfaW5kZXhQYXJhbXMARmxhbm5CYXNlZE1hdGNoZXIAX3NlYXJjaFBhcmFtcwB0cmFpbkRlc2NDb2xsZWN0aW9uLnNpemUoKSA9PSAwAHRyYWluAGluZGV4UGFyYW1zAGlwLnR5cGUoKSA9PSBGaWxlTm9kZTo6U0VRAHJlYWQAaXBbaV0udHlwZSgpID09IEZpbGVOb2RlOjpNQVAAbmFtZQB0eXBlAADs0AEAy80BAKkEAAADAAAAK9EBACzRAQA20QEAdmlydHVhbCB2b2lkIGN2OjpGbGFubkJhc2VkTWF0Y2hlcjo6cmVhZChjb25zdCBjdjo6RmlsZU5vZGUgJikAAChpbnQpdHlwZQAoaW50KUxBU1RfVkFMVUVfRkxBTk5fSU5ERVhfVFlQRQB2YWx1ZQBzZWFyY2hQYXJhbXMAc3AudHlwZSgpID09IEZpbGVOb2RlOjpTRVEAc3BbaV0udHlwZSgpID09IEZpbGVOb2RlOjpNQVAAAOzQAQDLzQEA0gQAAAMAAAAr0QEALNEBADbRAQBkZWVwIGNsb25lIGZ1bmN0aW9uYWxpdHkgaXMgbm90IGltcGxlbWVudGVkLCBiZWNhdXNlIEZsYW5uOjpJbmRleCBoYXMgbm90IGNvcHkgY29uc3RydWN0b3Igb3IgY2xvbmUgbWV0aG9kIABjbG9uZQBOMmN2MTdEZXNjcmlwdG9yTWF0Y2hlckUAADxqAgAy0gEAUCIBAE4yY3YxN0Rlc2NyaXB0b3JNYXRjaGVyMjBEZXNjcmlwdG9yQ29sbGVjdGlvbkUAABRqAgBY0gEATjJjdjE3Rmxhbm5CYXNlZE1hdGNoZXJFAAAAADxqAgCQ0gEATNIBAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAGTTAQC6CAAAuwgAALwIAACMAwAAvQgAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3YxN0ZsYW5uQmFzZWRNYXRjaGVyRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQA8agIAGNMBAMRlAgAAAAAA1NMBAL4IAAC/CAAAwAgAAIwDAADBCAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjVmbGFubjVJbmRleEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCAIzTAQDEZQIAAAAAAEjUAQDCCAAAwwgAAMQIAACMAwAAxQgAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y1Zmxhbm4xMUluZGV4UGFyYW1zRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQA8agIA/NMBAMRlAgBObyBlbGVtZW50IG5hbWUgaGFzIGJlZW4gZ2l2ZW4Ab3BlcmF0b3I8PAAvc3JjL21vZHVsZXMvY29yZS9pbmNsdWRlL29wZW5jdjIvY29yZS9wZXJzaXN0ZW5jZS5ocHAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAAAAAdNUBAMYIAADHCAAAyAgAAIwDAADJCAAAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzI2VW5pZm9ybVJhbmRvbUdlbmVyYXRvckltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAA8agIAGdUBAMRlAgAAAAAAUNYBAMoIAADLCAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAzAgAAM0IAADOCAAAzwgAANAIAADRCAAA0ggAANMIAADUCAAA1QgAAE4yY3Y0dXNhYzI2VW5pZm9ybVJhbmRvbUdlbmVyYXRvckltcGxFAE4yY3Y0dXNhYzIyVW5pZm9ybVJhbmRvbUdlbmVyYXRvckUATjJjdjR1c2FjMTVSYW5kb21HZW5lcmF0b3JFAAAAPGoCABrWAQBQIgEAPGoCAPfVAQA41gEAPGoCANDVAQBE1gEAeNYBAL/WAQDfAAAABQAAAOfWAQAI1wEACtcBAHZpcnR1YWwgdm9pZCBjdjo6dXNhYzo6VW5pZm9ybVJhbmRvbUdlbmVyYXRvckltcGw6OnJlc2V0R2VuZXJhdG9yKGludCkAL3NyYy9tb2R1bGVzL2NhbGliM2Qvc3JjL3VzYWMvdXRpbHMuY3BwAG1heCByYW5nZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwADAAbWF4X3JhbmdlXwAAAAA01wEAv9YBAOQAAAADAAAAk9cBAMfXAQDT1wEAdmlydHVhbCB2b2lkIGN2Ojp1c2FjOjpVbmlmb3JtUmFuZG9tR2VuZXJhdG9ySW1wbDo6Z2VuZXJhdGVVbmlxdWVSYW5kb21TZXQoc3RkOjp2ZWN0b3I8aW50PiAmKQBSYW5kb21HZW5lcmF0b3IuIFN1YnNldCBzaXplIG11c3QgYmUgTEUgdGhhbiByYW5nZSEAc3Vic2V0X3NpemUAbWF4X3JhbmdlAAAAAPzXAQC/1gEACAEAAAMAAACT1wEAZdgBAArXAQB2aXJ0dWFsIHZvaWQgY3Y6OnVzYWM6OlVuaWZvcm1SYW5kb21HZW5lcmF0b3JJbXBsOjpnZW5lcmF0ZVVuaXF1ZVJhbmRvbVNldChzdGQ6OnZlY3RvcjxpbnQ+ICYsIGludCwgaW50KQBzdWJzZXRfc2l6ZV8AAACQ2AEAv9YBAPoAAAADAAAAk9cBAMfXAQAK1wEAdmlydHVhbCB2b2lkIGN2Ojp1c2FjOjpVbmlmb3JtUmFuZG9tR2VuZXJhdG9ySW1wbDo6Z2VuZXJhdGVVbmlxdWVSYW5kb21TZXQoc3RkOjp2ZWN0b3I8aW50PiAmLCBpbnQpABDZAQC/1gEAFAEAAAMAAACT1wEAx9cBAIrZAQB2aXJ0dWFsIGNvbnN0IHN0ZDo6dmVjdG9yPGludD4gJmN2Ojp1c2FjOjpVbmlmb3JtUmFuZG9tR2VuZXJhdG9ySW1wbDo6Z2VuZXJhdGVVbmlxdWVSYW5kb21TdWJzZXQoc3RkOjp2ZWN0b3I8aW50PiAmLCBpbnQpAHNpemUxAAAAAAAQ2gEA1ggAANcIAADYCAAAjAMAANkIAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMzM1JhZGl1c1NlYXJjaE5laWdoYm9yaG9vZEdyYXBoSW1wbEVOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCAKzZAQDEZQIAAAAAABTbAQDaCAAA2wgAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAANwIAABjb250YWluZXJfLnR5cGUoKSA9PSBDVl8zMkYAUmFkaXVzU2VhcmNoTmVpZ2hib3Job29kR3JhcGhJbXBsAE4yY3Y0dXNhYzMzUmFkaXVzU2VhcmNoTmVpZ2hib3Job29kR3JhcGhJbXBsRQBOMmN2NHVzYWMyOVJhZGl1c1NlYXJjaE5laWdoYm9yaG9vZEdyYXBoRQBOMmN2NHVzYWMxN05laWdoYm9yaG9vZEdyYXBoRQA8agIA3toBAFAiAQA8agIAtNoBAPzaAQA8agIAhtoBAAjbAQAAAAAAkNsBAN0IAADeCAAA3wgAAIwDAADgCAAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJTjJjdjVmbGFubjE3S0RUcmVlSW5kZXhQYXJhbXNFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCADzbAQDEZQIAAAAAAAjcAQDhCAAA4ggAAOMIAACMAwAA5AgAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y1Zmxhbm4xMlNlYXJjaFBhcmFtc0VOU185YWxsb2NhdG9ySVMzX0VFRUUAAAAAPGoCALjbAQDEZQIAAAAAAIzcAQDlCAAA5ggAAOcIAACMAwAA6AgAAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSU4yY3Y0dXNhYzI2Rmxhbm5OZWlnaGJvcmhvb2RHcmFwaEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAPGoCADDcAQDEZQIAAAAAAFzdAQDpCAAA6ggAAFsEAABcBAAAXQQAAF4EAABfBAAAYAQAAOsIAADsCAAAa19uZWFyZXN0X25laWdoYm9ycyA8PSBwb2ludHNfc2l6ZQBGbGFubk5laWdoYm9yaG9vZEdyYXBoSW1wbABOMmN2NHVzYWMyNkZsYW5uTmVpZ2hib3Job29kR3JhcGhJbXBsRQBOMmN2NHVzYWMyMkZsYW5uTmVpZ2hib3Job29kR3JhcGhFADxqAgAt3QEA/NoBADxqAgAG3QEAUN0BAAAAAADg3QEA7QgAAO4IAADvCAAAjAMAAPAIAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOMmN2NHVzYWMyNUdyaWROZWlnaGJvcmhvb2RHcmFwaEltcGxFTlNfOWFsbG9jYXRvcklTM19FRUVFAAAAADxqAgCE3QEAxGUCAAAAAABs3gEA8QgAAPIIAABbBAAAXAQAAF0EAABeBAAAXwQAAGAEAADzCAAATjJjdjR1c2FjMjVHcmlkTmVpZ2hib3Job29kR3JhcGhJbXBsRQBOMmN2NHVzYWMyMUdyaWROZWlnaGJvcmhvb2RHcmFwaEUAPGoCAD7eAQD82gEAPGoCABjeAQBg3gEAY24gPT0gMQBtZWFuU2hpZnQA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BwsAAAhjAAAIIwAACaYAAAgDAAAIgwAACEMAAAnmABAHBwAACFsAAAgbAAAJlgAUB0MAAAh7AAAIOwAACdYAEgcTAAAIawAACCsAAAm2AAAICwAACIsAAAhLAAAJ9gAQBwUAAAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnOABEHDwAACGcAAAgnAAAJrgAACAcAAAiHAAAIRwAACe4AEAcJAAAIXwAACB8AAAmeABQHYwAACH8AAAg/AAAJ3gASBxsAAAhvAAAILwAACb4AAAgPAAAIjwAACE8AAAn+AGAHAAAACFAAAAgQABQIcwASBx8AAAhwAAAIMAAACcEAEAcKAAAIYAAACCAAAAmhAAAIAAAACIAAAAhAAAAJ4QAQBwYAAAhYAAAIGAAACZEAEwc7AAAIeAAACDgAAAnRABEHEQAACGgAAAgoAAAJsQAACAgAAAiIAAAISAAACfEAEAcEAAAIVAAACBQAFQjjABMHKwAACHQAAAg0AAAJyQARBw0AAAhkAAAIJAAACakAAAgEAAAIhAAACEQAAAnpABAHCAAACFwAAAgcAAAJmQAUB1MAAAh8AAAIPAAACdkAEgcXAAAIbAAACCwAAAm5AAAIDAAACIwAAAhMAAAJ+QAQBwMAAAhSAAAIEgAVCKMAEwcjAAAIcgAACDIAAAnFABEHCwAACGIAAAgiAAAJpQAACAIAAAiCAAAIQgAACeUAEAcHAAAIWgAACBoAAAmVABQHQwAACHoAAAg6AAAJ1QASBxMAAAhqAAAIKgAACbUAAAgKAAAIigAACEoAAAn1ABAHBQAACFYAAAgWAEAIAAATBzMAAAh2AAAINgAACc0AEQcPAAAIZgAACCYAAAmtAAAIBgAACIYAAAhGAAAJ7QAQBwkAAAheAAAIHgAACZ0AFAdjAAAIfgAACD4AAAndABIHGwAACG4AAAguAAAJvQAACA4AAAiOAAAITgAACf0AYAcAAAAIUQAACBEAFQiDABIHHwAACHEAAAgxAAAJwwAQBwoAAAhhAAAIIQAACaMAAAgBAAAIgQAACEEAAAnjABAHBgAACFkAAAgZAAAJkwATBzsAAAh5AAAIOQAACdMAEQcRAAAIaQAACCkAAAmzAAAICQAACIkAAAhJAAAJ8wAQBwQAAAhVAAAIFQAQCAIBEwcrAAAIdQAACDUAAAnLABEHDQAA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AAgAGgAIAJoACABaAAgA2gAIADoACAC6AAgAegAIAPoACAAGAAgAhgAIAEYACADGAAgAJgAIAKYACABmAAgA5gAIABYACACWAAgAVgAIANYACAA2AAgAtgAIAHYACAD2AAgADgAIAI4ACABOAAgAzgAIAC4ACACuAAgAbgAIAO4ACAAeAAgAngAIAF4ACADeAAgAPgAIAL4ACAB+AAgA/gAIAAEACACBAAgAQQAIAMEACAAhAAgAoQAIAGEACADhAAgAEQAIAJEACABRAAgA0QAIADEACACxAAgAcQAIAPEACAAJAAgAiQAIAEkACADJAAgAKQAIAKkACABpAAgA6QAIABkACACZAAgAWQAIANkACAA5AAgAuQAIAHkACAD5AAgABQAIAIUACABFAAgAxQAIACUACAClAAgAZQAIAOUACAAVAAgAlQAIAFUACADVAAgANQAIALUACAB1AAgA9QAIAA0ACACNAAgATQAIAM0ACAAtAAgArQAIAG0ACADtAAgAHQAIAJ0ACABdAAgA3QAIAD0ACAC9AAgAfQAIAP0ACAATAAkAEwEJAJMACQCTAQkAUwAJAFMBCQDTAAkA0wEJADMACQAzAQkAswAJALMBCQBzAAkAcwEJAPMACQDzAQkACwAJAAsBCQCLAAkAiwEJAEsACQBLAQkAywAJAMsBCQArAAkAKwEJAKsACQCrAQkAawAJAGsBCQDrAAkA6wEJABsACQAbAQkAmwAJAJsBCQBbAAkAWwEJANsACQDbAQkAOwAJADsBCQC7AAkAuwEJAHsACQB7AQkA+wAJAPsBCQAHAAkABwEJAIcACQCHAQkARwAJAEcBCQDHAAkAxwEJACcACQAnAQkApwAJAKcBCQBnAAkAZwEJAOcACQDnAQkAFwAJABcBCQCXAAkAlwEJAFcACQBXAQkA1wAJANcBCQA3AAkANwEJALcACQC3AQkAdwAJAHcBCQD3AAkA9wEJAA8ACQAPAQkAjwAJAI8BCQBPAAkATwEJAM8ACQDPAQkALwAJAC8BCQCvAAkArwEJAG8ACQBvAQkA7wAJAO8BCQAfAAkAHwEJAJ8ACQCfAQkAXwAJAF8BCQDfAAkA3wEJAD8ACQA/AQkAvwAJAL8BCQB/AAkAfwEJAP8ACQD/AQkAAAAHAEAABwAgAAcAYAAHABAABwBQAAcAMAAHAHAABwAIAAcASAAHACgABwBoAAcAGAAHAFgABwA4AAcAeAAHAAQABwBEAAcAJAAHAGQABwAUAAcAVAAHADQABwB0AAcAAwAIAIMACABDAAgAwwAIACMACACjAAgAYwAIAOMACAAAAAUAEAAFAAgABQAYAAUABAAFABQABQAMAAUAHAAFAAIABQASAAUACgAFABoABQAGAAUAFgAFAA4ABQAeAAUAAQAFABEABQAJAAUAGQAFAAUABQAVAAUADQAFAB0ABQADAAUAEwAFAAsABQAbAAUABwAFABcABQBB0KgIC00BAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAAAAFAAAABQBBwKkIC2UBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAFAAAABgAAAAYAAAAHAAAABwAAAAgAAAAIAAAACQAAAAkAAAAKAAAACgAAAAsAAAALAAAADAAAAAwAAAANAAAADQBB8KoICyMCAAAAAwAAAAcAAAAAAAAAEBESAAgHCQYKBQsEDAMNAg4BDwBBpKsIC2kBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4AAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAQaSsCAuzDAEAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAAABAACAAQAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAbmVlZCBkaWN0aW9uYXJ5AHN0cmVhbSBlbmQAAGZpbGUgZXJyb3IAc3RyZWFtIGVycm9yAGRhdGEgZXJyb3IAaW5zdWZmaWNpZW50IG1lbW9yeQBidWZmZXIgZXJyb3IAaW5jb21wYXRpYmxlIHZlcnNpb24AAAAAmBYCAKgWAgCzFgIAtBYCAL8WAgDMFgIA1xYCAOsWAgD4FgIAsxYCAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAZmxvYXQAZG91YmxlAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAAACYagIAThoCAAAAAAABAAAATF4AAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAmGoCAKgaAgAAAAAAAQAAAExeAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAACYagIAABsCAAAAAAABAAAATF4AAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAJhqAgBcGwIAAAAAAAEAAABMXgAAAAAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAFGoCALgbAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAABRqAgDgGwIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAAAUagIACBwCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAFGoCADAcAgBB4LgIC1cZEkQ7Aj8sRxQ9MzAKGwZGS0U3D0kOjhcDQB08aSs2H0otHAEgJSkhCAwVFiIuEDg+CzQxGGR0dXYvQQl/OREjQzJCiYqLBQQmKCcNKh41jAcaSJMTlJUAQcC5CAuKDklsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5v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BhEAAAAREREAQbHhCAshCwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAALAEHr4QgLAQwAQffhCAsVDAAAAAAMAAAAAAkMAAAAAAAMAAAMAEGl4ggLAQ4AQbHiCAsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEHf4ggLARAAQeviCAseDwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAEGi4wgLDhIAAAASEhIAAAAAAAAJAEHT4wgLAQsAQd/jCAsVCgAAAAAKAAAAAAkLAAAAAAALAAALAEGN5AgLAQwAQZnkCAvtAgwAAAAADAAAAAAJDAAAAAAADAAADAAAMDEyMzQ1Njc4OUFCQ0RFRi0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4ALgAAAADQqAIAaKkCAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAaW5maW5pdHkAbmFuAEGQ5wgLwwHRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///9jbG9ja19nZXR0aW1lKENMT0NLX01PTk9UT05JQykgZmFpbGVkAHN0ZDo6YmFkX2Z1bmN0aW9uX2NhbGwAAAAAAAAAAEg0AgAPBgAAAwkAAAQJAABOU3QzX18yMTdiYWRfZnVuY3Rpb25fY2FsbEUAPGoCACw0AgAUZwIAQeToCAvzDwIAAAADAAAABQAAAAcAAAALAAAADQAAABEAAAATAAAAFwAAAB0AAAAfAAAAJQAAACkAAAArAAAALwAAADUAAAA7AAAAPQAAAEMAAABHAAAASQAAAE8A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ANAJAABOU3QzX18yN251bV9wdXRJd05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAE5TdDNfXzI5X19udW1fcHV0SXdFRQAAAJhqAgDYVwIAAAAAAAEAAAAgVwIAAAAAAJhqAgCUVwIAAAAAAAIAAABwUAIAAgAAAPBXAgBBrLAJC5sLCFkCANEJAADSCQAAUgkAANMJAADUCQAA1QkAANYJAADXCQAA2AkAANkJAAD4////CFkCANoJAADbCQAA3AkAAN0JAADeCQAA3wkAAOAJAABOU3QzX18yOHRpbWVfZ2V0SWNOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yOXRpbWVfYmFzZUUAFGoCAMFYAgBOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUljRUUAAAAUagIA3FgCAJhqAgB8WAIAAAAAAAMAAABwUAIAAgAAANRYAgACAAAAAFkCAAAIAAAAAAAA9FkCAOEJAADiCQAAUgkAAOMJAADkCQAA5QkAAOYJAADnCQAA6AkAAOkJAAD4////9FkCAOoJAADrCQAA7AkAAO0JAADuCQAA7wkAAPAJAABOU3QzX18yOHRpbWVfZ2V0SXdOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUl3RUUAABRqAgDJWQIAmGoCAIRZAgAAAAAAAwAAAHBQAgACAAAA1FgCAAIAAADsWQIAAAgAAAAAAACYWgIA8QkAAPIJAABSCQAA8wkAAE5TdDNfXzI4dGltZV9wdXRJY05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzIxMF9fdGltZV9wdXRFAAAAFGoCAHlaAgCYagIANFoCAAAAAAACAAAAcFACAAIAAACQWgIAAAgAAAAAAAAYWwIA9AkAAPUJAABSCQAA9gkAAE5TdDNfXzI4dGltZV9wdXRJd05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVF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TlN0M19fMjE5X19zaGFyZWRfd2Vha19jb3VudEUAAACYagIApGUCAAAAAAABAAAAnGUCAAAAAAByZWN1cnNpdmVfbXV0ZXggY29uc3RydWN0b3IgZmFpbGVkAHJlY3Vyc2l2ZV9tdXRleCBsb2NrIGZhaWxlZABiYXNpY19zdHJpbmcAc3RvdWxsADogbm8gY29udmVyc2lvbgAlcwoAOiBvdXQgb2YgcmFuZ2UAdmVjdG9yAF9fY3hhX2d1YXJkX2FjcXVpcmUgZGV0ZWN0ZWQgcmVjdXJzaXZlIGluaXRpYWxpemF0aW9uAHRlcm1pbmF0aW5nAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABQdXJlIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQBzdGQ6OmV4Y2VwdGlvbgAAAAAAFGcCADUKAAA2CgAANwoAAFN0OWV4Y2VwdGlvbgAAAAAUagIABGcCAAAAAABAZwIAnAEAADgKAAA5CgAAU3QxMWxvZ2ljX2Vycm9yADxqAgAwZwIAFGcCAAAAAAB0ZwIAnAEAADoKAAA5CgAAU3QxMmxlbmd0aF9lcnJvcgAAAAA8agIAYGcCAEBnAgBTdDl0eXBlX2luZm8AAAAAFGoCAIBnAgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAA8agIAmGcCAJBnAgBOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAAA8agIAyGcCALxnAgBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAAA8agIA+GcCALxnAgBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQA8agIAKGgCABxoAgBOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAAPGoCAFhoAgC8ZwIATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAAPGoCAIxoAgAcaAIAAAAAAAxpAgA7CgAAPAoAAD0KAAA+CgAAPwoAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQA8agIA5GgCALxnAgB2AAAA0GgCABhpAgBEbgAA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AABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxME5lc3RlZE5hbWVFAAA8agIARH4CANh8AgA6OgBhdXRvAAAAAAD0fgIAYwoAAGQKAABlCgAAZgoAAGcKAABoCgAAVwoAAFgKAABpCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjRGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2VFAAAAADxqAgC0fgIA2HwCAGRlY2x0eXBlKAApAGdzACYmACYAJj0APQBhbGlnbm9mICgAY29uc3RfY2FzdAAsAH4AZHluYW1pY19jYXN0ACoALioALgAvAC89AF4AXj0APT0APj0APgA8PQA8PAA8PD0APAAtAC09ACo9AC0tACE9ACEAbm9leGNlcHQgKAB8fAB8AHw9AC0+KgArACs9ACsrAC0+AHJlaW50ZXJwcmV0X2Nhc3QAJQAlPQA+PgA+Pj0Ac3RhdGljX2Nhc3QAc2l6ZW9mICgAc2l6ZW9mLi4uICgAdHlwZWlkICgAdGhyb3cAdThfX3V1aWRvZnQAdThfX3V1aWRvZnoAd2NoYXJfdABiMEUAYjFFAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydAAAdQBsAHVsAGxsAHVsbABfX2ludDEyOAB1bnNpZ25lZCBfX2ludDEyOABEbkUAbnVsbHB0cgAAAAAAAAAA2IACAFEKAABSCgAAUwoAAFQKAABqCgAAVgoAAFcKAABYCgAAawoAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE0SW50ZWdlckxpdGVyYWxFAAA8agIApIACANh8AgAoAAAAAAAAAECBAgBRCgAAUgoAAFMKAABUCgAAbAoAAFYKAABXCgAAWAoAAG0KAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Qm9vbEV4cHJFADxqAgAUgQIA2HwCAHRydWUAZmFsc2UAAAAAAAC8gQIAUQoAAFIKAABTCgAAVAoAAG4KAABWCgAAVwoAAFgKAABvCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGbG9hdExpdGVyYWxJbXBsSWZFRQA8agIAhIECANh8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T0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNRdWFsaWZpZWROYW1lRQAAADxqAgBMjAIA2HwCAGRuAG9uAAAAAAAAAOyMAgBRCgAAUgoAAFMKAABUCgAAoQoAAFYKAABXCgAAWAoAAKIKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4RHRvck5hbWVFADxqAgDAjAIA2HwCAG9wZXJhdG9yJiYAb3BlcmF0b3ImAG9wZXJhdG9yJj0Ab3BlcmF0b3I9AG9wZXJhdG9yKCkAb3BlcmF0b3IsAG9wZXJhdG9yfgBvcGVyYXRvciBkZWxldGVbXQBvcGVyYXRvcioAb3BlcmF0b3IgZGVsZXRlAG9wZXJhdG9yLwBvcGVyYXRvci89AG9wZXJhdG9yXgBvcGVyYXRvcl49AG9wZXJhdG9yPT0Ab3BlcmF0b3I+PQBvcGVyYXRvcj4Ab3BlcmF0b3JbXQBvcGVyYXRvcjw9AG9wZXJhdG9yPDwAb3BlcmF0b3I8PD0Ab3BlcmF0b3I8AG9wZXJhdG9yLQBvcGVyYXRvci09AG9wZXJhdG9yKj0Ab3BlcmF0b3ItLQBvcGVyYXRvciBuZXdbXQBvcGVyYXRvciE9AG9wZXJhdG9yIQBvcGVyYXRvciBuZXcAb3BlcmF0b3J8fABvcGVyYXRvcnwAb3BlcmF0b3J8PQBvcGVyYXRvci0+KgBvcGVyYXRvcisAb3BlcmF0b3IrPQBvcGVyYXRvcisrAG9wZXJhdG9yLT4Ab3BlcmF0b3I/AG9wZXJhdG9yJQBvcGVyYXRvciU9AG9wZXJhdG9yPj4Ab3BlcmF0b3I+Pj0Ab3BlcmF0b3I8PT4AAAAAAABMjwIAUQoAAFIKAABTCgAAVAoAAKMKAABWCgAAVwoAAFgKAACkCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJDb252ZXJzaW9uT3BlcmF0b3JUeXBlRQAAPGoCABCPAgDYfAIAb3BlcmF0b3IgAAAAAAAAAMSPAgBRCgAAUgoAAFMKAABUCgAApQoAAFYKAABXCgAAWAoAAKYKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUxpdGVyYWxPcGVyYXRvckUAPGoCAJCPAgDYfAIAb3BlcmF0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YWxsb2NhdG9yPGNoYXI+ID4Ac3RkOjpiYXNpY19pc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBzdGQ6OmJhc2ljX29zdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AHN0ZDo6YmFzaWNfaW9zdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AGFsbG9jYXRvcgBiYXNpY19zdHJpbmcAYmFzaWNfaXN0cmVhbQBiYXNpY19vc3RyZWFtAGJhc2ljX2lvc3RyZWFtAAAAAAAAAAAsmAIAUQoAAFIKAABTCgAAVAoAAMcKAABWCgAAVwoAAFgKAADICgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJDdG9yRHRvck5hbWVFAAAAADxqAgD4lwIA2HwCAAAAAACUmAIAUQoAAFIKAABTCgAAVAoAAMkKAABWCgAAVwoAAFgKAADKCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBBYmlUYWdBdHRyRQAAPGoCAGSYAgDYfAIAW2FiaToAREMAAAAAAAAAABSZAgBRCgAAUgoAAFMKAABUCgAAywoAAFYKAABXCgAAWAoAAMwKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMVN0cnVjdHVyZWRCaW5kaW5nTmFtZUUAAAA8agIA2JgCANh8AgBzdHJpbmcgbGl0ZXJhbAAAAAAAAIyZAgBRCgAAUgoAAFMKAABUCgAAzQoAAFYKAABXCgAAWAoAAM4KAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5TG9jYWxOYW1lRQAAAAA8agIAXJkCANh8AgAAAAAA/JkCAFEKAABSCgAAUwoAAFQKAADPCgAAVgoAANAKAABYCgAA0QoAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE5U3BlY2lhbFN1YnN0aXR1dGlvbkUAPGoCAMSZAgDYfAIAc3RkOjpzdHJpbmcAc3RkOjppc3RyZWFtAHN0ZDo6b3N0cmVhbQBzdGQ6Omlvc3RyZWFtAHN0cmluZwBpc3RyZWFtAG9zdHJlYW0AaW9zdHJlYW0AAAAAALyaAgDSCgAA0woAANQKAADVCgAA1goAANcKAABXCgAAWAoAANgKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1BhcmFtZXRlclBhY2tFAAAAPGoCAIiaAgDYfAIAAAAAACibAgBRCgAAUgoAAFMKAABUCgAA2QoAAFYKAABXCgAAWAoAANoKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMlRlbXBsYXRlQXJnc0UAAAAAPGoCAPSaAgDYfAIAAAAAAJybAgBRCgAAUgoAAFMKAABUCgAA2woAAFYKAADcCgAAWAoAAN0KAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyME5hbWVXaXRoVGVtcGxhdGVBcmdzRQAAAAA8agIAYJsCANh8AgBTdEwAAAAAABCcAgBRCgAAUgoAAFMKAABUCgAA3goAAFYKAADfCgAAWAoAAOAKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNlN0ZFF1YWxpZmllZE5hbWVFAAAAADxqAgDYmwIA2HwCAHN0ZDo6AAAAAAAAAIycAgBRCgAAUgoAAFMKAABUCgAA4QoAAFYKAABXCgAAWAoAAOIKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMFRlbXBsYXRlQXJndW1lbnRQYWNrRQAAAAA8agIAUJwCANh8AgAAAAAA+JwCAFEKAABSCgAAUwoAAFQKAADjCgAAVgoAAFcKAABYCgAA5AoAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyRW5hYmxlSWZBdHRyRQAAAAA8agIAxJwCANh8AgAgW2VuYWJsZV9pZjoAAAAAAAAAAHidAgDlCgAAUgoAAOYKAABUCgAA5woAAOgKAABXCgAAWAoAAOkKAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZ1bmN0aW9uRW5jb2RpbmdFAAAAADxqAgBAnQIA2HwCACBjb25zdAAgdm9sYXRpbGUAIHJlc3RyaWN0ACAmACAmJgAAAAAAAAAEngIAUQoAAFIKAABTCgAAVAoAAOoKAABWCgAAVwoAAFgKAADrCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOURvdFN1ZmZpeEUAAAAAPGoCANSdAgDYfAIAdm9pZABib29sAGludAB1bnNpZ25lZCBpbnQAbG9uZwB1bnNpZ25lZCBsb25nAGxvbmcgbG9uZwB1bnNpZ25lZCBsb25nIGxvbmcAZmxvYXQAZG91YmxlAGxvbmcgZG91YmxlAF9fZmxvYXQxMjgAZGVjaW1hbDY0AGRlY2ltYWwxMjgAZGVjaW1hbDMyAGRlY2ltYWwxNgBjaGFyMzJfdABjaGFyMTZfdABjaGFyOF90AGRlY2x0eXBlKGF1dG8pAHN0ZDo6bnVsbHB0cl90ACBjb21wbGV4ACBpbWFnaW5hcnkARG8Abm9leGNlcHQARE8ARHcARHgAUkUAT0UAAAAAAABwnwIAUQoAAFIKAABTCgAAVAoAAOwKAABWCgAAVwoAAFgKAADtCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJOb2V4Y2VwdFNwZWNFAAAAADxqAgA8nwIA2HwCAG5vZXhjZXB0KAAAAAAAAADwnwIAUQoAAFIKAABTCgAAVAoAAO4KAABWCgAAVwoAAFgKAADvCgAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBEeW5hbWljRXhjZXB0aW9uU3BlY0UAAAAAPGoCALSfAgDYfAIAdGhyb3coAAAAAAAAZKACAPAKAABSCgAA8QoAAFQKAADyCgAA8woAAFcKAABYCgAA9AoAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyRnVuY3Rpb25UeXBlRQAAAAA8agIAMKACANh8AgBvYmpjcHJvdG8AAAAAAAAA3KACAFEKAABSCgAAUwoAAFQKAAD1CgAAVgoAAFcKAABYCgAA9goAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzT2JqQ1Byb3RvTmFtZUUAAAA8agIAqKACANh8AgAAAAAATKECAFEKAABSCgAAUwoAAFQKAAD3CgAAVgoAAFcKAABYCgAA+AoAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE3VmVuZG9yRXh0UXVhbFR5cGVFAAAAPGoCABShAgDYfAIAAAAAALChAgD5CgAA+goAAPsK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";function kA(){try{if(N)return new Uint8Array(N);var A=Vt(mA);if(A)return A;if(c)return c(mA);throw"both async and sync fetching of the wasm failed"}catch(A){wA(A)}}function SA(){return N||!E&&!n||"function"!=typeof fetch||fA(mA)?Promise.resolve().then(kA):fetch(mA,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at '"+mA+"'";return A.arrayBuffer()})).catch((function(){return kA()}))}function MA(){var A={env:Ot,wasi_snapshot_preview1:Ot};function g(A,g){var I=A.exports;e.asm=I,IA((F=e.asm.memory).buffer),tA=e.asm.__indirect_function_table,uA("wasm-instantiate")}function I(A){g(A.instance)}function t(g){return SA().then((function(g){return WebAssembly.instantiate(g,A)})).then(g,(function(A){p("failed to asynchronously prepare wasm: "+A),wA(A)}))}function B(){return N||"function"!=typeof WebAssembly.instantiateStreaming||yA(mA)||fA(mA)||"function"!=typeof fetch?t(I):fetch(mA,{credentials:"same-origin"}).then((function(g){return WebAssembly.instantiateStreaming(g,A).then(I,(function(A){return p("wasm streaming compile failed: "+A),p("falling back to ArrayBuffer instantiation"),t(I)}))}))}if(DA("wasm-instantiate"),e.instantiateWasm)try{return e.instantiateWasm(A,g)}catch(A){return p("Module.instantiateWasm callback failed with error: "+A),!1}return B().catch(C),{}}function UA(A,g){if(JA.mainLoop.timingMode=A,JA.mainLoop.timingValue=g,!JA.mainLoop.func)return 1;if(0==A)JA.mainLoop.scheduler=function(){var A=0|Math.max(0,JA.mainLoop.tickStartTime+g-RA());setTimeout(JA.mainLoop.runner,A)},JA.mainLoop.method="timeout";else if(1==A)JA.mainLoop.scheduler=function(){JA.requestAnimationFrame(JA.mainLoop.runner)},JA.mainLoop.method="rAF";else if(2==A){if("undefined"==typeof setImmediate){var I=[],t="setimmediate";addEventListener("message",(function(A){A.data!==t&&A.data.target!==t||(A.stopPropagation(),I.shift()())}),!0),setImmediate=function(A){I.push(A),n?(void 0===e.setImmediates&&(e.setImmediates=[]),e.setImmediates.push(A),postMessage({target:t})):postMessage(t,"*")}}JA.mainLoop.scheduler=function(){setImmediate(JA.mainLoop.runner)},JA.mainLoop.method="immediate"}return 0}function KA(A,g,I,t,C){k(!JA.mainLoop.func,"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."),JA.mainLoop.func=A,JA.mainLoop.arg=t;var e=JA.mainLoop.currentlyRunningMainloop;if(JA.mainLoop.runner=function(){if(!m)if(JA.mainLoop.queue.length>0){var g=Date.now(),I=JA.mainLoop.queue.shift();if(I.func(I.arg),JA.mainLoop.remainingBlockers){var t=JA.mainLoop.remainingBlockers,C=t%1==0?t-1:Math.floor(t);I.counted?JA.mainLoop.remainingBlockers=C:(C+=.5,JA.mainLoop.remainingBlockers=(8*t+C)/9)}if(console.log('main loop blocker "'+I.name+'" took '+(Date.now()-g)+" ms"),JA.mainLoop.updateStatus(),e<JA.mainLoop.currentlyRunningMainloop)return;setTimeout(JA.mainLoop.runner,0)}else e<JA.mainLoop.currentlyRunningMainloop||(JA.mainLoop.currentFrameNumber=JA.mainLoop.currentFrameNumber+1|0,1==JA.mainLoop.timingMode&&JA.mainLoop.timingValue>1&&JA.mainLoop.currentFrameNumber%JA.mainLoop.timingValue!=0?JA.mainLoop.scheduler():(0==JA.mainLoop.timingMode&&(JA.mainLoop.tickStartTime=RA()),JA.mainLoop.runIter(A),e<JA.mainLoop.currentlyRunningMainloop||("object"==typeof SDL&&SDL.audio&&SDL.audio.queueNewAudioData&&SDL.audio.queueNewAudioData(),JA.mainLoop.scheduler())))},C||(g&&g>0?UA(0,1e3/g):UA(1,1),JA.mainLoop.scheduler()),I)throw"unwind"}yA(mA)||(mA=w(mA)),RA=s?function(){var A=process.hrtime();return 1e3*A[0]+A[1]/1e6}:"undefined"!=typeof dateNow?dateNow:function(){return performance.now()};var JA={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function(){JA.mainLoop.scheduler=null,JA.mainLoop.currentlyRunningMainloop++},resume:function(){JA.mainLoop.currentlyRunningMainloop++;var A=JA.mainLoop.timingMode,g=JA.mainLoop.timingValue,I=JA.mainLoop.func;JA.mainLoop.func=null,KA(I,0,!1,JA.mainLoop.arg,!0),UA(A,g),JA.mainLoop.scheduler()},updateStatus:function(){if(e.setStatus){var A=e.statusMessage||"Please wait...",g=JA.mainLoop.remainingBlockers,I=JA.mainLoop.expectedBlockers;g?g<I?e.setStatus(A+" ("+(I-g)+"/"+I+")"):e.setStatus(A):e.setStatus("")}},runIter:function(A){if(!m){if(e.preMainLoop&&!1===e.preMainLoop())return;try{A()}catch(A){if(A instanceof _t)return;if("unwind"==A)return;throw A&&"object"==typeof A&&A.stack&&p("exception thrown: "+[A,A.stack]),A}e.postMainLoop&&e.postMainLoop()}}},isFullscreen:!1,pointerLock:!1,moduleContextCreatedCallbacks:[],workers:[],init:function(){if(e.preloadPlugins||(e.preloadPlugins=[]),!JA.initted){JA.initted=!0;try{new Blob,JA.hasBlobConstructor=!0}catch(A){JA.hasBlobConstructor=!1,console.log("warning: no blob constructor, cannot create blobs with mimetypes")}JA.BlobBuilder="undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:JA.hasBlobConstructor?null:console.log("warning: no BlobBuilder"),JA.URLObject="undefined"!=typeof window?window.URL?window.URL:window.webkitURL:void 0,e.noImageDecoding||void 0!==JA.URLObject||(console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available."),e.noImageDecoding=!0);var A={canHandle:function(A){return!e.noImageDecoding&&/\.(jpg|jpeg|png|bmp)$/i.test(A)},handle:function(A,g,I,t){var C=null;if(JA.hasBlobConstructor)try{(C=new Blob([A],{type:JA.getMimetype(g)})).size!==A.length&&(C=new Blob([new Uint8Array(A).buffer],{type:JA.getMimetype(g)}))}catch(A){f("Blob constructor present but fails: "+A+"; falling back to blob builder")}if(!C){var B=new JA.BlobBuilder;B.append(new Uint8Array(A).buffer),C=B.getBlob()}var i=JA.URLObject.createObjectURL(C),Q=new Image;Q.onload=function(){k(Q.complete,"Image "+g+" could not be decoded");var t=document.createElement("canvas");t.width=Q.width,t.height=Q.height,t.getContext("2d").drawImage(Q,0,0),e.preloadedImages[g]=t,JA.URLObject.revokeObjectURL(i),I&&I(A)},Q.onerror=function(A){console.log("Image "+i+" could not be decoded"),t&&t()},Q.src=i}};e.preloadPlugins.push(A);var g={canHandle:function(A){return!e.noAudioDecoding&&A.substr(-4)in{".ogg":1,".wav":1,".mp3":1}},handle:function(A,g,I,t){var C=!1;function B(t){C||(C=!0,e.preloadedAudios[g]=t,I&&I(A))}function i(){C||(C=!0,e.preloadedAudios[g]=new Audio,t&&t())}if(!JA.hasBlobConstructor)return i();try{var Q=new Blob([A],{type:JA.getMimetype(g)})}catch(A){return i()}var o=JA.URLObject.createObjectURL(Q),E=new Audio;E.addEventListener("canplaythrough",(function(){B(E)}),!1),E.onerror=function(I){function t(A){for(var g="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",I="=",t="",C=0,e=0,B=0;B<A.length;B++)for(C=C<<8|A[B],e+=8;e>=6;){var i=C>>e-6&63;e-=6,t+=g[i]}return 2==e?(t+=g[(3&C)<<4],t+=I+I):4==e&&(t+=g[(15&C)<<2],t+=I),t}C||(console.log("warning: browser could not fully decode audio "+g+", trying slower base64 approach"),E.src="data:audio/x-"+g.substr(-3)+";base64,"+t(A),B(E))},E.src=o,JA.safeSetTimeout((function(){B(E)}),1e4)}};e.preloadPlugins.push(g);var I=e.canvas;I&&(I.requestPointerLock=I.requestPointerLock||I.mozRequestPointerLock||I.webkitRequestPointerLock||I.msRequestPointerLock||function(){},I.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock||document.msExitPointerLock||function(){},I.exitPointerLock=I.exitPointerLock.bind(document),document.addEventListener("pointerlockchange",t,!1),document.addEventListener("mozpointerlockchange",t,!1),document.addEventListener("webkitpointerlockchange",t,!1),document.addEventListener("mspointerlockchange",t,!1),e.elementPointerLock&&I.addEventListener("click",(function(A){!JA.pointerLock&&e.canvas.requestPointerLock&&(e.canvas.requestPointerLock(),A.preventDefault())}),!1))}function t(){JA.pointerLock=document.pointerLockElement===e.canvas||document.mozPointerLockElement===e.canvas||document.webkitPointerLockElement===e.canvas||document.msPointerLockElement===e.canvas}},createContext:function(A,g,I,t){if(g&&e.ctx&&A==e.canvas)return e.ctx;var C,B;if(g){var i={antialias:!1,alpha:!1,majorVersion:1};if(t)for(var Q in t)i[Q]=t[Q];"undefined"!=typeof GL&&(B=GL.createContext(A,i))&&(C=GL.getContext(B).GLctx)}else C=A.getContext("2d");return C?(I&&(g||k("undefined"==typeof GLctx,"cannot set in module if GLctx is used, but we are a non-GL context that would replace it"),e.ctx=C,g&&GL.makeContextCurrent(B),e.useWebGL=g,JA.moduleContextCreatedCallbacks.forEach((function(A){A()})),JA.init()),C):null},destroyContext:function(A,g,I){},fullscreenHandlersInstalled:!1,lockPointer:void 0,resizeCanvas:void 0,requestFullscreen:function(A,g){JA.lockPointer=A,JA.resizeCanvas=g,void 0===JA.lockPointer&&(JA.lockPointer=!0),void 0===JA.resizeCanvas&&(JA.resizeCanvas=!1);var I=e.canvas;function t(){JA.isFullscreen=!1;var A=I.parentNode;(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===A?(I.exitFullscreen=JA.exitFullscreen,JA.lockPointer&&I.requestPointerLock(),JA.isFullscreen=!0,JA.resizeCanvas?JA.setFullscreenCanvasSize():JA.updateCanvasDimensions(I)):(A.parentNode.insertBefore(I,A),A.parentNode.removeChild(A),JA.resizeCanvas?JA.setWindowedCanvasSize():JA.updateCanvasDimensions(I)),e.onFullScreen&&e.onFullScreen(JA.isFullscreen),e.onFullscreen&&e.onFullscreen(JA.isFullscreen)}JA.fullscreenHandlersInstalled||(JA.fullscreenHandlersInstalled=!0,document.addEventListener("fullscreenchange",t,!1),document.addEventListener("mozfullscreenchange",t,!1),document.addEventListener("webkitfullscreenchange",t,!1),document.addEventListener("MSFullscreenChange",t,!1));var C=document.createElement("div");I.parentNode.insertBefore(C,I),C.appendChild(I),C.requestFullscreen=C.requestFullscreen||C.mozRequestFullScreen||C.msRequestFullscreen||(C.webkitRequestFullscreen?function(){C.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT)}:null)||(C.webkitRequestFullScreen?function(){C.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}:null),C.requestFullscreen()},exitFullscreen:function(){return!!JA.isFullscreen&&((document.exitFullscreen||document.cancelFullScreen||document.mozCancelFullScreen||document.msExitFullscreen||document.webkitCancelFullScreen||function(){}).apply(document,[]),!0)},nextRAF:0,fakeRequestAnimationFrame:function(A){var g=Date.now();if(0===JA.nextRAF)JA.nextRAF=g+1e3/60;else for(;g+2>=JA.nextRAF;)JA.nextRAF+=1e3/60;var I=Math.max(JA.nextRAF-g,0);setTimeout(A,I)},requestAnimationFrame:function(A){"function"!=typeof requestAnimationFrame?(0,JA.fakeRequestAnimationFrame)(A):requestAnimationFrame(A)},safeCallback:function(A){return function(){if(!m)return A.apply(null,arguments)}},allowAsyncCallbacks:!0,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function(){JA.allowAsyncCallbacks=!1},resumeAsyncCallbacks:function(){if(JA.allowAsyncCallbacks=!0,JA.queuedAsyncCallbacks.length>0){var A=JA.queuedAsyncCallbacks;JA.queuedAsyncCallbacks=[],A.forEach((function(A){A()}))}},safeRequestAnimationFrame:function(A){return JA.requestAnimationFrame((function(){m||(JA.allowAsyncCallbacks?A():JA.queuedAsyncCallbacks.push(A))}))},safeSetTimeout:function(A,g){return setTimeout((function(){m||(JA.allowAsyncCallbacks?A():JA.queuedAsyncCallbacks.push(A))}),g)},safeSetInterval:function(A,g){return setInterval((function(){m||JA.allowAsyncCallbacks&&A()}),g)},getMimetype:function(A){return{jpg:"image/jpeg",jpeg:"image/jpeg",png:"image/png",bmp:"image/bmp",ogg:"audio/ogg",wav:"audio/wav",mp3:"audio/mpeg"}[A.substr(A.lastIndexOf(".")+1)]},getUserMedia:function(A){window.getUserMedia||(window.getUserMedia=navigator.getUserMedia||navigator.mozGetUserMedia),window.getUserMedia(A)},getMovementX:function(A){return A.movementX||A.mozMovementX||A.webkitMovementX||0},getMovementY:function(A){return A.movementY||A.mozMovementY||A.webkitMovementY||0},getMouseWheelDelta:function(A){var g=0;switch(A.type){case"DOMMouseScroll":g=A.detail/3;break;case"mousewheel":g=A.wheelDelta/120;break;case"wheel":switch(g=A.deltaY,A.deltaMode){case 0:g/=100;break;case 1:g/=3;break;case 2:g*=80;break;default:throw"unrecognized mouse wheel delta mode: "+A.deltaMode}break;default:throw"unrecognized mouse wheel event: "+A.type}return g},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(A){if(JA.pointerLock)"mousemove"!=A.type&&"mozMovementX"in A?JA.mouseMovementX=JA.mouseMovementY=0:(JA.mouseMovementX=JA.getMovementX(A),JA.mouseMovementY=JA.getMovementY(A)),"undefined"!=typeof SDL?(JA.mouseX=SDL.mouseX+JA.mouseMovementX,JA.mouseY=SDL.mouseY+JA.mouseMovementY):(JA.mouseX+=JA.mouseMovementX,JA.mouseY+=JA.mouseMovementY);else{var g=e.canvas.getBoundingClientRect(),I=e.canvas.width,t=e.canvas.height,C=void 0!==window.scrollX?window.scrollX:window.pageXOffset,B=void 0!==window.scrollY?window.scrollY:window.pageYOffset;if("touchstart"===A.type||"touchend"===A.type||"touchmove"===A.type){var i=A.touch;if(void 0===i)return;var Q=i.pageX-(C+g.left),o=i.pageY-(B+g.top),E={x:Q*=I/g.width,y:o*=t/g.height};if("touchstart"===A.type)JA.lastTouches[i.identifier]=E,JA.touches[i.identifier]=E;else if("touchend"===A.type||"touchmove"===A.type){var n=JA.touches[i.identifier];n||(n=E),JA.lastTouches[i.identifier]=n,JA.touches[i.identifier]=E}return}var s=A.pageX-(C+g.left),a=A.pageY-(B+g.top);s*=I/g.width,a*=t/g.height,JA.mouseMovementX=s-JA.mouseX,JA.mouseMovementY=a-JA.mouseY,JA.mouseX=s,JA.mouseY=a}},asyncLoad:function(A,g,I,t){var C=t?"":lA("al "+A);h(A,(function(I){k(I,'Loading data file "'+A+'" failed (no arrayBuffer).'),g(new Uint8Array(I)),C&&uA(C)}),(function(g){if(!I)throw'Loading data file "'+A+'" failed.';I()})),C&&DA(C)},resizeListeners:[],updateResizeListeners:function(){var A=e.canvas;JA.resizeListeners.forEach((function(g){g(A.width,A.height)}))},setCanvasSize:function(A,g,I){var t=e.canvas;JA.updateCanvasDimensions(t,A,g),I||JA.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function(){if("undefined"!=typeof SDL){var A=v[SDL.screen>>2];A|=8388608,T[SDL.screen>>2]=A}JA.updateCanvasDimensions(e.canvas),JA.updateResizeListeners()},setWindowedCanvasSize:function(){if("undefined"!=typeof SDL){var A=v[SDL.screen>>2];A&=-8388609,T[SDL.screen>>2]=A}JA.updateCanvasDimensions(e.canvas),JA.updateResizeListeners()},updateCanvasDimensions:function(A,g,I){g&&I?(A.widthNative=g,A.heightNative=I):(g=A.widthNative,I=A.heightNative);var t=g,C=I;if(e.forcedAspectRatio&&e.forcedAspectRatio>0&&(t/C<e.forcedAspectRatio?t=Math.round(C*e.forcedAspectRatio):C=Math.round(t/e.forcedAspectRatio)),(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===A.parentNode&&"undefined"!=typeof screen){var B=Math.min(screen.width/t,screen.height/C);t=Math.round(t*B),C=Math.round(C*B)}JA.resizeCanvas?(A.width!=t&&(A.width=t),A.height!=C&&(A.height=C),void 0!==A.style&&(A.style.removeProperty("width"),A.style.removeProperty("height"))):(A.width!=g&&(A.width=g),A.height!=I&&(A.height=I),void 0!==A.style&&(t!=g||C!=I?(A.style.setProperty("width",t+"px","important"),A.style.setProperty("height",C+"px","important")):(A.style.removeProperty("width"),A.style.removeProperty("height"))))},wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function(){var A=JA.nextWgetRequestHandle;return JA.nextWgetRequestHandle++,A}};function YA(A){for(;A.length>0;){var g=A.shift();if("function"!=typeof g){var I=g.func;"number"==typeof I?void 0===g.arg?tA.get(I)():tA.get(I)(g.arg):I(void 0===g.arg?null:g.arg)}else g(e)}}var LA={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};function xA(A){return Pt(A+LA.SIZE)+LA.SIZE}function bA(A,g){}function HA(A,g){return bA(A,g)}function qA(A){this.excPtr=A,this.ptr=A-LA.SIZE,this.set_type=function(A){T[this.ptr+LA.TYPE_OFFSET>>2]=A},this.get_type=function(){return T[this.ptr+LA.TYPE_OFFSET>>2]},this.set_destructor=function(A){T[this.ptr+LA.DESTRUCTOR_OFFSET>>2]=A},this.get_destructor=function(){return T[this.ptr+LA.DESTRUCTOR_OFFSET>>2]},this.set_refcount=function(A){T[this.ptr+LA.REFCOUNT_OFFSET>>2]=A},this.set_caught=function(A){A=A?1:0,x[this.ptr+LA.CAUGHT_OFFSET>>0]=A},this.get_caught=function(){return 0!=x[this.ptr+LA.CAUGHT_OFFSET>>0]},this.set_rethrown=function(A){A=A?1:0,x[this.ptr+LA.RETHROWN_OFFSET>>0]=A},this.get_rethrown=function(){return 0!=x[this.ptr+LA.RETHROWN_OFFSET>>0]},this.init=function(A,g){this.set_type(A),this.set_destructor(g),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var A=T[this.ptr+LA.REFCOUNT_OFFSET>>2];T[this.ptr+LA.REFCOUNT_OFFSET>>2]=A+1},this.release_ref=function(){var A=T[this.ptr+LA.REFCOUNT_OFFSET>>2];return T[this.ptr+LA.REFCOUNT_OFFSET>>2]=A-1,1===A}}function TA(A,g,I){throw new qA(A).init(g,I),A}function vA(A){return T[jt()>>2]=A,A}var VA={splitPath:function(A){return/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(A).slice(1)},normalizeArray:function(A,g){for(var I=0,t=A.length-1;t>=0;t--){var C=A[t];"."===C?A.splice(t,1):".."===C?(A.splice(t,1),I++):I&&(A.splice(t,1),I--)}if(g)for(;I;I--)A.unshift("..");return A},normalize:function(A){var g="/"===A.charAt(0),I="/"===A.substr(-1);return(A=VA.normalizeArray(A.split("/").filter((function(A){return!!A})),!g).join("/"))||g||(A="."),A&&I&&(A+="/"),(g?"/":"")+A},dirname:function(A){var g=VA.splitPath(A),I=g[0],t=g[1];return I||t?(t&&(t=t.substr(0,t.length-1)),I+t):"."},basename:function(A){if("/"===A)return"/";var g=(A=(A=VA.normalize(A)).replace(/\/$/,"")).lastIndexOf("/");return-1===g?A:A.substr(g+1)},extname:function(A){return VA.splitPath(A)[3]},join:function(){var A=Array.prototype.slice.call(arguments,0);return VA.normalize(A.join("/"))},join2:function(A,g){return VA.normalize(A+"/"+g)}};function WA(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var A=new Uint8Array(1);return function(){return crypto.getRandomValues(A),A[0]}}if(s)try{var g=I(499);return function(){return g.randomBytes(1)[0]}}catch(A){}return function(){wA("randomDevice")}}var OA={resolve:function(){for(var A="",g=!1,I=arguments.length-1;I>=-1&&!g;I--){var t=I>=0?arguments[I]:jA.cwd();if("string"!=typeof t)throw new TypeError("Arguments to path.resolve must be strings");if(!t)return"";A=t+"/"+A,g="/"===t.charAt(0)}return(g?"/":"")+(A=VA.normalizeArray(A.split("/").filter((function(A){return!!A})),!g).join("/"))||"."},relative:function(A,g){function I(A){for(var g=0;g<A.length&&""===A[g];g++);for(var I=A.length-1;I>=0&&""===A[I];I--);return g>I?[]:A.slice(g,I-g+1)}A=OA.resolve(A).substr(1),g=OA.resolve(g).substr(1);for(var t=I(A.split("/")),C=I(g.split("/")),e=Math.min(t.length,C.length),B=e,i=0;i<e;i++)if(t[i]!==C[i]){B=i;break}var Q=[];for(i=B;i<t.length;i++)Q.push("..");return(Q=Q.concat(C.slice(B))).join("/")}},ZA={ttys:[],init:function(){},shutdown:function(){},register:function(A,g){ZA.ttys[A]={input:[],output:[],ops:g},jA.registerDevice(A,ZA.stream_ops)},stream_ops:{open:function(A){var g=ZA.ttys[A.node.rdev];if(!g)throw new jA.ErrnoError(43);A.tty=g,A.seekable=!1},close:function(A){A.tty.ops.flush(A.tty)},flush:function(A){A.tty.ops.flush(A.tty)},read:function(A,g,I,t,C){if(!A.tty||!A.tty.ops.get_char)throw new jA.ErrnoError(60);for(var e=0,B=0;B<t;B++){var i;try{i=A.tty.ops.get_char(A.tty)}catch(A){throw new jA.ErrnoError(29)}if(void 0===i&&0===e)throw new jA.ErrnoError(6);if(null==i)break;e++,g[I+B]=i}return e&&(A.node.timestamp=Date.now()),e},write:function(A,g,I,t,C){if(!A.tty||!A.tty.ops.put_char)throw new jA.ErrnoError(60);try{for(var e=0;e<t;e++)A.tty.ops.put_char(A.tty,g[I+e])}catch(A){throw new jA.ErrnoError(29)}return t&&(A.node.timestamp=Date.now()),e}},default_tty_ops:{get_char:function(A){if(!A.input.length){var g=null;if(s){var I=256,t=Buffer.alloc?Buffer.alloc(I):new Buffer(I),C=0;try{C=l.readSync(process.stdin.fd,t,0,I,null)}catch(A){if(-1==A.toString().indexOf("EOF"))throw A;C=0}g=C>0?t.slice(0,C).toString("utf-8"):null}else"undefined"!=typeof window&&"function"==typeof window.prompt?null!==(g=window.prompt("Input: "))&&(g+="\n"):"function"==typeof readline&&null!==(g=readline())&&(g+="\n");if(!g)return null;A.input=Ht(g,!0)}return A.input.shift()},put_char:function(A,g){null===g||10===g?(d(M(A.output,0)),A.output=[]):0!=g&&A.output.push(g)},flush:function(A){A.output&&A.output.length>0&&(d(M(A.output,0)),A.output=[])}},default_tty1_ops:{put_char:function(A,g){null===g||10===g?(p(M(A.output,0)),A.output=[]):0!=g&&A.output.push(g)},flush:function(A){A.output&&A.output.length>0&&(p(M(A.output,0)),A.output=[])}}};function PA(A){for(var g=G(A,16384),I=Pt(g);A<g;)x[I+A++]=0;return I}var XA={ops_table:null,mount:function(A){return XA.createNode(null,"/",16895,0)},createNode:function(A,g,I,t){if(jA.isBlkdev(I)||jA.isFIFO(I))throw new jA.ErrnoError(63);XA.ops_table||(XA.ops_table={dir:{node:{getattr:XA.node_ops.getattr,setattr:XA.node_ops.setattr,lookup:XA.node_ops.lookup,mknod:XA.node_ops.mknod,rename:XA.node_ops.rename,unlink:XA.node_ops.unlink,rmdir:XA.node_ops.rmdir,readdir:XA.node_ops.readdir,symlink:XA.node_ops.symlink},stream:{llseek:XA.stream_ops.llseek}},file:{node:{getattr:XA.node_ops.getattr,setattr:XA.node_ops.setattr},stream:{llseek:XA.stream_ops.llseek,read:XA.stream_ops.read,write:XA.stream_ops.write,allocate:XA.stream_ops.allocate,mmap:XA.stream_ops.mmap,msync:XA.stream_ops.msync}},link:{node:{getattr:XA.node_ops.getattr,setattr:XA.node_ops.setattr,readlink:XA.node_ops.readlink},stream:{}},chrdev:{node:{getattr:XA.node_ops.getattr,setattr:XA.node_ops.setattr},stream:jA.chrdev_stream_ops}});var C=jA.createNode(A,g,I,t);return jA.isDir(C.mode)?(C.node_ops=XA.ops_table.dir.node,C.stream_ops=XA.ops_table.dir.stream,C.contents={}):jA.isFile(C.mode)?(C.node_ops=XA.ops_table.file.node,C.stream_ops=XA.ops_table.file.stream,C.usedBytes=0,C.contents=null):jA.isLink(C.mode)?(C.node_ops=XA.ops_table.link.node,C.stream_ops=XA.ops_table.link.stream):jA.isChrdev(C.mode)&&(C.node_ops=XA.ops_table.chrdev.node,C.stream_ops=XA.ops_table.chrdev.stream),C.timestamp=Date.now(),A&&(A.contents[g]=C),C},getFileDataAsRegularArray:function(A){if(A.contents&&A.contents.subarray){for(var g=[],I=0;I<A.usedBytes;++I)g.push(A.contents[I]);return g}return A.contents},getFileDataAsTypedArray:function(A){return A.contents?A.contents.subarray?A.contents.subarray(0,A.usedBytes):new Uint8Array(A.contents):new Uint8Array(0)},expandFileStorage:function(A,g){var I=A.contents?A.contents.length:0;if(!(I>=g)){var t=1048576;g=Math.max(g,I*(I<t?2:1.125)>>>0),0!=I&&(g=Math.max(g,256));var C=A.contents;A.contents=new Uint8Array(g),A.usedBytes>0&&A.contents.set(C.subarray(0,A.usedBytes),0)}},resizeFileStorage:function(A,g){if(A.usedBytes!=g){if(0==g)return A.contents=null,void(A.usedBytes=0);if(!A.contents||A.contents.subarray){var I=A.contents;return A.contents=new Uint8Array(g),I&&A.contents.set(I.subarray(0,Math.min(g,A.usedBytes))),void(A.usedBytes=g)}if(A.contents||(A.contents=[]),A.contents.length>g)A.contents.length=g;else for(;A.contents.length<g;)A.contents.push(0);A.usedBytes=g}},node_ops:{getattr:function(A){var g={};return g.dev=jA.isChrdev(A.mode)?A.id:1,g.ino=A.id,g.mode=A.mode,g.nlink=1,g.uid=0,g.gid=0,g.rdev=A.rdev,jA.isDir(A.mode)?g.size=4096:jA.isFile(A.mode)?g.size=A.usedBytes:jA.isLink(A.mode)?g.size=A.link.length:g.size=0,g.atime=new Date(A.timestamp),g.mtime=new Date(A.timestamp),g.ctime=new Date(A.timestamp),g.blksize=4096,g.blocks=Math.ceil(g.size/g.blksize),g},setattr:function(A,g){void 0!==g.mode&&(A.mode=g.mode),void 0!==g.timestamp&&(A.timestamp=g.timestamp),void 0!==g.size&&XA.resizeFileStorage(A,g.size)},lookup:function(A,g){throw jA.genericErrors[44]},mknod:function(A,g,I,t){return XA.createNode(A,g,I,t)},rename:function(A,g,I){if(jA.isDir(A.mode)){var t;try{t=jA.lookupNode(g,I)}catch(A){}if(t)for(var C in t.contents)throw new jA.ErrnoError(55)}delete A.parent.contents[A.name],A.name=I,g.contents[I]=A,A.parent=g},unlink:function(A,g){delete A.contents[g]},rmdir:function(A,g){var I=jA.lookupNode(A,g);for(var t in I.contents)throw new jA.ErrnoError(55);delete A.contents[g]},readdir:function(A){var g=[".",".."];for(var I in A.contents)A.contents.hasOwnProperty(I)&&g.push(I);return g},symlink:function(A,g,I){var t=XA.createNode(A,g,41471,0);return t.link=I,t},readlink:function(A){if(!jA.isLink(A.mode))throw new jA.ErrnoError(28);return A.link}},stream_ops:{read:function(A,g,I,t,C){var e=A.node.contents;if(C>=A.node.usedBytes)return 0;var B=Math.min(A.node.usedBytes-C,t);if(B>8&&e.subarray)g.set(e.subarray(C,C+B),I);else for(var i=0;i<B;i++)g[I+i]=e[C+i];return B},write:function(A,g,I,t,C,e){if(g.buffer===x.buffer&&(e=!1),!t)return 0;var B=A.node;if(B.timestamp=Date.now(),g.subarray&&(!B.contents||B.contents.subarray)){if(e)return B.contents=g.subarray(I,I+t),B.usedBytes=t,t;if(0===B.usedBytes&&0===C)return B.contents=g.slice(I,I+t),B.usedBytes=t,t;if(C+t<=B.usedBytes)return B.contents.set(g.subarray(I,I+t),C),t}if(XA.expandFileStorage(B,C+t),B.contents.subarray&&g.subarray)B.contents.set(g.subarray(I,I+t),C);else for(var i=0;i<t;i++)B.contents[C+i]=g[I+i];return B.usedBytes=Math.max(B.usedBytes,C+t),t},llseek:function(A,g,I){var t=g;if(1===I?t+=A.position:2===I&&jA.isFile(A.node.mode)&&(t+=A.node.usedBytes),t<0)throw new jA.ErrnoError(28);return t},allocate:function(A,g,I){XA.expandFileStorage(A.node,g+I),A.node.usedBytes=Math.max(A.node.usedBytes,g+I)},mmap:function(A,g,I,t,C,e){if(k(0===g),!jA.isFile(A.node.mode))throw new jA.ErrnoError(43);var B,i,Q=A.node.contents;if(2&e||Q.buffer!==L){if((t>0||t+I<Q.length)&&(Q=Q.subarray?Q.subarray(t,t+I):Array.prototype.slice.call(Q,t,t+I)),i=!0,!(B=PA(I)))throw new jA.ErrnoError(48);x.set(Q,B)}else i=!1,B=Q.byteOffset;return{ptr:B,allocated:i}},msync:function(A,g,I,t,C){if(!jA.isFile(A.node.mode))throw new jA.ErrnoError(43);return 2&C||XA.stream_ops.write(A,g,0,t,I,!1),0}}},jA={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:!1,ignorePermissions:!0,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:function(A,g){if(g=g||{},!(A=OA.resolve(jA.cwd(),A)))return{path:"",node:null};var I={follow_mount:!0,recurse_count:0};for(var t in I)void 0===g[t]&&(g[t]=I[t]);if(g.recurse_count>8)throw new jA.ErrnoError(32);for(var C=VA.normalizeArray(A.split("/").filter((function(A){return!!A})),!1),e=jA.root,B="/",i=0;i<C.length;i++){var Q=i===C.length-1;if(Q&&g.parent)break;if(e=jA.lookupNode(e,C[i]),B=VA.join2(B,C[i]),jA.isMountpoint(e)&&(!Q||Q&&g.follow_mount)&&(e=e.mounted.root),!Q||g.follow)for(var o=0;jA.isLink(e.mode);){var E=jA.readlink(B);if(B=OA.resolve(VA.dirname(B),E),e=jA.lookupPath(B,{recurse_count:g.recurse_count}).node,o++>40)throw new jA.ErrnoError(32)}}return{path:B,node:e}},getPath:function(A){for(var g;;){if(jA.isRoot(A)){var I=A.mount.mountpoint;return g?"/"!==I[I.length-1]?I+"/"+g:I+g:I}g=g?A.name+"/"+g:A.name,A=A.parent}},hashName:function(A,g){for(var I=0,t=0;t<g.length;t++)I=(I<<5)-I+g.charCodeAt(t)|0;return(A+I>>>0)%jA.nameTable.length},hashAddNode:function(A){var g=jA.hashName(A.parent.id,A.name);A.name_next=jA.nameTable[g],jA.nameTable[g]=A},hashRemoveNode:function(A){var g=jA.hashName(A.parent.id,A.name);if(jA.nameTable[g]===A)jA.nameTable[g]=A.name_next;else for(var I=jA.nameTable[g];I;){if(I.name_next===A){I.name_next=A.name_next;break}I=I.name_next}},lookupNode:function(A,g){var I=jA.mayLookup(A);if(I)throw new jA.ErrnoError(I,A);for(var t=jA.hashName(A.id,g),C=jA.nameTable[t];C;C=C.name_next){var e=C.name;if(C.parent.id===A.id&&e===g)return C}return jA.lookup(A,g)},createNode:function(A,g,I,t){var C=new jA.FSNode(A,g,I,t);return jA.hashAddNode(C),C},destroyNode:function(A){jA.hashRemoveNode(A)},isRoot:function(A){return A===A.parent},isMountpoint:function(A){return!!A.mounted},isFile:function(A){return 32768==(61440&A)},isDir:function(A){return 16384==(61440&A)},isLink:function(A){return 40960==(61440&A)},isChrdev:function(A){return 8192==(61440&A)},isBlkdev:function(A){return 24576==(61440&A)},isFIFO:function(A){return 4096==(61440&A)},isSocket:function(A){return 49152==(49152&A)},flagModes:{r:0,"r+":2,w:577,"w+":578,a:1089,"a+":1090},modeStringToFlags:function(A){var g=jA.flagModes[A];if(void 0===g)throw new Error("Unknown file open mode: "+A);return g},flagsToPermissionString:function(A){var g=["r","w","rw"][3&A];return 512&A&&(g+="w"),g},nodePermissions:function(A,g){return jA.ignorePermissions||(-1===g.indexOf("r")||292&A.mode)&&(-1===g.indexOf("w")||146&A.mode)&&(-1===g.indexOf("x")||73&A.mode)?0:2},mayLookup:function(A){var g=jA.nodePermissions(A,"x");return g||(A.node_ops.lookup?0:2)},mayCreate:function(A,g){try{return jA.lookupNode(A,g),20}catch(A){}return jA.nodePermissions(A,"wx")},mayDelete:function(A,g,I){var t;try{t=jA.lookupNode(A,g)}catch(A){return A.errno}var C=jA.nodePermissions(A,"wx");if(C)return C;if(I){if(!jA.isDir(t.mode))return 54;if(jA.isRoot(t)||jA.getPath(t)===jA.cwd())return 10}else if(jA.isDir(t.mode))return 31;return 0},mayOpen:function(A,g){return A?jA.isLink(A.mode)?32:jA.isDir(A.mode)&&("r"!==jA.flagsToPermissionString(g)||512&g)?31:jA.nodePermissions(A,jA.flagsToPermissionString(g)):44},MAX_OPEN_FDS:4096,nextfd:function(A,g){A=A||0,g=g||jA.MAX_OPEN_FDS;for(var I=A;I<=g;I++)if(!jA.streams[I])return I;throw new jA.ErrnoError(33)},getStream:function(A){return jA.streams[A]},createStream:function(A,g,I){jA.FSStream||(jA.FSStream=function(){},jA.FSStream.prototype={object:{get:function(){return this.node},set:function(A){this.node=A}},isRead:{get:function(){return 1!=(2097155&this.flags)}},isWrite:{get:function(){return 0!=(2097155&this.flags)}},isAppend:{get:function(){return 1024&this.flags}}});var t=new jA.FSStream;for(var C in A)t[C]=A[C];A=t;var e=jA.nextfd(g,I);return A.fd=e,jA.streams[e]=A,A},closeStream:function(A){jA.streams[A]=null},chrdev_stream_ops:{open:function(A){var g=jA.getDevice(A.node.rdev);A.stream_ops=g.stream_ops,A.stream_ops.open&&A.stream_ops.open(A)},llseek:function(){throw new jA.ErrnoError(70)}},major:function(A){return A>>8},minor:function(A){return 255&A},makedev:function(A,g){return A<<8|g},registerDevice:function(A,g){jA.devices[A]={stream_ops:g}},getDevice:function(A){return jA.devices[A]},getMounts:function(A){for(var g=[],I=[A];I.length;){var t=I.pop();g.push(t),I.push.apply(I,t.mounts)}return g},syncfs:function(A,g){"function"==typeof A&&(g=A,A=!1),jA.syncFSRequests++,jA.syncFSRequests>1&&p("warning: "+jA.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");var I=jA.getMounts(jA.root.mount),t=0;function C(A){return jA.syncFSRequests--,g(A)}function e(A){if(A)return e.errored?void 0:(e.errored=!0,C(A));++t>=I.length&&C(null)}I.forEach((function(g){if(!g.type.syncfs)return e(null);g.type.syncfs(g,A,e)}))},mount:function(A,g,I){var t,C="/"===I,e=!I;if(C&&jA.root)throw new jA.ErrnoError(10);if(!C&&!e){var B=jA.lookupPath(I,{follow_mount:!1});if(I=B.path,t=B.node,jA.isMountpoint(t))throw new jA.ErrnoError(10);if(!jA.isDir(t.mode))throw new jA.ErrnoError(54)}var i={type:A,opts:g,mountpoint:I,mounts:[]},Q=A.mount(i);return Q.mount=i,i.root=Q,C?jA.root=Q:t&&(t.mounted=i,t.mount&&t.mount.mounts.push(i)),Q},unmount:function(A){var g=jA.lookupPath(A,{follow_mount:!1});if(!jA.isMountpoint(g.node))throw new jA.ErrnoError(28);var I=g.node,t=I.mounted,C=jA.getMounts(t);Object.keys(jA.nameTable).forEach((function(A){for(var g=jA.nameTable[A];g;){var I=g.name_next;-1!==C.indexOf(g.mount)&&jA.destroyNode(g),g=I}})),I.mounted=null;var e=I.mount.mounts.indexOf(t);I.mount.mounts.splice(e,1)},lookup:function(A,g){return A.node_ops.lookup(A,g)},mknod:function(A,g,I){var t=jA.lookupPath(A,{parent:!0}).node,C=VA.basename(A);if(!C||"."===C||".."===C)throw new jA.ErrnoError(28);var e=jA.mayCreate(t,C);if(e)throw new jA.ErrnoError(e);if(!t.node_ops.mknod)throw new jA.ErrnoError(63);return t.node_ops.mknod(t,C,g,I)},create:function(A,g){return g=void 0!==g?g:438,g&=4095,g|=32768,jA.mknod(A,g,0)},mkdir:function(A,g){return g=void 0!==g?g:511,g&=1023,g|=16384,jA.mknod(A,g,0)},mkdirTree:function(A,g){for(var I=A.split("/"),t="",C=0;C<I.length;++C)if(I[C]){t+="/"+I[C];try{jA.mkdir(t,g)}catch(A){if(20!=A.errno)throw A}}},mkdev:function(A,g,I){return void 0===I&&(I=g,g=438),g|=8192,jA.mknod(A,g,I)},symlink:function(A,g){if(!OA.resolve(A))throw new jA.ErrnoError(44);var I=jA.lookupPath(g,{parent:!0}).node;if(!I)throw new jA.ErrnoError(44);var t=VA.basename(g),C=jA.mayCreate(I,t);if(C)throw new jA.ErrnoError(C);if(!I.node_ops.symlink)throw new jA.ErrnoError(63);return I.node_ops.symlink(I,t,A)},rename:function(A,g){var I,t,C=VA.dirname(A),e=VA.dirname(g),B=VA.basename(A),i=VA.basename(g);if(I=jA.lookupPath(A,{parent:!0}).node,t=jA.lookupPath(g,{parent:!0}).node,!I||!t)throw new jA.ErrnoError(44);if(I.mount!==t.mount)throw new jA.ErrnoError(75);var Q,o=jA.lookupNode(I,B),E=OA.relative(A,e);if("."!==E.charAt(0))throw new jA.ErrnoError(28);if("."!==(E=OA.relative(g,C)).charAt(0))throw new jA.ErrnoError(55);try{Q=jA.lookupNode(t,i)}catch(A){}if(o!==Q){var n=jA.isDir(o.mode),s=jA.mayDelete(I,B,n);if(s)throw new jA.ErrnoError(s);if(s=Q?jA.mayDelete(t,i,n):jA.mayCreate(t,i))throw new jA.ErrnoError(s);if(!I.node_ops.rename)throw new jA.ErrnoError(63);if(jA.isMountpoint(o)||Q&&jA.isMountpoint(Q))throw new jA.ErrnoError(10);if(t!==I&&(s=jA.nodePermissions(I,"w")))throw new jA.ErrnoError(s);try{jA.trackingDelegate.willMovePath&&jA.trackingDelegate.willMovePath(A,g)}catch(I){p("FS.trackingDelegate['willMovePath']('"+A+"', '"+g+"') threw an exception: "+I.message)}jA.hashRemoveNode(o);try{I.node_ops.rename(o,t,i)}catch(A){throw A}finally{jA.hashAddNode(o)}try{jA.trackingDelegate.onMovePath&&jA.trackingDelegate.onMovePath(A,g)}catch(I){p("FS.trackingDelegate['onMovePath']('"+A+"', '"+g+"') threw an exception: "+I.message)}}},rmdir:function(A){var g=jA.lookupPath(A,{parent:!0}).node,I=VA.basename(A),t=jA.lookupNode(g,I),C=jA.mayDelete(g,I,!0);if(C)throw new jA.ErrnoError(C);if(!g.node_ops.rmdir)throw new jA.ErrnoError(63);if(jA.isMountpoint(t))throw new jA.ErrnoError(10);try{jA.trackingDelegate.willDeletePath&&jA.trackingDelegate.willDeletePath(A)}catch(g){p("FS.trackingDelegate['willDeletePath']('"+A+"') threw an exception: "+g.message)}g.node_ops.rmdir(g,I),jA.destroyNode(t);try{jA.trackingDelegate.onDeletePath&&jA.trackingDelegate.onDeletePath(A)}catch(g){p("FS.trackingDelegate['onDeletePath']('"+A+"') threw an exception: "+g.message)}},readdir:function(A){var g=jA.lookupPath(A,{follow:!0}).node;if(!g.node_ops.readdir)throw new jA.ErrnoError(54);return g.node_ops.readdir(g)},unlink:function(A){var g=jA.lookupPath(A,{parent:!0}).node,I=VA.basename(A),t=jA.lookupNode(g,I),C=jA.mayDelete(g,I,!1);if(C)throw new jA.ErrnoError(C);if(!g.node_ops.unlink)throw new jA.ErrnoError(63);if(jA.isMountpoint(t))throw new jA.ErrnoError(10);try{jA.trackingDelegate.willDeletePath&&jA.trackingDelegate.willDeletePath(A)}catch(g){p("FS.trackingDelegate['willDeletePath']('"+A+"') threw an exception: "+g.message)}g.node_ops.unlink(g,I),jA.destroyNode(t);try{jA.trackingDelegate.onDeletePath&&jA.trackingDelegate.onDeletePath(A)}catch(g){p("FS.trackingDelegate['onDeletePath']('"+A+"') threw an exception: "+g.message)}},readlink:function(A){var g=jA.lookupPath(A).node;if(!g)throw new jA.ErrnoError(44);if(!g.node_ops.readlink)throw new jA.ErrnoError(28);return OA.resolve(jA.getPath(g.parent),g.node_ops.readlink(g))},stat:function(A,g){var I=jA.lookupPath(A,{follow:!g}).node;if(!I)throw new jA.ErrnoError(44);if(!I.node_ops.getattr)throw new jA.ErrnoError(63);return I.node_ops.getattr(I)},lstat:function(A){return jA.stat(A,!0)},chmod:function(A,g,I){var t;if(!(t="string"==typeof A?jA.lookupPath(A,{follow:!I}).node:A).node_ops.setattr)throw new jA.ErrnoError(63);t.node_ops.setattr(t,{mode:4095&g|-4096&t.mode,timestamp:Date.now()})},lchmod:function(A,g){jA.chmod(A,g,!0)},fchmod:function(A,g){var I=jA.getStream(A);if(!I)throw new jA.ErrnoError(8);jA.chmod(I.node,g)},chown:function(A,g,I,t){var C;if(!(C="string"==typeof A?jA.lookupPath(A,{follow:!t}).node:A).node_ops.setattr)throw new jA.ErrnoError(63);C.node_ops.setattr(C,{timestamp:Date.now()})},lchown:function(A,g,I){jA.chown(A,g,I,!0)},fchown:function(A,g,I){var t=jA.getStream(A);if(!t)throw new jA.ErrnoError(8);jA.chown(t.node,g,I)},truncate:function(A,g){if(g<0)throw new jA.ErrnoError(28);var I;if(!(I="string"==typeof A?jA.lookupPath(A,{follow:!0}).node:A).node_ops.setattr)throw new jA.ErrnoError(63);if(jA.isDir(I.mode))throw new jA.ErrnoError(31);if(!jA.isFile(I.mode))throw new jA.ErrnoError(28);var t=jA.nodePermissions(I,"w");if(t)throw new jA.ErrnoError(t);I.node_ops.setattr(I,{size:g,timestamp:Date.now()})},ftruncate:function(A,g){var I=jA.getStream(A);if(!I)throw new jA.ErrnoError(8);if(0==(2097155&I.flags))throw new jA.ErrnoError(28);jA.truncate(I.node,g)},utime:function(A,g,I){var t=jA.lookupPath(A,{follow:!0}).node;t.node_ops.setattr(t,{timestamp:Math.max(g,I)})},open:function(A,g,I,t,C){if(""===A)throw new jA.ErrnoError(44);var B;if(I=void 0===I?438:I,I=64&(g="string"==typeof g?jA.modeStringToFlags(g):g)?4095&I|32768:0,"object"==typeof A)B=A;else{A=VA.normalize(A);try{B=jA.lookupPath(A,{follow:!(131072&g)}).node}catch(A){}}var i=!1;if(64&g)if(B){if(128&g)throw new jA.ErrnoError(20)}else B=jA.mknod(A,I,0),i=!0;if(!B)throw new jA.ErrnoError(44);if(jA.isChrdev(B.mode)&&(g&=-513),65536&g&&!jA.isDir(B.mode))throw new jA.ErrnoError(54);if(!i){var Q=jA.mayOpen(B,g);if(Q)throw new jA.ErrnoError(Q)}512&g&&jA.truncate(B,0),g&=-131713;var o=jA.createStream({node:B,path:jA.getPath(B),flags:g,seekable:!0,position:0,stream_ops:B.stream_ops,ungotten:[],error:!1},t,C);o.stream_ops.open&&o.stream_ops.open(o),!e.logReadFiles||1&g||(jA.readFiles||(jA.readFiles={}),A in jA.readFiles||(jA.readFiles[A]=1,p("FS.trackingDelegate error on read file: "+A)));try{if(jA.trackingDelegate.onOpenFile){var E=0;1!=(2097155&g)&&(E|=jA.tracking.openFlags.READ),0!=(2097155&g)&&(E|=jA.tracking.openFlags.WRITE),jA.trackingDelegate.onOpenFile(A,E)}}catch(g){p("FS.trackingDelegate['onOpenFile']('"+A+"', flags) threw an exception: "+g.message)}return o},close:function(A){if(jA.isClosed(A))throw new jA.ErrnoError(8);A.getdents&&(A.getdents=null);try{A.stream_ops.close&&A.stream_ops.close(A)}catch(A){throw A}finally{jA.closeStream(A.fd)}A.fd=null},isClosed:function(A){return null===A.fd},llseek:function(A,g,I){if(jA.isClosed(A))throw new jA.ErrnoError(8);if(!A.seekable||!A.stream_ops.llseek)throw new jA.ErrnoError(70);if(0!=I&&1!=I&&2!=I)throw new jA.ErrnoError(28);return A.position=A.stream_ops.llseek(A,g,I),A.ungotten=[],A.position},read:function(A,g,I,t,C){if(t<0||C<0)throw new jA.ErrnoError(28);if(jA.isClosed(A))throw new jA.ErrnoError(8);if(1==(2097155&A.flags))throw new jA.ErrnoError(8);if(jA.isDir(A.node.mode))throw new jA.ErrnoError(31);if(!A.stream_ops.read)throw new jA.ErrnoError(28);var e=void 0!==C;if(e){if(!A.seekable)throw new jA.ErrnoError(70)}else C=A.position;var B=A.stream_ops.read(A,g,I,t,C);return e||(A.position+=B),B},write:function(A,g,I,t,C,e){if(t<0||C<0)throw new jA.ErrnoError(28);if(jA.isClosed(A))throw new jA.ErrnoError(8);if(0==(2097155&A.flags))throw new jA.ErrnoError(8);if(jA.isDir(A.node.mode))throw new jA.ErrnoError(31);if(!A.stream_ops.write)throw new jA.ErrnoError(28);A.seekable&&1024&A.flags&&jA.llseek(A,0,2);var B=void 0!==C;if(B){if(!A.seekable)throw new jA.ErrnoError(70)}else C=A.position;var i=A.stream_ops.write(A,g,I,t,C,e);B||(A.position+=i);try{A.path&&jA.trackingDelegate.onWriteToFile&&jA.trackingDelegate.onWriteToFile(A.path)}catch(g){p("FS.trackingDelegate['onWriteToFile']('"+A.path+"') threw an exception: "+g.message)}return i},allocate:function(A,g,I){if(jA.isClosed(A))throw new jA.ErrnoError(8);if(g<0||I<=0)throw new jA.ErrnoError(28);if(0==(2097155&A.flags))throw new jA.ErrnoError(8);if(!jA.isFile(A.node.mode)&&!jA.isDir(A.node.mode))throw new jA.ErrnoError(43);if(!A.stream_ops.allocate)throw new jA.ErrnoError(138);A.stream_ops.allocate(A,g,I)},mmap:function(A,g,I,t,C,e){if(0!=(2&C)&&0==(2&e)&&2!=(2097155&A.flags))throw new jA.ErrnoError(2);if(1==(2097155&A.flags))throw new jA.ErrnoError(2);if(!A.stream_ops.mmap)throw new jA.ErrnoError(43);return A.stream_ops.mmap(A,g,I,t,C,e)},msync:function(A,g,I,t,C){return A&&A.stream_ops.msync?A.stream_ops.msync(A,g,I,t,C):0},munmap:function(A){return 0},ioctl:function(A,g,I){if(!A.stream_ops.ioctl)throw new jA.ErrnoError(59);return A.stream_ops.ioctl(A,g,I)},readFile:function(A,g){if((g=g||{}).flags=g.flags||0,g.encoding=g.encoding||"binary","utf8"!==g.encoding&&"binary"!==g.encoding)throw new Error('Invalid encoding type "'+g.encoding+'"');var I,t=jA.open(A,g.flags),C=jA.stat(A).size,e=new Uint8Array(C);return jA.read(t,e,0,C,0),"utf8"===g.encoding?I=M(e,0):"binary"===g.encoding&&(I=e),jA.close(t),I},writeFile:function(A,g,I){(I=I||{}).flags=I.flags||577;var t=jA.open(A,I.flags,I.mode);if("string"==typeof g){var C=new Uint8Array(Y(g)+1),e=K(g,C,0,C.length);jA.write(t,C,0,e,void 0,I.canOwn)}else{if(!ArrayBuffer.isView(g))throw new Error("Unsupported data type");jA.write(t,g,0,g.byteLength,void 0,I.canOwn)}jA.close(t)},cwd:function(){return jA.currentPath},chdir:function(A){var g=jA.lookupPath(A,{follow:!0});if(null===g.node)throw new jA.ErrnoError(44);if(!jA.isDir(g.node.mode))throw new jA.ErrnoError(54);var I=jA.nodePermissions(g.node,"x");if(I)throw new jA.ErrnoError(I);jA.currentPath=g.path},createDefaultDirectories:function(){jA.mkdir("/tmp"),jA.mkdir("/home"),jA.mkdir("/home/web_user")},createDefaultDevices:function(){jA.mkdir("/dev"),jA.registerDevice(jA.makedev(1,3),{read:function(){return 0},write:function(A,g,I,t,C){return t}}),jA.mkdev("/dev/null",jA.makedev(1,3)),ZA.register(jA.makedev(5,0),ZA.default_tty_ops),ZA.register(jA.makedev(6,0),ZA.default_tty1_ops),jA.mkdev("/dev/tty",jA.makedev(5,0)),jA.mkdev("/dev/tty1",jA.makedev(6,0));var A=WA();jA.createDevice("/dev","random",A),jA.createDevice("/dev","urandom",A),jA.mkdir("/dev/shm"),jA.mkdir("/dev/shm/tmp")},createSpecialDirectories:function(){jA.mkdir("/proc"),jA.mkdir("/proc/self"),jA.mkdir("/proc/self/fd"),jA.mount({mount:function(){var A=jA.createNode("/proc/self","fd",16895,73);return A.node_ops={lookup:function(A,g){var I=+g,t=jA.getStream(I);if(!t)throw new jA.ErrnoError(8);var C={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:function(){return t.path}}};return C.parent=C,C}},A}},{},"/proc/self/fd")},createStandardStreams:function(){e.stdin?jA.createDevice("/dev","stdin",e.stdin):jA.symlink("/dev/tty","/dev/stdin"),e.stdout?jA.createDevice("/dev","stdout",null,e.stdout):jA.symlink("/dev/tty","/dev/stdout"),e.stderr?jA.createDevice("/dev","stderr",null,e.stderr):jA.symlink("/dev/tty1","/dev/stderr"),jA.open("/dev/stdin",0),jA.open("/dev/stdout",1),jA.open("/dev/stderr",1)},ensureErrnoError:function(){jA.ErrnoError||(jA.ErrnoError=function(A,g){this.node=g,this.setErrno=function(A){this.errno=A},this.setErrno(A),this.message="FS error"},jA.ErrnoError.prototype=new Error,jA.ErrnoError.prototype.constructor=jA.ErrnoError,[44].forEach((function(A){jA.genericErrors[A]=new jA.ErrnoError(A),jA.genericErrors[A].stack="<generic error, no stack>"})))},staticInit:function(){jA.ensureErrnoError(),jA.nameTable=new Array(4096),jA.mount(XA,{},"/"),jA.createDefaultDirectories(),jA.createDefaultDevices(),jA.createSpecialDirectories(),jA.filesystems={MEMFS:XA}},init:function(A,g,I){jA.init.initialized=!0,jA.ensureErrnoError(),e.stdin=A||e.stdin,e.stdout=g||e.stdout,e.stderr=I||e.stderr,jA.createStandardStreams()},quit:function(){jA.init.initialized=!1;var A=e._fflush;A&&A(0);for(var g=0;g<jA.streams.length;g++){var I=jA.streams[g];I&&jA.close(I)}},getMode:function(A,g){var I=0;return A&&(I|=365),g&&(I|=146),I},findObject:function(A,g){var I=jA.analyzePath(A,g);return I.exists?I.object:null},analyzePath:function(A,g){try{A=(t=jA.lookupPath(A,{follow:!g})).path}catch(A){}var I={isRoot:!1,exists:!1,error:0,name:null,path:null,object:null,parentExists:!1,parentPath:null,parentObject:null};try{var t=jA.lookupPath(A,{parent:!0});I.parentExists=!0,I.parentPath=t.path,I.parentObject=t.node,I.name=VA.basename(A),t=jA.lookupPath(A,{follow:!g}),I.exists=!0,I.path=t.path,I.object=t.node,I.name=t.node.name,I.isRoot="/"===t.path}catch(A){I.error=A.errno}return I},createPath:function(A,g,I,t){A="string"==typeof A?A:jA.getPath(A);for(var C=g.split("/").reverse();C.length;){var e=C.pop();if(e){var B=VA.join2(A,e);try{jA.mkdir(B)}catch(A){}A=B}}return B},createFile:function(A,g,I,t,C){var e=VA.join2("string"==typeof A?A:jA.getPath(A),g),B=jA.getMode(t,C);return jA.create(e,B)},createDataFile:function(A,g,I,t,C,e){var B=g?VA.join2("string"==typeof A?A:jA.getPath(A),g):A,i=jA.getMode(t,C),Q=jA.create(B,i);if(I){if("string"==typeof I){for(var o=new Array(I.length),E=0,n=I.length;E<n;++E)o[E]=I.charCodeAt(E);I=o}jA.chmod(Q,146|i);var s=jA.open(Q,577);jA.write(s,I,0,I.length,0,e),jA.close(s),jA.chmod(Q,i)}return Q},createDevice:function(A,g,I,t){var C=VA.join2("string"==typeof A?A:jA.getPath(A),g),e=jA.getMode(!!I,!!t);jA.createDevice.major||(jA.createDevice.major=64);var B=jA.makedev(jA.createDevice.major++,0);return jA.registerDevice(B,{open:function(A){A.seekable=!1},close:function(A){t&&t.buffer&&t.buffer.length&&t(10)},read:function(A,g,t,C,e){for(var B=0,i=0;i<C;i++){var Q;try{Q=I()}catch(A){throw new jA.ErrnoError(29)}if(void 0===Q&&0===B)throw new jA.ErrnoError(6);if(null==Q)break;B++,g[t+i]=Q}return B&&(A.node.timestamp=Date.now()),B},write:function(A,g,I,C,e){for(var B=0;B<C;B++)try{t(g[I+B])}catch(A){throw new jA.ErrnoError(29)}return C&&(A.node.timestamp=Date.now()),B}}),jA.mkdev(C,e,B)},forceLoadFile:function(A){if(A.isDevice||A.isFolder||A.link||A.contents)return!0;if("undefined"!=typeof XMLHttpRequest)throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");if(!r)throw new Error("Cannot load without read() or XMLHttpRequest.");try{A.contents=Ht(r(A.url),!0),A.usedBytes=A.contents.length}catch(A){throw new jA.ErrnoError(29)}},createLazyFile:function(A,g,I,t,C){function e(){this.lengthKnown=!1,this.chunks=[]}if(e.prototype.get=function(A){if(!(A>this.length-1||A<0)){var g=A%this.chunkSize,I=A/this.chunkSize|0;return this.getter(I)[g]}},e.prototype.setDataGetter=function(A){this.getter=A},e.prototype.cacheLength=function(){var A=new XMLHttpRequest;if(A.open("HEAD",I,!1),A.send(null),!(A.status>=200&&A.status<300||304===A.status))throw new Error("Couldn't load "+I+". Status: "+A.status);var g,t=Number(A.getResponseHeader("Content-length")),C=(g=A.getResponseHeader("Accept-Ranges"))&&"bytes"===g,e=(g=A.getResponseHeader("Content-Encoding"))&&"gzip"===g,B=1048576;C||(B=t);var i=function(A,g){if(A>g)throw new Error("invalid range ("+A+", "+g+") or no bytes requested!");if(g>t-1)throw new Error("only "+t+" bytes available! programmer error!");var C=new XMLHttpRequest;if(C.open("GET",I,!1),t!==B&&C.setRequestHeader("Range","bytes="+A+"-"+g),"undefined"!=typeof Uint8Array&&(C.responseType="arraybuffer"),C.overrideMimeType&&C.overrideMimeType("text/plain; charset=x-user-defined"),C.send(null),!(C.status>=200&&C.status<300||304===C.status))throw new Error("Couldn't load "+I+". Status: "+C.status);return void 0!==C.response?new Uint8Array(C.response||[]):Ht(C.responseText||"",!0)},Q=this;Q.setDataGetter((function(A){var g=A*B,I=(A+1)*B-1;if(I=Math.min(I,t-1),void 0===Q.chunks[A]&&(Q.chunks[A]=i(g,I)),void 0===Q.chunks[A])throw new Error("doXHR failed!");return Q.chunks[A]})),!e&&t||(B=t=1,t=this.getter(0).length,B=t,d("LazyFiles on gzip forces download of the whole file when length is accessed")),this._length=t,this._chunkSize=B,this.lengthKnown=!0},"undefined"!=typeof XMLHttpRequest){if(!n)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var B=new e;Object.defineProperties(B,{length:{get:function(){return this.lengthKnown||this.cacheLength(),this._length}},chunkSize:{get:function(){return this.lengthKnown||this.cacheLength(),this._chunkSize}}});var i={isDevice:!1,contents:B}}else i={isDevice:!1,url:I};var Q=jA.createFile(A,g,i,t,C);i.contents?Q.contents=i.contents:i.url&&(Q.contents=null,Q.url=i.url),Object.defineProperties(Q,{usedBytes:{get:function(){return this.contents.length}}});var o={};return Object.keys(Q.stream_ops).forEach((function(A){var g=Q.stream_ops[A];o[A]=function(){return jA.forceLoadFile(Q),g.apply(null,arguments)}})),o.read=function(A,g,I,t,C){jA.forceLoadFile(Q);var e=A.node.contents;if(C>=e.length)return 0;var B=Math.min(e.length-C,t);if(e.slice)for(var i=0;i<B;i++)g[I+i]=e[C+i];else for(i=0;i<B;i++)g[I+i]=e.get(C+i);return B},Q.stream_ops=o,Q},createPreloadedFile:function(A,g,I,t,C,B,i,Q,o,E){JA.init();var n=g?OA.resolve(VA.join2(A,g)):A,s=lA("cp "+n);function a(I){function a(I){E&&E(),Q||jA.createDataFile(A,g,I,t,C,o),B&&B(),uA(s)}var r=!1;e.preloadPlugins.forEach((function(A){r||A.canHandle(n)&&(A.handle(I,n,a,(function(){i&&i(),uA(s)})),r=!0)})),r||a(I)}DA(s),"string"==typeof I?JA.asyncLoad(I,(function(A){a(A)}),i):a(I)},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(A,g,I){g=g||function(){},I=I||function(){};var t=jA.indexedDB();try{var C=t.open(jA.DB_NAME(),jA.DB_VERSION)}catch(A){return I(A)}C.onupgradeneeded=function(){d("creating db"),C.result.createObjectStore(jA.DB_STORE_NAME)},C.onsuccess=function(){var t=C.result.transaction([jA.DB_STORE_NAME],"readwrite"),e=t.objectStore(jA.DB_STORE_NAME),B=0,i=0,Q=A.length;function o(){0==i?g():I()}A.forEach((function(A){var g=e.put(jA.analyzePath(A).object.contents,A);g.onsuccess=function(){++B+i==Q&&o()},g.onerror=function(){i++,B+i==Q&&o()}})),t.onerror=I},C.onerror=I},loadFilesFromDB:function(A,g,I){g=g||function(){},I=I||function(){};var t=jA.indexedDB();try{var C=t.open(jA.DB_NAME(),jA.DB_VERSION)}catch(A){return I(A)}C.onupgradeneeded=I,C.onsuccess=function(){var t=C.result;try{var e=t.transaction([jA.DB_STORE_NAME],"readonly")}catch(A){return void I(A)}var B=e.objectStore(jA.DB_STORE_NAME),i=0,Q=0,o=A.length;function E(){0==Q?g():I()}A.forEach((function(A){var g=B.get(A);g.onsuccess=function(){jA.analyzePath(A).exists&&jA.unlink(A),jA.createDataFile(VA.dirname(A),VA.basename(A),g.result,!0,!0,!0),++i+Q==o&&E()},g.onerror=function(){Q++,i+Q==o&&E()}})),e.onerror=I},C.onerror=I}},zA={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(A,g){if("/"!==g[0]){var I;if(-100===A)I=jA.cwd();else{var t=jA.getStream(A);if(!t)throw new jA.ErrnoError(8);I=t.path}g=VA.join2(I,g)}return g},doStat:function(A,g,I){try{var t=A(g)}catch(A){if(A&&A.node&&VA.normalize(g)!==VA.normalize(jA.getPath(A.node)))return-54;throw A}return T[I>>2]=t.dev,T[I+4>>2]=0,T[I+8>>2]=t.ino,T[I+12>>2]=t.mode,T[I+16>>2]=t.nlink,T[I+20>>2]=t.uid,T[I+24>>2]=t.gid,T[I+28>>2]=t.rdev,T[I+32>>2]=0,FA=[t.size>>>0,(NA=t.size,+Math.abs(NA)>=1?NA>0?(0|Math.min(+Math.floor(NA/4294967296),4294967295))>>>0:~~+Math.ceil((NA-+(~~NA>>>0))/4294967296)>>>0:0)],T[I+40>>2]=FA[0],T[I+44>>2]=FA[1],T[I+48>>2]=4096,T[I+52>>2]=t.blocks,T[I+56>>2]=t.atime.getTime()/1e3|0,T[I+60>>2]=0,T[I+64>>2]=t.mtime.getTime()/1e3|0,T[I+68>>2]=0,T[I+72>>2]=t.ctime.getTime()/1e3|0,T[I+76>>2]=0,FA=[t.ino>>>0,(NA=t.ino,+Math.abs(NA)>=1?NA>0?(0|Math.min(+Math.floor(NA/4294967296),4294967295))>>>0:~~+Math.ceil((NA-+(~~NA>>>0))/4294967296)>>>0:0)],T[I+80>>2]=FA[0],T[I+84>>2]=FA[1],0},doMsync:function(A,g,I,t,C){var e=b.slice(A,A+I);jA.msync(g,e,C,I,t)},doMkdir:function(A,g){return"/"===(A=VA.normalize(A))[A.length-1]&&(A=A.substr(0,A.length-1)),jA.mkdir(A,g,0),0},doMknod:function(A,g,I){switch(61440&g){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28}return jA.mknod(A,g,I),0},doReadlink:function(A,g,I){if(I<=0)return-28;var t=jA.readlink(A),C=Math.min(I,Y(t)),e=x[g+C];return J(t,g,I+1),x[g+C]=e,C},doAccess:function(A,g){if(-8&g)return-28;var I;if(!(I=jA.lookupPath(A,{follow:!0}).node))return-44;var t="";return 4&g&&(t+="r"),2&g&&(t+="w"),1&g&&(t+="x"),t&&jA.nodePermissions(I,t)?-2:0},doDup:function(A,g,I){var t=jA.getStream(I);return t&&jA.close(t),jA.open(A,g,0,I,I).fd},doReadv:function(A,g,I,t){for(var C=0,e=0;e<I;e++){var B=T[g+8*e>>2],i=T[g+(8*e+4)>>2],Q=jA.read(A,x,B,i,t);if(Q<0)return-1;if(C+=Q,Q<i)break}return C},doWritev:function(A,g,I,t){for(var C=0,e=0;e<I;e++){var B=T[g+8*e>>2],i=T[g+(8*e+4)>>2],Q=jA.write(A,x,B,i,t);if(Q<0)return-1;C+=Q}return C},varargs:void 0,get:function(){return zA.varargs+=4,T[zA.varargs-4>>2]},getStr:function(A){return U(A)},getStreamFromFD:function(A){var g=jA.getStream(A);if(!g)throw new jA.ErrnoError(8);return g},get64:function(A,g){return A}};function _A(A,g,I){zA.varargs=I;try{var t=zA.getStreamFromFD(A);switch(g){case 0:return(C=zA.get())<0?-28:jA.open(t.path,t.flags,0,C).fd;case 1:case 2:case 13:case 14:return 0;case 3:return t.flags;case 4:var C=zA.get();return t.flags|=C,0;case 12:return C=zA.get(),H[C+0>>1]=2,0;case 16:case 8:default:return-28;case 9:return vA(28),-1}}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),-A.errno}}function $A(A,g,I){zA.varargs=I;try{var t=zA.getStreamFromFD(A);switch(g){case 21509:case 21505:case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:case 21523:case 21524:return t.tty?0:-59;case 21519:if(!t.tty)return-59;var C=zA.get();return T[C>>2]=0,0;case 21520:return t.tty?-28:-59;case 21531:return C=zA.get(),jA.ioctl(t,g,C);default:wA("bad ioctl syscall "+g)}}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),-A.errno}}function Ag(A,g,I){zA.varargs=I;try{var t=zA.getStr(A),C=zA.get();return jA.open(t,g,C).fd}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),-A.errno}}var gg={};function Ig(A){for(;A.length;){var g=A.pop();A.pop()(g)}}function tg(A){return this.fromWireType(v[A>>2])}var Cg={},eg={},Bg={},ig=48,Qg=57;function og(A){if(void 0===A)return"_unknown";var g=(A=A.replace(/[^a-zA-Z0-9_]/g,"$")).charCodeAt(0);return g>=ig&&g<=Qg?"_"+A:A}function Eg(A,g){return A=og(A),new Function("body","return function "+A+'() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(g)}function ng(A,g){var I=Eg(g,(function(A){this.name=g,this.message=A;var I=new Error(A).stack;void 0!==I&&(this.stack=this.toString()+"\n"+I.replace(/^Error(:[^\n]*)?\n/,""))}));return I.prototype=Object.create(A.prototype),I.prototype.constructor=I,I.prototype.toString=function(){return void 0===this.message?this.name:this.name+": "+this.message},I}var sg=void 0;function ag(A){throw new sg(A)}function rg(A,g,I){function t(g){var t=I(g);t.length!==A.length&&ag("Mismatched type converter count");for(var C=0;C<A.length;++C)Gg(A[C],t[C])}A.forEach((function(A){Bg[A]=g}));var C=new Array(g.length),e=[],B=0;g.forEach((function(A,g){eg.hasOwnProperty(A)?C[g]=eg[A]:(e.push(A),Cg.hasOwnProperty(A)||(Cg[A]=[]),Cg[A].push((function(){C[g]=eg[A],++B===e.length&&t(C)})))})),0===e.length&&t(C)}function hg(A){var g=gg[A];delete gg[A];var I=g.elements,t=I.length,C=I.map((function(A){return A.getterReturnType})).concat(I.map((function(A){return A.setterArgumentType}))),e=g.rawConstructor,B=g.rawDestructor;rg([A],C,(function(A){return I.forEach((function(g,I){var C=A[I],e=g.getter,B=g.getterContext,i=A[I+t],Q=g.setter,o=g.setterContext;g.read=function(A){return C.fromWireType(e(B,A))},g.write=function(A,g){var I=[];Q(o,A,i.toWireType(I,g)),Ig(I)}})),[{name:g.name,fromWireType:function(A){for(var g=new Array(t),C=0;C<t;++C)g[C]=I[C].read(A);return B(A),g},toWireType:function(A,C){if(t!==C.length)throw new TypeError("Incorrect number of tuple elements for "+g.name+": expected="+t+", actual="+C.length);for(var i=e(),Q=0;Q<t;++Q)I[Q].write(i,C[Q]);return null!==A&&A.push(B,i),i},argPackAdvance:8,readValueFromPointer:tg,destructorFunction:B}]}))}var cg={};function lg(A){var g=cg[A];delete cg[A];var I=g.rawConstructor,t=g.rawDestructor,C=g.fields;rg([A],C.map((function(A){return A.getterReturnType})).concat(C.map((function(A){return A.setterArgumentType}))),(function(A){var e={};return C.forEach((function(g,I){var t=g.fieldName,B=A[I],i=g.getter,Q=g.getterContext,o=A[I+C.length],E=g.setter,n=g.setterContext;e[t]={read:function(A){return B.fromWireType(i(Q,A))},write:function(A,g){var I=[];E(n,A,o.toWireType(I,g)),Ig(I)}}})),[{name:g.name,fromWireType:function(A){var g={};for(var I in e)g[I]=e[I].read(A);return t(A),g},toWireType:function(A,g){for(var C in e)if(!(C in g))throw new TypeError('Missing field:  "'+C+'"');var B=I();for(C in e)e[C].write(B,g[C]);return null!==A&&A.push(t,B),B},argPackAdvance:8,readValueFromPointer:tg,destructorFunction:t}]}))}function Dg(A){switch(A){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+A)}}function ug(){for(var A=new Array(256),g=0;g<256;++g)A[g]=String.fromCharCode(g);wg=A}var wg=void 0;function dg(A){for(var g="",I=A;b[I];)g+=wg[b[I++]];return g}var pg=void 0;function yg(A){throw new pg(A)}function Gg(A,g,I){if(I=I||{},!("argPackAdvance"in g))throw new TypeError("registerType registeredInstance requires argPackAdvance");var t=g.name;if(A||yg('type "'+t+'" must have a positive integer typeid pointer'),eg.hasOwnProperty(A)){if(I.ignoreDuplicateRegistrations)return;yg("Cannot register type '"+t+"' twice")}if(eg[A]=g,delete Bg[A],Cg.hasOwnProperty(A)){var C=Cg[A];delete Cg[A],C.forEach((function(A){A()}))}}function fg(A,g,I,t,C){var e=Dg(I);Gg(A,{name:g=dg(g),fromWireType:function(A){return!!A},toWireType:function(A,g){return g?t:C},argPackAdvance:8,readValueFromPointer:function(A){var t;if(1===I)t=x;else if(2===I)t=H;else{if(4!==I)throw new TypeError("Unknown boolean type size: "+g);t=T}return this.fromWireType(t[A>>e])},destructorFunction:null})}function Ng(A){if(!(this instanceof Tg))return!1;if(!(A instanceof Tg))return!1;for(var g=this.$$.ptrType.registeredClass,I=this.$$.ptr,t=A.$$.ptrType.registeredClass,C=A.$$.ptr;g.baseClass;)I=g.upcast(I),g=g.baseClass;for(;t.baseClass;)C=t.upcast(C),t=t.baseClass;return g===t&&I===C}function Fg(A){return{count:A.count,deleteScheduled:A.deleteScheduled,preservePointerOnDelete:A.preservePointerOnDelete,ptr:A.ptr,ptrType:A.ptrType,smartPtr:A.smartPtr,smartPtrType:A.smartPtrType}}function Rg(A){function g(A){return A.$$.ptrType.registeredClass.name}yg(g(A)+" instance already deleted")}var mg=!1;function kg(A){}function Sg(A){A.smartPtr?A.smartPtrType.rawDestructor(A.smartPtr):A.ptrType.registeredClass.rawDestructor(A.ptr)}function Mg(A){A.count.value-=1,0===A.count.value&&Sg(A)}function Ug(A){return"undefined"==typeof FinalizationGroup?(Ug=function(A){return A},A):(mg=new FinalizationGroup((function(A){for(var g=A.next();!g.done;g=A.next()){var I=g.value;I.ptr?Mg(I):console.warn("object already deleted: "+I.ptr)}})),Ug=function(A){return mg.register(A,A.$$,A.$$),A},kg=function(A){mg.unregister(A.$$)},Ug(A))}function Kg(){if(this.$$.ptr||Rg(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var A=Ug(Object.create(Object.getPrototypeOf(this),{$$:{value:Fg(this.$$)}}));return A.$$.count.value+=1,A.$$.deleteScheduled=!1,A}function Jg(){this.$$.ptr||Rg(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&yg("Object already scheduled for deletion"),kg(this),Mg(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function Yg(){return!this.$$.ptr}var Lg=void 0,xg=[];function bg(){for(;xg.length;){var A=xg.pop();A.$$.deleteScheduled=!1,A.delete()}}function Hg(){return this.$$.ptr||Rg(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&yg("Object already scheduled for deletion"),xg.push(this),1===xg.length&&Lg&&Lg(bg),this.$$.deleteScheduled=!0,this}function qg(){Tg.prototype.isAliasOf=Ng,Tg.prototype.clone=Kg,Tg.prototype.delete=Jg,Tg.prototype.isDeleted=Yg,Tg.prototype.deleteLater=Hg}function Tg(){}var vg={};function Vg(A,g,I){if(void 0===A[g].overloadTable){var t=A[g];A[g]=function(){return A[g].overloadTable.hasOwnProperty(arguments.length)||yg("Function '"+I+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+A[g].overloadTable+")!"),A[g].overloadTable[arguments.length].apply(this,arguments)},A[g].overloadTable=[],A[g].overloadTable[t.argCount]=t}}function Wg(A,g,I){e.hasOwnProperty(A)?((void 0===I||void 0!==e[A].overloadTable&&void 0!==e[A].overloadTable[I])&&yg("Cannot register public name '"+A+"' twice"),Vg(e,A,A),e.hasOwnProperty(I)&&yg("Cannot register multiple overloads of a function with the same number of arguments ("+I+")!"),e[A].overloadTable[I]=g):(e[A]=g,void 0!==I&&(e[A].numArguments=I))}function Og(A,g,I,t,C,e,B,i){this.name=A,this.constructor=g,this.instancePrototype=I,this.rawDestructor=t,this.baseClass=C,this.getActualType=e,this.upcast=B,this.downcast=i,this.pureVirtualFunctions=[]}function Zg(A,g,I){for(;g!==I;)g.upcast||yg("Expected null or instance of "+I.name+", got an instance of "+g.name),A=g.upcast(A),g=g.baseClass;return A}function Pg(A,g){if(null===g)return this.isReference&&yg("null is not a valid "+this.name),0;g.$$||yg('Cannot pass "'+xI(g)+'" as a '+this.name),g.$$.ptr||yg("Cannot pass deleted object as a pointer of type "+this.name);var I=g.$$.ptrType.registeredClass;return Zg(g.$$.ptr,I,this.registeredClass)}function Xg(A,g){var I;if(null===g)return this.isReference&&yg("null is not a valid "+this.name),this.isSmartPointer?(I=this.rawConstructor(),null!==A&&A.push(this.rawDestructor,I),I):0;g.$$||yg('Cannot pass "'+xI(g)+'" as a '+this.name),g.$$.ptr||yg("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&g.$$.ptrType.isConst&&yg("Cannot convert argument of type "+(g.$$.smartPtrType?g.$$.smartPtrType.name:g.$$.ptrType.name)+" to parameter type "+this.name);var t=g.$$.ptrType.registeredClass;if(I=Zg(g.$$.ptr,t,this.registeredClass),this.isSmartPointer)switch(void 0===g.$$.smartPtr&&yg("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:g.$$.smartPtrType===this?I=g.$$.smartPtr:yg("Cannot convert argument of type "+(g.$$.smartPtrType?g.$$.smartPtrType.name:g.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:I=g.$$.smartPtr;break;case 2:if(g.$$.smartPtrType===this)I=g.$$.smartPtr;else{var C=g.clone();I=this.rawShare(I,YI((function(){C.delete()}))),null!==A&&A.push(this.rawDestructor,I)}break;default:yg("Unsupporting sharing policy")}return I}function jg(A,g){if(null===g)return this.isReference&&yg("null is not a valid "+this.name),0;g.$$||yg('Cannot pass "'+xI(g)+'" as a '+this.name),g.$$.ptr||yg("Cannot pass deleted object as a pointer of type "+this.name),g.$$.ptrType.isConst&&yg("Cannot convert argument of type "+g.$$.ptrType.name+" to parameter type "+this.name);var I=g.$$.ptrType.registeredClass;return Zg(g.$$.ptr,I,this.registeredClass)}function zg(A){return this.rawGetPointee&&(A=this.rawGetPointee(A)),A}function _g(A){this.rawDestructor&&this.rawDestructor(A)}function $g(A){null!==A&&A.delete()}function AI(A,g,I){if(g===I)return A;if(void 0===I.baseClass)return null;var t=AI(A,g,I.baseClass);return null===t?null:I.downcast(t)}function gI(){return Object.keys(eI).length}function II(){var A=[];for(var g in eI)eI.hasOwnProperty(g)&&A.push(eI[g]);return A}function tI(A){Lg=A,xg.length&&Lg&&Lg(bg)}function CI(){e.getInheritedInstanceCount=gI,e.getLiveInheritedInstances=II,e.flushPendingDeletes=bg,e.setDelayFunction=tI}var eI={};function BI(A,g){for(void 0===g&&yg("ptr should not be undefined");A.baseClass;)g=A.upcast(g),A=A.baseClass;return g}function iI(A,g){return g=BI(A,g),eI[g]}function QI(A,g){return g.ptrType&&g.ptr||ag("makeClassHandle requires ptr and ptrType"),!!g.smartPtrType!=!!g.smartPtr&&ag("Both smartPtrType and smartPtr must be specified"),g.count={value:1},Ug(Object.create(A,{$$:{value:g}}))}function oI(A){var g=this.getPointee(A);if(!g)return this.destructor(A),null;var I=iI(this.registeredClass,g);if(void 0!==I){if(0===I.$$.count.value)return I.$$.ptr=g,I.$$.smartPtr=A,I.clone();var t=I.clone();return this.destructor(A),t}function C(){return this.isSmartPointer?QI(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:g,smartPtrType:this,smartPtr:A}):QI(this.registeredClass.instancePrototype,{ptrType:this,ptr:A})}var e,B=this.registeredClass.getActualType(g),i=vg[B];if(!i)return C.call(this);e=this.isConst?i.constPointerType:i.pointerType;var Q=AI(g,this.registeredClass,e.registeredClass);return null===Q?C.call(this):this.isSmartPointer?QI(e.registeredClass.instancePrototype,{ptrType:e,ptr:Q,smartPtrType:this,smartPtr:A}):QI(e.registeredClass.instancePrototype,{ptrType:e,ptr:Q})}function EI(){nI.prototype.getPointee=zg,nI.prototype.destructor=_g,nI.prototype.argPackAdvance=8,nI.prototype.readValueFromPointer=tg,nI.prototype.deleteObject=$g,nI.prototype.fromWireType=oI}function nI(A,g,I,t,C,e,B,i,Q,o,E){this.name=A,this.registeredClass=g,this.isReference=I,this.isConst=t,this.isSmartPointer=C,this.pointeeType=e,this.sharingPolicy=B,this.rawGetPointee=i,this.rawConstructor=Q,this.rawShare=o,this.rawDestructor=E,C||void 0!==g.baseClass?this.toWireType=Xg:t?(this.toWireType=Pg,this.destructorFunction=null):(this.toWireType=jg,this.destructorFunction=null)}function sI(A,g,I){e.hasOwnProperty(A)||ag("Replacing nonexistant public symbol"),void 0!==e[A].overloadTable&&void 0!==I?e[A].overloadTable[I]=g:(e[A]=g,e[A].argCount=I)}function aI(A,g,I){return I&&I.length?e["dynCall_"+A].apply(null,[g].concat(I)):e["dynCall_"+A].call(null,g)}function rI(A,g,I){return-1!=A.indexOf("j")?aI(A,g,I):tA.get(g).apply(null,I)}function hI(A,g){k(A.indexOf("j")>=0,"getDynCaller should only be called with i64 sigs");var I=[];return function(){I.length=arguments.length;for(var t=0;t<arguments.length;t++)I[t]=arguments[t];return rI(A,g,I)}}function cI(A,g){function I(){return-1!=A.indexOf("j")?hI(A,g):tA.get(g)}A=dg(A);var t=I();return"function"!=typeof t&&yg("unknown function pointer with signature "+A+": "+g),t}var lI=void 0;function DI(A){var g=zt(A),I=dg(g);return Xt(g),I}function uI(A,g){var I=[],t={};function C(A){t[A]||eg[A]||(Bg[A]?Bg[A].forEach(C):(I.push(A),t[A]=!0))}throw g.forEach(C),new lI(A+": "+I.map(DI).join([", "]))}function wI(A,g,I,t,C,e,B,i,Q,o,E,n,s){E=dg(E),e=cI(C,e),i&&(i=cI(B,i)),o&&(o=cI(Q,o)),s=cI(n,s);var a=og(E);Wg(a,(function(){uI("Cannot construct "+E+" due to unbound types",[t])})),rg([A,g,I],t?[t]:[],(function(g){var I,C;g=g[0],C=t?(I=g.registeredClass).instancePrototype:Tg.prototype;var B=Eg(a,(function(){if(Object.getPrototypeOf(this)!==Q)throw new pg("Use 'new' to construct "+E);if(void 0===n.constructor_body)throw new pg(E+" has no accessible constructor");var A=n.constructor_body[arguments.length];if(void 0===A)throw new pg("Tried to invoke ctor of "+E+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(n.constructor_body).toString()+") parameters instead!");return A.apply(this,arguments)})),Q=Object.create(C,{constructor:{value:B}});B.prototype=Q;var n=new Og(E,B,Q,s,I,e,i,o),r=new nI(E,n,!0,!1,!1),h=new nI(E+"*",n,!1,!1,!1),c=new nI(E+" const*",n,!1,!0,!1);return vg[A]={pointerType:h,constPointerType:c},sI(a,B),[r,h,c]}))}function dI(A,g){if(!(A instanceof Function))throw new TypeError("new_ called with constructor type "+typeof A+" which is not a function");var I=Eg(A.name||"unknownFunctionName",(function(){}));I.prototype=A.prototype;var t=new I,C=A.apply(t,g);return C instanceof Object?C:t}function pI(A,g,I,t,C){var e=g.length;e<2&&yg("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var B=null!==g[1]&&null!==I,i=!1,Q=1;Q<g.length;++Q)if(null!==g[Q]&&void 0===g[Q].destructorFunction){i=!0;break}var o="void"!==g[0].name,E="",n="";for(Q=0;Q<e-2;++Q)E+=(0!==Q?", ":"")+"arg"+Q,n+=(0!==Q?", ":"")+"arg"+Q+"Wired";var s="return function "+og(A)+"("+E+") {\nif (arguments.length !== "+(e-2)+") {\nthrowBindingError('function "+A+" called with ' + arguments.length + ' arguments, expected "+(e-2)+" args!');\n}\n";i&&(s+="var destructors = [];\n");var a=i?"destructors":"null",r=["throwBindingError","invoker","fn","runDestructors","retType","classParam"],h=[yg,t,C,Ig,g[0],g[1]];for(B&&(s+="var thisWired = classParam.toWireType("+a+", this);\n"),Q=0;Q<e-2;++Q)s+="var arg"+Q+"Wired = argType"+Q+".toWireType("+a+", arg"+Q+"); // "+g[Q+2].name+"\n",r.push("argType"+Q),h.push(g[Q+2]);if(B&&(n="thisWired"+(n.length>0?", ":"")+n),s+=(o?"var rv = ":"")+"invoker(fn"+(n.length>0?", ":"")+n+");\n",i)s+="runDestructors(destructors);\n";else for(Q=B?1:2;Q<g.length;++Q){var c=1===Q?"thisWired":"arg"+(Q-2)+"Wired";null!==g[Q].destructorFunction&&(s+=c+"_dtor("+c+"); // "+g[Q].name+"\n",r.push(c+"_dtor"),h.push(g[Q].destructorFunction))}return o&&(s+="var ret = retType.fromWireType(rv);\nreturn ret;\n"),s+="}\n",r.push(s),dI(Function,r).apply(null,h)}function yI(A,g){for(var I=[],t=0;t<A;t++)I.push(T[(g>>2)+t]);return I}function GI(A,g,I,t,C,e,B){var i=yI(I,t);g=dg(g),e=cI(C,e),rg([],[A],(function(A){var t=(A=A[0]).name+"."+g;function C(){uI("Cannot call "+t+" due to unbound types",i)}var Q=A.registeredClass.constructor;return void 0===Q[g]?(C.argCount=I-1,Q[g]=C):(Vg(Q,g,t),Q[g].overloadTable[I-1]=C),rg([],i,(function(A){var C=[A[0],null].concat(A.slice(1)),i=pI(t,C,null,e,B);return void 0===Q[g].overloadTable?(i.argCount=I-1,Q[g]=i):Q[g].overloadTable[I-1]=i,[]})),[]}))}function fI(A,g,I,t,C,e){k(g>0);var B=yI(g,I);C=cI(t,C);var i=[e],Q=[];rg([],[A],(function(A){var I="constructor "+(A=A[0]).name;if(void 0===A.registeredClass.constructor_body&&(A.registeredClass.constructor_body=[]),void 0!==A.registeredClass.constructor_body[g-1])throw new pg("Cannot register multiple constructors with identical number of parameters ("+(g-1)+") for class '"+A.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return A.registeredClass.constructor_body[g-1]=function(){uI("Cannot construct "+A.name+" due to unbound types",B)},rg([],B,(function(t){return A.registeredClass.constructor_body[g-1]=function(){arguments.length!==g-1&&yg(I+" called with "+arguments.length+" arguments, expected "+(g-1)),Q.length=0,i.length=g;for(var A=1;A<g;++A)i[A]=t[A].toWireType(Q,arguments[A-1]);var e=C.apply(null,i);return Ig(Q),t[0].fromWireType(e)},[]})),[]}))}function NI(A,g,I,t,C,e,B,i){var Q=yI(I,t);g=dg(g),e=cI(C,e),rg([],[A],(function(A){var t=(A=A[0]).name+"."+g;function C(){uI("Cannot call "+t+" due to unbound types",Q)}i&&A.registeredClass.pureVirtualFunctions.push(g);var o=A.registeredClass.instancePrototype,E=o[g];return void 0===E||void 0===E.overloadTable&&E.className!==A.name&&E.argCount===I-2?(C.argCount=I-2,C.className=A.name,o[g]=C):(Vg(o,g,t),o[g].overloadTable[I-2]=C),rg([],Q,(function(C){var i=pI(t,C,A,e,B);return void 0===o[g].overloadTable?(i.argCount=I-2,o[g]=i):o[g].overloadTable[I-2]=i,[]})),[]}))}function FI(A,g,I){return A instanceof Object||yg(I+' with invalid "this": '+A),A instanceof g.registeredClass.constructor||yg(I+' incompatible with "this" of type '+A.constructor.name),A.$$.ptr||yg("cannot call emscripten binding method "+I+" on deleted object"),Zg(A.$$.ptr,A.$$.ptrType.registeredClass,g.registeredClass)}function RI(A,g,I,t,C,e,B,i,Q,o){g=dg(g),C=cI(t,C),rg([],[A],(function(A){var t=(A=A[0]).name+"."+g,E={get:function(){uI("Cannot access "+t+" due to unbound types",[I,B])},enumerable:!0,configurable:!0};return E.set=Q?function(){uI("Cannot access "+t+" due to unbound types",[I,B])}:function(A){yg(t+" is a read-only property")},Object.defineProperty(A.registeredClass.instancePrototype,g,E),rg([],Q?[I,B]:[I],(function(I){var B=I[0],E={get:function(){var g=FI(this,A,t+" getter");return B.fromWireType(C(e,g))},enumerable:!0};if(Q){Q=cI(i,Q);var n=I[1];E.set=function(g){var I=FI(this,A,t+" setter"),C=[];Q(o,I,n.toWireType(C,g)),Ig(C)}}return Object.defineProperty(A.registeredClass.instancePrototype,g,E),[]})),[]}))}function mI(A,g,I){A=dg(A),rg([],[g],(function(g){return g=g[0],e[A]=g.fromWireType(I),[]}))}var kI=[],SI=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function MI(A){A>4&&0==--SI[A].refcount&&(SI[A]=void 0,kI.push(A))}function UI(){for(var A=0,g=5;g<SI.length;++g)void 0!==SI[g]&&++A;return A}function KI(){for(var A=5;A<SI.length;++A)if(void 0!==SI[A])return SI[A];return null}function JI(){e.count_emval_handles=UI,e.get_first_emval=KI}function YI(A){switch(A){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:var g=kI.length?kI.pop():SI.length;return SI[g]={refcount:1,value:A},g}}function LI(A,g){Gg(A,{name:g=dg(g),fromWireType:function(A){var g=SI[A].value;return MI(A),g},toWireType:function(A,g){return YI(g)},argPackAdvance:8,readValueFromPointer:tg,destructorFunction:null})}function xI(A){if(null===A)return"null";var g=typeof A;return"object"===g||"array"===g||"function"===g?A.toString():""+A}function bI(A,g){switch(g){case 2:return function(A){return this.fromWireType(V[A>>2])};case 3:return function(A){return this.fromWireType(W[A>>3])};default:throw new TypeError("Unknown float type: "+A)}}function HI(A,g,I){var t=Dg(I);Gg(A,{name:g=dg(g),fromWireType:function(A){return A},toWireType:function(A,g){if("number"!=typeof g&&"boolean"!=typeof g)throw new TypeError('Cannot convert "'+xI(g)+'" to '+this.name);return g},argPackAdvance:8,readValueFromPointer:bI(g,t),destructorFunction:null})}function qI(A,g,I,t,C,e){var B=yI(g,I);A=dg(A),C=cI(t,C),Wg(A,(function(){uI("Cannot call "+A+" due to unbound types",B)}),g-1),rg([],B,(function(I){var t=[I[0],null].concat(I.slice(1));return sI(A,pI(A,t,null,C,e),g-1),[]}))}function TI(A,g,I){switch(g){case 0:return I?function(A){return x[A]}:function(A){return b[A]};case 1:return I?function(A){return H[A>>1]}:function(A){return q[A>>1]};case 2:return I?function(A){return T[A>>2]}:function(A){return v[A>>2]};default:throw new TypeError("Unknown integer type: "+A)}}function vI(A,g,I,t,C){g=dg(g),-1===C&&(C=4294967295);var e=Dg(I),B=function(A){return A};if(0===t){var i=32-8*I;B=function(A){return A<<i>>>i}}var Q=-1!=g.indexOf("unsigned");Gg(A,{name:g,fromWireType:B,toWireType:function(A,I){if("number"!=typeof I&&"boolean"!=typeof I)throw new TypeError('Cannot convert "'+xI(I)+'" to '+this.name);if(I<t||I>C)throw new TypeError('Passing a number "'+xI(I)+'" from JS side to C/C++ side to an argument of type "'+g+'", which is outside the valid range ['+t+", "+C+"]!");return Q?I>>>0:0|I},argPackAdvance:8,readValueFromPointer:TI(g,e,0!==t),destructorFunction:null})}function VI(A,g,I){var t=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][g];function C(A){var g=v,I=g[A>>=2],C=g[A+1];return new t(L,C,I)}Gg(A,{name:I=dg(I),fromWireType:C,argPackAdvance:8,readValueFromPointer:C},{ignoreDuplicateRegistrations:!0})}function WI(A,g){var I="std::string"===(g=dg(g));Gg(A,{name:g,fromWireType:function(A){var g,t=v[A>>2];if(I)for(var C=A+4,e=0;e<=t;++e){var B=A+4+e;if(e==t||0==b[B]){var i=U(C,B-C);void 0===g?g=i:(g+=String.fromCharCode(0),g+=i),C=B+1}}else{var Q=new Array(t);for(e=0;e<t;++e)Q[e]=String.fromCharCode(b[A+4+e]);g=Q.join("")}return Xt(A),g},toWireType:function(A,g){g instanceof ArrayBuffer&&(g=new Uint8Array(g));var t="string"==typeof g;t||g instanceof Uint8Array||g instanceof Uint8ClampedArray||g instanceof Int8Array||yg("Cannot pass non-string to std::string");var C=(I&&t?function(){return Y(g)}:function(){return g.length})(),e=Pt(4+C+1);if(v[e>>2]=C,I&&t)J(g,e+4,C+1);else if(t)for(var B=0;B<C;++B){var i=g.charCodeAt(B);i>255&&(Xt(e),yg("String has UTF-16 code units that do not fit in 8 bits")),b[e+4+B]=i}else for(B=0;B<C;++B)b[e+4+B]=g[B];return null!==A&&A.push(Xt,e),e},argPackAdvance:8,readValueFromPointer:tg,destructorFunction:function(A){Xt(A)}})}function OI(A,g,I){var t,C,e,B,i;I=dg(I),2===g?(t=Z,C=P,B=X,e=function(){return q},i=1):4===g&&(t=j,C=z,B=_,e=function(){return v},i=2),Gg(A,{name:I,fromWireType:function(A){for(var I,C=v[A>>2],B=e(),Q=A+4,o=0;o<=C;++o){var E=A+4+o*g;if(o==C||0==B[E>>i]){var n=t(Q,E-Q);void 0===I?I=n:(I+=String.fromCharCode(0),I+=n),Q=E+g}}return Xt(A),I},toWireType:function(A,t){"string"!=typeof t&&yg("Cannot pass non-string to C++ string type "+I);var e=B(t),Q=Pt(4+e+g);return v[Q>>2]=e>>i,C(t,Q+4,e+g),null!==A&&A.push(Xt,Q),Q},argPackAdvance:8,readValueFromPointer:tg,destructorFunction:function(A){Xt(A)}})}function ZI(A,g,I,t,C,e){gg[A]={name:dg(g),rawConstructor:cI(I,t),rawDestructor:cI(C,e),elements:[]}}function PI(A,g,I,t,C,e,B,i,Q){gg[A].elements.push({getterReturnType:g,getter:cI(I,t),getterContext:C,setterArgumentType:e,setter:cI(B,i),setterContext:Q})}function XI(A,g,I,t,C,e){cg[A]={name:dg(g),rawConstructor:cI(I,t),rawDestructor:cI(C,e),fields:[]}}function jI(A,g,I,t,C,e,B,i,Q,o){cg[A].fields.push({fieldName:dg(g),getterReturnType:I,getter:cI(t,C),getterContext:e,setterArgumentType:B,setter:cI(i,Q),setterContext:o})}function zI(A,g){Gg(A,{isVoid:!0,name:g=dg(g),argPackAdvance:0,fromWireType:function(){},toWireType:function(A,g){}})}var _I={};function $I(A){var g=_I[A];return void 0===g?dg(A):g}var At=[];function gt(A){return A||yg("Cannot use deleted val. handle = "+A),SI[A].value}function It(A,g,I,t){(A=At[A])(g=gt(g),I=$I(I),null,t)}function tt(A){var g=At.length;return At.push(A),g}function Ct(A,g){var I=eg[A];return void 0===I&&yg(g+" has unknown type "+DI(A)),I}function et(A,g){for(var I=new Array(A),t=0;t<A;++t)I[t]=Ct(T[(g>>2)+t],"parameter "+t);return I}function Bt(A,g){for(var I=et(A,g),t=I[0],C=t.name+"_$"+I.slice(1).map((function(A){return A.name})).join("_")+"$",e=["retType"],B=[t],i="",Q=0;Q<A-1;++Q)i+=(0!==Q?", ":"")+"arg"+Q,e.push("argType"+Q),B.push(I[1+Q]);var o="return function "+og("methodCaller_"+C)+"(handle, name, destructors, args) {\n",E=0;for(Q=0;Q<A-1;++Q)o+="    var arg"+Q+" = argType"+Q+".readValueFromPointer(args"+(E?"+"+E:"")+");\n",E+=I[Q+1].argPackAdvance;for(o+="    var rv = handle[name]("+i+");\n",Q=0;Q<A-1;++Q)I[Q+1].deleteObject&&(o+="    argType"+Q+".deleteObject(arg"+Q+");\n");return t.isVoid||(o+="    return retType.toWireType(destructors, rv);\n"),o+="};\n",e.push(o),tt(dI(Function,e).apply(null,B))}function it(A){A>4&&(SI[A].refcount+=1)}function Qt(){return YI([])}function ot(A){return YI($I(A))}function Et(A,g,I){A=gt(A),g=gt(g),I=gt(I),A[g]=I}function nt(A,g){return YI((A=Ct(A,"_emval_take_value")).readValueFromPointer(g))}function st(){wA()}var at=!0;function rt(A,g){var I;if(0===A)I=Date.now();else{if(1!==A&&4!==A||!at)return vA(28),-1;I=RA()}return T[g>>2]=I/1e3|0,T[g+4>>2]=I%1e3*1e3*1e3|0,0}function ht(A,g,I){b.copyWithin(A,g,g+I)}function ct(){return b.length}function lt(A){try{return F.grow(A-L.byteLength+65535>>>16),IA(F.buffer),1}catch(A){}}function Dt(A){A>>>=0;var g=ct(),I=1073741824;if(A>I)return!1;for(var t=16777216,C=1;C<=4;C*=2){var e=g*(1+.2/C);if(e=Math.min(e,A+100663296),lt(Math.min(I,gA(Math.max(t,A,e),65536))))return!0}return!1}var ut={};function wt(){return o||"./this.program"}function dt(){if(!dt.strings){var A={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:wt()};for(var g in ut)A[g]=ut[g];var I=[];for(var g in A)I.push(g+"="+A[g]);dt.strings=I}return dt.strings}function pt(A,g){try{var I=0;return dt().forEach((function(t,C){var e=g+I;T[A+4*C>>2]=e,AA(t,e),I+=t.length+1})),0}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),A.errno}}function yt(A,g){try{var I=dt();T[A>>2]=I.length;var t=0;return I.forEach((function(A){t+=A.length+1})),T[g>>2]=t,0}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),A.errno}}function Gt(A){try{var g=zA.getStreamFromFD(A);return jA.close(g),0}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),A.errno}}function ft(A,g,I,t){try{var C=zA.getStreamFromFD(A),e=zA.doReadv(C,g,I);return T[t>>2]=e,0}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),A.errno}}function Nt(A,g,I,t,C){try{var e=zA.getStreamFromFD(A),B=4294967296*I+(g>>>0),i=9007199254740992;return B<=-i||B>=i?-61:(jA.llseek(e,B,t),FA=[e.position>>>0,(NA=e.position,+Math.abs(NA)>=1?NA>0?(0|Math.min(+Math.floor(NA/4294967296),4294967295))>>>0:~~+Math.ceil((NA-+(~~NA>>>0))/4294967296)>>>0:0)],T[C>>2]=FA[0],T[C+4>>2]=FA[1],e.getdents&&0===B&&0===t&&(e.getdents=null),0)}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),A.errno}}function Ft(A,g,I,t){try{var C=zA.getStreamFromFD(A),e=zA.doWritev(C,g,I);return T[t>>2]=e,0}catch(A){return void 0!==jA&&A instanceof jA.ErrnoError||wA(A),A.errno}}function Rt(A){R(0|A)}function mt(A){return A%4==0&&(A%100!=0||A%400==0)}function kt(A,g){for(var I=0,t=0;t<=g;I+=A[t++]);return I}var St=[31,29,31,30,31,30,31,31,30,31,30,31],Mt=[31,28,31,30,31,30,31,31,30,31,30,31];function Ut(A,g){for(var I=new Date(A.getTime());g>0;){var t=mt(I.getFullYear()),C=I.getMonth(),e=(t?St:Mt)[C];if(!(g>e-I.getDate()))return I.setDate(I.getDate()+g),I;g-=e-I.getDate()+1,I.setDate(1),C<11?I.setMonth(C+1):(I.setMonth(0),I.setFullYear(I.getFullYear()+1))}return I}function Kt(A,g,I,t){var C=T[t+40>>2],e={tm_sec:T[t>>2],tm_min:T[t+4>>2],tm_hour:T[t+8>>2],tm_mday:T[t+12>>2],tm_mon:T[t+16>>2],tm_year:T[t+20>>2],tm_wday:T[t+24>>2],tm_yday:T[t+28>>2],tm_isdst:T[t+32>>2],tm_gmtoff:T[t+36>>2],tm_zone:C?U(C):""},B=U(I),i={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Q in i)B=B.replace(new RegExp(Q,"g"),i[Q]);var o=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],E=["January","February","March","April","May","June","July","August","September","October","November","December"];function n(A,g,I){for(var t="number"==typeof A?A.toString():A||"";t.length<g;)t=I[0]+t;return t}function s(A,g){return n(A,g,"0")}function a(A,g){function I(A){return A<0?-1:A>0?1:0}var t;return 0===(t=I(A.getFullYear()-g.getFullYear()))&&0===(t=I(A.getMonth()-g.getMonth()))&&(t=I(A.getDate()-g.getDate())),t}function r(A){switch(A.getDay()){case 0:return new Date(A.getFullYear()-1,11,29);case 1:return A;case 2:return new Date(A.getFullYear(),0,3);case 3:return new Date(A.getFullYear(),0,2);case 4:return new Date(A.getFullYear(),0,1);case 5:return new Date(A.getFullYear()-1,11,31);case 6:return new Date(A.getFullYear()-1,11,30)}}function h(A){var g=Ut(new Date(A.tm_year+1900,0,1),A.tm_yday),I=new Date(g.getFullYear(),0,4),t=new Date(g.getFullYear()+1,0,4),C=r(I),e=r(t);return a(C,g)<=0?a(e,g)<=0?g.getFullYear()+1:g.getFullYear():g.getFullYear()-1}var c={"%a":function(A){return o[A.tm_wday].substring(0,3)},"%A":function(A){return o[A.tm_wday]},"%b":function(A){return E[A.tm_mon].substring(0,3)},"%B":function(A){return E[A.tm_mon]},"%C":function(A){return s((A.tm_year+1900)/100|0,2)},"%d":function(A){return s(A.tm_mday,2)},"%e":function(A){return n(A.tm_mday,2," ")},"%g":function(A){return h(A).toString().substring(2)},"%G":function(A){return h(A)},"%H":function(A){return s(A.tm_hour,2)},"%I":function(A){var g=A.tm_hour;return 0==g?g=12:g>12&&(g-=12),s(g,2)},"%j":function(A){return s(A.tm_mday+kt(mt(A.tm_year+1900)?St:Mt,A.tm_mon-1),3)},"%m":function(A){return s(A.tm_mon+1,2)},"%M":function(A){return s(A.tm_min,2)},"%n":function(){return"\n"},"%p":function(A){return A.tm_hour>=0&&A.tm_hour<12?"AM":"PM"},"%S":function(A){return s(A.tm_sec,2)},"%t":function(){return"\t"},"%u":function(A){return A.tm_wday||7},"%U":function(A){var g=new Date(A.tm_year+1900,0,1),I=0===g.getDay()?g:Ut(g,7-g.getDay()),t=new Date(A.tm_year+1900,A.tm_mon,A.tm_mday);if(a(I,t)<0){var C=kt(mt(t.getFullYear())?St:Mt,t.getMonth()-1)-31,e=31-I.getDate()+C+t.getDate();return s(Math.ceil(e/7),2)}return 0===a(I,g)?"01":"00"},"%V":function(A){var g,I=new Date(A.tm_year+1900,0,4),t=new Date(A.tm_year+1901,0,4),C=r(I),e=r(t),B=Ut(new Date(A.tm_year+1900,0,1),A.tm_yday);return a(B,C)<0?"53":a(e,B)<=0?"01":(g=C.getFullYear()<A.tm_year+1900?A.tm_yday+32-C.getDate():A.tm_yday+1-C.getDate(),s(Math.ceil(g/7),2))},"%w":function(A){return A.tm_wday},"%W":function(A){var g=new Date(A.tm_year,0,1),I=1===g.getDay()?g:Ut(g,0===g.getDay()?1:7-g.getDay()+1),t=new Date(A.tm_year+1900,A.tm_mon,A.tm_mday);if(a(I,t)<0){var C=kt(mt(t.getFullYear())?St:Mt,t.getMonth()-1)-31,e=31-I.getDate()+C+t.getDate();return s(Math.ceil(e/7),2)}return 0===a(I,g)?"01":"00"},"%y":function(A){return(A.tm_year+1900).toString().substring(2)},"%Y":function(A){return A.tm_year+1900},"%z":function(A){var g=A.tm_gmtoff,I=g>=0;return g=(g=Math.abs(g)/60)/60*100+g%60,(I?"+":"-")+String("0000"+g).slice(-4)},"%Z":function(A){return A.tm_zone},"%%":function(){return"%"}};for(var Q in c)B.indexOf(Q)>=0&&(B=B.replace(new RegExp(Q,"g"),c[Q](e)));var l=Ht(B,!1);return l.length>g?0:($(l,A),l.length-1)}function Jt(A,g,I,t){return Kt(A,g,I,t)}e.requestFullscreen=function(A,g){JA.requestFullscreen(A,g)},e.requestAnimationFrame=function(A){JA.requestAnimationFrame(A)},e.setCanvasSize=function(A,g,I){JA.setCanvasSize(A,g,I)},e.pauseMainLoop=function(){JA.mainLoop.pause()},e.resumeMainLoop=function(){JA.mainLoop.resume()},e.getUserMedia=function(){JA.getUserMedia()},e.createContext=function(A,g,I,t){return JA.createContext(A,g,I,t)};var Yt=function(A,g,I,t){A||(A=this),this.parent=A,this.mount=A.mount,this.mounted=null,this.id=jA.nextInode++,this.name=g,this.mode=I,this.node_ops={},this.stream_ops={},this.rdev=t},Lt=365,xt=146;Object.defineProperties(Yt.prototype,{read:{get:function(){return(this.mode&Lt)===Lt},set:function(A){A?this.mode|=Lt:this.mode&=~Lt}},write:{get:function(){return(this.mode&xt)===xt},set:function(A){A?this.mode|=xt:this.mode&=~xt}},isFolder:{get:function(){return jA.isDir(this.mode)}},isDevice:{get:function(){return jA.isChrdev(this.mode)}}}),jA.FSNode=Yt,jA.staticInit(),e.FS_createPath=jA.createPath,e.FS_createDataFile=jA.createDataFile,e.FS_createPreloadedFile=jA.createPreloadedFile,e.FS_createLazyFile=jA.createLazyFile,e.FS_createDevice=jA.createDevice,e.FS_unlink=jA.unlink,sg=e.InternalError=ng(Error,"InternalError"),ug(),pg=e.BindingError=ng(Error,"BindingError"),qg(),EI(),CI(),lI=e.UnboundTypeError=ng(Error,"UnboundTypeError"),JI();var bt=!1;function Ht(A,g,I){var t=I>0?I:Y(A)+1,C=new Array(t),e=K(A,C,0,C.length);return g&&(C.length=e),C}function qt(A){for(var g=[],I=0;I<A.length;I++){var t=A[I];t>255&&(bt&&k(!1,"Character code "+t+" ("+String.fromCharCode(t)+")  at offset "+I+" not in 0x00-0xFF."),t&=255),g.push(String.fromCharCode(t))}return g.join("")}var Tt="function"==typeof atob?atob:function(A){var g,I,t,C,e,B,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Q="",o=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{g=i.indexOf(A.charAt(o++))<<2|(C=i.indexOf(A.charAt(o++)))>>4,I=(15&C)<<4|(e=i.indexOf(A.charAt(o++)))>>2,t=(3&e)<<6|(B=i.indexOf(A.charAt(o++))),Q+=String.fromCharCode(g),64!==e&&(Q+=String.fromCharCode(I)),64!==B&&(Q+=String.fromCharCode(t))}while(o<A.length);return Q};function vt(A){if("boolean"==typeof s&&s){var g;try{g=Buffer.from(A,"base64")}catch(I){g=new Buffer(A,"base64")}return new Uint8Array(g.buffer,g.byteOffset,g.byteLength)}try{for(var I=Tt(A),t=new Uint8Array(I.length),C=0;C<I.length;++C)t[C]=I.charCodeAt(C);return t}catch(A){throw new Error("Converting base64 string to bytes failed.")}}function Vt(A){if(yA(A))return vt(A.slice(pA.length))}eA.push({func:function(){Zt()}});var Wt,Ot={__cxa_allocate_exception:xA,__cxa_atexit:HA,__cxa_throw:TA,__sys_fcntl64:_A,__sys_ioctl:$A,__sys_open:Ag,_embind_finalize_value_array:hg,_embind_finalize_value_object:lg,_embind_register_bool:fg,_embind_register_class:wI,_embind_register_class_class_function:GI,_embind_register_class_constructor:fI,_embind_register_class_function:NI,_embind_register_class_property:RI,_embind_register_constant:mI,_embind_register_emval:LI,_embind_register_float:HI,_embind_register_function:qI,_embind_register_integer:vI,_embind_register_memory_view:VI,_embind_register_std_string:WI,_embind_register_std_wstring:OI,_embind_register_value_array:ZI,_embind_register_value_array_element:PI,_embind_register_value_object:XI,_embind_register_value_object_field:jI,_embind_register_void:zI,_emval_call_void_method:It,_emval_decref:MI,_emval_get_method_caller:Bt,_emval_incref:it,_emval_new_array:Qt,_emval_new_cstring:ot,_emval_set_property:Et,_emval_take_value:nt,abort:st,clock_gettime:rt,emscripten_memcpy_big:ht,emscripten_resize_heap:Dt,environ_get:pt,environ_sizes_get:yt,fd_close:Gt,fd_read:ft,fd_seek:Nt,fd_write:Ft,setTempRet0:Rt,strftime_l:Jt},Zt=(MA(),e.___wasm_call_ctors=function(){return(Zt=e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)}),Pt=e._malloc=function(){return(Pt=e._malloc=e.asm.malloc).apply(null,arguments)},Xt=e._free=function(){return(Xt=e._free=e.asm.free).apply(null,arguments)},jt=e.___errno_location=function(){return(jt=e.___errno_location=e.asm.__errno_location).apply(null,arguments)},zt=e.___getTypeName=function(){return(zt=e.___getTypeName=e.asm.__getTypeName).apply(null,arguments)};function _t(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function $t(A){function g(){Wt||(Wt=!0,e.calledRun=!0,m||(oA(),EA(),t(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),nA()))}A=A||Q,rA>0||(QA(),rA>0||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),g()}),1)):g()))}if(e.___embind_register_native_and_builtin_types=function(){return(e.___embind_register_native_and_builtin_types=e.asm.__embind_register_native_and_builtin_types).apply(null,arguments)},e._emscripten_main_thread_process_queued_calls=function(){return(e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},e.stackSave=function(){return(e.stackSave=e.asm.stackSave).apply(null,arguments)},e.stackRestore=function(){return(e.stackRestore=e.asm.stackRestore).apply(null,arguments)},e.stackAlloc=function(){return(e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)},e._setThrew=function(){return(e._setThrew=e.asm.setThrew).apply(null,arguments)},e.___cxa_demangle=function(){return(e.___cxa_demangle=e.asm.__cxa_demangle).apply(null,arguments)},e.dynCall_viijii=function(){return(e.dynCall_viijii=e.asm.dynCall_viijii).apply(null,arguments)},e.dynCall_ji=function(){return(e.dynCall_ji=e.asm.dynCall_ji).apply(null,arguments)},e.dynCall_vij=function(){return(e.dynCall_vij=e.asm.dynCall_vij).apply(null,arguments)},e.dynCall_jiji=function(){return(e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)},e.dynCall_iiiiij=function(){return(e.dynCall_iiiiij=e.asm.dynCall_iiiiij).apply(null,arguments)},e.dynCall_iiiiijj=function(){return(e.dynCall_iiiiijj=e.asm.dynCall_iiiiijj).apply(null,arguments)},e.dynCall_iiiiiijj=function(){return(e.dynCall_iiiiiijj=e.asm.dynCall_iiiiiijj).apply(null,arguments)},e.addRunDependency=DA,e.removeRunDependency=uA,e.FS_createPath=jA.createPath,e.FS_createDataFile=jA.createDataFile,e.FS_createPreloadedFile=jA.createPreloadedFile,e.FS_createLazyFile=jA.createLazyFile,e.FS_createDevice=jA.createDevice,e.FS_unlink=jA.unlink,cA=function A(){Wt||$t(),Wt||(cA=A)},e.run=$t,e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();function AC(A,g){this.start=void 0===A?0:A,this.end=void 0===g?0:g}function gC(A,g){this.x=void 0===A?0:A,this.y=void 0===g?0:g}function IC(A,g){this.width=void 0===A?0:A,this.height=void 0===g?0:g}function tC(){switch(arguments.length){case 0:this.x=0,this.y=0,this.width=0,this.height=0;break;case 1:var A=arguments[0];this.x=A.x,this.y=A.y,this.width=A.width,this.height=A.height;break;case 2:var g=arguments[0],I=arguments[1];this.x=g.x,this.y=g.y,this.width=I.width,this.height=I.height;break;case 4:this.x=arguments[0],this.y=arguments[1],this.width=arguments[2],this.height=arguments[3];break;default:throw new Error("Invalid arguments")}}function CC(){switch(arguments.length){case 0:this.center={x:0,y:0},this.size={width:0,height:0},this.angle=0;break;case 3:this.center=arguments[0],this.size=arguments[1],this.angle=arguments[2];break;default:throw new Error("Invalid arguments")}}function eC(A,g,I,t){this.push(void 0===A?0:A),this.push(void 0===g?0:g),this.push(void 0===I?0:I),this.push(void 0===t?0:t)}function BC(){switch(arguments.length){case 0:this.minVal=0,this.maxVal=0,this.minLoc=new gC,this.maxLoc=new gC;break;case 4:this.minVal=arguments[0],this.maxVal=arguments[1],this.minLoc=arguments[2],this.maxLoc=arguments[3];break;default:throw new Error("Invalid arguments")}}function iC(){switch(arguments.length){case 0:this.center=new gC,this.radius=0;break;case 2:this.center=arguments[0],this.radius=arguments[1];break;default:throw new Error("Invalid arguments")}}function QC(){switch(arguments.length){case 0:this.type=0,this.maxCount=0,this.epsilon=0;break;case 3:this.type=arguments[0],this.maxCount=arguments[1],this.epsilon=arguments[2];break;default:throw new Error("Invalid arguments")}}return $t(),void 0===e.FS&&void 0!==jA&&(e.FS=jA),e.imread=function(g){var I=null,t=null,C=null;if((I="string"==typeof g?document.getElementById(g):g)instanceof HTMLImageElement)(t=document.createElement("canvas")).width=I.width,t.height=I.height,(C=t.getContext("2d")).drawImage(I,0,0,I.width,I.height);else{if(!(I instanceof HTMLCanvasElement))throw new Error("Please input the valid canvas or img id.");C=(t=I).getContext("2d")}var e=C.getImageData(0,0,t.width,t.height);return A.matFromImageData(e)},e.imshow=function(g,I){var t=null;if(!((t="string"==typeof g?document.getElementById(g):g)instanceof HTMLCanvasElement))throw new Error("Please input the valid canvas element or id.");if(!(I instanceof A.Mat))throw new Error("Please input the valid cv.Mat instance.");var C=new A.Mat,e=I.type()%8,B=e<=A.CV_8S?1:e<=A.CV_32S?1/256:255,i=e===A.CV_8S||e===A.CV_16S?128:0;switch(I.convertTo(C,A.CV_8U,B,i),C.type()){case A.CV_8UC1:A.cvtColor(C,C,A.COLOR_GRAY2RGBA);break;case A.CV_8UC3:A.cvtColor(C,C,A.COLOR_RGB2RGBA);break;case A.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}var Q=new ImageData(new Uint8ClampedArray(C.data),C.cols,C.rows),o=t.getContext("2d");o.clearRect(0,0,t.width,t.height),t.width=Q.width,t.height=Q.height,o.putImageData(Q,0,0),C.delete()},e.VideoCapture=function(g){var I=null;if(!((I="string"==typeof g?document.getElementById(g):g)instanceof HTMLVideoElement))throw new Error("Please input the valid video element or id.");var t=document.createElement("canvas");t.width=I.width,t.height=I.height;var C=t.getContext("2d");this.video=I,this.read=function(g){if(!(g instanceof A.Mat))throw new Error("Please input the valid cv.Mat instance.");if(g.type()!==A.CV_8UC4)throw new Error("Bad type of input mat: the type should be cv.CV_8UC4.");if(g.cols!==I.width||g.rows!==I.height)throw new Error("Bad size of input mat: the size should be same as the video.");C.drawImage(I,0,0,I.width,I.height),g.data.set(C.getImageData(0,0,I.width,I.height).data)}},e.Range=AC,e.Point=gC,e.Size=IC,e.Rect=tC,CC.points=function(A){return e.rotatedRectPoints(A)},CC.boundingRect=function(A){return e.rotatedRectBoundingRect(A)},CC.boundingRect2f=function(A){return e.rotatedRectBoundingRect2f(A)},e.RotatedRect=CC,eC.prototype=new Array,eC.all=function(A){return new eC(A,A,A,A)},e.Scalar=eC,e.MinMaxLoc=BC,e.Circle=iC,e.TermCriteria=QC,e.matFromArray=function(g,I,t,C){var e=new A.Mat(g,I,t);switch(t){case A.CV_8U:case A.CV_8UC1:case A.CV_8UC2:case A.CV_8UC3:case A.CV_8UC4:e.data.set(C);break;case A.CV_8S:case A.CV_8SC1:case A.CV_8SC2:case A.CV_8SC3:case A.CV_8SC4:e.data8S.set(C);break;case A.CV_16U:case A.CV_16UC1:case A.CV_16UC2:case A.CV_16UC3:case A.CV_16UC4:e.data16U.set(C);break;case A.CV_16S:case A.CV_16SC1:case A.CV_16SC2:case A.CV_16SC3:case A.CV_16SC4:e.data16S.set(C);break;case A.CV_32S:case A.CV_32SC1:case A.CV_32SC2:case A.CV_32SC3:case A.CV_32SC4:e.data32S.set(C);break;case A.CV_32F:case A.CV_32FC1:case A.CV_32FC2:case A.CV_32FC3:case A.CV_32FC4:e.data32F.set(C);break;case A.CV_64F:case A.CV_64FC1:case A.CV_64FC2:case A.CV_64FC3:case A.CV_64FC4:e.data64F.set(C);break;default:throw new Error("Type is unsupported")}return e},e.matFromImageData=function(g){var I=new A.Mat(g.height,g.width,A.CV_8UC4);return I.data.set(g.data),I},A.ready},A.exports=t,"undefined"==typeof Module&&(Module={}),t(Module));var g,t}.call(g,I,g,A),void 0===t||(A.exports=t)},804:(A,g,I)=>{var t=I(477);A.exports=function(){return t('(()=>{var t={646:(t,e,r)=>{const{resize:a}=r(45);t.exports={buildImageList:t=>{const e=[];let r=100/Math.min(t.width,t.height);for(;;)if(e.push(r),r*=Math.pow(2,1/3),r>=.95){r=1;break}e.push(r),e.reverse();const i=[];for(let r=0;r<e.length;r++){t.width,e[r],t.height,e[r];i.push(Object.assign(a({image:t,ratio:e[r]}),{scale:e[r]}))}return i},buildTrackingImageList:t=>{const e=Math.min(t.width,t.height),r=[],i=[];r.push(256/e),r.push(128/e);for(let e=0;e<r.length;e++)i.push(Object.assign(a({image:t,ratio:r[e]}),{scale:r[e]}));return i}}},111:(t,e,r)=>{const{Cumsum:a}=r(115),i=t=>{let{image:e,featureMap:r,templateSize:a,searchSize:i,occSize:h,maxSimThresh:l,minSimThresh:u,sdThresh:n,imageDataCumsum:m,imageDataSqrCumsum:c}=t;const{data:f,width:g,height:d,scale:p}=e;h=Math.floor(Math.min(e.width,e.height)/10);const w=3*(2*a+1),M=Math.floor(g/w),y=Math.floor(d/w);let x=Math.floor(g/h)*Math.floor(d/h)+M*y;const q=[],C=new Float32Array(f.length);for(let t=0;t<C.length;t++)C[t]=r[t];let S=0;for(;S<x;){let t=l,r=-1,f=-1;for(let e=0;e<d;e++)for(let a=0;a<g;a++)C[e*g+a]<t&&(t=C[e*g+a],r=a,f=e);if(-1===r)break;const p=s({image:e,cx:r,cy:f,sdThresh:0,imageDataCumsum:m,imageDataSqrCumsum:c});if(null===p){C[f*g+r]=1;continue}if(p/(2*a+1)<n){C[f*g+r]=1;continue}let w=1,M=-1;for(let a=-i;a<=i;a++){for(let s=-i;s<=i;s++){if(s*s+a*a>i*i)continue;if(0===s&&0===a)continue;const h=o({image:e,vlen:p,cx:r+s,cy:f+a,tx:r,ty:f,imageDataCumsum:m,imageDataSqrCumsum:c});if(null!==h){if(h<w&&(w=h,w<u&&w<t))break;if(h>M&&(M=h,M>.99))break}}if(w<u&&w<t||M>.99)break}if(w<u&&w<t||M>.99)C[f*g+r]=1;else{q.push({x:r,y:f}),S+=1;for(let t=-h;t<=h;t++)for(let e=-h;e<=h;e++)f+t<0||f+t>=d||r+e<0||r+e>=g||(C[(f+t)*g+(r+e)]=1)}}return q},s=({image:t,cx:e,cy:r,sdThresh:a,imageDataCumsum:i,imageDataSqrCumsum:s})=>{if(e-6<0||e+6>=t.width)return null;if(r-6<0||r+6>=t.height)return null;let o=i.query(e-6,r-6,e+6,r+6);o/=169;let h=s.query(e-6,r-6,e+6,r+6);return h-=2*o*i.query(e-6,r-6,e+6,r+6),h+=169*o*o,h/169<a*a?null:(h=Math.sqrt(h),h)},o=t=>{const{image:e,cx:r,cy:a,vlen:i,tx:s,ty:o,imageDataCumsum:h,imageDataSqrCumsum:l}=t,{data:u,width:n,height:m}=e;if(r-6<0||r+6>=n)return null;if(a-6<0||a+6>=m)return null;const c=13;let f=h.query(r-6,a-6,r+6,a+6),g=l.query(r-6,a-6,r+6,a+6),d=0,p=(a-6)*n+(r-6),w=(o-6)*n+(s-6),M=n-c;for(let t=0;t<c;t++){for(let t=0;t<c;t++)d+=u[p]*u[w],p+=1,w+=1;p+=M,w+=M}let y=h.query(s-6,o-6,s+6,o+6);y/=169,d-=y*f;let x=g-f*f/169;if(0==x)return null;x=Math.sqrt(x);return 1*d/(i*x)};t.exports={extract:t=>{const{data:e,width:r,height:h,scale:l}=t,u=[r*h];for(let t=0;t<u.length;t++)u[t]=!1;const n=new Float32Array(e.length);for(let t=0;t<r;t++)n[t]=-1,n[r*(h-1)+t]=-1;for(let t=0;t<h;t++)n[t*r]=-1,n[t*r+r-1]=-1;for(let t=1;t<r-1;t++)for(let a=1;a<h-1;a++){let i=t+r*a,s=0,o=0;for(let t=-1;t<=1;t++)s+=e[i+r*t+1]-e[i+r*t-1],o+=e[i+r+t]-e[i-r+t];s/=768,o/=768,n[i]=Math.sqrt((s*s+o*o)/2)}const m=new Uint32Array(1e3);for(let t=0;t<1e3;t++)m[t]=0;const c=[-1,1,-r,r];let f=0;for(let t=1;t<r-1;t++)for(let e=1;e<h-1;e++){let a=t+r*e,i=!0;for(let t=0;t<c.length;t++)if(n[a]<=n[a+c[t]]){i=!1;break}if(i){let t=Math.floor(1e3*n[a]);t>999&&(t=999),t<0&&(t=0),m[t]+=1,f+=1,u[a]=!0}}const g=.02*r*h;let d=999,p=0;for(;d>=0&&(p+=m[d],!(p>g));)d--;for(let t=0;t<u.length;t++)u[t]&&1e3*n[t]<d&&(u[t]=!1);const w=[];for(let t=0;t<e.length;t++)w[t]=e[t]*e[t];const M=new a(e,r,h),y=new a(w,r,h),x=new Float32Array(e.length);for(let e=0;e<r;e++)for(let a=0;a<h;a++){const i=a*r+e;if(!u[i]){x[i]=1;continue}const h=s({image:t,cx:e,cy:a,sdThresh:5,imageDataCumsum:M,imageDataSqrCumsum:y});if(null===h){x[i]=1;continue}let l=-1;for(let r=-10;r<=10;r++){for(let i=-10;i<=10;i++){if(i*i+r*r<=4)continue;const s=o({image:t,cx:e+i,cy:a+r,vlen:h,tx:e,ty:a,imageDataCumsum:M,imageDataSqrCumsum:y});if(null!==s&&(s>l&&(l=s,l>.95)))break}if(l>.95)break}x[i]=l}return i({image:t,featureMap:x,templateSize:6,searchSize:2,occSize:16,maxSimThresh:.9,minSimThresh:.2,sdThresh:8,imageDataCumsum:M,imageDataSqrCumsum:y})}}},115:t=>{t.exports={Cumsum:class{constructor(t,e,r){this.cumsum=[];for(let t=0;t<r;t++){this.cumsum.push([]);for(let r=0;r<e;r++)this.cumsum[t].push(0)}this.cumsum[0][0]=t[0];for(let r=1;r<e;r++)this.cumsum[0][r]=this.cumsum[0][r-1]+t[r];for(let a=1;a<r;a++)this.cumsum[a][0]=this.cumsum[a-1][0]+t[a*e];for(let a=1;a<r;a++)for(let r=1;r<e;r++)this.cumsum[a][r]=t[a*e+r]+this.cumsum[a-1][r]+this.cumsum[a][r-1]-this.cumsum[a-1][r-1]}query(t,e,r,a){let i=this.cumsum[a][r];return e>0&&(i-=this.cumsum[e-1][r]),t>0&&(i-=this.cumsum[a][t-1]),t>0&&e>0&&(i+=this.cumsum[e-1][t-1]),i}}}},45:t=>{t.exports={downsampleBilinear:({image:t})=>{const{data:e,width:r,height:a}=t,i=Math.floor(r/2),s=Math.floor(a/2),o=new Float32Array(i*s),h=[0,1,r,r+1];for(let t=0;t<s;t++)for(let a=0;a<i;a++){let s=2*t*r+2*a,l=0;for(let t=0;t<h.length;t++)l+=e[s+h[t]];l*=.25,o[t*i+a]=l}return{data:o,width:i,height:s}},upsampleBilinear:({image:t,padOneWidth:e,padOneHeight:r})=>{const{width:a,height:i,data:s}=t,o=2*t.width+(e?1:0),h=2*t.height+(r?1:0),l=new Float32Array(o*h);for(let t=0;t<o;t++){const e=.5*t-.25;let r=Math.floor(e),u=Math.ceil(e);r<0&&(r=0),u>=a&&(u=a-1);for(let n=0;n<h;n++){const h=.5*n-.25;let m=Math.floor(h),c=Math.ceil(h);m<0&&(m=0),c>=i&&(c=i-1);const f=(u-e)*(c-h)*s[m*a+r]+(u-e)*(h-m)*s[c*a+r]+(e-r)*(c-h)*s[m*a+u]+(e-r)*(h-m)*s[c*a+u];l[n*o+t]=f}}return{data:l,width:o,height:h}},resize:({image:t,ratio:e})=>{const r=Math.round(t.width*e),a=Math.round(t.height*e),i=new Uint8Array(r*a);for(let s=0;s<r;s++){let o=Math.round(1*s/e),h=Math.round(1*(s+1)/e)-1;h>=t.width&&(h=t.width-1);for(let l=0;l<a;l++){let a=Math.round(1*l/e),u=Math.round(1*(l+1)/e)-1;u>=t.height&&(u=t.height-1);let n=0,m=0;for(let e=o;e<=h;e++)for(let r=a;r<=u;r++)n+=1*t.data[r*t.width+e],m+=1;i[l*r+s]=Math.floor(n/m)}}return{data:i,width:r,height:a}}}}},e={};function r(a){var i=e[a];if(void 0!==i)return i.exports;var s=e[a]={exports:{}};return t[a](s,s.exports,r),s.exports}(()=>{const{extract:t}=r(111),{buildTrackingImageList:e}=r(646);onmessage=t=>{const{data:r}=t;if("compile"===r.type){const{targetImages:t}=r,i=50/t.length;let s=0;const o=[];for(let r=0;r<t.length;r++){const h=t[r],l=e(h),u=i/l.length,n=a(l,(t=>{s+=u,postMessage({type:"progress",percent:s})}));o.push(n)}postMessage({type:"compileDone",list:o})}};const a=(e,r)=>{const a=[];for(let i=0;i<e.length;i++){const s=e[i],o=t(s),h={data:s.data,scale:s.scale,width:s.width,height:s.height,points:o};a.push(h),r(i)}return a}})()})();',"Worker",void 0,I.p+"compiler.worker.js")}},246:(A,g,I)=>{var t=I(477);A.exports=function(){return t('(()=>{var t={91:(t,e,r)=>{"use strict";r.r(e),r.d(e,{isAnyArray:()=>o});const s=Object.prototype.toString;function o(t){const e=s.call(t);return e.endsWith("Array]")&&!e.includes("Big")}},805:(t,e,r)=>{"use strict";r.r(e),r.d(e,{default:()=>o});var s=r(91);function o(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(0,s.isAnyArray)(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!(0,s.isAnyArray)(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var o=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(0,s.isAnyArray)(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,o=void 0===r?0:r,n=e.toIndex,i=void 0===n?t.length:n;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=o||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[o],l=o+1;l<i;l++)t[l]<h&&(h=t[l]);return h}(t),n=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(0,s.isAnyArray)(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,o=void 0===r?0:r,n=e.toIndex,i=void 0===n?t.length:n;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=o||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[o],l=o+1;l<i;l++)t[l]>h&&(h=t[l]);return h}(t);if(o===n)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var i=r.min,h=void 0===i?r.autoMinMax?o:0:i,l=r.max,u=void 0===l?r.autoMinMax?n:1:l;if(h>=u)throw new RangeError("min option must be smaller than max option");for(var a=(u-h)/(n-o),c=0;c<t.length;c++)e[c]=(t[c]-o)*a+h;return e}},406:(t,e,r)=>{"use strict";var s=r(91),o=r(805);const n=" ".repeat(2),i=" ".repeat(4);function h(t,e={}){const{maxRows:r=15,maxColumns:s=10,maxNumSize:o=8,padMinus:h="auto"}=e;return`${t.constructor.name} {\\n${n}[\\n${i}${function(t,e,r,s,o){const{rows:n,columns:h}=t,u=Math.min(n,e),a=Math.min(h,r),c=[];if("auto"===o){o=!1;t:for(let e=0;e<u;e++)for(let r=0;r<a;r++)if(t.get(e,r)<0){o=!0;break t}}for(let e=0;e<u;e++){let r=[];for(let n=0;n<a;n++)r.push(l(t.get(e,n),s,o));c.push(`${r.join(" ")}`)}a!==h&&(c[c.length-1]+=` ... ${h-r} more columns`);u!==n&&c.push(`... ${n-e} more rows`);return c.join(`\\n${i}`)}(t,r,s,o,h)}\\n${n}]\\n${n}rows: ${t.rows}\\n${n}columns: ${t.columns}\\n}`}function l(t,e,r){return(t>=0&&r?` ${u(t,e-1)}`:u(t,e)).padEnd(e)}function u(t,e){let r=t.toString();if(r.length<=e)return r;let s=t.toFixed(e);if(s.length>e&&(s=t.toFixed(Math.max(0,e-(s.length-e)))),s.length<=e&&!s.startsWith("0.000")&&!s.startsWith("-0.000"))return s;let o=t.toExponential(e);return o.length>e&&(o=t.toExponential(Math.max(0,e-(o.length-e)))),o.slice(0)}function a(t,e,r){let s=r?t.rows:t.rows-1;if(e<0||e>s)throw new RangeError("Row index out of range")}function c(t,e,r){let s=r?t.columns:t.columns-1;if(e<0||e>s)throw new RangeError("Column index out of range")}function f(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function m(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function g(t,e){if(!s.isAnyArray(e))throw new TypeError("row indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.rows)throw new RangeError("row indices are out of range")}function w(t,e){if(!s.isAnyArray(e))throw new TypeError("column indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.columns)throw new RangeError("column indices are out of range")}function p(t,e,r,s,o){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(y("startRow",e),y("endRow",r),y("startColumn",s),y("endColumn",o),e>r||s>o||e<0||e>=t.rows||r<0||r>=t.rows||s<0||s>=t.columns||o<0||o>=t.columns)throw new RangeError("Submatrix indices are out of range")}function d(t,e=0){let r=[];for(let s=0;s<t;s++)r.push(e);return r}function y(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function M(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}class b{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let s=new E(t,e);for(let o=0;o<t;o++)for(let t=0;t<e;t++)s.set(o,t,r[o*e+t]);return s}static rowVector(t){let e=new E(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new E(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new E(t,e)}static ones(t,e){return new E(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:s=Math.random}=r;let o=new E(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)o.set(r,t,s());return o}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:s=0,max:o=1e3,random:n=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(s>=o)throw new RangeError("min must be smaller than max");let i=o-s,h=new E(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=s+Math.round(n()*i);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let s=Math.min(t,e),o=this.zeros(t,e);for(let t=0;t<s;t++)o.set(t,t,r);return o}static diag(t,e,r){let s=t.length;void 0===e&&(e=s),void 0===r&&(r=e);let o=Math.min(s,e,r),n=this.zeros(e,r);for(let e=0;e<o;e++)n.set(e,e,t[e]);return n}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new E(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.min(t.get(n,r),e.get(n,r)));return o}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new this(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.max(t.get(n,r),e.get(n,r)));return o}static checkMatrix(t){return b.isMatrix(t)?t:new E(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);t++}return s}isReducedEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(s=!1);t++}return s}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let s=e;for(let o=e;o<t.rows;o++)t.get(o,r)>t.get(s,r)&&(s=o);if(0===t.get(s,r))r++;else{t.swapRows(e,s);let o=t.get(e,r);for(let s=r;s<t.columns;s++)t.set(e,s,t.get(e,s)/o);for(let s=e+1;s<t.rows;s++){let o=t.get(s,r)/t.get(e,r);t.set(s,r,0);for(let n=r+1;n<t.columns;n++)t.set(s,n,t.get(s,n)-t.get(e,n)*o)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,s=r-1;for(;s>=0;)if(0===t.maxRow(s))s--;else{let o=0,n=!1;for(;o<r&&!1===n;)1===t.get(s,o)?n=!0:o++;for(let r=0;r<s;r++){let n=t.get(r,o);for(let i=o;i<e;i++){let e=t.get(r,i)-n*t.get(s,i);t.set(r,i,e)}}s--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new E(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)s.setSubMatrix(this,this.rows*t,this.columns*e);return s}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){a(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return E.rowVector(this.getRow(t))}setRow(t,e){a(this,t),e=f(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){a(this,t),a(this,e);for(let r=0;r<this.columns;r++){let s=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,s)}return this}getColumn(t){c(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return E.columnVector(this.getColumn(t))}setColumn(t,e){c(this,t),e=m(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){c(this,t),c(this,e);for(let r=0;r<this.rows;r++){let s=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,s)}return this}addRowVector(t){t=f(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=f(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=f(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=f(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=m(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=m(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=m(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=m(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){a(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){c(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){M(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}minIndex(){M(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}maxRow(t){if(a(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){a(this,t),M(this);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s),r[1]=s);return r}minRow(t){if(a(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){a(this,t),M(this);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s),r[1]=s);return r}maxColumn(t){if(c(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){c(this,t),M(this);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)>e&&(e=this.get(s,t),r[0]=s);return r}minColumn(t){if(c(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){c(this,t),M(this);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)<e&&(e=this.get(s,t),r[0]=s);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){switch(t){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${t}`)}}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){b.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<e.length;s++)r+=e[s]*t[s];return r}mmul(t){t=E.checkMatrix(t);let e=this.rows,r=this.columns,s=t.columns,o=new E(e,s),n=new Float64Array(r);for(let i=0;i<s;i++){for(let e=0;e<r;e++)n[e]=t.get(e,i);for(let t=0;t<e;t++){let e=0;for(let s=0;s<r;s++)e+=this.get(t,s)*n[s];o.set(t,i,e)}}return o}strassen2x2(t){t=E.checkMatrix(t);let e=new E(2,2);const r=this.get(0,0),s=t.get(0,0),o=this.get(0,1),n=t.get(0,1),i=this.get(1,0),h=t.get(1,0),l=this.get(1,1),u=t.get(1,1),a=(r+l)*(s+u),c=(i+l)*s,f=r*(n-u),m=l*(h-s),g=(r+o)*u,w=a+m-g+(o-l)*(h+u),p=f+g,d=c+m,y=a-c+f+(i-r)*(s+n);return e.set(0,0,w),e.set(0,1,p),e.set(1,0,d),e.set(1,1,y),e}strassen3x3(t){t=E.checkMatrix(t);let e=new E(3,3);const r=this.get(0,0),s=this.get(0,1),o=this.get(0,2),n=this.get(1,0),i=this.get(1,1),h=this.get(1,2),l=this.get(2,0),u=this.get(2,1),a=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),w=t.get(1,1),p=t.get(1,2),d=t.get(2,0),y=t.get(2,1),M=t.get(2,2),b=(r-n)*(-f+w),x=(-r+n+i)*(c-f+w),v=(n+i)*(-c+f),S=r*c,k=(-r+l+u)*(c-m+p),I=(-r+l)*(m-p),R=(l+u)*(-c+m),A=(-o+u+a)*(w+d-y),T=(o-a)*(w-y),q=o*d,C=(u+a)*(-d+y),N=(-o+i+h)*(p+d-M),P=(o-h)*(p-M),V=(i+h)*(-d+M),j=S+q+s*g,F=(r+s+o-n-i-u-a)*w+x+v+S+A+q+C,z=S+k+R+(r+s+o-i-h-l-u)*p+q+N+V,D=b+i*(-c+f+g-w-p-d+M)+x+S+q+N+P,_=b+x+v+S+h*y,H=q+N+P+V+n*m,$=S+k+I+u*(-c+m+g-w-p-d+y)+A+T+q,L=A+T+q+C+l*f,O=S+k+I+R+a*M;return e.set(0,0,j),e.set(0,1,F),e.set(0,2,z),e.set(1,0,D),e.set(1,1,_),e.set(1,2,H),e.set(2,0,$),e.set(2,1,L),e.set(2,2,O),e}mmulStrassen(t){t=E.checkMatrix(t);let e=this.clone(),r=e.rows,s=e.columns,o=t.rows,n=t.columns;function i(t,e,r){let s=t.rows,o=t.columns;if(s===e&&o===r)return t;{let s=b.zeros(e,r);return s=s.setSubMatrix(t,0,0),s}}s!==o&&console.warn(`Multiplying ${r} x ${s} and ${o} x ${n} matrix: dimensions do not match.`);let h=Math.max(r,o),l=Math.max(s,n);return e=i(e,h,l),function t(e,r,s,o){if(s<=512||o<=512)return e.mmul(r);s%2==1&&o%2==1?(e=i(e,s+1,o+1),r=i(r,s+1,o+1)):s%2==1?(e=i(e,s+1,o),r=i(r,s+1,o)):o%2==1&&(e=i(e,s,o+1),r=i(r,s,o+1));let n=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),l=e.subMatrix(0,n-1,0,h-1),u=r.subMatrix(0,n-1,0,h-1),a=e.subMatrix(0,n-1,h,e.columns-1),c=r.subMatrix(0,n-1,h,r.columns-1),f=e.subMatrix(n,e.rows-1,0,h-1),m=r.subMatrix(n,r.rows-1,0,h-1),g=e.subMatrix(n,e.rows-1,h,e.columns-1),w=r.subMatrix(n,r.rows-1,h,r.columns-1),p=t(b.add(l,g),b.add(u,w),n,h),d=t(b.add(f,g),u,n,h),y=t(l,b.sub(c,w),n,h),M=t(g,b.sub(m,u),n,h),x=t(b.add(l,a),w,n,h),E=t(b.sub(f,l),b.add(u,c),n,h),v=t(b.sub(a,g),b.add(m,w),n,h),S=b.add(p,M);S.sub(x),S.add(v);let k=b.add(y,x),I=b.add(d,M),R=b.sub(p,d);R.add(y),R.add(E);let A=b.zeros(2*S.rows,2*S.columns);return A=A.setSubMatrix(S,0,0),A=A.setSubMatrix(k,S.rows,0),A=A.setSubMatrix(I,0,S.columns),A=A.setSubMatrix(R,S.rows,S.columns),A.subMatrix(0,s-1,0,o-1)}(e,t=i(t,h,l),h,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new E(this.rows,this.columns);for(let t=0;t<this.rows;t++){const n=this.getRow(t);n.length>0&&o(n,{min:e,max:r,output:n}),s.setRow(t,n)}return s}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new E(this.rows,this.columns);for(let t=0;t<this.columns;t++){const n=this.getColumn(t);n.length&&o(n,{min:e,max:r,output:n}),s.setColumn(t,n)}return s}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),s=this.get(e,this.columns-1-r);this.set(e,r,s),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),s=this.get(this.rows-1-r,e);this.set(r,e,s),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=E.checkMatrix(t);let e=this.rows,r=this.columns,s=t.rows,o=t.columns,n=new E(e*s,r*o);for(let i=0;i<e;i++)for(let e=0;e<r;e++)for(let r=0;r<s;r++)for(let h=0;h<o;h++)n.set(s*i+r,o*e+h,this.get(i,e)*t.get(r,h));return n}kroneckerSum(t){if(t=E.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,r=t.rows,s=this.kroneckerProduct(E.eye(r,r)),o=E.eye(e,e).kroneckerProduct(t);return s.add(o)}transpose(){let t=new E(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=x){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=x){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,s){p(this,t,e,r,s);let o=new E(e-t+1,s-r+1);for(let n=t;n<=e;n++)for(let e=r;e<=s;e++)o.set(n-t,e-r,this.get(n,e));return o}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new E(t.length,r-e+1);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.rows)throw new RangeError(`Row index out of range: ${t[o]}`);s.set(o,n-e,this.get(t[o],n))}return s}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new E(r-e+1,t.length);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.columns)throw new RangeError(`Column index out of range: ${t[o]}`);s.set(n-e,o,this.get(n,t[o]))}return s}setSubMatrix(t,e,r){if((t=E.checkMatrix(t)).isEmpty())return this;p(this,e,e+t.rows-1,r,r+t.columns-1);for(let s=0;s<t.rows;s++)for(let o=0;o<t.columns;o++)this.set(e+s,r+o,t.get(s,o));return this}selection(t,e){g(this,t),w(this,e);let r=new E(t.length,e.length);for(let s=0;s<t.length;s++){let o=t[s];for(let t=0;t<e.length;t++){let n=e[t];r.set(s,t,this.get(o,n))}}return r}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new E(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=d(t.rows);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]+=t.get(r,s);return e}(this);case"column":return function(t){let e=d(t.columns);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]+=t.get(r,s);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e+=t.get(r,s);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=d(t.rows,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]*=t.get(r,s);return e}(this);case"column":return function(t){let e=d(t.columns,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]*=t.get(r,s);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e*=t.get(r,s);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:o=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!s.isAnyArray(o))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<s;i++){let s=0,h=0,l=0;for(let e=0;e<o;e++)l=t.get(i,e)-r[i],s+=l,h+=l*l;e?n.push((h-s*s/o)/(o-1)):n.push((h-s*s/o)/o)}return n}(this,r,o);case"column":if(!s.isAnyArray(o))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<o;i++){let o=0,h=0,l=0;for(let e=0;e<s;e++)l=t.get(e,i)-r[i],o+=l,h+=l*l;e?n.push((h-o*o/s)/(s-1)):n.push((h-o*o/s)/s)}return n}(this,r,o);case void 0:if("number"!=typeof o)throw new TypeError("mean must be a number");return function(t,e,r){const s=t.rows,o=t.columns,n=s*o;let i=0,h=0,l=0;for(let e=0;e<s;e++)for(let s=0;s<o;s++)l=t.get(e,s)-r,i+=l,h+=l*l;return e?(h-i*i/n)/(n-1):(h-i*i/n)/n}(this,r,o);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!s.isAnyArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[r])}(this,r),this;case"column":if(!s.isAnyArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[s])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let s=0;for(let e=0;e<t.columns;e++)s+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(s))}return e}(this);else if(!s.isAnyArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let s=0;for(let e=0;e<t.rows;e++)s+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(s))}return e}(this);else if(!s.isAnyArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[s])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let s=0;s<t.columns;s++)for(let o=0;o<t.rows;o++)r+=Math.pow(t.get(o,s),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return h(this,t)}}function x(t,e){return t-e}b.prototype.klass="Matrix","undefined"!=typeof Symbol&&(b.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return h(this)}),b.random=b.rand,b.randomInt=b.randInt,b.diagonal=b.diag,b.prototype.diagonal=b.prototype.diag,b.identity=b.eye,b.prototype.negate=b.prototype.neg,b.prototype.tensorProduct=b.prototype.kroneckerProduct;class E extends b{constructor(t,e){if(super(),E.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!s.isAnyArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if("number"!=typeof(e=(t=r.length)?r[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<t;s++){if(r[s].length!==e)throw new RangeError("Inconsistent array dimensions");if(!r[s].every((t=>"number"==typeof t)))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(r[s]))}}}this.rows=t,this.columns=e}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){return a(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),a(this,t,!0),e=Float64Array.from(f(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){c(this,t);for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let s=0;s<t;s++)r[s]=this.data[e][s];for(let s=t+1;s<this.columns;s++)r[s-1]=this.data[e][s];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),c(this,t,!0),e=m(this,e);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let o=0;for(;o<t;o++)s[o]=this.data[r][o];for(s[o++]=e[r];o<this.columns+1;o++)s[o]=this.data[r][o-1];this.data[r]=s}return this.columns+=1,this}}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}(b,E);class v extends b{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class S extends v{constructor(t,e,r){g(t,e),w(t,r),super(t,e.length,r.length),this.rowIndices=e,this.columnIndices=r}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class k extends b{constructor(t,e={}){const{rows:r=1}=e;if(t.length%r!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){let s=this._calculateIndex(t,e);return this.data[s]=r,this}get(t,e){let r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class I extends b{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}class R{constructor(t){let e,r,s,o,n,i,h,l,u,a=(t=I.checkMatrix(t)).clone(),c=a.rows,f=a.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(l=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)l[e]=a.get(e,r);for(e=0;e<c;e++){for(u=Math.min(e,r),n=0,s=0;s<u;s++)n+=a.get(e,s)*l[s];l[e]-=n,a.set(e,r,l[e])}for(o=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[o])&&(o=e);if(o!==r){for(s=0;s<f;s++)i=a.get(o,s),a.set(o,s,a.get(r,s)),a.set(r,s,i);h=m[o],m[o]=m[r],m[r]=h,g=-g}if(r<c&&0!==a.get(r,r))for(e=r+1;e<c;e++)a.set(e,r,a.get(e,r)/a.get(r,r))}this.LU=a,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=E.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,s,o,n=t.columns,i=t.subMatrixRow(this.pivotVector,0,n-1),h=e.columns;for(o=0;o<h;o++)for(r=o+1;r<h;r++)for(s=0;s<n;s++)i.set(r,s,i.get(r,s)-i.get(o,s)*e.get(r,o));for(o=h-1;o>=0;o--){for(s=0;s<n;s++)i.set(o,s,i.get(o,s)/e.get(o,o));for(r=0;r<o;r++)for(s=0;s<n;s++)i.set(r,s,i.get(r,s)-i.get(o,s)*e.get(r,o))}return i}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let s=0;s<r;s++)e*=t.get(s,s);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new E(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o>e?s.set(o,e,t.get(o,e)):o===e?s.set(o,e,1):s.set(o,e,0);return s}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new E(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o<=e?s.set(o,e,t.get(o,e)):s.set(o,e,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function A(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class T{constructor(t){let e,r,s,o,n=(t=I.checkMatrix(t)).clone(),i=t.rows,h=t.columns,l=new Float64Array(h);for(s=0;s<h;s++){let t=0;for(e=s;e<i;e++)t=A(t,n.get(e,s));if(0!==t){for(n.get(s,s)<0&&(t=-t),e=s;e<i;e++)n.set(e,s,n.get(e,s)/t);for(n.set(s,s,n.get(s,s)+1),r=s+1;r<h;r++){for(o=0,e=s;e<i;e++)o+=n.get(e,s)*n.get(e,r);for(o=-o/n.get(s,s),e=s;e<i;e++)n.set(e,r,n.get(e,r)+o*n.get(e,s))}}l[s]=-t}this.QR=n,this.Rdiag=l}solve(t){t=E.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s,o,n,i,h=t.columns,l=t.clone(),u=e.columns;for(n=0;n<u;n++)for(o=0;o<h;o++){for(i=0,s=n;s<r;s++)i+=e.get(s,n)*l.get(s,o);for(i=-i/e.get(n,n),s=n;s<r;s++)l.set(s,o,l.get(s,o)+i*e.get(s,n))}for(n=u-1;n>=0;n--){for(o=0;o<h;o++)l.set(n,o,l.get(n,o)/this.Rdiag[n]);for(s=0;s<n;s++)for(o=0;o<h;o++)l.set(s,o,l.get(s,o)-l.get(n,o)*e.get(s,n))}return l.subMatrix(0,u-1,0,h-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,s=r.columns,o=new E(s,s);for(t=0;t<s;t++)for(e=0;e<s;e++)t<e?o.set(t,e,r.get(t,e)):t===e?o.set(t,e,this.Rdiag[t]):o.set(t,e,0);return o}get orthogonalMatrix(){let t,e,r,s,o=this.QR,n=o.rows,i=o.columns,h=new E(n,i);for(r=i-1;r>=0;r--){for(t=0;t<n;t++)h.set(t,r,0);for(h.set(r,r,1),e=r;e<i;e++)if(0!==o.get(r,r)){for(s=0,t=r;t<n;t++)s+=o.get(t,r)*h.get(t,e);for(s=-s/o.get(r,r),t=r;t<n;t++)h.set(t,e,h.get(t,e)+s*o.get(t,r))}}return h}}class q{constructor(t,e={}){if((t=I.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,s=t.columns;const{computeLeftSingularVectors:o=!0,computeRightSingularVectors:n=!0,autoTranspose:i=!1}=e;let h,l=Boolean(o),u=Boolean(n),a=!1;if(r<s)if(i){h=t.transpose(),r=h.rows,s=h.columns,a=!0;let e=l;l=u,u=e}else h=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else h=t.clone();let c=Math.min(r,s),f=Math.min(r+1,s),m=new Float64Array(f),g=new E(r,c),w=new E(s,s),p=new Float64Array(s),d=new Float64Array(r),y=new Float64Array(f);for(let t=0;t<f;t++)y[t]=t;let M=Math.min(r-1,s),b=Math.max(0,Math.min(s-2,r)),x=Math.max(M,b);for(let t=0;t<x;t++){if(t<M){m[t]=0;for(let e=t;e<r;e++)m[t]=A(m[t],h.get(e,t));if(0!==m[t]){h.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)h.set(e,t,h.get(e,t)/m[t]);h.set(t,t,h.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<s;e++){if(t<M&&0!==m[t]){let s=0;for(let o=t;o<r;o++)s+=h.get(o,t)*h.get(o,e);s=-s/h.get(t,t);for(let o=t;o<r;o++)h.set(o,e,h.get(o,e)+s*h.get(o,t))}p[e]=h.get(t,e)}if(l&&t<M)for(let e=t;e<r;e++)g.set(e,t,h.get(e,t));if(t<b){p[t]=0;for(let e=t+1;e<s;e++)p[t]=A(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<s;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)d[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<s;r++)d[e]+=p[r]*h.get(e,r);for(let e=t+1;e<s;e++){let s=-p[e]/p[t+1];for(let o=t+1;o<r;o++)h.set(o,e,h.get(o,e)+s*d[o])}}if(u)for(let e=t+1;e<s;e++)w.set(e,t,p[e])}}let v=Math.min(s,r+1);if(M<s&&(m[M]=h.get(M,M)),r<v&&(m[v-1]=0),b+1<v&&(p[b]=h.get(b,v-1)),p[v-1]=0,l){for(let t=M;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=M-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let s=0;for(let o=t;o<r;o++)s+=g.get(o,t)*g.get(o,e);s=-s/g.get(t,t);for(let o=t;o<r;o++)g.set(o,e,g.get(o,e)+s*g.get(o,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(u)for(let t=s-1;t>=0;t--){if(t<b&&0!==p[t])for(let e=t+1;e<s;e++){let r=0;for(let o=t+1;o<s;o++)r+=w.get(o,t)*w.get(o,e);r=-r/w.get(t+1,t);for(let o=t+1;o<s;o++)w.set(o,e,w.get(o,e)+r*w.get(o,t))}for(let e=0;e<s;e++)w.set(e,t,0);w.set(t,t,1)}let S=v-1,k=Number.EPSILON;for(;v>0;){let t,e;for(t=v-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+k*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===v-2)e=4;else{let r;for(r=v-1;r>=t&&r!==t;r--){let e=(r!==v?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=k*e){m[r]=0;break}}r===t?e=3:r===v-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[v-2];p[v-2]=0;for(let r=v-2;r>=t;r--){let o=A(m[r],e),n=m[r]/o,i=e/o;if(m[r]=o,r!==t&&(e=-i*p[r-1],p[r-1]=n*p[r-1]),u)for(let t=0;t<s;t++)o=n*w.get(t,r)+i*w.get(t,v-1),w.set(t,v-1,-i*w.get(t,r)+n*w.get(t,v-1)),w.set(t,r,o)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let s=t;s<v;s++){let o=A(m[s],e),n=m[s]/o,i=e/o;if(m[s]=o,e=-i*p[s],p[s]=n*p[s],l)for(let e=0;e<r;e++)o=n*g.get(e,s)+i*g.get(e,t-1),g.set(e,t-1,-i*g.get(e,s)+n*g.get(e,t-1)),g.set(e,s,o)}break}case 3:{const e=Math.max(Math.abs(m[v-1]),Math.abs(m[v-2]),Math.abs(p[v-2]),Math.abs(m[t]),Math.abs(p[t])),o=m[v-1]/e,n=m[v-2]/e,i=p[v-2]/e,h=m[t]/e,a=p[t]/e,c=((n+o)*(n-o)+i*i)/2,f=o*i*(o*i);let d=0;0===c&&0===f||(d=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f),d=f/(c+d));let y=(h+o)*(h-o)+d,M=h*a;for(let e=t;e<v-1;e++){let o=A(y,M);0===o&&(o=Number.MIN_VALUE);let n=y/o,i=M/o;if(e!==t&&(p[e-1]=o),y=n*m[e]+i*p[e],p[e]=n*p[e]-i*m[e],M=i*m[e+1],m[e+1]=n*m[e+1],u)for(let t=0;t<s;t++)o=n*w.get(t,e)+i*w.get(t,e+1),w.set(t,e+1,-i*w.get(t,e)+n*w.get(t,e+1)),w.set(t,e,o);if(o=A(y,M),0===o&&(o=Number.MIN_VALUE),n=y/o,i=M/o,m[e]=o,y=n*p[e]+i*m[e+1],m[e+1]=-i*p[e]+n*m[e+1],M=i*p[e+1],p[e+1]=n*p[e+1],l&&e<r-1)for(let t=0;t<r;t++)o=n*g.get(t,e)+i*g.get(t,e+1),g.set(t,e+1,-i*g.get(t,e)+n*g.get(t,e+1)),g.set(t,e,o)}p[v-2]=y;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,u))for(let e=0;e<=S;e++)w.set(e,t,-w.get(e,t));for(;t<S&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,u&&t<s-1)for(let r=0;r<s;r++)e=w.get(r,t+1),w.set(r,t+1,w.get(r,t)),w.set(r,t,e);if(l&&t<r-1)for(let s=0;s<r;s++)e=g.get(s,t+1),g.set(s,t+1,g.get(s,t)),g.set(s,t,e);t++}v--}}if(a){let t=w;w=g,g=t}this.m=r,this.n=s,this.s=m,this.U=g,this.V=w}solve(t){let e=t,r=this.threshold,s=this.s.length,o=E.zeros(s,s);for(let t=0;t<s;t++)Math.abs(this.s[t])<=r?o.set(t,t,0):o.set(t,t,1/this.s[t]);let n=this.U,i=this.rightSingularVectors,h=i.mmul(o),l=i.rows,u=n.rows,a=E.zeros(l,u);for(let t=0;t<l;t++)for(let e=0;e<u;e++){let r=0;for(let o=0;o<s;o++)r+=h.get(t,o)*n.get(e,o);a.set(t,e,r)}return a.mmul(e)}solveForDiagonal(t){return this.solve(E.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,s=t.columns,o=new E(r,this.s.length);for(let n=0;n<r;n++)for(let r=0;r<s;r++)Math.abs(this.s[r])>e&&o.set(n,r,t.get(n,r)/this.s[r]);let n=this.U,i=n.rows,h=n.columns,l=new E(r,i);for(let t=0;t<r;t++)for(let e=0;e<i;e++){let r=0;for(let s=0;s<h;s++)r+=o.get(t,s)*n.get(e,s);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let s=0,o=r.length;s<o;s++)r[s]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return E.diag(this.s)}}function C(t,e,r=!1){return t=I.checkMatrix(t),e=I.checkMatrix(e),r?new q(t).solve(e):t.isSquare()?new R(t).solve(e):new T(t).solve(e)}function N(t,e){let r=[];for(let s=0;s<t;s++)s!==e&&r.push(s);return r}function P(t,e,r,s=1e-9,o=1e-9){if(t>o)return new Array(e.rows+1).fill(0);{let t=e.addRow(r,[0]);for(let e=0;e<t.rows;e++)Math.abs(t.get(e,0))<s&&t.set(e,0,0);return t.to1DArray()}}class V{constructor(t,e={}){const{assumeSymmetric:r=!1}=e;if(!(t=I.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let s,o,n=t.columns,i=new E(n,n),h=new Float64Array(n),l=new Float64Array(n),u=t,a=!1;if(a=!!r||t.isSymmetric(),a){for(s=0;s<n;s++)for(o=0;o<n;o++)i.set(s,o,u.get(s,o));!function(t,e,r,s){let o,n,i,h,l,u,a,c;for(l=0;l<t;l++)r[l]=s.get(t-1,l);for(h=t-1;h>0;h--){for(c=0,i=0,u=0;u<h;u++)c+=Math.abs(r[u]);if(0===c)for(e[h]=r[h-1],l=0;l<h;l++)r[l]=s.get(h-1,l),s.set(h,l,0),s.set(l,h,0);else{for(u=0;u<h;u++)r[u]/=c,i+=r[u]*r[u];for(o=r[h-1],n=Math.sqrt(i),o>0&&(n=-n),e[h]=c*n,i-=o*n,r[h-1]=o-n,l=0;l<h;l++)e[l]=0;for(l=0;l<h;l++){for(o=r[l],s.set(l,h,o),n=e[l]+s.get(l,l)*o,u=l+1;u<=h-1;u++)n+=s.get(u,l)*r[u],e[u]+=s.get(u,l)*o;e[l]=n}for(o=0,l=0;l<h;l++)e[l]/=i,o+=e[l]*r[l];for(a=o/(i+i),l=0;l<h;l++)e[l]-=a*r[l];for(l=0;l<h;l++){for(o=r[l],n=e[l],u=l;u<=h-1;u++)s.set(u,l,s.get(u,l)-(o*e[u]+n*r[u]));r[l]=s.get(h-1,l),s.set(h,l,0)}}r[h]=i}for(h=0;h<t-1;h++){if(s.set(t-1,h,s.get(h,h)),s.set(h,h,1),i=r[h+1],0!==i){for(u=0;u<=h;u++)r[u]=s.get(u,h+1)/i;for(l=0;l<=h;l++){for(n=0,u=0;u<=h;u++)n+=s.get(u,h+1)*s.get(u,l);for(u=0;u<=h;u++)s.set(u,l,s.get(u,l)-n*r[u])}}for(u=0;u<=h;u++)s.set(u,h+1,0)}for(l=0;l<t;l++)r[l]=s.get(t-1,l),s.set(t-1,l,0);s.set(t-1,t-1,1),e[0]=0}(n,l,h,i),function(t,e,r,s){let o,n,i,h,l,u,a,c,f,m,g,w,p,d,y,M;for(i=1;i<t;i++)e[i-1]=e[i];e[t-1]=0;let b=0,x=0,E=Number.EPSILON;for(u=0;u<t;u++){for(x=Math.max(x,Math.abs(r[u])+Math.abs(e[u])),a=u;a<t&&!(Math.abs(e[a])<=E*x);)a++;if(a>u)do{for(o=r[u],c=(r[u+1]-o)/(2*e[u]),f=A(c,1),c<0&&(f=-f),r[u]=e[u]/(c+f),r[u+1]=e[u]*(c+f),m=r[u+1],n=o-r[u],i=u+2;i<t;i++)r[i]-=n;for(b+=n,c=r[a],g=1,w=g,p=g,d=e[u+1],y=0,M=0,i=a-1;i>=u;i--)for(p=w,w=g,M=y,o=g*e[i],n=g*c,f=A(c,e[i]),e[i+1]=y*f,y=e[i]/f,g=c/f,c=g*r[i]-y*o,r[i+1]=n+y*(g*o+y*r[i]),l=0;l<t;l++)n=s.get(l,i+1),s.set(l,i+1,y*s.get(l,i)+g*n),s.set(l,i,g*s.get(l,i)-y*n);c=-y*M*p*d*e[u]/m,e[u]=y*c,r[u]=g*c}while(Math.abs(e[u])>E*x);r[u]=r[u]+b,e[u]=0}for(i=0;i<t-1;i++){for(l=i,c=r[i],h=i+1;h<t;h++)r[h]<c&&(l=h,c=r[h]);if(l!==i)for(r[l]=r[i],r[i]=c,h=0;h<t;h++)c=s.get(h,i),s.set(h,i,s.get(h,l)),s.set(h,l,c)}}(n,l,h,i)}else{let t=new E(n,n),e=new Float64Array(n);for(o=0;o<n;o++)for(s=0;s<n;s++)t.set(s,o,u.get(s,o));!function(t,e,r,s){let o,n,i,h,l,u,a,c=0,f=t-1;for(u=c+1;u<=f-1;u++){for(a=0,h=u;h<=f;h++)a+=Math.abs(e.get(h,u-1));if(0!==a){for(i=0,h=f;h>=u;h--)r[h]=e.get(h,u-1)/a,i+=r[h]*r[h];for(n=Math.sqrt(i),r[u]>0&&(n=-n),i-=r[u]*n,r[u]=r[u]-n,l=u;l<t;l++){for(o=0,h=f;h>=u;h--)o+=r[h]*e.get(h,l);for(o/=i,h=u;h<=f;h++)e.set(h,l,e.get(h,l)-o*r[h])}for(h=0;h<=f;h++){for(o=0,l=f;l>=u;l--)o+=r[l]*e.get(h,l);for(o/=i,l=u;l<=f;l++)e.set(h,l,e.get(h,l)-o*r[l])}r[u]=a*r[u],e.set(u,u-1,a*n)}}for(h=0;h<t;h++)for(l=0;l<t;l++)s.set(h,l,h===l?1:0);for(u=f-1;u>=c+1;u--)if(0!==e.get(u,u-1)){for(h=u+1;h<=f;h++)r[h]=e.get(h,u-1);for(l=u;l<=f;l++){for(n=0,h=u;h<=f;h++)n+=r[h]*s.get(h,l);for(n=n/r[u]/e.get(u,u-1),h=u;h<=f;h++)s.set(h,l,s.get(h,l)+n*r[h])}}}(n,t,e,i),function(t,e,r,s,o){let n,i,h,l,u,a,c,f,m,g,w,p,d,y,M,b=t-1,x=0,E=t-1,v=Number.EPSILON,S=0,k=0,I=0,R=0,A=0,T=0,q=0,C=0;for(n=0;n<t;n++)for((n<x||n>E)&&(r[n]=o.get(n,n),e[n]=0),i=Math.max(n-1,0);i<t;i++)k+=Math.abs(o.get(n,i));for(;b>=x;){for(l=b;l>x&&(T=Math.abs(o.get(l-1,l-1))+Math.abs(o.get(l,l)),0===T&&(T=k),!(Math.abs(o.get(l,l-1))<v*T));)l--;if(l===b)o.set(b,b,o.get(b,b)+S),r[b]=o.get(b,b),e[b]=0,b--,C=0;else if(l===b-1){if(c=o.get(b,b-1)*o.get(b-1,b),I=(o.get(b-1,b-1)-o.get(b,b))/2,R=I*I+c,q=Math.sqrt(Math.abs(R)),o.set(b,b,o.get(b,b)+S),o.set(b-1,b-1,o.get(b-1,b-1)+S),f=o.get(b,b),R>=0){for(q=I>=0?I+q:I-q,r[b-1]=f+q,r[b]=r[b-1],0!==q&&(r[b]=f-c/q),e[b-1]=0,e[b]=0,f=o.get(b,b-1),T=Math.abs(f)+Math.abs(q),I=f/T,R=q/T,A=Math.sqrt(I*I+R*R),I/=A,R/=A,i=b-1;i<t;i++)q=o.get(b-1,i),o.set(b-1,i,R*q+I*o.get(b,i)),o.set(b,i,R*o.get(b,i)-I*q);for(n=0;n<=b;n++)q=o.get(n,b-1),o.set(n,b-1,R*q+I*o.get(n,b)),o.set(n,b,R*o.get(n,b)-I*q);for(n=x;n<=E;n++)q=s.get(n,b-1),s.set(n,b-1,R*q+I*s.get(n,b)),s.set(n,b,R*s.get(n,b)-I*q)}else r[b-1]=f+I,r[b]=f+I,e[b-1]=q,e[b]=-q;b-=2,C=0}else{if(f=o.get(b,b),m=0,c=0,l<b&&(m=o.get(b-1,b-1),c=o.get(b,b-1)*o.get(b-1,b)),10===C){for(S+=f,n=x;n<=b;n++)o.set(n,n,o.get(n,n)-f);T=Math.abs(o.get(b,b-1))+Math.abs(o.get(b-1,b-2)),f=m=.75*T,c=-.4375*T*T}if(30===C&&(T=(m-f)/2,T=T*T+c,T>0)){for(T=Math.sqrt(T),m<f&&(T=-T),T=f-c/((m-f)/2+T),n=x;n<=b;n++)o.set(n,n,o.get(n,n)-T);S+=T,f=m=c=.964}for(C+=1,u=b-2;u>=l&&(q=o.get(u,u),A=f-q,T=m-q,I=(A*T-c)/o.get(u+1,u)+o.get(u,u+1),R=o.get(u+1,u+1)-q-A-T,A=o.get(u+2,u+1),T=Math.abs(I)+Math.abs(R)+Math.abs(A),I/=T,R/=T,A/=T,u!==l)&&!(Math.abs(o.get(u,u-1))*(Math.abs(R)+Math.abs(A))<v*(Math.abs(I)*(Math.abs(o.get(u-1,u-1))+Math.abs(q)+Math.abs(o.get(u+1,u+1)))));)u--;for(n=u+2;n<=b;n++)o.set(n,n-2,0),n>u+2&&o.set(n,n-3,0);for(h=u;h<=b-1&&(y=h!==b-1,h!==u&&(I=o.get(h,h-1),R=o.get(h+1,h-1),A=y?o.get(h+2,h-1):0,f=Math.abs(I)+Math.abs(R)+Math.abs(A),0!==f&&(I/=f,R/=f,A/=f)),0!==f);h++)if(T=Math.sqrt(I*I+R*R+A*A),I<0&&(T=-T),0!==T){for(h!==u?o.set(h,h-1,-T*f):l!==u&&o.set(h,h-1,-o.get(h,h-1)),I+=T,f=I/T,m=R/T,q=A/T,R/=I,A/=I,i=h;i<t;i++)I=o.get(h,i)+R*o.get(h+1,i),y&&(I+=A*o.get(h+2,i),o.set(h+2,i,o.get(h+2,i)-I*q)),o.set(h,i,o.get(h,i)-I*f),o.set(h+1,i,o.get(h+1,i)-I*m);for(n=0;n<=Math.min(b,h+3);n++)I=f*o.get(n,h)+m*o.get(n,h+1),y&&(I+=q*o.get(n,h+2),o.set(n,h+2,o.get(n,h+2)-I*A)),o.set(n,h,o.get(n,h)-I),o.set(n,h+1,o.get(n,h+1)-I*R);for(n=x;n<=E;n++)I=f*s.get(n,h)+m*s.get(n,h+1),y&&(I+=q*s.get(n,h+2),s.set(n,h+2,s.get(n,h+2)-I*A)),s.set(n,h,s.get(n,h)-I),s.set(n,h+1,s.get(n,h+1)-I*R)}}}if(0===k)return;for(b=t-1;b>=0;b--)if(I=r[b],R=e[b],0===R)for(l=b,o.set(b,b,1),n=b-1;n>=0;n--){for(c=o.get(n,n)-I,A=0,i=l;i<=b;i++)A+=o.get(n,i)*o.get(i,b);if(e[n]<0)q=c,T=A;else if(l=n,0===e[n]?o.set(n,b,0!==c?-A/c:-A/(v*k)):(f=o.get(n,n+1),m=o.get(n+1,n),R=(r[n]-I)*(r[n]-I)+e[n]*e[n],a=(f*T-q*A)/R,o.set(n,b,a),o.set(n+1,b,Math.abs(f)>Math.abs(q)?(-A-c*a)/f:(-T-m*a)/q)),a=Math.abs(o.get(n,b)),v*a*a>1)for(i=n;i<=b;i++)o.set(i,b,o.get(i,b)/a)}else if(R<0)for(l=b-1,Math.abs(o.get(b,b-1))>Math.abs(o.get(b-1,b))?(o.set(b-1,b-1,R/o.get(b,b-1)),o.set(b-1,b,-(o.get(b,b)-I)/o.get(b,b-1))):(M=j(0,-o.get(b-1,b),o.get(b-1,b-1)-I,R),o.set(b-1,b-1,M[0]),o.set(b-1,b,M[1])),o.set(b,b-1,0),o.set(b,b,1),n=b-2;n>=0;n--){for(g=0,w=0,i=l;i<=b;i++)g+=o.get(n,i)*o.get(i,b-1),w+=o.get(n,i)*o.get(i,b);if(c=o.get(n,n)-I,e[n]<0)q=c,A=g,T=w;else if(l=n,0===e[n]?(M=j(-g,-w,c,R),o.set(n,b-1,M[0]),o.set(n,b,M[1])):(f=o.get(n,n+1),m=o.get(n+1,n),p=(r[n]-I)*(r[n]-I)+e[n]*e[n]-R*R,d=2*(r[n]-I)*R,0===p&&0===d&&(p=v*k*(Math.abs(c)+Math.abs(R)+Math.abs(f)+Math.abs(m)+Math.abs(q))),M=j(f*A-q*g+R*w,f*T-q*w-R*g,p,d),o.set(n,b-1,M[0]),o.set(n,b,M[1]),Math.abs(f)>Math.abs(q)+Math.abs(R)?(o.set(n+1,b-1,(-g-c*o.get(n,b-1)+R*o.get(n,b))/f),o.set(n+1,b,(-w-c*o.get(n,b)-R*o.get(n,b-1))/f)):(M=j(-A-m*o.get(n,b-1),-T-m*o.get(n,b),q,R),o.set(n+1,b-1,M[0]),o.set(n+1,b,M[1]))),a=Math.max(Math.abs(o.get(n,b-1)),Math.abs(o.get(n,b))),v*a*a>1)for(i=n;i<=b;i++)o.set(i,b-1,o.get(i,b-1)/a),o.set(i,b,o.get(i,b)/a)}for(n=0;n<t;n++)if(n<x||n>E)for(i=n;i<t;i++)s.set(n,i,o.get(n,i));for(i=t-1;i>=x;i--)for(n=x;n<=E;n++){for(q=0,h=x;h<=Math.min(i,E);h++)q+=s.get(n,h)*o.get(h,i);s.set(n,i,q)}}(n,l,h,i,t)}this.n=n,this.e=l,this.d=h,this.V=i}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,r=this.n,s=this.e,o=this.d,n=new E(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)n.set(t,e,0);n.set(t,t,o[t]),s[t]>0?n.set(t,t+1,s[t]):s[t]<0&&n.set(t,t-1,s[t])}return n}}function j(t,e,r,s){let o,n;return Math.abs(r)>Math.abs(s)?(o=s/r,n=r+o*s,[(t+o*e)/n,(e-o*t)/n]):(o=r/s,n=s+o*r,[(o*t+e)/n,(o*e-t)/n])}class F{constructor(t){if(!(t=I.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");let e,r,s,o=t,n=o.rows,i=new E(n,n),h=!0;for(r=0;r<n;r++){let t=0;for(s=0;s<r;s++){let n=0;for(e=0;e<s;e++)n+=i.get(s,e)*i.get(r,e);n=(o.get(r,s)-n)/i.get(s,s),i.set(r,s,n),t+=n*n}for(t=o.get(r,r)-t,h&=t>0,i.set(r,r,Math.sqrt(Math.max(t,0))),s=r+1;s<n;s++)i.set(r,s,0)}this.L=i,this.positiveDefinite=Boolean(h)}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=I.checkMatrix(t);let e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let s,o,n,i=t.columns,h=t.clone();for(n=0;n<r;n++)for(o=0;o<i;o++){for(s=0;s<n;s++)h.set(n,o,h.get(n,o)-h.get(s,o)*e.get(n,s));h.set(n,o,h.get(n,o)/e.get(n,n))}for(n=r-1;n>=0;n--)for(o=0;o<i;o++){for(s=n+1;s<r;s++)h.set(n,o,h.get(n,o)-h.get(s,o)*e.get(s,n));h.set(n,o,h.get(n,o)/e.get(n,n))}return h}get lowerTriangularMatrix(){return this.L}}class z{constructor(t,e={}){t=I.checkMatrix(t);let{Y:r}=e;const{scaleScores:o=!1,maxIterations:n=1e3,terminationCriteria:i=1e-10}=e;let h;if(r){if(r=s.isAnyArray(r)&&"number"==typeof r[0]?E.columnVector(r):I.checkMatrix(r),r.rows!==t.rows)throw new Error("Y should have the same number of rows as X");h=r.getColumnVector(0)}else h=t.getColumnVector(0);let l,u,a,c,f=1;for(let e=0;e<n&&f>i;e++)a=t.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),a=a.div(a.norm()),l=t.mmul(a).div(a.transpose().mmul(a).get(0,0)),e>0&&(f=l.clone().sub(c).pow(2).sum()),c=l.clone(),r?(u=r.transpose().mmul(l).div(l.transpose().mmul(l).get(0,0)),u=u.div(u.norm()),h=r.mmul(u).div(u.transpose().mmul(u).get(0,0))):h=l;if(r){let e=t.transpose().mmul(l).div(l.transpose().mmul(l).get(0,0));e=e.div(e.norm());let s=t.clone().sub(l.clone().mmul(e.transpose())),o=h.transpose().mmul(l).div(l.transpose().mmul(l).get(0,0)),n=r.clone().sub(l.clone().mulS(o.get(0,0)).mmul(u.transpose()));this.t=l,this.p=e.transpose(),this.w=a.transpose(),this.q=u,this.u=h,this.s=l.transpose().mmul(l),this.xResidual=s,this.yResidual=n,this.betas=o}else this.w=a.transpose(),this.s=l.transpose().mmul(l).sqrt(),this.t=o?l.clone().div(this.s.get(0,0)):l,this.xResidual=t.sub(l.mmul(a.transpose()))}}e.AbstractMatrix=b,e.CHO=F,e.CholeskyDecomposition=F,e.EVD=V,e.EigenvalueDecomposition=V,e.LU=R,e.LuDecomposition=R,e.Matrix=E,e.MatrixColumnSelectionView=class extends v{constructor(t,e){w(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}},e.MatrixColumnView=class extends v{constructor(t,e){c(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}},e.MatrixFlipColumnView=class extends v{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}},e.MatrixFlipRowView=class extends v{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}},e.MatrixRowSelectionView=class extends v{constructor(t,e){g(t,e),super(t,e.length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}},e.MatrixRowView=class extends v{constructor(t,e){a(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}},e.MatrixSelectionView=S,e.MatrixSubView=class extends v{constructor(t,e,r,s,o){p(t,e,r,s,o),super(t,r-e+1,o-s+1),this.startRow=e,this.startColumn=s}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}},e.MatrixTransposeView=class extends v{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}},e.NIPALS=z,e.Nipals=z,e.QR=T,e.QrDecomposition=T,e.SVD=q,e.SingularValueDecomposition=q,e.WrapperMatrix1D=k,e.WrapperMatrix2D=I,e.correlation=function(t,e=t,r={}){t=new E(t);let o=!1;if("object"!=typeof e||E.isMatrix(e)||s.isAnyArray(e)?e=new E(e):(r=e,e=t,o=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:n=!0,scale:i=!0}=r;n&&(t.center("column"),o||e.center("column")),i&&(t.scale("column"),o||e.scale("column"));const h=t.standardDeviation("column",{unbiased:!0}),l=o?h:e.standardDeviation("column",{unbiased:!0}),u=t.transpose().mmul(e);for(let e=0;e<u.rows;e++)for(let r=0;r<u.columns;r++)u.set(e,r,u.get(e,r)*(1/(h[e]*l[r]))*(1/(t.rows-1)));return u},e.covariance=function(t,e=t,r={}){t=new E(t);let o=!1;if("object"!=typeof e||E.isMatrix(e)||s.isAnyArray(e)?e=new E(e):(r=e,e=t,o=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:n=!0}=r;n&&(t=t.center("column"),o||(e=e.center("column")));const i=t.transpose().mmul(e);for(let e=0;e<i.rows;e++)for(let r=0;r<i.columns;r++)i.set(e,r,i.get(e,r)*(1/(t.rows-1)));return i},e.default=E,e.determinant=function t(e){if((e=E.checkMatrix(e)).isSquare()){if(0===e.columns)return 1;let r,s,o,n;if(2===e.columns)return r=e.get(0,0),s=e.get(0,1),o=e.get(1,0),n=e.get(1,1),r*n-s*o;if(3===e.columns){let n,i,h;return n=new S(e,[1,2],[1,2]),i=new S(e,[1,2],[0,2]),h=new S(e,[1,2],[0,1]),r=e.get(0,0),s=e.get(0,1),o=e.get(0,2),r*t(n)-s*t(i)+o*t(h)}return new R(e).determinant}throw Error("determinant can only be calculated for a square matrix")},e.inverse=function(t,e=!1){return t=I.checkMatrix(t),e?new q(t).inverse():C(t,E.eye(t.rows))},e.linearDependencies=function(t,e={}){const{thresholdValue:r=1e-9,thresholdError:s=1e-9}=e;let o=(t=E.checkMatrix(t)).rows,n=new E(o,o);for(let e=0;e<o;e++){let i=E.columnVector(t.getRow(e)),h=t.subMatrixRow(N(o,e)).transpose(),l=new q(h).solve(i),u=E.sub(i,h.mmul(l)).abs().max();n.setRow(e,P(u,l,e,r,s))}return n},e.pseudoInverse=function(t,e=Number.EPSILON){if((t=E.checkMatrix(t)).isEmpty())return t.transpose();let r=new q(t,{autoTranspose:!0}),s=r.leftSingularVectors,o=r.rightSingularVectors,n=r.diagonal;for(let t=0;t<n.length;t++)Math.abs(n[t])>e?n[t]=1/n[t]:n[t]=0;return o.mmul(E.diag(n).mmul(s.transpose()))},e.solve=C,e.wrap=function(t,e){if(s.isAnyArray(t))return t[0]&&s.isAnyArray(t[0])?new I(t):new k(t,e);throw new Error("the argument is not an array")}},842:(t,e,r)=>{"use strict";r.d(e,{Z:()=>s});class s{constructor(t=[],e=o){if(this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:r}=this,s=e[t];for(;t>0;){const o=t-1>>1,n=e[o];if(r(s,n)>=0)break;e[t]=n,t=o}e[t]=s}_down(t){const{data:e,compare:r}=this,s=this.length>>1,o=e[t];for(;t<s;){let s=1+(t<<1),n=e[s];const i=s+1;if(i<this.length&&r(e[i],n)<0&&(s=i,n=e[i]),r(n,o)>=0)break;e[t]=n,t=s}e[t]=o}}function o(t,e){return t<e?-1:t>e?1:0}},603:(t,e,r)=>{const{Matrix:s,inverse:o}=r(406),{solveHomography:n}=r(268);t.exports={estimate:({screenCoords:t,worldCoords:e,projectionTransform:r})=>{const i=n(e.map((t=>[t.x,t.y])),t.map((t=>[t.x,t.y]))),h=new s([[i[0],i[1],i[2]],[i[3],i[4],i[5]],[i[6],i[7],i[8]]]),l=new s(r),u=o(l).mmul(h).to1DArray(),a=Math.sqrt(u[0]*u[0]+u[3]*u[3]+u[6]*u[6]),c=Math.sqrt(u[1]*u[1]+u[4]*u[4]+u[7]*u[7]),f=(a+c)/2,m=[];m[0]=u[0]/a,m[3]=u[3]/a,m[6]=u[6]/a,m[1]=u[1]/c,m[4]=u[4]/c,m[7]=u[7]/c,m[2]=m[3]*m[7]-m[6]*m[4],m[5]=m[6]*m[1]-m[0]*m[7],m[8]=m[0]*m[4]-m[1]*m[3];const g=Math.sqrt(m[2]*m[2]+m[5]*m[5]+m[8]*m[8]);m[2]/=g,m[5]/=g,m[8]/=g;const w=[];return w[0]=u[2]/f,w[1]=u[5]/f,w[2]=u[8]/f,[[m[0],m[1],m[2],w[0]],[m[3],m[4],m[5],w[1]],[m[6],m[7],m[8],w[2]]]}}},150:(t,e,r)=>{const{estimate:s}=r(603),{refineEstimate:o}=r(287);t.exports={Estimator:class{constructor(t){this.projectionTransform=t}estimate({screenCoords:t,worldCoords:e}){return s({screenCoords:t,worldCoords:e,projectionTransform:this.projectionTransform})}refineEstimate({initialModelViewTransform:t,worldCoords:e,screenCoords:r}){return o({initialModelViewTransform:t,worldCoords:e,screenCoords:r,projectionTransform:this.projectionTransform})}}}},287:(t,e,r)=>{const{Matrix:s,inverse:o}=r(406),{normalizePoints:n,applyModelViewProjectionTransform:i,buildModelViewProjectionTransform:h,computeScreenCoordiate:l}=r(740);let u=[[],[],[]],a=[[],[]],c=[[],[],[]];const f=({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:s,inlierProb:o})=>{const n=o<1;let i=t,u=0,a=0,c=new Array(r.length),f=new Array(r.length),p=new Array(r.length),d=new Array(r.length);for(let t=0;t<=10;t++){const y=h(e,i);for(let t=0;t<r.length;t++){const e=l(y,r[t].x,r[t].y,r[t].z),o=s[t].x-e.x,n=s[t].y-e.y;p[t]=o,d[t]=n,c[t]=o*o+n*n}let M;if(a=0,n){const t=Math.max(3,Math.floor(r.length*o)-1);for(let t=0;t<r.length;t++)f[t]=c[t];f.sort(((t,e)=>t-e)),M=Math.max(4*f[t],16);for(let t=0;t<r.length;t++)f[t]>M?a+=M/6:a+=M/6*(1-(1-f[t]/M)*(1-f[t]/M)*(1-f[t]/M))}else for(let t=0;t<r.length;t++)a+=c[t];if(a/=r.length,a<.1)break;if(t>0&&a/u>.99)break;if(10===t)break;u=a;const b=[],x=[];for(let t=0;t<r.length;t++){if(n&&c[t]>M)continue;const s=w({modelViewProjectionTransform:y,modelViewTransform:i,projectionTransform:e,worldCoord:r[t]});if(n){const e=(1-c[t]/M)*(1-c[t]/M);for(let t=0;t<2;t++)for(let r=0;r<6;r++)s[t][r]*=e;b.push([p[t]*e]),b.push([d[t]*e])}else b.push([p[t]]),b.push([d[t]]);for(let t=0;t<s.length;t++)x.push(s[t])}const E=g({dU:b,J_U_S:x});if(null===E)break;i=m({modelViewTransform:i,dS:E})}return{modelViewTransform:i,err:a}},m=({modelViewTransform:t,dS:e})=>{let r,s,o,n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2];n<1e-6?(r=1,s=0,o=0,n=0):(n=Math.sqrt(n),r=e[0]/n,s=e[1]/n,o=e[2]/n);const i=Math.cos(n),h=Math.sin(n),l=1-i;u[0][0]=r*r*l+i,u[0][1]=r*s*l-o*h,u[0][2]=r*o*l+s*h,u[0][3]=e[3],u[1][0]=s*r*l+o*h,u[1][1]=s*s*l+i,u[1][2]=s*o*l-r*h,u[1][3]=e[4],u[2][0]=o*r*l-s*h,u[2][1]=o*s*l+r*h,u[2][2]=o*o*l+i,u[2][3]=e[5];const a=[[],[],[]];for(let e=0;e<3;e++){for(let r=0;r<4;r++)a[e][r]=t[e][0]*u[0][r]+t[e][1]*u[1][r]+t[e][2]*u[2][r];a[e][3]+=t[e][3]}return a},g=({dU:t,J_U_S:e})=>{const r=new s(e),n=new s(t),i=r.transpose(),h=i.mmul(r),l=i.mmul(n);let u;try{u=o(h)}catch(t){return null}return u.mmul(l).to1DArray()},w=({modelViewProjectionTransform:t,modelViewTransform:e,projectionTransform:r,worldCoord:s})=>{const o=e,{x:n,y:h,z:l}=s,u=i(t,n,h,l),f=u.z*u.z;a[0][0]=r[0][0]*u.z/f,a[0][1]=r[0][1]*u.z/f,a[0][2]=(r[0][2]*u.z-r[2][2]*u.x)/f,a[1][0]=r[1][0]*u.z/f,a[1][1]=r[1][1]*u.z/f,a[1][2]=(r[1][2]*u.z-r[2][2]*u.y)/f,c[0][0]=o[0][2]*h,c[0][1]=-o[0][2]*n,c[0][2]=o[0][1]*n-o[0][0]*h,c[0][3]=o[0][0],c[0][4]=o[0][1],c[0][5]=o[0][2],c[1][0]=o[1][2]*h,c[1][1]=-o[1][2]*n,c[1][2]=o[1][1]*n-o[1][0]*h,c[1][3]=o[1][0],c[1][4]=o[1][1],c[1][5]=o[1][2],c[2][0]=o[2][2]*h,c[2][1]=-o[2][2]*n,c[2][2]=o[2][1]*n-o[2][0]*h,c[2][3]=o[2][0],c[2][4]=o[2][1],c[2][5]=o[2][2];const m=[[],[]];for(let t=0;t<2;t++)for(let e=0;e<6;e++){m[t][e]=0;for(let r=0;r<3;r++)m[t][e]+=a[t][r]*c[r][e]}return m};t.exports={refineEstimate:({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:s})=>{let o=0,n=0;for(let t=0;t<r.length;t++)o+=r[t].x,n+=r[t].y;o/=r.length,n/=r.length;const i=[];for(let t=0;t<r.length;t++)i.push({x:r[t].x-o,y:r[t].y-n,z:r[t].z});const h=[[],[],[]];for(let e=0;e<3;e++)for(let r=0;r<3;r++)h[e][r]=t[e][r];h[0][3]=t[0][0]*o+t[0][1]*n+t[0][3],h[1][3]=t[1][0]*o+t[1][1]*n+t[1][3],h[2][3]=t[2][0]*o+t[2][1]*n+t[2][3];const l=[1,.8,.6,.4,0];let u=h,a=null;for(let t=0;t<l.length;t++){const r=f({initialModelViewTransform:u,projectionTransform:e,worldCoords:i,screenCoords:s,inlierProb:l[t]});if(u=r.modelViewTransform,r.err<5){a=u;break}}return null===a?null:(a[0][3]=a[0][3]-a[0][0]*o-a[0][1]*n,a[1][3]=a[1][3]-a[1][0]*o-a[1][1]*n,a[2][3]=a[2][3]-a[2][0]*o-a[2][1]*n,a)}}},740:t=>{const e=(t,e,r,s)=>({x:t[0][0]*e+t[0][1]*r+t[0][3],y:t[1][0]*e+t[1][1]*r+t[1][3],z:t[2][0]*e+t[2][1]*r+t[2][3]});t.exports={buildModelViewProjectionTransform:(t,e)=>[[t[0][0]*e[0][0]+t[0][2]*e[2][0],t[0][0]*e[0][1]+t[0][2]*e[2][1],t[0][0]*e[0][2]+t[0][2]*e[2][2],t[0][0]*e[0][3]+t[0][2]*e[2][3]],[t[1][1]*e[1][0]+t[1][2]*e[2][0],t[1][1]*e[1][1]+t[1][2]*e[2][1],t[1][1]*e[1][2]+t[1][2]*e[2][2],t[1][1]*e[1][3]+t[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],applyModelViewProjectionTransform:e,computeScreenCoordiate:(t,r,s,o)=>{const{x:n,y:i,z:h}=e(t,r,s);return{x:n/h,y:i/h}}}},646:t=>{const e=t=>{var e=t-(t>>1&1431655765);return e=((e=((e=((e=(e>>2&858993459)+(858993459&e))>>4)+e&252645135)>>8)+e&16711935)>>16)+e&65535};t.exports={compute:t=>{const{v1:r,v2:s}=t;let o=0;for(let t=0;t<r.length;t++){let n=(r[t]^s[t])>>>0;o+=e(n)}return o}}},551:t=>{const e=({querypoint:t,keypoint:e,keycenterX:r,keycenterY:s,scaleOneOverLogK:o})=>{let n=t.angle-e.angle;n<=-Math.PI?n+=2*Math.PI:n>Math.PI&&(n-=2*Math.PI);const i=t.scale/e.scale,h=i*Math.cos(n),l=i*Math.sin(n),u=[h,-l,l,h],a=[u[0]*e.x+u[1]*e.y,u[2]*e.x+u[3]*e.y],c=t.x-a[0],f=t.y-a[1];return{x:u[0]*r+u[1]*s+c,y:u[2]*r+u[3]*s+f,angle:n,scale:Math.log(i)*o}};t.exports={computeHoughMatches:t=>{const{keywidth:r,keyheight:s,querywidth:o,queryheight:n,matches:i}=t,h=1.2*o,l=-h,u=1.2*n,a=-u,c=12,f=1/Math.log(10),m=Math.max(r,s),g=Math.floor(r/2),w=Math.floor(s/2),p=[];for(let t=0;t<i.length;t++){const e=i[t].querypoint.scale,r=i[t].keypoint.scale;0==r&&console.log("ERROR divide zero");const s=e/r;p.push(s*m)}p.sort(((t,e)=>t-e));const d=.25*p[Math.floor(p.length/2)-(p.length%2==0?1:0)-1],y=Math.max(5,Math.ceil((h-l)/d)),M=Math.max(5,Math.ceil((u-a)/d)),b=y*M,x=b*c,E=[],v=[],S={};for(let t=0;t<i.length;t++){const r=i[t].querypoint,s=i[t].keypoint,{x:o,y:n,scale:m,angle:p}=e({querypoint:r,keypoint:s,keycenterX:g,keycenterY:w,scaleOneOverLogK:f});if(o<l||o>=h||n<a||n>=u||p<=-Math.PI||p>Math.PI||m<-1||m>=1){E[t]=!1;continue}let d=y*(o-l)/(h-l),k=M*(n-a)/(u-a),I=c*(p+Math.PI)/(2*Math.PI),R=10*(m- -1)/2;v[t]={binX:d,binY:k,binAngle:I,binScale:R};let A=Math.floor(d-.5),T=Math.floor(k-.5),q=Math.floor(R-.5),C=(Math.floor(I-.5)+c)%c;if(A<0||A+1>=y||T<0||T+1>=M||q<0||q+1>=10)E[t]=!1;else{for(let t=0;t<2;t++){let e=A+t;for(let t=0;t<2;t++){let r=T+t;for(let t=0;t<2;t++){let s=(C+t)%c;for(let t=0;t<2;t++){const o=e+r*y+s*b+(q+t)*x;void 0===S[o]&&(S[o]=0),S[o]+=1}}}}E[t]=!0}}let k=0,I=-1;if(Object.keys(S).forEach((t=>{S[t]>k&&(k=S[t],I=t)})),k<3)return[];const R=Math.floor(I%x%b%y),A=Math.floor((I-R)%x%b/y),T=Math.floor((I-R-A*y)%x/b),q=Math.floor((I-R-A*y-T*b)/x),C=[];for(let t=0;t<i.length;t++){if(!E[t])continue;const e=v[t];if(Math.abs(e.binX-(R+.5))>=1)continue;if(Math.abs(e.binY-(A+.5))>=1)continue;if(Math.abs(e.binScale-(q+.5))>=1)continue;const r=Math.abs(e.binAngle-(T+.5));Math.min(r,c-r)>=1||C.push(i[t])}return C}}},51:(t,e,r)=>{const{match:s}=r(561);t.exports={Matcher:class{constructor(t,e,r=!1){this.queryWidth=t,this.queryHeight=e,this.debugMode=r}matchDetection(t,e){let r={frames:[]},o=null;for(let n=0;n<t.length;n++){const{H:i,matches:h,debugExtra:l}=s({keyframe:t[n],querypoints:e,querywidth:this.queryWidth,queryheight:this.queryHeight,debugMode:this.debugMode});r.frames.push(l),i&&(null===o||o.matches.length<h.length)&&(o={keyframeIndex:n,H:i,matches:h})}if(null===o)return{keyframeIndex:-1,debugExtra:r};const n=[],i=[],h=t[o.keyframeIndex];for(let t=0;t<o.matches.length;t++){const e=o.matches[t].querypoint,r=o.matches[t].keypoint;n.push({x:e.x,y:e.y}),i.push({x:(r.x+.5)/h.scale,y:(r.y+.5)/h.scale,z:0})}return{screenCoords:n,worldCoords:i,keyframeIndex:o.keyframeIndex,debugExtra:r}}}}},561:(t,e,r)=>{const s=r(842).Z,{compute:o}=r(646),{computeHoughMatches:n}=r(551),{computeHomography:i}=r(864),{multiplyPointHomographyInhomogenous:h,matrixInverse33:l}=r(596),u=({node:t,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i})=>{if(t.leaf){for(let e=0;e<t.pointIndexes.length;e++)n.push(t.pointIndexes[e]);return}const h=[];for(let s=0;s<t.children.length;s++){const n=t.children[s].centerPointIndex,i=o({v1:e[n].descriptors,v2:r.descriptors});h.push(i)}let l=Number.MAX_SAFE_INTEGER;for(let e=0;e<t.children.length;e++)l=Math.min(l,h[e]);for(let e=0;e<t.children.length;e++)h[e]!==l&&s.push({node:t.children[e],d:h[e]});for(let o=0;o<t.children.length;o++)h[o]===l&&u({node:t.children[o],keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i});if(i<8&&s.length>0){const{node:t,d:o}=s.pop();u({node:t,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i+=1})}},a=t=>{const{H:e,matches:r,threshold:s}=t,o=s*s,n=[];for(let t=0;t<r.length;t++){const s=r[t].querypoint,i=r[t].keypoint,l=h([i.x,i.y],e);(l[0]-s.x)*(l[0]-s.x)+(l[1]-s.y)*(l[1]-s.y)<=o&&n.push(r[t])}return n};t.exports={match:({keyframe:t,querypoints:e,querywidth:r,queryheight:c,debugMode:f})=>{let m={};const g=[];for(let r=0;r<e.length;r++){const n=e[r],i=n.maxima?t.maximaPoints:t.minimaPoints;if(0===i.length)continue;const h=n.maxima?t.maximaPointsCluster.rootNode:t.minimaPointsCluster.rootNode,l=[],a=new s([],((t,e)=>t.d-e.d));u({node:h,keypoints:i,querypoint:n,queue:a,keypointIndexes:l,numPop:0});let c=-1,f=Number.MAX_SAFE_INTEGER,m=Number.MAX_SAFE_INTEGER;for(let t=0;t<l.length;t++){const e=i[l[t]],r=o({v1:e.descriptors,v2:n.descriptors});r<f?(m=f,f=r,c=l[t]):r<m&&(m=r)}-1!==c&&(m===Number.MAX_SAFE_INTEGER||1*f/m<.7)&&g.push({querypoint:n,keypoint:i[c]})}if(f&&(m.matches=g),g.length<6)return{debugExtra:m};const w=n({keywidth:t.width,keyheight:t.height,querywidth:r,queryheight:c,matches:g});f&&(m.houghMatches=w);const p=i({srcPoints:w.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:w.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:t});if(null===p)return{debugExtra:m};const d=a({H:p,matches:w,threshold:3});if(f&&(m.inlierMatches=d),d.length<6)return{debugExtra:m};const y=l(p,1e-5),M=[];for(let r=0;r<e.length;r++){const s=e[r],n=h([s.x,s.y],y);let i=-1,l=Number.MAX_SAFE_INTEGER,u=Number.MAX_SAFE_INTEGER;const a=s.maxima?t.maximaPoints:t.minimaPoints;for(let t=0;t<a.length;t++){const e=a[t];if((e.x-n[0])*(e.x-n[0])+(e.y-n[1])*(e.y-n[1])>100)continue;const r=o({v1:e.descriptors,v2:s.descriptors});r<l?(u=l,l=r,i=t):r<u&&(u=r)}-1!==i&&(u===Number.MAX_SAFE_INTEGER||1*l/u<.7)&&M.push({querypoint:s,keypoint:a[i]})}f&&(m.matches2=M);const b=n({keywidth:t.width,keyheight:t.height,querywidth:r,queryheight:c,matches:M});f&&(m.houghMatches2=b);const x=i({srcPoints:b.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:b.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:t});if(null===x)return{debugExtra:m};const E=a({H:x,matches:b,threshold:3});return f&&(m.inlierMatches2=E),{H:x,matches:E,debugExtra:m}}}},864:(t,e,r)=>{const{Matrix:s,inverse:o}=r(406),{createRandomizer:n}=r(262),{quadrilateralConvex:i,matrixInverse33:h,smallestTriangleArea:l,multiplyPointHomographyInhomogenous:u,checkThreePointsConsistent:a,checkFourPointsConsistent:c,determinant:f}=r(596),{solveHomography:m}=r(268),g=({H:t,testPoints:e,keyframe:r})=>{const s=h(t,1e-5);if(null===s)return!1;const o=[];for(let t=0;t<e.length;t++)o.push(u(e[t],s));return!(l(o[0],o[1],o[2],o[3])<r.width*r.height*1e-4)&&!!i(o[0],o[1],o[2],o[3])},w=({inH:t})=>{const e=1/t[8],r=[];for(let s=0;s<8;s++)r[s]=t[s]*e;return r[8]=1,r},p=({H:t,srcPoint:e,dstPoint:r,oneOverScale2:s})=>{const o=u(e,t),n=[o[0]-r[0],o[1]-r[1]];return Math.log(1+(n[0]*n[0]+n[1]*n[1])*s)},d=({H:t,testPoints:e})=>{const r=[];for(let s=0;s<e.length;s++)r[s]=u(e[s],t);for(let t=0;t<e.length;t++){const s=t,o=(t+1)%e.length,n=(t+2)%e.length;if(!a(e[s],e[o],e[n],r[s],r[o],r[n]))return!1}return!0};t.exports={computeHomography:t=>{const{srcPoints:e,dstPoints:r,keyframe:s,quickMode:o}=t,i=[[0,0],[s.width,0],[s.width,s.height],[0,s.height]];if(e.length<4)return null;const h=Math.min(10,e.length),l=n(),u=[];for(let t=0;t<e.length;t++)u[t]=t;l.arrayShuffle({arr:u,sampleSize:u.length});const a=o?10:20,f=2*a;let y=0;const M=[];for(;y<f&&M.length<a;){if(y+=1,l.arrayShuffle({arr:u,sampleSize:4}),!c(e[u[0]],e[u[1]],e[u[2]],e[u[3]],r[u[0]],r[u[1]],r[u[2]],r[u[3]]))continue;const t=m([e[u[0]],e[u[1]],e[u[2]],e[u[3]]],[r[u[0]],r[u[1]],r[u[2]],r[u[3]]]);null!==t&&(d({H:t,testPoints:i})&&M.push(t))}if(0===M.length)return null;const b=[];for(let t=0;t<M.length;t++)b.push({H:M[t],cost:0});let x=h;for(let t=0;t<e.length&&b.length>2;t+=x){x=Math.min(h,e.length-t);let s=t+x;for(let o=0;o<b.length;o++)for(let n=t;n<s;n++){const t=p({H:b[o].H,srcPoint:e[n],dstPoint:r[n],oneOverScale2:1e4});b[o].cost+=t}b.sort(((t,e)=>t.cost-e.cost)),b.splice(-Math.floor((b.length+1)/2))}let E=null;for(let t=0;t<b.length;t++){const e=w({inH:b[t].H});if(g({H:e,testPoints:i,keyframe:s})){E=e;break}}return E}}},596:t=>{const e=(t,e,r)=>(e[0]-t[0])*(r[1]-t[1])-(e[1]-t[1])*(r[0]-t[0]),r=t=>{const e=t[4]*t[8]-t[5]*t[7],r=t[3]*t[8]-t[5]*t[6],s=t[3]*t[7]-t[4]*t[6];return t[0]*e-t[1]*r+t[2]*s},s=(t,e)=>[t[0]-e[0],t[1]-e[1]],o=(t,e)=>{const r=t[0]*e[1]-t[1]*e[0];return.5*Math.abs(r)};t.exports={matrixInverse33:(t,e)=>{const s=r(t);if(Math.abs(s)<=e)return null;const o=1/s;return[(t[4]*t[8]-t[5]*t[7])*o,(t[2]*t[7]-t[1]*t[8])*o,(t[1]*t[5]-t[2]*t[4])*o,(t[5]*t[6]-t[3]*t[8])*o,(t[0]*t[8]-t[2]*t[6])*o,(t[2]*t[3]-t[0]*t[5])*o,(t[3]*t[7]-t[4]*t[6])*o,(t[1]*t[6]-t[0]*t[7])*o,(t[0]*t[4]-t[1]*t[3])*o]},matrixMul33:(t,e)=>{const r=[];return r[0]=t[0]*e[0]+t[1]*e[3]+t[2]*e[6],r[1]=t[0]*e[1]+t[1]*e[4]+t[2]*e[7],r[2]=t[0]*e[2]+t[1]*e[5]+t[2]*e[8],r[3]=t[3]*e[0]+t[4]*e[3]+t[5]*e[6],r[4]=t[3]*e[1]+t[4]*e[4]+t[5]*e[7],r[5]=t[3]*e[2]+t[4]*e[5]+t[5]*e[8],r[6]=t[6]*e[0]+t[7]*e[3]+t[8]*e[6],r[7]=t[6]*e[1]+t[7]*e[4]+t[8]*e[7],r[8]=t[6]*e[2]+t[7]*e[5]+t[8]*e[8],r},quadrilateralConvex:(t,r,s,o)=>{const n=e(t,r,s)<=0;return e(r,s,o)<=0===n&&(e(s,o,t)<=0===n&&e(o,t,r)<=0===n)},smallestTriangleArea:(t,e,r,n)=>{const i=s(e,t),h=s(r,t),l=s(n,t),u=s(e,r),a=s(n,r),c=o(i,h),f=o(h,l),m=o(i,l),g=o(u,a);return Math.min(Math.min(Math.min(c,f),m),g)},multiplyPointHomographyInhomogenous:(t,e)=>{const r=e[6]*t[0]+e[7]*t[1]+e[8],s=[];return s[0]=(e[0]*t[0]+e[1]*t[1]+e[2])/r,s[1]=(e[3]*t[0]+e[4]*t[1]+e[5])/r,s},checkThreePointsConsistent:(t,r,s,o,n,i)=>e(t,r,s)>0==e(o,n,i)>0,checkFourPointsConsistent:(t,r,s,o,n,i,h,l)=>e(t,r,s)>0==e(n,i,h)>0&&(e(r,s,o)>0==e(i,h,l)>0&&(e(s,o,t)>0==e(h,l,n)>0&&e(o,t,r)>0==e(l,n,i)>0)),determinant:r}},268:(t,e,r)=>{const{Matrix:s,inverse:o}=r(406),n=t=>{let e=0,r=0;for(let s=0;s<t.length;s++)e+=t[s][0],r+=t[s][1];let s=e/t.length,o=r/t.length,n=0;for(let e=0;e<t.length;e++){const r=t[e][0]-s,i=t[e][1]-o;n+=Math.sqrt(r*r+i*i)}let i=Math.sqrt(2)*t.length/n;const h=[];for(let e=0;e<t.length;e++)h.push([(t[e][0]-s)*i,(t[e][1]-o)*i]);return{normPoints:h,param:{meanX:s,meanY:o,s:i}}},i=(t,e,r)=>{const s=r.s*r.meanX,o=r.s*r.meanY,n=[t[0]+s*t[6],t[1]+s*t[7],(t[0]+s*t[6])*-e.meanX+(t[1]+s*t[7])*-e.meanY+(t[2]+s)/e.s,t[3]+o*t[6],t[4]+o*t[7],(t[3]+o*t[6])*-e.meanX+(t[4]+o*t[7])*-e.meanY+(t[5]+o)/e.s,r.s*t[6],r.s*t[7],r.s*t[6]*-e.meanX+r.s*t[7]*-e.meanY+r.s/e.s];for(let t=0;t<9;t++)n[t]=n[t]/n[8];return n};t.exports={solveHomography:(t,e)=>{const{normPoints:r,param:h}=n(t),{normPoints:l,param:u}=n(e),a=l.length,c=[],f=[];for(let t=0;t<a;t++){const e=[r[t][0],r[t][1],1,0,0,0,-r[t][0]*l[t][0],-r[t][1]*l[t][0]],s=[0,0,0,r[t][0],r[t][1],1,-r[t][0]*l[t][1],-r[t][1]*l[t][1]];c.push(e),c.push(s),f.push([l[t][0]]),f.push([l[t][1]])}try{const t=new s(c),e=new s(f),r=t.transpose(),n=r.mmul(t),l=r.mmul(e),a=o(n).mmul(l).to1DArray();return i(a,h,u)}catch(t){return null}}}},262:t=>{t.exports={createRandomizer:()=>({seed:1234,arrayShuffle(t){const{arr:e,sampleSize:r}=t;for(let t=0;t<r;t++){this.seed=(214013*this.seed+2531011)%(1<<31);let r=this.seed>>16&32767;r%=e.length;let s=e[t];e[t]=e[r],e[r]=s}},nextInt(t){this.seed=(214013*this.seed+2531011)%(1<<31);let e=this.seed>>16&32767;return e%=t,e}})}}},e={};function r(s){var o=e[s];if(void 0!==o)return o.exports;var n=e[s]={exports:{}};return t[s](n,n.exports,r),n.exports}r.d=(t,e)=>{for(var s in e)r.o(e,s)&&!r.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{const{Matcher:t}=r(51),{Estimator:e}=r(150);let s=null,o=null,n=!1,i=null,h=null;onmessage=r=>{const{data:l}=r;if("setup"===l.type)s=l.projectionTransform,o=l.matchingDataList,n=l.debugMode,i=new t(l.inputWidth,l.inputHeight,n),h=new e(l.projectionTransform);else if("match"===l.type){const t=l.targetIndexes;let e=-1,r=null,s=null;for(let n=0;n<t.length;n++){const u=t[n],{keyframeIndex:a,screenCoords:c,worldCoords:f,debugExtra:m}=i.matchDetection(o[u],l.featurePoints);if(s=m,-1!==a){const t=h.estimate({screenCoords:c,worldCoords:f});t&&(e=u,r=t);break}}postMessage({type:"matchDone",targetIndex:e,modelViewTransform:r,debugExtra:s})}else if("trackUpdate"===l.type){const{modelViewTransform:t,worldCoords:e,screenCoords:r}=l,s=h.refineEstimate({initialModelViewTransform:t,worldCoords:e,screenCoords:r});postMessage({type:"trackUpdateDone",modelViewTransform:s})}}})()})();',"Worker",void 0,I.p+"controller.worker.js")}}},g={};function I(t){var C=g[t];if(void 0!==C)return C.exports;var e=g[t]={id:t,loaded:!1,exports:{}};return A[t].call(e.exports,e,e.exports,I),e.loaded=!0,e.exports}I.amdD=function(){throw new Error("define cannot be used indirect")},I.amdO={},I.n=A=>{var g=A&&A.__esModule?()=>A.default:()=>A;return I.d(g,{a:g}),g},I.d=(A,g)=>{for(var t in g)I.o(g,t)&&!I.o(A,t)&&Object.defineProperty(A,t,{enumerable:!0,get:g[t]})},I.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(A){if("object"==typeof window)return window}}(),I.o=(A,g)=>Object.prototype.hasOwnProperty.call(A,g),I.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},I.nmd=A=>(A.paths=[],A.children||(A.children=[]),A),(()=>{var A;I.g.importScripts&&(A=I.g.location+"");var g=I.g.document;if(!A&&g&&(g.currentScript&&(A=g.currentScript.src),!A)){var t=g.getElementsByTagName("script");if(t.length)for(var C=t.length-1;C>-1&&!A;)A=t[C--].src}if(!A)throw new Error("Automatic publicPath is not supported in this browser");A=A.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),I.p=A})();var t={};(()=>{"use strict";I.r(t),I.d(t,{ARAnchor:()=>tQ,ARFaceMesh:()=>CQ,ARView:()=>IQ});const A=require("@react-three/fiber");var g=I(35);const C="145",e=0,B=1,i=2,Q=1,o=2,E=3,n=0,s=1,a=2,r=0,h=1,c=2,l=3,D=4,u=5,w=100,d=101,p=102,y=103,G=104,f=200,N=201,F=202,R=203,m=204,k=205,S=206,M=207,U=208,K=209,J=210,Y=0,L=1,x=2,b=3,H=4,q=5,T=6,v=7,V=0,W=1,O=2,Z=0,P=1,X=2,j=3,z=4,_=5,$=301,AA=302,gA=303,IA=304,tA=306,CA=1e3,eA=1001,BA=1002,iA=1003,QA=1004,oA=1005,EA=1006,nA=1007,sA=1008,aA=1009,rA=1010,hA=1011,cA=1012,lA=1013,DA=1014,uA=1015,wA=1016,dA=1017,pA=1018,yA=1020,GA=1021,fA=1022,NA=1023,FA=1024,RA=1025,mA=1026,kA=1027,SA=1028,MA=1029,UA=1030,KA=1031,JA=1033,YA=33776,LA=33777,xA=33778,bA=33779,HA=35840,qA=35841,TA=35842,vA=35843,VA=36196,WA=37492,OA=37496,ZA=37808,PA=37809,XA=37810,jA=37811,zA=37812,_A=37813,$A=37814,Ag=37815,gg=37816,Ig=37817,tg=37818,Cg=37819,eg=37820,Bg=37821,ig=36492,Qg=2300,og=2301,Eg=2302,ng=2400,sg=2401,ag=2402,rg=3e3,hg=3001,cg=3201,lg=0,Dg=1,ug="srgb",wg="srgb-linear",dg=7680,pg=35044,yg="300 es",Gg=1035;class fg{addEventListener(A,g){void 0===this._listeners&&(this._listeners={});const I=this._listeners;void 0===I[A]&&(I[A]=[]),-1===I[A].indexOf(g)&&I[A].push(g)}hasEventListener(A,g){if(void 0===this._listeners)return!1;const I=this._listeners;return void 0!==I[A]&&-1!==I[A].indexOf(g)}removeEventListener(A,g){if(void 0===this._listeners)return;const I=this._listeners[A];if(void 0!==I){const A=I.indexOf(g);-1!==A&&I.splice(A,1)}}dispatchEvent(A){if(void 0===this._listeners)return;const g=this._listeners[A.type];if(void 0!==g){A.target=this;const I=g.slice(0);for(let g=0,t=I.length;g<t;g++)I[g].call(this,A);A.target=null}}}const Ng=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];const Fg=Math.PI/180,Rg=180/Math.PI;function mg(){const A=4294967295*Math.random()|0,g=4294967295*Math.random()|0,I=4294967295*Math.random()|0,t=4294967295*Math.random()|0;return(Ng[255&A]+Ng[A>>8&255]+Ng[A>>16&255]+Ng[A>>24&255]+"-"+Ng[255&g]+Ng[g>>8&255]+"-"+Ng[g>>16&15|64]+Ng[g>>24&255]+"-"+Ng[63&I|128]+Ng[I>>8&255]+"-"+Ng[I>>16&255]+Ng[I>>24&255]+Ng[255&t]+Ng[t>>8&255]+Ng[t>>16&255]+Ng[t>>24&255]).toLowerCase()}function kg(A,g,I){return Math.max(g,Math.min(I,A))}function Sg(A,g){return(A%g+g)%g}function Mg(A,g,I){return(1-I)*A+I*g}function Ug(A){return 0==(A&A-1)&&0!==A}function Kg(A){return Math.pow(2,Math.floor(Math.log(A)/Math.LN2))}function Jg(A,g){switch(g.constructor){case Float32Array:return A;case Uint16Array:return A/65535;case Uint8Array:return A/255;case Int16Array:return Math.max(A/32767,-1);case Int8Array:return Math.max(A/127,-1);default:throw new Error("Invalid component type.")}}function Yg(A,g){switch(g.constructor){case Float32Array:return A;case Uint16Array:return Math.round(65535*A);case Uint8Array:return Math.round(255*A);case Int16Array:return Math.round(32767*A);case Int8Array:return Math.round(127*A);default:throw new Error("Invalid component type.")}}class Lg{constructor(A=0,g=0){Lg.prototype.isVector2=!0,this.x=A,this.y=g}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,g){return this.x=A,this.y=g,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,g){switch(A){case 0:this.x=g;break;case 1:this.y=g;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,g){return this.x=A.x+g.x,this.y=A.y+g.y,this}addScaledVector(A,g){return this.x+=A.x*g,this.y+=A.y*g,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,g){return this.x=A.x-g.x,this.y=A.y-g.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const g=this.x,I=this.y,t=A.elements;return this.x=t[0]*g+t[3]*I+t[6],this.y=t[1]*g+t[4]*I+t[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,g){return this.x=Math.max(A.x,Math.min(g.x,this.x)),this.y=Math.max(A.y,Math.min(g.y,this.y)),this}clampScalar(A,g){return this.x=Math.max(A,Math.min(g,this.x)),this.y=Math.max(A,Math.min(g,this.y)),this}clampLength(A,g){const I=this.length();return this.divideScalar(I||1).multiplyScalar(Math.max(A,Math.min(g,I)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const g=this.x-A.x,I=this.y-A.y;return g*g+I*I}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,g){return this.x+=(A.x-this.x)*g,this.y+=(A.y-this.y)*g,this}lerpVectors(A,g,I){return this.x=A.x+(g.x-A.x)*I,this.y=A.y+(g.y-A.y)*I,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,g=0){return this.x=A[g],this.y=A[g+1],this}toArray(A=[],g=0){return A[g]=this.x,A[g+1]=this.y,A}fromBufferAttribute(A,g){return this.x=A.getX(g),this.y=A.getY(g),this}rotateAround(A,g){const I=Math.cos(g),t=Math.sin(g),C=this.x-A.x,e=this.y-A.y;return this.x=C*I-e*t+A.x,this.y=C*t+e*I+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class xg{constructor(){xg.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(A,g,I,t,C,e,B,i,Q){const o=this.elements;return o[0]=A,o[1]=t,o[2]=B,o[3]=g,o[4]=C,o[5]=i,o[6]=I,o[7]=e,o[8]=Q,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const g=this.elements,I=A.elements;return g[0]=I[0],g[1]=I[1],g[2]=I[2],g[3]=I[3],g[4]=I[4],g[5]=I[5],g[6]=I[6],g[7]=I[7],g[8]=I[8],this}extractBasis(A,g,I){return A.setFromMatrix3Column(this,0),g.setFromMatrix3Column(this,1),I.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const g=A.elements;return this.set(g[0],g[4],g[8],g[1],g[5],g[9],g[2],g[6],g[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,g){const I=A.elements,t=g.elements,C=this.elements,e=I[0],B=I[3],i=I[6],Q=I[1],o=I[4],E=I[7],n=I[2],s=I[5],a=I[8],r=t[0],h=t[3],c=t[6],l=t[1],D=t[4],u=t[7],w=t[2],d=t[5],p=t[8];return C[0]=e*r+B*l+i*w,C[3]=e*h+B*D+i*d,C[6]=e*c+B*u+i*p,C[1]=Q*r+o*l+E*w,C[4]=Q*h+o*D+E*d,C[7]=Q*c+o*u+E*p,C[2]=n*r+s*l+a*w,C[5]=n*h+s*D+a*d,C[8]=n*c+s*u+a*p,this}multiplyScalar(A){const g=this.elements;return g[0]*=A,g[3]*=A,g[6]*=A,g[1]*=A,g[4]*=A,g[7]*=A,g[2]*=A,g[5]*=A,g[8]*=A,this}determinant(){const A=this.elements,g=A[0],I=A[1],t=A[2],C=A[3],e=A[4],B=A[5],i=A[6],Q=A[7],o=A[8];return g*e*o-g*B*Q-I*C*o+I*B*i+t*C*Q-t*e*i}invert(){const A=this.elements,g=A[0],I=A[1],t=A[2],C=A[3],e=A[4],B=A[5],i=A[6],Q=A[7],o=A[8],E=o*e-B*Q,n=B*i-o*C,s=Q*C-e*i,a=g*E+I*n+t*s;if(0===a)return this.set(0,0,0,0,0,0,0,0,0);const r=1/a;return A[0]=E*r,A[1]=(t*Q-o*I)*r,A[2]=(B*I-t*e)*r,A[3]=n*r,A[4]=(o*g-t*i)*r,A[5]=(t*C-B*g)*r,A[6]=s*r,A[7]=(I*i-Q*g)*r,A[8]=(e*g-I*C)*r,this}transpose(){let A;const g=this.elements;return A=g[1],g[1]=g[3],g[3]=A,A=g[2],g[2]=g[6],g[6]=A,A=g[5],g[5]=g[7],g[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const g=this.elements;return A[0]=g[0],A[1]=g[3],A[2]=g[6],A[3]=g[1],A[4]=g[4],A[5]=g[7],A[6]=g[2],A[7]=g[5],A[8]=g[8],this}setUvTransform(A,g,I,t,C,e,B){const i=Math.cos(C),Q=Math.sin(C);return this.set(I*i,I*Q,-I*(i*e+Q*B)+e+A,-t*Q,t*i,-t*(-Q*e+i*B)+B+g,0,0,1),this}scale(A,g){const I=this.elements;return I[0]*=A,I[3]*=A,I[6]*=A,I[1]*=g,I[4]*=g,I[7]*=g,this}rotate(A){const g=Math.cos(A),I=Math.sin(A),t=this.elements,C=t[0],e=t[3],B=t[6],i=t[1],Q=t[4],o=t[7];return t[0]=g*C+I*i,t[3]=g*e+I*Q,t[6]=g*B+I*o,t[1]=-I*C+g*i,t[4]=-I*e+g*Q,t[7]=-I*B+g*o,this}translate(A,g){const I=this.elements;return I[0]+=A*I[2],I[3]+=A*I[5],I[6]+=A*I[8],I[1]+=g*I[2],I[4]+=g*I[5],I[7]+=g*I[8],this}equals(A){const g=this.elements,I=A.elements;for(let A=0;A<9;A++)if(g[A]!==I[A])return!1;return!0}fromArray(A,g=0){for(let I=0;I<9;I++)this.elements[I]=A[I+g];return this}toArray(A=[],g=0){const I=this.elements;return A[g]=I[0],A[g+1]=I[1],A[g+2]=I[2],A[g+3]=I[3],A[g+4]=I[4],A[g+5]=I[5],A[g+6]=I[6],A[g+7]=I[7],A[g+8]=I[8],A}clone(){return(new this.constructor).fromArray(this.elements)}}function bg(A){for(let g=A.length-1;g>=0;--g)if(A[g]>=65535)return!0;return!1}Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;function Hg(A){return document.createElementNS("http://www.w3.org/1999/xhtml",A)}function qg(A){return A<.04045?.0773993808*A:Math.pow(.9478672986*A+.0521327014,2.4)}function Tg(A){return A<.0031308?12.92*A:1.055*Math.pow(A,.41666)-.055}const vg={[ug]:{[wg]:qg},[wg]:{[ug]:Tg}},Vg={legacyMode:!0,get workingColorSpace(){return wg},set workingColorSpace(A){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(A,g,I){if(this.legacyMode||g===I||!g||!I)return A;if(vg[g]&&void 0!==vg[g][I]){const t=vg[g][I];return A.r=t(A.r),A.g=t(A.g),A.b=t(A.b),A}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(A,g){return this.convert(A,this.workingColorSpace,g)},toWorkingColorSpace:function(A,g){return this.convert(A,g,this.workingColorSpace)}},Wg={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Og={r:0,g:0,b:0},Zg={h:0,s:0,l:0},Pg={h:0,s:0,l:0};function Xg(A,g,I){return I<0&&(I+=1),I>1&&(I-=1),I<1/6?A+6*(g-A)*I:I<.5?g:I<2/3?A+6*(g-A)*(2/3-I):A}function jg(A,g){return g.r=A.r,g.g=A.g,g.b=A.b,g}class zg{constructor(A,g,I){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===g&&void 0===I?this.set(A):this.setRGB(A,g,I)}set(A){return A&&A.isColor?this.copy(A):"number"==typeof A?this.setHex(A):"string"==typeof A&&this.setStyle(A),this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,g=ug){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(255&A)/255,Vg.toWorkingColorSpace(this,g),this}setRGB(A,g,I,t=wg){return this.r=A,this.g=g,this.b=I,Vg.toWorkingColorSpace(this,t),this}setHSL(A,g,I,t=wg){if(A=Sg(A,1),g=kg(g,0,1),I=kg(I,0,1),0===g)this.r=this.g=this.b=I;else{const t=I<=.5?I*(1+g):I+g-I*g,C=2*I-t;this.r=Xg(C,t,A+1/3),this.g=Xg(C,t,A),this.b=Xg(C,t,A-1/3)}return Vg.toWorkingColorSpace(this,t),this}setStyle(A,g=ug){function I(g){void 0!==g&&parseFloat(g)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let t;if(t=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(A)){let A;const C=t[1],e=t[2];switch(C){case"rgb":case"rgba":if(A=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(e))return this.r=Math.min(255,parseInt(A[1],10))/255,this.g=Math.min(255,parseInt(A[2],10))/255,this.b=Math.min(255,parseInt(A[3],10))/255,Vg.toWorkingColorSpace(this,g),I(A[4]),this;if(A=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(e))return this.r=Math.min(100,parseInt(A[1],10))/100,this.g=Math.min(100,parseInt(A[2],10))/100,this.b=Math.min(100,parseInt(A[3],10))/100,Vg.toWorkingColorSpace(this,g),I(A[4]),this;break;case"hsl":case"hsla":if(A=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(e)){const t=parseFloat(A[1])/360,C=parseFloat(A[2])/100,e=parseFloat(A[3])/100;return I(A[4]),this.setHSL(t,C,e,g)}}}else if(t=/^\#([A-Fa-f\d]+)$/.exec(A)){const A=t[1],I=A.length;if(3===I)return this.r=parseInt(A.charAt(0)+A.charAt(0),16)/255,this.g=parseInt(A.charAt(1)+A.charAt(1),16)/255,this.b=parseInt(A.charAt(2)+A.charAt(2),16)/255,Vg.toWorkingColorSpace(this,g),this;if(6===I)return this.r=parseInt(A.charAt(0)+A.charAt(1),16)/255,this.g=parseInt(A.charAt(2)+A.charAt(3),16)/255,this.b=parseInt(A.charAt(4)+A.charAt(5),16)/255,Vg.toWorkingColorSpace(this,g),this}return A&&A.length>0?this.setColorName(A,g):this}setColorName(A,g=ug){const I=Wg[A.toLowerCase()];return void 0!==I?this.setHex(I,g):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=qg(A.r),this.g=qg(A.g),this.b=qg(A.b),this}copyLinearToSRGB(A){return this.r=Tg(A.r),this.g=Tg(A.g),this.b=Tg(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=ug){return Vg.fromWorkingColorSpace(jg(this,Og),A),kg(255*Og.r,0,255)<<16^kg(255*Og.g,0,255)<<8^kg(255*Og.b,0,255)<<0}getHexString(A=ug){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,g=wg){Vg.fromWorkingColorSpace(jg(this,Og),g);const I=Og.r,t=Og.g,C=Og.b,e=Math.max(I,t,C),B=Math.min(I,t,C);let i,Q;const o=(B+e)/2;if(B===e)i=0,Q=0;else{const A=e-B;switch(Q=o<=.5?A/(e+B):A/(2-e-B),e){case I:i=(t-C)/A+(t<C?6:0);break;case t:i=(C-I)/A+2;break;case C:i=(I-t)/A+4}i/=6}return A.h=i,A.s=Q,A.l=o,A}getRGB(A,g=wg){return Vg.fromWorkingColorSpace(jg(this,Og),g),A.r=Og.r,A.g=Og.g,A.b=Og.b,A}getStyle(A=ug){return Vg.fromWorkingColorSpace(jg(this,Og),A),A!==ug?`color(${A} ${Og.r} ${Og.g} ${Og.b})`:`rgb(${255*Og.r|0},${255*Og.g|0},${255*Og.b|0})`}offsetHSL(A,g,I){return this.getHSL(Zg),Zg.h+=A,Zg.s+=g,Zg.l+=I,this.setHSL(Zg.h,Zg.s,Zg.l),this}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,g){return this.r=A.r+g.r,this.g=A.g+g.g,this.b=A.b+g.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,g){return this.r+=(A.r-this.r)*g,this.g+=(A.g-this.g)*g,this.b+=(A.b-this.b)*g,this}lerpColors(A,g,I){return this.r=A.r+(g.r-A.r)*I,this.g=A.g+(g.g-A.g)*I,this.b=A.b+(g.b-A.b)*I,this}lerpHSL(A,g){this.getHSL(Zg),A.getHSL(Pg);const I=Mg(Zg.h,Pg.h,g),t=Mg(Zg.s,Pg.s,g),C=Mg(Zg.l,Pg.l,g);return this.setHSL(I,t,C),this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,g=0){return this.r=A[g],this.g=A[g+1],this.b=A[g+2],this}toArray(A=[],g=0){return A[g]=this.r,A[g+1]=this.g,A[g+2]=this.b,A}fromBufferAttribute(A,g){return this.r=A.getX(g),this.g=A.getY(g),this.b=A.getZ(g),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let _g;zg.NAMES=Wg;class $g{static getDataURL(A){if(/^data:/i.test(A.src))return A.src;if("undefined"==typeof HTMLCanvasElement)return A.src;let g;if(A instanceof HTMLCanvasElement)g=A;else{void 0===_g&&(_g=Hg("canvas")),_g.width=A.width,_g.height=A.height;const I=_g.getContext("2d");A instanceof ImageData?I.putImageData(A,0,0):I.drawImage(A,0,0,A.width,A.height),g=_g}return g.width>2048||g.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),g.toDataURL("image/jpeg",.6)):g.toDataURL("image/png")}static sRGBToLinear(A){if("undefined"!=typeof HTMLImageElement&&A instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&A instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&A instanceof ImageBitmap){const g=Hg("canvas");g.width=A.width,g.height=A.height;const I=g.getContext("2d");I.drawImage(A,0,0,A.width,A.height);const t=I.getImageData(0,0,A.width,A.height),C=t.data;for(let A=0;A<C.length;A++)C[A]=255*qg(C[A]/255);return I.putImageData(t,0,0),g}if(A.data){const g=A.data.slice(0);for(let A=0;A<g.length;A++)g instanceof Uint8Array||g instanceof Uint8ClampedArray?g[A]=Math.floor(255*qg(g[A]/255)):g[A]=qg(g[A]);return{data:g,width:A.width,height:A.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}class AI{constructor(A=null){this.isSource=!0,this.uuid=mg(),this.data=A,this.version=0}set needsUpdate(A){!0===A&&this.version++}toJSON(A){const g=void 0===A||"string"==typeof A;if(!g&&void 0!==A.images[this.uuid])return A.images[this.uuid];const I={uuid:this.uuid,url:""},t=this.data;if(null!==t){let A;if(Array.isArray(t)){A=[];for(let g=0,I=t.length;g<I;g++)t[g].isDataTexture?A.push(gI(t[g].image)):A.push(gI(t[g]))}else A=gI(t);I.url=A}return g||(A.images[this.uuid]=I),I}}function gI(A){return"undefined"!=typeof HTMLImageElement&&A instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&A instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&A instanceof ImageBitmap?$g.getDataURL(A):A.data?{data:Array.from(A.data),width:A.width,height:A.height,type:A.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let II=0;class tI extends fg{constructor(A=tI.DEFAULT_IMAGE,g=tI.DEFAULT_MAPPING,I=eA,t=eA,C=EA,e=sA,B=NA,i=aA,Q=1,o=rg){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:II++}),this.uuid=mg(),this.name="",this.source=new AI(A),this.mipmaps=[],this.mapping=g,this.wrapS=I,this.wrapT=t,this.magFilter=C,this.minFilter=e,this.anisotropy=Q,this.format=B,this.internalFormat=null,this.type=i,this.offset=new Lg(0,0),this.repeat=new Lg(1,1),this.center=new Lg(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xg,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=o,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(A){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.encoding=A.encoding,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const g=void 0===A||"string"==typeof A;if(!g&&void 0!==A.textures[this.uuid])return A.textures[this.uuid];const I={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(I.userData=this.userData),g||(A.textures[this.uuid]=I),I}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(300!==this.mapping)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case CA:A.x=A.x-Math.floor(A.x);break;case eA:A.x=A.x<0?0:1;break;case BA:1===Math.abs(Math.floor(A.x)%2)?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x)}if(A.y<0||A.y>1)switch(this.wrapT){case CA:A.y=A.y-Math.floor(A.y);break;case eA:A.y=A.y<0?0:1;break;case BA:1===Math.abs(Math.floor(A.y)%2)?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y)}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){!0===A&&(this.version++,this.source.needsUpdate=!0)}}tI.DEFAULT_IMAGE=null,tI.DEFAULT_MAPPING=300;class CI{constructor(A=0,g=0,I=0,t=1){CI.prototype.isVector4=!0,this.x=A,this.y=g,this.z=I,this.w=t}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,g,I,t){return this.x=A,this.y=g,this.z=I,this.w=t,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,g){switch(A){case 0:this.x=g;break;case 1:this.y=g;break;case 2:this.z=g;break;case 3:this.w=g;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=void 0!==A.w?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,g){return this.x=A.x+g.x,this.y=A.y+g.y,this.z=A.z+g.z,this.w=A.w+g.w,this}addScaledVector(A,g){return this.x+=A.x*g,this.y+=A.y*g,this.z+=A.z*g,this.w+=A.w*g,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,g){return this.x=A.x-g.x,this.y=A.y-g.y,this.z=A.z-g.z,this.w=A.w-g.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const g=this.x,I=this.y,t=this.z,C=this.w,e=A.elements;return this.x=e[0]*g+e[4]*I+e[8]*t+e[12]*C,this.y=e[1]*g+e[5]*I+e[9]*t+e[13]*C,this.z=e[2]*g+e[6]*I+e[10]*t+e[14]*C,this.w=e[3]*g+e[7]*I+e[11]*t+e[15]*C,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const g=Math.sqrt(1-A.w*A.w);return g<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/g,this.y=A.y/g,this.z=A.z/g),this}setAxisAngleFromRotationMatrix(A){let g,I,t,C;const e=.01,B=.1,i=A.elements,Q=i[0],o=i[4],E=i[8],n=i[1],s=i[5],a=i[9],r=i[2],h=i[6],c=i[10];if(Math.abs(o-n)<e&&Math.abs(E-r)<e&&Math.abs(a-h)<e){if(Math.abs(o+n)<B&&Math.abs(E+r)<B&&Math.abs(a+h)<B&&Math.abs(Q+s+c-3)<B)return this.set(1,0,0,0),this;g=Math.PI;const A=(Q+1)/2,i=(s+1)/2,l=(c+1)/2,D=(o+n)/4,u=(E+r)/4,w=(a+h)/4;return A>i&&A>l?A<e?(I=0,t=.707106781,C=.707106781):(I=Math.sqrt(A),t=D/I,C=u/I):i>l?i<e?(I=.707106781,t=0,C=.707106781):(t=Math.sqrt(i),I=D/t,C=w/t):l<e?(I=.707106781,t=.707106781,C=0):(C=Math.sqrt(l),I=u/C,t=w/C),this.set(I,t,C,g),this}let l=Math.sqrt((h-a)*(h-a)+(E-r)*(E-r)+(n-o)*(n-o));return Math.abs(l)<.001&&(l=1),this.x=(h-a)/l,this.y=(E-r)/l,this.z=(n-o)/l,this.w=Math.acos((Q+s+c-1)/2),this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,g){return this.x=Math.max(A.x,Math.min(g.x,this.x)),this.y=Math.max(A.y,Math.min(g.y,this.y)),this.z=Math.max(A.z,Math.min(g.z,this.z)),this.w=Math.max(A.w,Math.min(g.w,this.w)),this}clampScalar(A,g){return this.x=Math.max(A,Math.min(g,this.x)),this.y=Math.max(A,Math.min(g,this.y)),this.z=Math.max(A,Math.min(g,this.z)),this.w=Math.max(A,Math.min(g,this.w)),this}clampLength(A,g){const I=this.length();return this.divideScalar(I||1).multiplyScalar(Math.max(A,Math.min(g,I)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,g){return this.x+=(A.x-this.x)*g,this.y+=(A.y-this.y)*g,this.z+=(A.z-this.z)*g,this.w+=(A.w-this.w)*g,this}lerpVectors(A,g,I){return this.x=A.x+(g.x-A.x)*I,this.y=A.y+(g.y-A.y)*I,this.z=A.z+(g.z-A.z)*I,this.w=A.w+(g.w-A.w)*I,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,g=0){return this.x=A[g],this.y=A[g+1],this.z=A[g+2],this.w=A[g+3],this}toArray(A=[],g=0){return A[g]=this.x,A[g+1]=this.y,A[g+2]=this.z,A[g+3]=this.w,A}fromBufferAttribute(A,g){return this.x=A.getX(g),this.y=A.getY(g),this.z=A.getZ(g),this.w=A.getW(g),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class eI extends fg{constructor(A,g,I={}){super(),this.isWebGLRenderTarget=!0,this.width=A,this.height=g,this.depth=1,this.scissor=new CI(0,0,A,g),this.scissorTest=!1,this.viewport=new CI(0,0,A,g);const t={width:A,height:g,depth:1};this.texture=new tI(t,I.mapping,I.wrapS,I.wrapT,I.magFilter,I.minFilter,I.format,I.type,I.anisotropy,I.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==I.generateMipmaps&&I.generateMipmaps,this.texture.internalFormat=void 0!==I.internalFormat?I.internalFormat:null,this.texture.minFilter=void 0!==I.minFilter?I.minFilter:EA,this.depthBuffer=void 0===I.depthBuffer||I.depthBuffer,this.stencilBuffer=void 0!==I.stencilBuffer&&I.stencilBuffer,this.depthTexture=void 0!==I.depthTexture?I.depthTexture:null,this.samples=void 0!==I.samples?I.samples:0}setSize(A,g,I=1){this.width===A&&this.height===g&&this.depth===I||(this.width=A,this.height=g,this.depth=I,this.texture.image.width=A,this.texture.image.height=g,this.texture.image.depth=I,this.dispose()),this.viewport.set(0,0,A,g),this.scissor.set(0,0,A,g)}clone(){return(new this.constructor).copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.viewport.copy(A.viewport),this.texture=A.texture.clone(),this.texture.isRenderTargetTexture=!0;const g=Object.assign({},A.texture.image);return this.texture.source=new AI(g),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,null!==A.depthTexture&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class BI extends tI{constructor(A=null,g=1,I=1,t=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:g,height:I,depth:t},this.magFilter=iA,this.minFilter=iA,this.wrapR=eA,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class iI extends tI{constructor(A=null,g=1,I=1,t=1){super(null),this.isData3DTexture=!0,this.image={data:A,width:g,height:I,depth:t},this.magFilter=iA,this.minFilter=iA,this.wrapR=eA,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class QI{constructor(A=0,g=0,I=0,t=1){this.isQuaternion=!0,this._x=A,this._y=g,this._z=I,this._w=t}static slerpFlat(A,g,I,t,C,e,B){let i=I[t+0],Q=I[t+1],o=I[t+2],E=I[t+3];const n=C[e+0],s=C[e+1],a=C[e+2],r=C[e+3];if(0===B)return A[g+0]=i,A[g+1]=Q,A[g+2]=o,void(A[g+3]=E);if(1===B)return A[g+0]=n,A[g+1]=s,A[g+2]=a,void(A[g+3]=r);if(E!==r||i!==n||Q!==s||o!==a){let A=1-B;const g=i*n+Q*s+o*a+E*r,I=g>=0?1:-1,t=1-g*g;if(t>Number.EPSILON){const C=Math.sqrt(t),e=Math.atan2(C,g*I);A=Math.sin(A*e)/C,B=Math.sin(B*e)/C}const C=B*I;if(i=i*A+n*C,Q=Q*A+s*C,o=o*A+a*C,E=E*A+r*C,A===1-B){const A=1/Math.sqrt(i*i+Q*Q+o*o+E*E);i*=A,Q*=A,o*=A,E*=A}}A[g]=i,A[g+1]=Q,A[g+2]=o,A[g+3]=E}static multiplyQuaternionsFlat(A,g,I,t,C,e){const B=I[t],i=I[t+1],Q=I[t+2],o=I[t+3],E=C[e],n=C[e+1],s=C[e+2],a=C[e+3];return A[g]=B*a+o*E+i*s-Q*n,A[g+1]=i*a+o*n+Q*E-B*s,A[g+2]=Q*a+o*s+B*n-i*E,A[g+3]=o*a-B*E-i*n-Q*s,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,g,I,t){return this._x=A,this._y=g,this._z=I,this._w=t,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,g){const I=A._x,t=A._y,C=A._z,e=A._order,B=Math.cos,i=Math.sin,Q=B(I/2),o=B(t/2),E=B(C/2),n=i(I/2),s=i(t/2),a=i(C/2);switch(e){case"XYZ":this._x=n*o*E+Q*s*a,this._y=Q*s*E-n*o*a,this._z=Q*o*a+n*s*E,this._w=Q*o*E-n*s*a;break;case"YXZ":this._x=n*o*E+Q*s*a,this._y=Q*s*E-n*o*a,this._z=Q*o*a-n*s*E,this._w=Q*o*E+n*s*a;break;case"ZXY":this._x=n*o*E-Q*s*a,this._y=Q*s*E+n*o*a,this._z=Q*o*a+n*s*E,this._w=Q*o*E-n*s*a;break;case"ZYX":this._x=n*o*E-Q*s*a,this._y=Q*s*E+n*o*a,this._z=Q*o*a-n*s*E,this._w=Q*o*E+n*s*a;break;case"YZX":this._x=n*o*E+Q*s*a,this._y=Q*s*E+n*o*a,this._z=Q*o*a-n*s*E,this._w=Q*o*E-n*s*a;break;case"XZY":this._x=n*o*E-Q*s*a,this._y=Q*s*E-n*o*a,this._z=Q*o*a+n*s*E,this._w=Q*o*E+n*s*a;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+e)}return!1!==g&&this._onChangeCallback(),this}setFromAxisAngle(A,g){const I=g/2,t=Math.sin(I);return this._x=A.x*t,this._y=A.y*t,this._z=A.z*t,this._w=Math.cos(I),this._onChangeCallback(),this}setFromRotationMatrix(A){const g=A.elements,I=g[0],t=g[4],C=g[8],e=g[1],B=g[5],i=g[9],Q=g[2],o=g[6],E=g[10],n=I+B+E;if(n>0){const A=.5/Math.sqrt(n+1);this._w=.25/A,this._x=(o-i)*A,this._y=(C-Q)*A,this._z=(e-t)*A}else if(I>B&&I>E){const A=2*Math.sqrt(1+I-B-E);this._w=(o-i)/A,this._x=.25*A,this._y=(t+e)/A,this._z=(C+Q)/A}else if(B>E){const A=2*Math.sqrt(1+B-I-E);this._w=(C-Q)/A,this._x=(t+e)/A,this._y=.25*A,this._z=(i+o)/A}else{const A=2*Math.sqrt(1+E-I-B);this._w=(e-t)/A,this._x=(C+Q)/A,this._y=(i+o)/A,this._z=.25*A}return this._onChangeCallback(),this}setFromUnitVectors(A,g){let I=A.dot(g)+1;return I<Number.EPSILON?(I=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=I):(this._x=0,this._y=-A.z,this._z=A.y,this._w=I)):(this._x=A.y*g.z-A.z*g.y,this._y=A.z*g.x-A.x*g.z,this._z=A.x*g.y-A.y*g.x,this._w=I),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(kg(this.dot(A),-1,1)))}rotateTowards(A,g){const I=this.angleTo(A);if(0===I)return this;const t=Math.min(1,g/I);return this.slerp(A,t),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return 0===A?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,g){const I=A._x,t=A._y,C=A._z,e=A._w,B=g._x,i=g._y,Q=g._z,o=g._w;return this._x=I*o+e*B+t*Q-C*i,this._y=t*o+e*i+C*B-I*Q,this._z=C*o+e*Q+I*i-t*B,this._w=e*o-I*B-t*i-C*Q,this._onChangeCallback(),this}slerp(A,g){if(0===g)return this;if(1===g)return this.copy(A);const I=this._x,t=this._y,C=this._z,e=this._w;let B=e*A._w+I*A._x+t*A._y+C*A._z;if(B<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,B=-B):this.copy(A),B>=1)return this._w=e,this._x=I,this._y=t,this._z=C,this;const i=1-B*B;if(i<=Number.EPSILON){const A=1-g;return this._w=A*e+g*this._w,this._x=A*I+g*this._x,this._y=A*t+g*this._y,this._z=A*C+g*this._z,this.normalize(),this._onChangeCallback(),this}const Q=Math.sqrt(i),o=Math.atan2(Q,B),E=Math.sin((1-g)*o)/Q,n=Math.sin(g*o)/Q;return this._w=e*E+this._w*n,this._x=I*E+this._x*n,this._y=t*E+this._y*n,this._z=C*E+this._z*n,this._onChangeCallback(),this}slerpQuaternions(A,g,I){return this.copy(A).slerp(g,I)}random(){const A=Math.random(),g=Math.sqrt(1-A),I=Math.sqrt(A),t=2*Math.PI*Math.random(),C=2*Math.PI*Math.random();return this.set(g*Math.cos(t),I*Math.sin(C),I*Math.cos(C),g*Math.sin(t))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,g=0){return this._x=A[g],this._y=A[g+1],this._z=A[g+2],this._w=A[g+3],this._onChangeCallback(),this}toArray(A=[],g=0){return A[g]=this._x,A[g+1]=this._y,A[g+2]=this._z,A[g+3]=this._w,A}fromBufferAttribute(A,g){return this._x=A.getX(g),this._y=A.getY(g),this._z=A.getZ(g),this._w=A.getW(g),this}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class oI{constructor(A=0,g=0,I=0){oI.prototype.isVector3=!0,this.x=A,this.y=g,this.z=I}set(A,g,I){return void 0===I&&(I=this.z),this.x=A,this.y=g,this.z=I,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,g){switch(A){case 0:this.x=g;break;case 1:this.y=g;break;case 2:this.z=g;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,g){return this.x=A.x+g.x,this.y=A.y+g.y,this.z=A.z+g.z,this}addScaledVector(A,g){return this.x+=A.x*g,this.y+=A.y*g,this.z+=A.z*g,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,g){return this.x=A.x-g.x,this.y=A.y-g.y,this.z=A.z-g.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,g){return this.x=A.x*g.x,this.y=A.y*g.y,this.z=A.z*g.z,this}applyEuler(A){return this.applyQuaternion(nI.setFromEuler(A))}applyAxisAngle(A,g){return this.applyQuaternion(nI.setFromAxisAngle(A,g))}applyMatrix3(A){const g=this.x,I=this.y,t=this.z,C=A.elements;return this.x=C[0]*g+C[3]*I+C[6]*t,this.y=C[1]*g+C[4]*I+C[7]*t,this.z=C[2]*g+C[5]*I+C[8]*t,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const g=this.x,I=this.y,t=this.z,C=A.elements,e=1/(C[3]*g+C[7]*I+C[11]*t+C[15]);return this.x=(C[0]*g+C[4]*I+C[8]*t+C[12])*e,this.y=(C[1]*g+C[5]*I+C[9]*t+C[13])*e,this.z=(C[2]*g+C[6]*I+C[10]*t+C[14])*e,this}applyQuaternion(A){const g=this.x,I=this.y,t=this.z,C=A.x,e=A.y,B=A.z,i=A.w,Q=i*g+e*t-B*I,o=i*I+B*g-C*t,E=i*t+C*I-e*g,n=-C*g-e*I-B*t;return this.x=Q*i+n*-C+o*-B-E*-e,this.y=o*i+n*-e+E*-C-Q*-B,this.z=E*i+n*-B+Q*-e-o*-C,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const g=this.x,I=this.y,t=this.z,C=A.elements;return this.x=C[0]*g+C[4]*I+C[8]*t,this.y=C[1]*g+C[5]*I+C[9]*t,this.z=C[2]*g+C[6]*I+C[10]*t,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,g){return this.x=Math.max(A.x,Math.min(g.x,this.x)),this.y=Math.max(A.y,Math.min(g.y,this.y)),this.z=Math.max(A.z,Math.min(g.z,this.z)),this}clampScalar(A,g){return this.x=Math.max(A,Math.min(g,this.x)),this.y=Math.max(A,Math.min(g,this.y)),this.z=Math.max(A,Math.min(g,this.z)),this}clampLength(A,g){const I=this.length();return this.divideScalar(I||1).multiplyScalar(Math.max(A,Math.min(g,I)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,g){return this.x+=(A.x-this.x)*g,this.y+=(A.y-this.y)*g,this.z+=(A.z-this.z)*g,this}lerpVectors(A,g,I){return this.x=A.x+(g.x-A.x)*I,this.y=A.y+(g.y-A.y)*I,this.z=A.z+(g.z-A.z)*I,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,g){const I=A.x,t=A.y,C=A.z,e=g.x,B=g.y,i=g.z;return this.x=t*i-C*B,this.y=C*e-I*i,this.z=I*B-t*e,this}projectOnVector(A){const g=A.lengthSq();if(0===g)return this.set(0,0,0);const I=A.dot(this)/g;return this.copy(A).multiplyScalar(I)}projectOnPlane(A){return EI.copy(this).projectOnVector(A),this.sub(EI)}reflect(A){return this.sub(EI.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const g=Math.sqrt(this.lengthSq()*A.lengthSq());if(0===g)return Math.PI/2;const I=this.dot(A)/g;return Math.acos(kg(I,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const g=this.x-A.x,I=this.y-A.y,t=this.z-A.z;return g*g+I*I+t*t}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,g,I){const t=Math.sin(g)*A;return this.x=t*Math.sin(I),this.y=Math.cos(g)*A,this.z=t*Math.cos(I),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,g,I){return this.x=A*Math.sin(g),this.y=I,this.z=A*Math.cos(g),this}setFromMatrixPosition(A){const g=A.elements;return this.x=g[12],this.y=g[13],this.z=g[14],this}setFromMatrixScale(A){const g=this.setFromMatrixColumn(A,0).length(),I=this.setFromMatrixColumn(A,1).length(),t=this.setFromMatrixColumn(A,2).length();return this.x=g,this.y=I,this.z=t,this}setFromMatrixColumn(A,g){return this.fromArray(A.elements,4*g)}setFromMatrix3Column(A,g){return this.fromArray(A.elements,3*g)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,g=0){return this.x=A[g],this.y=A[g+1],this.z=A[g+2],this}toArray(A=[],g=0){return A[g]=this.x,A[g+1]=this.y,A[g+2]=this.z,A}fromBufferAttribute(A,g){return this.x=A.getX(g),this.y=A.getY(g),this.z=A.getZ(g),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=2*(Math.random()-.5),g=Math.random()*Math.PI*2,I=Math.sqrt(1-A**2);return this.x=I*Math.cos(g),this.y=I*Math.sin(g),this.z=A,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const EI=new oI,nI=new QI;class sI{constructor(A=new oI(1/0,1/0,1/0),g=new oI(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=g}set(A,g){return this.min.copy(A),this.max.copy(g),this}setFromArray(A){let g=1/0,I=1/0,t=1/0,C=-1/0,e=-1/0,B=-1/0;for(let i=0,Q=A.length;i<Q;i+=3){const Q=A[i],o=A[i+1],E=A[i+2];Q<g&&(g=Q),o<I&&(I=o),E<t&&(t=E),Q>C&&(C=Q),o>e&&(e=o),E>B&&(B=E)}return this.min.set(g,I,t),this.max.set(C,e,B),this}setFromBufferAttribute(A){let g=1/0,I=1/0,t=1/0,C=-1/0,e=-1/0,B=-1/0;for(let i=0,Q=A.count;i<Q;i++){const Q=A.getX(i),o=A.getY(i),E=A.getZ(i);Q<g&&(g=Q),o<I&&(I=o),E<t&&(t=E),Q>C&&(C=Q),o>e&&(e=o),E>B&&(B=E)}return this.min.set(g,I,t),this.max.set(C,e,B),this}setFromPoints(A){this.makeEmpty();for(let g=0,I=A.length;g<I;g++)this.expandByPoint(A[g]);return this}setFromCenterAndSize(A,g){const I=rI.copy(g).multiplyScalar(.5);return this.min.copy(A).sub(I),this.max.copy(A).add(I),this}setFromObject(A,g=!1){return this.makeEmpty(),this.expandByObject(A,g)}clone(){return(new this.constructor).copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,g=!1){A.updateWorldMatrix(!1,!1);const I=A.geometry;if(void 0!==I)if(g&&null!=I.attributes&&void 0!==I.attributes.position){const g=I.attributes.position;for(let I=0,t=g.count;I<t;I++)rI.fromBufferAttribute(g,I).applyMatrix4(A.matrixWorld),this.expandByPoint(rI)}else null===I.boundingBox&&I.computeBoundingBox(),hI.copy(I.boundingBox),hI.applyMatrix4(A.matrixWorld),this.union(hI);const t=A.children;for(let A=0,I=t.length;A<I;A++)this.expandByObject(t[A],g);return this}containsPoint(A){return!(A.x<this.min.x||A.x>this.max.x||A.y<this.min.y||A.y>this.max.y||A.z<this.min.z||A.z>this.max.z)}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,g){return g.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return!(A.max.x<this.min.x||A.min.x>this.max.x||A.max.y<this.min.y||A.min.y>this.max.y||A.max.z<this.min.z||A.min.z>this.max.z)}intersectsSphere(A){return this.clampPoint(A.center,rI),rI.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let g,I;return A.normal.x>0?(g=A.normal.x*this.min.x,I=A.normal.x*this.max.x):(g=A.normal.x*this.max.x,I=A.normal.x*this.min.x),A.normal.y>0?(g+=A.normal.y*this.min.y,I+=A.normal.y*this.max.y):(g+=A.normal.y*this.max.y,I+=A.normal.y*this.min.y),A.normal.z>0?(g+=A.normal.z*this.min.z,I+=A.normal.z*this.max.z):(g+=A.normal.z*this.max.z,I+=A.normal.z*this.min.z),g<=-A.constant&&I>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(pI),yI.subVectors(this.max,pI),cI.subVectors(A.a,pI),lI.subVectors(A.b,pI),DI.subVectors(A.c,pI),uI.subVectors(lI,cI),wI.subVectors(DI,lI),dI.subVectors(cI,DI);let g=[0,-uI.z,uI.y,0,-wI.z,wI.y,0,-dI.z,dI.y,uI.z,0,-uI.x,wI.z,0,-wI.x,dI.z,0,-dI.x,-uI.y,uI.x,0,-wI.y,wI.x,0,-dI.y,dI.x,0];return!!NI(g,cI,lI,DI,yI)&&(g=[1,0,0,0,1,0,0,0,1],!!NI(g,cI,lI,DI,yI)&&(GI.crossVectors(uI,wI),g=[GI.x,GI.y,GI.z],NI(g,cI,lI,DI,yI)))}clampPoint(A,g){return g.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return rI.copy(A).clamp(this.min,this.max).sub(A).length()}getBoundingSphere(A){return this.getCenter(A.center),A.radius=.5*this.getSize(rI).length(),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()||(aI[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),aI[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),aI[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),aI[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),aI[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),aI[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),aI[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),aI[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(aI)),this}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const aI=[new oI,new oI,new oI,new oI,new oI,new oI,new oI,new oI],rI=new oI,hI=new sI,cI=new oI,lI=new oI,DI=new oI,uI=new oI,wI=new oI,dI=new oI,pI=new oI,yI=new oI,GI=new oI,fI=new oI;function NI(A,g,I,t,C){for(let e=0,B=A.length-3;e<=B;e+=3){fI.fromArray(A,e);const B=C.x*Math.abs(fI.x)+C.y*Math.abs(fI.y)+C.z*Math.abs(fI.z),i=g.dot(fI),Q=I.dot(fI),o=t.dot(fI);if(Math.max(-Math.max(i,Q,o),Math.min(i,Q,o))>B)return!1}return!0}const FI=new sI,RI=new oI,mI=new oI,kI=new oI;class SI{constructor(A=new oI,g=-1){this.center=A,this.radius=g}set(A,g){return this.center.copy(A),this.radius=g,this}setFromPoints(A,g){const I=this.center;void 0!==g?I.copy(g):FI.setFromPoints(A).getCenter(I);let t=0;for(let g=0,C=A.length;g<C;g++)t=Math.max(t,I.distanceToSquared(A[g]));return this.radius=Math.sqrt(t),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const g=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=g*g}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,g){const I=this.center.distanceToSquared(A);return g.copy(A),I>this.radius*this.radius&&(g.sub(this.center).normalize(),g.multiplyScalar(this.radius).add(this.center)),g}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;kI.subVectors(A,this.center);const g=kI.lengthSq();if(g>this.radius*this.radius){const A=Math.sqrt(g),I=.5*(A-this.radius);this.center.add(kI.multiplyScalar(I/A)),this.radius+=I}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(!0===this.center.equals(A.center)?mI.set(0,0,1).multiplyScalar(A.radius):mI.subVectors(A.center,this.center).normalize().multiplyScalar(A.radius),this.expandByPoint(RI.copy(A.center).add(mI)),this.expandByPoint(RI.copy(A.center).sub(mI)),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const MI=new oI,UI=new oI,KI=new oI,JI=new oI,YI=new oI,LI=new oI,xI=new oI;class bI{constructor(A=new oI,g=new oI(0,0,-1)){this.origin=A,this.direction=g}set(A,g){return this.origin.copy(A),this.direction.copy(g),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,g){return g.copy(this.direction).multiplyScalar(A).add(this.origin)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,MI)),this}closestPointToPoint(A,g){g.subVectors(A,this.origin);const I=g.dot(this.direction);return I<0?g.copy(this.origin):g.copy(this.direction).multiplyScalar(I).add(this.origin)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const g=MI.subVectors(A,this.origin).dot(this.direction);return g<0?this.origin.distanceToSquared(A):(MI.copy(this.direction).multiplyScalar(g).add(this.origin),MI.distanceToSquared(A))}distanceSqToSegment(A,g,I,t){UI.copy(A).add(g).multiplyScalar(.5),KI.copy(g).sub(A).normalize(),JI.copy(this.origin).sub(UI);const C=.5*A.distanceTo(g),e=-this.direction.dot(KI),B=JI.dot(this.direction),i=-JI.dot(KI),Q=JI.lengthSq(),o=Math.abs(1-e*e);let E,n,s,a;if(o>0)if(E=e*i-B,n=e*B-i,a=C*o,E>=0)if(n>=-a)if(n<=a){const A=1/o;E*=A,n*=A,s=E*(E+e*n+2*B)+n*(e*E+n+2*i)+Q}else n=C,E=Math.max(0,-(e*n+B)),s=-E*E+n*(n+2*i)+Q;else n=-C,E=Math.max(0,-(e*n+B)),s=-E*E+n*(n+2*i)+Q;else n<=-a?(E=Math.max(0,-(-e*C+B)),n=E>0?-C:Math.min(Math.max(-C,-i),C),s=-E*E+n*(n+2*i)+Q):n<=a?(E=0,n=Math.min(Math.max(-C,-i),C),s=n*(n+2*i)+Q):(E=Math.max(0,-(e*C+B)),n=E>0?C:Math.min(Math.max(-C,-i),C),s=-E*E+n*(n+2*i)+Q);else n=e>0?-C:C,E=Math.max(0,-(e*n+B)),s=-E*E+n*(n+2*i)+Q;return I&&I.copy(this.direction).multiplyScalar(E).add(this.origin),t&&t.copy(KI).multiplyScalar(n).add(UI),s}intersectSphere(A,g){MI.subVectors(A.center,this.origin);const I=MI.dot(this.direction),t=MI.dot(MI)-I*I,C=A.radius*A.radius;if(t>C)return null;const e=Math.sqrt(C-t),B=I-e,i=I+e;return B<0&&i<0?null:B<0?this.at(i,g):this.at(B,g)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const g=A.normal.dot(this.direction);if(0===g)return 0===A.distanceToPoint(this.origin)?0:null;const I=-(this.origin.dot(A.normal)+A.constant)/g;return I>=0?I:null}intersectPlane(A,g){const I=this.distanceToPlane(A);return null===I?null:this.at(I,g)}intersectsPlane(A){const g=A.distanceToPoint(this.origin);if(0===g)return!0;return A.normal.dot(this.direction)*g<0}intersectBox(A,g){let I,t,C,e,B,i;const Q=1/this.direction.x,o=1/this.direction.y,E=1/this.direction.z,n=this.origin;return Q>=0?(I=(A.min.x-n.x)*Q,t=(A.max.x-n.x)*Q):(I=(A.max.x-n.x)*Q,t=(A.min.x-n.x)*Q),o>=0?(C=(A.min.y-n.y)*o,e=(A.max.y-n.y)*o):(C=(A.max.y-n.y)*o,e=(A.min.y-n.y)*o),I>e||C>t?null:((C>I||I!=I)&&(I=C),(e<t||t!=t)&&(t=e),E>=0?(B=(A.min.z-n.z)*E,i=(A.max.z-n.z)*E):(B=(A.max.z-n.z)*E,i=(A.min.z-n.z)*E),I>i||B>t?null:((B>I||I!=I)&&(I=B),(i<t||t!=t)&&(t=i),t<0?null:this.at(I>=0?I:t,g)))}intersectsBox(A){return null!==this.intersectBox(A,MI)}intersectTriangle(A,g,I,t,C){YI.subVectors(g,A),LI.subVectors(I,A),xI.crossVectors(YI,LI);let e,B=this.direction.dot(xI);if(B>0){if(t)return null;e=1}else{if(!(B<0))return null;e=-1,B=-B}JI.subVectors(this.origin,A);const i=e*this.direction.dot(LI.crossVectors(JI,LI));if(i<0)return null;const Q=e*this.direction.dot(YI.cross(JI));if(Q<0)return null;if(i+Q>B)return null;const o=-e*JI.dot(xI);return o<0?null:this.at(o/B,C)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class HI{constructor(){HI.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(A,g,I,t,C,e,B,i,Q,o,E,n,s,a,r,h){const c=this.elements;return c[0]=A,c[4]=g,c[8]=I,c[12]=t,c[1]=C,c[5]=e,c[9]=B,c[13]=i,c[2]=Q,c[6]=o,c[10]=E,c[14]=n,c[3]=s,c[7]=a,c[11]=r,c[15]=h,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new HI).fromArray(this.elements)}copy(A){const g=this.elements,I=A.elements;return g[0]=I[0],g[1]=I[1],g[2]=I[2],g[3]=I[3],g[4]=I[4],g[5]=I[5],g[6]=I[6],g[7]=I[7],g[8]=I[8],g[9]=I[9],g[10]=I[10],g[11]=I[11],g[12]=I[12],g[13]=I[13],g[14]=I[14],g[15]=I[15],this}copyPosition(A){const g=this.elements,I=A.elements;return g[12]=I[12],g[13]=I[13],g[14]=I[14],this}setFromMatrix3(A){const g=A.elements;return this.set(g[0],g[3],g[6],0,g[1],g[4],g[7],0,g[2],g[5],g[8],0,0,0,0,1),this}extractBasis(A,g,I){return A.setFromMatrixColumn(this,0),g.setFromMatrixColumn(this,1),I.setFromMatrixColumn(this,2),this}makeBasis(A,g,I){return this.set(A.x,g.x,I.x,0,A.y,g.y,I.y,0,A.z,g.z,I.z,0,0,0,0,1),this}extractRotation(A){const g=this.elements,I=A.elements,t=1/qI.setFromMatrixColumn(A,0).length(),C=1/qI.setFromMatrixColumn(A,1).length(),e=1/qI.setFromMatrixColumn(A,2).length();return g[0]=I[0]*t,g[1]=I[1]*t,g[2]=I[2]*t,g[3]=0,g[4]=I[4]*C,g[5]=I[5]*C,g[6]=I[6]*C,g[7]=0,g[8]=I[8]*e,g[9]=I[9]*e,g[10]=I[10]*e,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,this}makeRotationFromEuler(A){const g=this.elements,I=A.x,t=A.y,C=A.z,e=Math.cos(I),B=Math.sin(I),i=Math.cos(t),Q=Math.sin(t),o=Math.cos(C),E=Math.sin(C);if("XYZ"===A.order){const A=e*o,I=e*E,t=B*o,C=B*E;g[0]=i*o,g[4]=-i*E,g[8]=Q,g[1]=I+t*Q,g[5]=A-C*Q,g[9]=-B*i,g[2]=C-A*Q,g[6]=t+I*Q,g[10]=e*i}else if("YXZ"===A.order){const A=i*o,I=i*E,t=Q*o,C=Q*E;g[0]=A+C*B,g[4]=t*B-I,g[8]=e*Q,g[1]=e*E,g[5]=e*o,g[9]=-B,g[2]=I*B-t,g[6]=C+A*B,g[10]=e*i}else if("ZXY"===A.order){const A=i*o,I=i*E,t=Q*o,C=Q*E;g[0]=A-C*B,g[4]=-e*E,g[8]=t+I*B,g[1]=I+t*B,g[5]=e*o,g[9]=C-A*B,g[2]=-e*Q,g[6]=B,g[10]=e*i}else if("ZYX"===A.order){const A=e*o,I=e*E,t=B*o,C=B*E;g[0]=i*o,g[4]=t*Q-I,g[8]=A*Q+C,g[1]=i*E,g[5]=C*Q+A,g[9]=I*Q-t,g[2]=-Q,g[6]=B*i,g[10]=e*i}else if("YZX"===A.order){const A=e*i,I=e*Q,t=B*i,C=B*Q;g[0]=i*o,g[4]=C-A*E,g[8]=t*E+I,g[1]=E,g[5]=e*o,g[9]=-B*o,g[2]=-Q*o,g[6]=I*E+t,g[10]=A-C*E}else if("XZY"===A.order){const A=e*i,I=e*Q,t=B*i,C=B*Q;g[0]=i*o,g[4]=-E,g[8]=Q*o,g[1]=A*E+C,g[5]=e*o,g[9]=I*E-t,g[2]=t*E-I,g[6]=B*o,g[10]=C*E+A}return g[3]=0,g[7]=0,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,this}makeRotationFromQuaternion(A){return this.compose(vI,A,VI)}lookAt(A,g,I){const t=this.elements;return ZI.subVectors(A,g),0===ZI.lengthSq()&&(ZI.z=1),ZI.normalize(),WI.crossVectors(I,ZI),0===WI.lengthSq()&&(1===Math.abs(I.z)?ZI.x+=1e-4:ZI.z+=1e-4,ZI.normalize(),WI.crossVectors(I,ZI)),WI.normalize(),OI.crossVectors(ZI,WI),t[0]=WI.x,t[4]=OI.x,t[8]=ZI.x,t[1]=WI.y,t[5]=OI.y,t[9]=ZI.y,t[2]=WI.z,t[6]=OI.z,t[10]=ZI.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,g){const I=A.elements,t=g.elements,C=this.elements,e=I[0],B=I[4],i=I[8],Q=I[12],o=I[1],E=I[5],n=I[9],s=I[13],a=I[2],r=I[6],h=I[10],c=I[14],l=I[3],D=I[7],u=I[11],w=I[15],d=t[0],p=t[4],y=t[8],G=t[12],f=t[1],N=t[5],F=t[9],R=t[13],m=t[2],k=t[6],S=t[10],M=t[14],U=t[3],K=t[7],J=t[11],Y=t[15];return C[0]=e*d+B*f+i*m+Q*U,C[4]=e*p+B*N+i*k+Q*K,C[8]=e*y+B*F+i*S+Q*J,C[12]=e*G+B*R+i*M+Q*Y,C[1]=o*d+E*f+n*m+s*U,C[5]=o*p+E*N+n*k+s*K,C[9]=o*y+E*F+n*S+s*J,C[13]=o*G+E*R+n*M+s*Y,C[2]=a*d+r*f+h*m+c*U,C[6]=a*p+r*N+h*k+c*K,C[10]=a*y+r*F+h*S+c*J,C[14]=a*G+r*R+h*M+c*Y,C[3]=l*d+D*f+u*m+w*U,C[7]=l*p+D*N+u*k+w*K,C[11]=l*y+D*F+u*S+w*J,C[15]=l*G+D*R+u*M+w*Y,this}multiplyScalar(A){const g=this.elements;return g[0]*=A,g[4]*=A,g[8]*=A,g[12]*=A,g[1]*=A,g[5]*=A,g[9]*=A,g[13]*=A,g[2]*=A,g[6]*=A,g[10]*=A,g[14]*=A,g[3]*=A,g[7]*=A,g[11]*=A,g[15]*=A,this}determinant(){const A=this.elements,g=A[0],I=A[4],t=A[8],C=A[12],e=A[1],B=A[5],i=A[9],Q=A[13],o=A[2],E=A[6],n=A[10],s=A[14];return A[3]*(+C*i*E-t*Q*E-C*B*n+I*Q*n+t*B*s-I*i*s)+A[7]*(+g*i*s-g*Q*n+C*e*n-t*e*s+t*Q*o-C*i*o)+A[11]*(+g*Q*E-g*B*s-C*e*E+I*e*s+C*B*o-I*Q*o)+A[15]*(-t*B*o-g*i*E+g*B*n+t*e*E-I*e*n+I*i*o)}transpose(){const A=this.elements;let g;return g=A[1],A[1]=A[4],A[4]=g,g=A[2],A[2]=A[8],A[8]=g,g=A[6],A[6]=A[9],A[9]=g,g=A[3],A[3]=A[12],A[12]=g,g=A[7],A[7]=A[13],A[13]=g,g=A[11],A[11]=A[14],A[14]=g,this}setPosition(A,g,I){const t=this.elements;return A.isVector3?(t[12]=A.x,t[13]=A.y,t[14]=A.z):(t[12]=A,t[13]=g,t[14]=I),this}invert(){const A=this.elements,g=A[0],I=A[1],t=A[2],C=A[3],e=A[4],B=A[5],i=A[6],Q=A[7],o=A[8],E=A[9],n=A[10],s=A[11],a=A[12],r=A[13],h=A[14],c=A[15],l=E*h*Q-r*n*Q+r*i*s-B*h*s-E*i*c+B*n*c,D=a*n*Q-o*h*Q-a*i*s+e*h*s+o*i*c-e*n*c,u=o*r*Q-a*E*Q+a*B*s-e*r*s-o*B*c+e*E*c,w=a*E*i-o*r*i-a*B*n+e*r*n+o*B*h-e*E*h,d=g*l+I*D+t*u+C*w;if(0===d)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const p=1/d;return A[0]=l*p,A[1]=(r*n*C-E*h*C-r*t*s+I*h*s+E*t*c-I*n*c)*p,A[2]=(B*h*C-r*i*C+r*t*Q-I*h*Q-B*t*c+I*i*c)*p,A[3]=(E*i*C-B*n*C-E*t*Q+I*n*Q+B*t*s-I*i*s)*p,A[4]=D*p,A[5]=(o*h*C-a*n*C+a*t*s-g*h*s-o*t*c+g*n*c)*p,A[6]=(a*i*C-e*h*C-a*t*Q+g*h*Q+e*t*c-g*i*c)*p,A[7]=(e*n*C-o*i*C+o*t*Q-g*n*Q-e*t*s+g*i*s)*p,A[8]=u*p,A[9]=(a*E*C-o*r*C-a*I*s+g*r*s+o*I*c-g*E*c)*p,A[10]=(e*r*C-a*B*C+a*I*Q-g*r*Q-e*I*c+g*B*c)*p,A[11]=(o*B*C-e*E*C-o*I*Q+g*E*Q+e*I*s-g*B*s)*p,A[12]=w*p,A[13]=(o*r*t-a*E*t+a*I*n-g*r*n-o*I*h+g*E*h)*p,A[14]=(a*B*t-e*r*t-a*I*i+g*r*i+e*I*h-g*B*h)*p,A[15]=(e*E*t-o*B*t+o*I*i-g*E*i-e*I*n+g*B*n)*p,this}scale(A){const g=this.elements,I=A.x,t=A.y,C=A.z;return g[0]*=I,g[4]*=t,g[8]*=C,g[1]*=I,g[5]*=t,g[9]*=C,g[2]*=I,g[6]*=t,g[10]*=C,g[3]*=I,g[7]*=t,g[11]*=C,this}getMaxScaleOnAxis(){const A=this.elements,g=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],I=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],t=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(g,I,t))}makeTranslation(A,g,I){return this.set(1,0,0,A,0,1,0,g,0,0,1,I,0,0,0,1),this}makeRotationX(A){const g=Math.cos(A),I=Math.sin(A);return this.set(1,0,0,0,0,g,-I,0,0,I,g,0,0,0,0,1),this}makeRotationY(A){const g=Math.cos(A),I=Math.sin(A);return this.set(g,0,I,0,0,1,0,0,-I,0,g,0,0,0,0,1),this}makeRotationZ(A){const g=Math.cos(A),I=Math.sin(A);return this.set(g,-I,0,0,I,g,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,g){const I=Math.cos(g),t=Math.sin(g),C=1-I,e=A.x,B=A.y,i=A.z,Q=C*e,o=C*B;return this.set(Q*e+I,Q*B-t*i,Q*i+t*B,0,Q*B+t*i,o*B+I,o*i-t*e,0,Q*i-t*B,o*i+t*e,C*i*i+I,0,0,0,0,1),this}makeScale(A,g,I){return this.set(A,0,0,0,0,g,0,0,0,0,I,0,0,0,0,1),this}makeShear(A,g,I,t,C,e){return this.set(1,I,C,0,A,1,e,0,g,t,1,0,0,0,0,1),this}compose(A,g,I){const t=this.elements,C=g._x,e=g._y,B=g._z,i=g._w,Q=C+C,o=e+e,E=B+B,n=C*Q,s=C*o,a=C*E,r=e*o,h=e*E,c=B*E,l=i*Q,D=i*o,u=i*E,w=I.x,d=I.y,p=I.z;return t[0]=(1-(r+c))*w,t[1]=(s+u)*w,t[2]=(a-D)*w,t[3]=0,t[4]=(s-u)*d,t[5]=(1-(n+c))*d,t[6]=(h+l)*d,t[7]=0,t[8]=(a+D)*p,t[9]=(h-l)*p,t[10]=(1-(n+r))*p,t[11]=0,t[12]=A.x,t[13]=A.y,t[14]=A.z,t[15]=1,this}decompose(A,g,I){const t=this.elements;let C=qI.set(t[0],t[1],t[2]).length();const e=qI.set(t[4],t[5],t[6]).length(),B=qI.set(t[8],t[9],t[10]).length();this.determinant()<0&&(C=-C),A.x=t[12],A.y=t[13],A.z=t[14],TI.copy(this);const i=1/C,Q=1/e,o=1/B;return TI.elements[0]*=i,TI.elements[1]*=i,TI.elements[2]*=i,TI.elements[4]*=Q,TI.elements[5]*=Q,TI.elements[6]*=Q,TI.elements[8]*=o,TI.elements[9]*=o,TI.elements[10]*=o,g.setFromRotationMatrix(TI),I.x=C,I.y=e,I.z=B,this}makePerspective(A,g,I,t,C,e){const B=this.elements,i=2*C/(g-A),Q=2*C/(I-t),o=(g+A)/(g-A),E=(I+t)/(I-t),n=-(e+C)/(e-C),s=-2*e*C/(e-C);return B[0]=i,B[4]=0,B[8]=o,B[12]=0,B[1]=0,B[5]=Q,B[9]=E,B[13]=0,B[2]=0,B[6]=0,B[10]=n,B[14]=s,B[3]=0,B[7]=0,B[11]=-1,B[15]=0,this}makeOrthographic(A,g,I,t,C,e){const B=this.elements,i=1/(g-A),Q=1/(I-t),o=1/(e-C),E=(g+A)*i,n=(I+t)*Q,s=(e+C)*o;return B[0]=2*i,B[4]=0,B[8]=0,B[12]=-E,B[1]=0,B[5]=2*Q,B[9]=0,B[13]=-n,B[2]=0,B[6]=0,B[10]=-2*o,B[14]=-s,B[3]=0,B[7]=0,B[11]=0,B[15]=1,this}equals(A){const g=this.elements,I=A.elements;for(let A=0;A<16;A++)if(g[A]!==I[A])return!1;return!0}fromArray(A,g=0){for(let I=0;I<16;I++)this.elements[I]=A[I+g];return this}toArray(A=[],g=0){const I=this.elements;return A[g]=I[0],A[g+1]=I[1],A[g+2]=I[2],A[g+3]=I[3],A[g+4]=I[4],A[g+5]=I[5],A[g+6]=I[6],A[g+7]=I[7],A[g+8]=I[8],A[g+9]=I[9],A[g+10]=I[10],A[g+11]=I[11],A[g+12]=I[12],A[g+13]=I[13],A[g+14]=I[14],A[g+15]=I[15],A}}const qI=new oI,TI=new HI,vI=new oI(0,0,0),VI=new oI(1,1,1),WI=new oI,OI=new oI,ZI=new oI,PI=new HI,XI=new QI;class jI{constructor(A=0,g=0,I=0,t=jI.DefaultOrder){this.isEuler=!0,this._x=A,this._y=g,this._z=I,this._order=t}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,g,I,t=this._order){return this._x=A,this._y=g,this._z=I,this._order=t,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,g=this._order,I=!0){const t=A.elements,C=t[0],e=t[4],B=t[8],i=t[1],Q=t[5],o=t[9],E=t[2],n=t[6],s=t[10];switch(g){case"XYZ":this._y=Math.asin(kg(B,-1,1)),Math.abs(B)<.9999999?(this._x=Math.atan2(-o,s),this._z=Math.atan2(-e,C)):(this._x=Math.atan2(n,Q),this._z=0);break;case"YXZ":this._x=Math.asin(-kg(o,-1,1)),Math.abs(o)<.9999999?(this._y=Math.atan2(B,s),this._z=Math.atan2(i,Q)):(this._y=Math.atan2(-E,C),this._z=0);break;case"ZXY":this._x=Math.asin(kg(n,-1,1)),Math.abs(n)<.9999999?(this._y=Math.atan2(-E,s),this._z=Math.atan2(-e,Q)):(this._y=0,this._z=Math.atan2(i,C));break;case"ZYX":this._y=Math.asin(-kg(E,-1,1)),Math.abs(E)<.9999999?(this._x=Math.atan2(n,s),this._z=Math.atan2(i,C)):(this._x=0,this._z=Math.atan2(-e,Q));break;case"YZX":this._z=Math.asin(kg(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-o,Q),this._y=Math.atan2(-E,C)):(this._x=0,this._y=Math.atan2(B,s));break;case"XZY":this._z=Math.asin(-kg(e,-1,1)),Math.abs(e)<.9999999?(this._x=Math.atan2(n,Q),this._y=Math.atan2(B,C)):(this._x=Math.atan2(-o,s),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+g)}return this._order=g,!0===I&&this._onChangeCallback(),this}setFromQuaternion(A,g,I){return PI.makeRotationFromQuaternion(A),this.setFromRotationMatrix(PI,g,I)}setFromVector3(A,g=this._order){return this.set(A.x,A.y,A.z,g)}reorder(A){return XI.setFromEuler(this),this.setFromQuaternion(XI,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],void 0!==A[3]&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],g=0){return A[g]=this._x,A[g+1]=this._y,A[g+2]=this._z,A[g+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}jI.DefaultOrder="XYZ",jI.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class zI{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return 0!=(this.mask&A.mask)}isEnabled(A){return 0!=(this.mask&(1<<A|0))}}let _I=0;const $I=new oI,At=new QI,gt=new HI,It=new oI,tt=new oI,Ct=new oI,et=new QI,Bt=new oI(1,0,0),it=new oI(0,1,0),Qt=new oI(0,0,1),ot={type:"added"},Et={type:"removed"};class nt extends fg{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_I++}),this.uuid=mg(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=nt.DefaultUp.clone();const A=new oI,g=new jI,I=new QI,t=new oI(1,1,1);g._onChange((function(){I.setFromEuler(g,!1)})),I._onChange((function(){g.setFromQuaternion(I,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:g},quaternion:{configurable:!0,enumerable:!0,value:I},scale:{configurable:!0,enumerable:!0,value:t},modelViewMatrix:{value:new HI},normalMatrix:{value:new xg}}),this.matrix=new HI,this.matrixWorld=new HI,this.matrixAutoUpdate=nt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=nt.DefaultMatrixWorldAutoUpdate,this.layers=new zI,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,g){this.quaternion.setFromAxisAngle(A,g)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,g){return At.setFromAxisAngle(A,g),this.quaternion.multiply(At),this}rotateOnWorldAxis(A,g){return At.setFromAxisAngle(A,g),this.quaternion.premultiply(At),this}rotateX(A){return this.rotateOnAxis(Bt,A)}rotateY(A){return this.rotateOnAxis(it,A)}rotateZ(A){return this.rotateOnAxis(Qt,A)}translateOnAxis(A,g){return $I.copy(A).applyQuaternion(this.quaternion),this.position.add($I.multiplyScalar(g)),this}translateX(A){return this.translateOnAxis(Bt,A)}translateY(A){return this.translateOnAxis(it,A)}translateZ(A){return this.translateOnAxis(Qt,A)}localToWorld(A){return A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return A.applyMatrix4(gt.copy(this.matrixWorld).invert())}lookAt(A,g,I){A.isVector3?It.copy(A):It.set(A,g,I);const t=this.parent;this.updateWorldMatrix(!0,!1),tt.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?gt.lookAt(tt,It,this.up):gt.lookAt(It,tt,this.up),this.quaternion.setFromRotationMatrix(gt),t&&(gt.extractRotation(t.matrixWorld),At.setFromRotationMatrix(gt),this.quaternion.premultiply(At.invert()))}add(A){if(arguments.length>1){for(let A=0;A<arguments.length;A++)this.add(arguments[A]);return this}return A===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",A),this):(A&&A.isObject3D?(null!==A.parent&&A.parent.remove(A),A.parent=this,this.children.push(A),A.dispatchEvent(ot)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let A=0;A<arguments.length;A++)this.remove(arguments[A]);return this}const g=this.children.indexOf(A);return-1!==g&&(A.parent=null,this.children.splice(g,1),A.dispatchEvent(Et)),this}removeFromParent(){const A=this.parent;return null!==A&&A.remove(this),this}clear(){for(let A=0;A<this.children.length;A++){const g=this.children[A];g.parent=null,g.dispatchEvent(Et)}return this.children.length=0,this}attach(A){return this.updateWorldMatrix(!0,!1),gt.copy(this.matrixWorld).invert(),null!==A.parent&&(A.parent.updateWorldMatrix(!0,!1),gt.multiply(A.parent.matrixWorld)),A.applyMatrix4(gt),this.add(A),A.updateWorldMatrix(!1,!0),this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,g){if(this[A]===g)return this;for(let I=0,t=this.children.length;I<t;I++){const t=this.children[I].getObjectByProperty(A,g);if(void 0!==t)return t}}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(tt,A,Ct),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(tt,et,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const g=this.matrixWorld.elements;return A.set(g[8],g[9],g[10]).normalize()}raycast(){}traverse(A){A(this);const g=this.children;for(let I=0,t=g.length;I<t;I++)g[I].traverse(A)}traverseVisible(A){if(!1===this.visible)return;A(this);const g=this.children;for(let I=0,t=g.length;I<t;I++)g[I].traverseVisible(A)}traverseAncestors(A){const g=this.parent;null!==g&&(A(g),g.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,A=!0);const g=this.children;for(let I=0,t=g.length;I<t;I++){const t=g[I];!0!==t.matrixWorldAutoUpdate&&!0!==A||t.updateMatrixWorld(A)}}updateWorldMatrix(A,g){const I=this.parent;if(!0===A&&null!==I&&!0===I.matrixWorldAutoUpdate&&I.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===g){const A=this.children;for(let g=0,I=A.length;g<I;g++){const I=A[g];!0===I.matrixWorldAutoUpdate&&I.updateWorldMatrix(!1,!0)}}}toJSON(A){const g=void 0===A||"string"==typeof A,I={};g&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},I.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const t={};function C(g,I){return void 0===g[I.uuid]&&(g[I.uuid]=I.toJSON(A)),I.uuid}if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),!0===this.castShadow&&(t.castShadow=!0),!0===this.receiveShadow&&(t.receiveShadow=!0),!1===this.visible&&(t.visible=!1),!1===this.frustumCulled&&(t.frustumCulled=!1),0!==this.renderOrder&&(t.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),t.layers=this.layers.mask,t.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(t.matrixAutoUpdate=!1),this.isInstancedMesh&&(t.type="InstancedMesh",t.count=this.count,t.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(t.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?t.background=this.background.toJSON():this.background.isTexture&&(t.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(t.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){t.geometry=C(A.geometries,this.geometry);const g=this.geometry.parameters;if(void 0!==g&&void 0!==g.shapes){const I=g.shapes;if(Array.isArray(I))for(let g=0,t=I.length;g<t;g++){const t=I[g];C(A.shapes,t)}else C(A.shapes,I)}}if(this.isSkinnedMesh&&(t.bindMode=this.bindMode,t.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(C(A.skeletons,this.skeleton),t.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const g=[];for(let I=0,t=this.material.length;I<t;I++)g.push(C(A.materials,this.material[I]));t.material=g}else t.material=C(A.materials,this.material);if(this.children.length>0){t.children=[];for(let g=0;g<this.children.length;g++)t.children.push(this.children[g].toJSON(A).object)}if(this.animations.length>0){t.animations=[];for(let g=0;g<this.animations.length;g++){const I=this.animations[g];t.animations.push(C(A.animations,I))}}if(g){const g=e(A.geometries),t=e(A.materials),C=e(A.textures),B=e(A.images),i=e(A.shapes),Q=e(A.skeletons),o=e(A.animations),E=e(A.nodes);g.length>0&&(I.geometries=g),t.length>0&&(I.materials=t),C.length>0&&(I.textures=C),B.length>0&&(I.images=B),i.length>0&&(I.shapes=i),Q.length>0&&(I.skeletons=Q),o.length>0&&(I.animations=o),E.length>0&&(I.nodes=E)}return I.object=t,I;function e(A){const g=[];for(const I in A){const t=A[I];delete t.metadata,g.push(t)}return g}}clone(A){return(new this.constructor).copy(this,A)}copy(A,g=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.userData=JSON.parse(JSON.stringify(A.userData)),!0===g)for(let g=0;g<A.children.length;g++){const I=A.children[g];this.add(I.clone())}return this}}nt.DefaultUp=new oI(0,1,0),nt.DefaultMatrixAutoUpdate=!0,nt.DefaultMatrixWorldAutoUpdate=!0;const st=new oI,at=new oI,rt=new oI,ht=new oI,ct=new oI,lt=new oI,Dt=new oI,ut=new oI,wt=new oI,dt=new oI;class pt{constructor(A=new oI,g=new oI,I=new oI){this.a=A,this.b=g,this.c=I}static getNormal(A,g,I,t){t.subVectors(I,g),st.subVectors(A,g),t.cross(st);const C=t.lengthSq();return C>0?t.multiplyScalar(1/Math.sqrt(C)):t.set(0,0,0)}static getBarycoord(A,g,I,t,C){st.subVectors(t,g),at.subVectors(I,g),rt.subVectors(A,g);const e=st.dot(st),B=st.dot(at),i=st.dot(rt),Q=at.dot(at),o=at.dot(rt),E=e*Q-B*B;if(0===E)return C.set(-2,-1,-1);const n=1/E,s=(Q*i-B*o)*n,a=(e*o-B*i)*n;return C.set(1-s-a,a,s)}static containsPoint(A,g,I,t){return this.getBarycoord(A,g,I,t,ht),ht.x>=0&&ht.y>=0&&ht.x+ht.y<=1}static getUV(A,g,I,t,C,e,B,i){return this.getBarycoord(A,g,I,t,ht),i.set(0,0),i.addScaledVector(C,ht.x),i.addScaledVector(e,ht.y),i.addScaledVector(B,ht.z),i}static isFrontFacing(A,g,I,t){return st.subVectors(I,g),at.subVectors(A,g),st.cross(at).dot(t)<0}set(A,g,I){return this.a.copy(A),this.b.copy(g),this.c.copy(I),this}setFromPointsAndIndices(A,g,I,t){return this.a.copy(A[g]),this.b.copy(A[I]),this.c.copy(A[t]),this}setFromAttributeAndIndices(A,g,I,t){return this.a.fromBufferAttribute(A,g),this.b.fromBufferAttribute(A,I),this.c.fromBufferAttribute(A,t),this}clone(){return(new this.constructor).copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return st.subVectors(this.c,this.b),at.subVectors(this.a,this.b),.5*st.cross(at).length()}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return pt.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,g){return pt.getBarycoord(A,this.a,this.b,this.c,g)}getUV(A,g,I,t,C){return pt.getUV(A,this.a,this.b,this.c,g,I,t,C)}containsPoint(A){return pt.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return pt.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,g){const I=this.a,t=this.b,C=this.c;let e,B;ct.subVectors(t,I),lt.subVectors(C,I),ut.subVectors(A,I);const i=ct.dot(ut),Q=lt.dot(ut);if(i<=0&&Q<=0)return g.copy(I);wt.subVectors(A,t);const o=ct.dot(wt),E=lt.dot(wt);if(o>=0&&E<=o)return g.copy(t);const n=i*E-o*Q;if(n<=0&&i>=0&&o<=0)return e=i/(i-o),g.copy(I).addScaledVector(ct,e);dt.subVectors(A,C);const s=ct.dot(dt),a=lt.dot(dt);if(a>=0&&s<=a)return g.copy(C);const r=s*Q-i*a;if(r<=0&&Q>=0&&a<=0)return B=Q/(Q-a),g.copy(I).addScaledVector(lt,B);const h=o*a-s*E;if(h<=0&&E-o>=0&&s-a>=0)return Dt.subVectors(C,t),B=(E-o)/(E-o+(s-a)),g.copy(t).addScaledVector(Dt,B);const c=1/(h+r+n);return e=r*c,B=n*c,g.copy(I).addScaledVector(ct,e).addScaledVector(lt,B)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}let yt=0;class Gt extends fg{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:yt++}),this.uuid=mg(),this.name="",this.type="Material",this.blending=h,this.side=n,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=m,this.blendDst=k,this.blendEquation=w,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=b,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=dg,this.stencilZFail=dg,this.stencilZPass=dg,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(void 0!==A)for(const g in A){const I=A[g];if(void 0===I){console.warn("THREE.Material: '"+g+"' parameter is undefined.");continue}const t=this[g];void 0!==t?t&&t.isColor?t.set(I):t&&t.isVector3&&I&&I.isVector3?t.copy(I):this[g]=I:console.warn("THREE."+this.type+": '"+g+"' is not a property of this material.")}}toJSON(A){const g=void 0===A||"string"==typeof A;g&&(A={textures:{},images:{}});const I={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function t(A){const g=[];for(const I in A){const t=A[I];delete t.metadata,g.push(t)}return g}if(I.uuid=this.uuid,I.type=this.type,""!==this.name&&(I.name=this.name),this.color&&this.color.isColor&&(I.color=this.color.getHex()),void 0!==this.roughness&&(I.roughness=this.roughness),void 0!==this.metalness&&(I.metalness=this.metalness),void 0!==this.sheen&&(I.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(I.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(I.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(I.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(I.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(I.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(I.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(I.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(I.shininess=this.shininess),void 0!==this.clearcoat&&(I.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(I.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(I.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(I.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(I.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,I.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(I.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(I.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(I.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(I.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(I.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(I.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(I.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(I.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(I.lightMap=this.lightMap.toJSON(A).uuid,I.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(I.aoMap=this.aoMap.toJSON(A).uuid,I.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(I.bumpMap=this.bumpMap.toJSON(A).uuid,I.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(I.normalMap=this.normalMap.toJSON(A).uuid,I.normalMapType=this.normalMapType,I.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(I.displacementMap=this.displacementMap.toJSON(A).uuid,I.displacementScale=this.displacementScale,I.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(I.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(I.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(I.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(I.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(I.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(I.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(I.envMap=this.envMap.toJSON(A).uuid,void 0!==this.combine&&(I.combine=this.combine)),void 0!==this.envMapIntensity&&(I.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(I.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(I.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(I.gradientMap=this.gradientMap.toJSON(A).uuid),void 0!==this.transmission&&(I.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(I.transmissionMap=this.transmissionMap.toJSON(A).uuid),void 0!==this.thickness&&(I.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(I.thicknessMap=this.thicknessMap.toJSON(A).uuid),void 0!==this.attenuationDistance&&(I.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(I.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(I.size=this.size),null!==this.shadowSide&&(I.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(I.sizeAttenuation=this.sizeAttenuation),this.blending!==h&&(I.blending=this.blending),this.side!==n&&(I.side=this.side),this.vertexColors&&(I.vertexColors=!0),this.opacity<1&&(I.opacity=this.opacity),!0===this.transparent&&(I.transparent=this.transparent),I.depthFunc=this.depthFunc,I.depthTest=this.depthTest,I.depthWrite=this.depthWrite,I.colorWrite=this.colorWrite,I.stencilWrite=this.stencilWrite,I.stencilWriteMask=this.stencilWriteMask,I.stencilFunc=this.stencilFunc,I.stencilRef=this.stencilRef,I.stencilFuncMask=this.stencilFuncMask,I.stencilFail=this.stencilFail,I.stencilZFail=this.stencilZFail,I.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(I.rotation=this.rotation),!0===this.polygonOffset&&(I.polygonOffset=!0),0!==this.polygonOffsetFactor&&(I.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(I.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(I.linewidth=this.linewidth),void 0!==this.dashSize&&(I.dashSize=this.dashSize),void 0!==this.gapSize&&(I.gapSize=this.gapSize),void 0!==this.scale&&(I.scale=this.scale),!0===this.dithering&&(I.dithering=!0),this.alphaTest>0&&(I.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(I.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(I.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(I.wireframe=this.wireframe),this.wireframeLinewidth>1&&(I.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(I.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(I.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(I.flatShading=this.flatShading),!1===this.visible&&(I.visible=!1),!1===this.toneMapped&&(I.toneMapped=!1),!1===this.fog&&(I.fog=!1),"{}"!==JSON.stringify(this.userData)&&(I.userData=this.userData),g){const g=t(A.textures),C=t(A.images);g.length>0&&(I.textures=g),C.length>0&&(I.images=C)}return I}clone(){return(new this.constructor).copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const g=A.clippingPlanes;let I=null;if(null!==g){const A=g.length;I=new Array(A);for(let t=0;t!==A;++t)I[t]=g[t].clone()}return this.clippingPlanes=I,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){!0===A&&this.version++}}class ft extends Gt{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new zg(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=V,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const Nt=new oI,Ft=new Lg;class Rt{constructor(A,g,I){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=g,this.count=void 0!==A?A.length/g:0,this.normalized=!0===I,this.usage=pg,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(A){!0===A&&this.version++}setUsage(A){return this.usage=A,this}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this}copyAt(A,g,I){A*=this.itemSize,I*=g.itemSize;for(let t=0,C=this.itemSize;t<C;t++)this.array[A+t]=g.array[I+t];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(2===this.itemSize)for(let g=0,I=this.count;g<I;g++)Ft.fromBufferAttribute(this,g),Ft.applyMatrix3(A),this.setXY(g,Ft.x,Ft.y);else if(3===this.itemSize)for(let g=0,I=this.count;g<I;g++)Nt.fromBufferAttribute(this,g),Nt.applyMatrix3(A),this.setXYZ(g,Nt.x,Nt.y,Nt.z);return this}applyMatrix4(A){for(let g=0,I=this.count;g<I;g++)Nt.fromBufferAttribute(this,g),Nt.applyMatrix4(A),this.setXYZ(g,Nt.x,Nt.y,Nt.z);return this}applyNormalMatrix(A){for(let g=0,I=this.count;g<I;g++)Nt.fromBufferAttribute(this,g),Nt.applyNormalMatrix(A),this.setXYZ(g,Nt.x,Nt.y,Nt.z);return this}transformDirection(A){for(let g=0,I=this.count;g<I;g++)Nt.fromBufferAttribute(this,g),Nt.transformDirection(A),this.setXYZ(g,Nt.x,Nt.y,Nt.z);return this}set(A,g=0){return this.array.set(A,g),this}getX(A){let g=this.array[A*this.itemSize];return this.normalized&&(g=Jg(g,this.array)),g}setX(A,g){return this.normalized&&(g=Yg(g,this.array)),this.array[A*this.itemSize]=g,this}getY(A){let g=this.array[A*this.itemSize+1];return this.normalized&&(g=Jg(g,this.array)),g}setY(A,g){return this.normalized&&(g=Yg(g,this.array)),this.array[A*this.itemSize+1]=g,this}getZ(A){let g=this.array[A*this.itemSize+2];return this.normalized&&(g=Jg(g,this.array)),g}setZ(A,g){return this.normalized&&(g=Yg(g,this.array)),this.array[A*this.itemSize+2]=g,this}getW(A){let g=this.array[A*this.itemSize+3];return this.normalized&&(g=Jg(g,this.array)),g}setW(A,g){return this.normalized&&(g=Yg(g,this.array)),this.array[A*this.itemSize+3]=g,this}setXY(A,g,I){return A*=this.itemSize,this.normalized&&(g=Yg(g,this.array),I=Yg(I,this.array)),this.array[A+0]=g,this.array[A+1]=I,this}setXYZ(A,g,I,t){return A*=this.itemSize,this.normalized&&(g=Yg(g,this.array),I=Yg(I,this.array),t=Yg(t,this.array)),this.array[A+0]=g,this.array[A+1]=I,this.array[A+2]=t,this}setXYZW(A,g,I,t,C){return A*=this.itemSize,this.normalized&&(g=Yg(g,this.array),I=Yg(I,this.array),t=Yg(t,this.array),C=Yg(C,this.array)),this.array[A+0]=g,this.array[A+1]=I,this.array[A+2]=t,this.array[A+3]=C,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(A.name=this.name),this.usage!==pg&&(A.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(A.updateRange=this.updateRange),A}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class mt extends Rt{constructor(A,g,I){super(new Uint16Array(A),g,I)}}class kt extends Rt{constructor(A,g,I){super(new Uint32Array(A),g,I)}}class St extends Rt{constructor(A,g,I){super(new Float32Array(A),g,I)}}let Mt=0;const Ut=new HI,Kt=new nt,Jt=new oI,Yt=new sI,Lt=new sI,xt=new oI;class bt extends fg{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Mt++}),this.uuid=mg(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(bg(A)?kt:mt)(A,1):this.index=A,this}getAttribute(A){return this.attributes[A]}setAttribute(A,g){return this.attributes[A]=g,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return void 0!==this.attributes[A]}addGroup(A,g,I=0){this.groups.push({start:A,count:g,materialIndex:I})}clearGroups(){this.groups=[]}setDrawRange(A,g){this.drawRange.start=A,this.drawRange.count=g}applyMatrix4(A){const g=this.attributes.position;void 0!==g&&(g.applyMatrix4(A),g.needsUpdate=!0);const I=this.attributes.normal;if(void 0!==I){const g=(new xg).getNormalMatrix(A);I.applyNormalMatrix(g),I.needsUpdate=!0}const t=this.attributes.tangent;return void 0!==t&&(t.transformDirection(A),t.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(A){return Ut.makeRotationFromQuaternion(A),this.applyMatrix4(Ut),this}rotateX(A){return Ut.makeRotationX(A),this.applyMatrix4(Ut),this}rotateY(A){return Ut.makeRotationY(A),this.applyMatrix4(Ut),this}rotateZ(A){return Ut.makeRotationZ(A),this.applyMatrix4(Ut),this}translate(A,g,I){return Ut.makeTranslation(A,g,I),this.applyMatrix4(Ut),this}scale(A,g,I){return Ut.makeScale(A,g,I),this.applyMatrix4(Ut),this}lookAt(A){return Kt.lookAt(A),Kt.updateMatrix(),this.applyMatrix4(Kt.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Jt).negate(),this.translate(Jt.x,Jt.y,Jt.z),this}setFromPoints(A){const g=[];for(let I=0,t=A.length;I<t;I++){const t=A[I];g.push(t.x,t.y,t.z||0)}return this.setAttribute("position",new St(g,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new sI);const A=this.attributes.position,g=this.morphAttributes.position;if(A&&A.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new oI(-1/0,-1/0,-1/0),new oI(1/0,1/0,1/0));if(void 0!==A){if(this.boundingBox.setFromBufferAttribute(A),g)for(let A=0,I=g.length;A<I;A++){const I=g[A];Yt.setFromBufferAttribute(I),this.morphTargetsRelative?(xt.addVectors(this.boundingBox.min,Yt.min),this.boundingBox.expandByPoint(xt),xt.addVectors(this.boundingBox.max,Yt.max),this.boundingBox.expandByPoint(xt)):(this.boundingBox.expandByPoint(Yt.min),this.boundingBox.expandByPoint(Yt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new SI);const A=this.attributes.position,g=this.morphAttributes.position;if(A&&A.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new oI,1/0);if(A){const I=this.boundingSphere.center;if(Yt.setFromBufferAttribute(A),g)for(let A=0,I=g.length;A<I;A++){const I=g[A];Lt.setFromBufferAttribute(I),this.morphTargetsRelative?(xt.addVectors(Yt.min,Lt.min),Yt.expandByPoint(xt),xt.addVectors(Yt.max,Lt.max),Yt.expandByPoint(xt)):(Yt.expandByPoint(Lt.min),Yt.expandByPoint(Lt.max))}Yt.getCenter(I);let t=0;for(let g=0,C=A.count;g<C;g++)xt.fromBufferAttribute(A,g),t=Math.max(t,I.distanceToSquared(xt));if(g)for(let C=0,e=g.length;C<e;C++){const e=g[C],B=this.morphTargetsRelative;for(let g=0,C=e.count;g<C;g++)xt.fromBufferAttribute(e,g),B&&(Jt.fromBufferAttribute(A,g),xt.add(Jt)),t=Math.max(t,I.distanceToSquared(xt))}this.boundingSphere.radius=Math.sqrt(t),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const A=this.index,g=this.attributes;if(null===A||void 0===g.position||void 0===g.normal||void 0===g.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const I=A.array,t=g.position.array,C=g.normal.array,e=g.uv.array,B=t.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Rt(new Float32Array(4*B),4));const i=this.getAttribute("tangent").array,Q=[],o=[];for(let A=0;A<B;A++)Q[A]=new oI,o[A]=new oI;const E=new oI,n=new oI,s=new oI,a=new Lg,r=new Lg,h=new Lg,c=new oI,l=new oI;function D(A,g,I){E.fromArray(t,3*A),n.fromArray(t,3*g),s.fromArray(t,3*I),a.fromArray(e,2*A),r.fromArray(e,2*g),h.fromArray(e,2*I),n.sub(E),s.sub(E),r.sub(a),h.sub(a);const C=1/(r.x*h.y-h.x*r.y);isFinite(C)&&(c.copy(n).multiplyScalar(h.y).addScaledVector(s,-r.y).multiplyScalar(C),l.copy(s).multiplyScalar(r.x).addScaledVector(n,-h.x).multiplyScalar(C),Q[A].add(c),Q[g].add(c),Q[I].add(c),o[A].add(l),o[g].add(l),o[I].add(l))}let u=this.groups;0===u.length&&(u=[{start:0,count:I.length}]);for(let A=0,g=u.length;A<g;++A){const g=u[A],t=g.start;for(let A=t,C=t+g.count;A<C;A+=3)D(I[A+0],I[A+1],I[A+2])}const w=new oI,d=new oI,p=new oI,y=new oI;function G(A){p.fromArray(C,3*A),y.copy(p);const g=Q[A];w.copy(g),w.sub(p.multiplyScalar(p.dot(g))).normalize(),d.crossVectors(y,g);const I=d.dot(o[A])<0?-1:1;i[4*A]=w.x,i[4*A+1]=w.y,i[4*A+2]=w.z,i[4*A+3]=I}for(let A=0,g=u.length;A<g;++A){const g=u[A],t=g.start;for(let A=t,C=t+g.count;A<C;A+=3)G(I[A+0]),G(I[A+1]),G(I[A+2])}}computeVertexNormals(){const A=this.index,g=this.getAttribute("position");if(void 0!==g){let I=this.getAttribute("normal");if(void 0===I)I=new Rt(new Float32Array(3*g.count),3),this.setAttribute("normal",I);else for(let A=0,g=I.count;A<g;A++)I.setXYZ(A,0,0,0);const t=new oI,C=new oI,e=new oI,B=new oI,i=new oI,Q=new oI,o=new oI,E=new oI;if(A)for(let n=0,s=A.count;n<s;n+=3){const s=A.getX(n+0),a=A.getX(n+1),r=A.getX(n+2);t.fromBufferAttribute(g,s),C.fromBufferAttribute(g,a),e.fromBufferAttribute(g,r),o.subVectors(e,C),E.subVectors(t,C),o.cross(E),B.fromBufferAttribute(I,s),i.fromBufferAttribute(I,a),Q.fromBufferAttribute(I,r),B.add(o),i.add(o),Q.add(o),I.setXYZ(s,B.x,B.y,B.z),I.setXYZ(a,i.x,i.y,i.z),I.setXYZ(r,Q.x,Q.y,Q.z)}else for(let A=0,B=g.count;A<B;A+=3)t.fromBufferAttribute(g,A+0),C.fromBufferAttribute(g,A+1),e.fromBufferAttribute(g,A+2),o.subVectors(e,C),E.subVectors(t,C),o.cross(E),I.setXYZ(A+0,o.x,o.y,o.z),I.setXYZ(A+1,o.x,o.y,o.z),I.setXYZ(A+2,o.x,o.y,o.z);this.normalizeNormals(),I.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const A=this.attributes.normal;for(let g=0,I=A.count;g<I;g++)xt.fromBufferAttribute(A,g),xt.normalize(),A.setXYZ(g,xt.x,xt.y,xt.z)}toNonIndexed(){function A(A,g){const I=A.array,t=A.itemSize,C=A.normalized,e=new I.constructor(g.length*t);let B=0,i=0;for(let C=0,Q=g.length;C<Q;C++){B=A.isInterleavedBufferAttribute?g[C]*A.data.stride+A.offset:g[C]*t;for(let A=0;A<t;A++)e[i++]=I[B++]}return new Rt(e,t,C)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const g=new bt,I=this.index.array,t=this.attributes;for(const C in t){const e=A(t[C],I);g.setAttribute(C,e)}const C=this.morphAttributes;for(const t in C){const e=[],B=C[t];for(let g=0,t=B.length;g<t;g++){const t=A(B[g],I);e.push(t)}g.morphAttributes[t]=e}g.morphTargetsRelative=this.morphTargetsRelative;const e=this.groups;for(let A=0,I=e.length;A<I;A++){const I=e[A];g.addGroup(I.start,I.count,I.materialIndex)}return g}toJSON(){const A={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,""!==this.name&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),void 0!==this.parameters){const g=this.parameters;for(const I in g)void 0!==g[I]&&(A[I]=g[I]);return A}A.data={attributes:{}};const g=this.index;null!==g&&(A.data.index={type:g.array.constructor.name,array:Array.prototype.slice.call(g.array)});const I=this.attributes;for(const g in I){const t=I[g];A.data.attributes[g]=t.toJSON(A.data)}const t={};let C=!1;for(const g in this.morphAttributes){const I=this.morphAttributes[g],e=[];for(let g=0,t=I.length;g<t;g++){const t=I[g];e.push(t.toJSON(A.data))}e.length>0&&(t[g]=e,C=!0)}C&&(A.data.morphAttributes=t,A.data.morphTargetsRelative=this.morphTargetsRelative);const e=this.groups;e.length>0&&(A.data.groups=JSON.parse(JSON.stringify(e)));const B=this.boundingSphere;return null!==B&&(A.data.boundingSphere={center:B.center.toArray(),radius:B.radius}),A}clone(){return(new this.constructor).copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const g={};this.name=A.name;const I=A.index;null!==I&&this.setIndex(I.clone(g));const t=A.attributes;for(const A in t){const I=t[A];this.setAttribute(A,I.clone(g))}const C=A.morphAttributes;for(const A in C){const I=[],t=C[A];for(let A=0,C=t.length;A<C;A++)I.push(t[A].clone(g));this.morphAttributes[A]=I}this.morphTargetsRelative=A.morphTargetsRelative;const e=A.groups;for(let A=0,g=e.length;A<g;A++){const g=e[A];this.addGroup(g.start,g.count,g.materialIndex)}const B=A.boundingBox;null!==B&&(this.boundingBox=B.clone());const i=A.boundingSphere;return null!==i&&(this.boundingSphere=i.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,void 0!==A.parameters&&(this.parameters=Object.assign({},A.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ht=new HI,qt=new bI,Tt=new SI,vt=new oI,Vt=new oI,Wt=new oI,Ot=new oI,Zt=new oI,Pt=new oI,Xt=new oI,jt=new oI,zt=new oI,_t=new Lg,$t=new Lg,AC=new Lg,gC=new oI,IC=new oI;class tC extends nt{constructor(A=new bt,g=new ft){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=g,this.updateMorphTargets()}copy(A,g){return super.copy(A,g),void 0!==A.morphTargetInfluences&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),void 0!==A.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=A.material,this.geometry=A.geometry,this}updateMorphTargets(){const A=this.geometry.morphAttributes,g=Object.keys(A);if(g.length>0){const I=A[g[0]];if(void 0!==I){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let A=0,g=I.length;A<g;A++){const g=I[A].name||String(A);this.morphTargetInfluences.push(0),this.morphTargetDictionary[g]=A}}}}raycast(A,g){const I=this.geometry,t=this.material,C=this.matrixWorld;if(void 0===t)return;if(null===I.boundingSphere&&I.computeBoundingSphere(),Tt.copy(I.boundingSphere),Tt.applyMatrix4(C),!1===A.ray.intersectsSphere(Tt))return;if(Ht.copy(C).invert(),qt.copy(A.ray).applyMatrix4(Ht),null!==I.boundingBox&&!1===qt.intersectsBox(I.boundingBox))return;let e;const B=I.index,i=I.attributes.position,Q=I.morphAttributes.position,o=I.morphTargetsRelative,E=I.attributes.uv,n=I.attributes.uv2,s=I.groups,a=I.drawRange;if(null!==B)if(Array.isArray(t))for(let I=0,C=s.length;I<C;I++){const C=s[I],r=t[C.materialIndex];for(let I=Math.max(C.start,a.start),t=Math.min(B.count,Math.min(C.start+C.count,a.start+a.count));I<t;I+=3){const t=B.getX(I),s=B.getX(I+1),a=B.getX(I+2);e=CC(this,r,A,qt,i,Q,o,E,n,t,s,a),e&&(e.faceIndex=Math.floor(I/3),e.face.materialIndex=C.materialIndex,g.push(e))}}else{for(let I=Math.max(0,a.start),C=Math.min(B.count,a.start+a.count);I<C;I+=3){const C=B.getX(I),s=B.getX(I+1),a=B.getX(I+2);e=CC(this,t,A,qt,i,Q,o,E,n,C,s,a),e&&(e.faceIndex=Math.floor(I/3),g.push(e))}}else if(void 0!==i)if(Array.isArray(t))for(let I=0,C=s.length;I<C;I++){const C=s[I],B=t[C.materialIndex];for(let I=Math.max(C.start,a.start),t=Math.min(i.count,Math.min(C.start+C.count,a.start+a.count));I<t;I+=3){e=CC(this,B,A,qt,i,Q,o,E,n,I,I+1,I+2),e&&(e.faceIndex=Math.floor(I/3),e.face.materialIndex=C.materialIndex,g.push(e))}}else{for(let I=Math.max(0,a.start),C=Math.min(i.count,a.start+a.count);I<C;I+=3){e=CC(this,t,A,qt,i,Q,o,E,n,I,I+1,I+2),e&&(e.faceIndex=Math.floor(I/3),g.push(e))}}}}function CC(A,g,I,t,C,e,B,i,Q,o,E,n){vt.fromBufferAttribute(C,o),Vt.fromBufferAttribute(C,E),Wt.fromBufferAttribute(C,n);const r=A.morphTargetInfluences;if(e&&r){Xt.set(0,0,0),jt.set(0,0,0),zt.set(0,0,0);for(let A=0,g=e.length;A<g;A++){const g=r[A],I=e[A];0!==g&&(Ot.fromBufferAttribute(I,o),Zt.fromBufferAttribute(I,E),Pt.fromBufferAttribute(I,n),B?(Xt.addScaledVector(Ot,g),jt.addScaledVector(Zt,g),zt.addScaledVector(Pt,g)):(Xt.addScaledVector(Ot.sub(vt),g),jt.addScaledVector(Zt.sub(Vt),g),zt.addScaledVector(Pt.sub(Wt),g)))}vt.add(Xt),Vt.add(jt),Wt.add(zt)}A.isSkinnedMesh&&(A.boneTransform(o,vt),A.boneTransform(E,Vt),A.boneTransform(n,Wt));const h=function(A,g,I,t,C,e,B,i){let Q;if(Q=g.side===s?t.intersectTriangle(B,e,C,!0,i):t.intersectTriangle(C,e,B,g.side!==a,i),null===Q)return null;IC.copy(i),IC.applyMatrix4(A.matrixWorld);const o=I.ray.origin.distanceTo(IC);return o<I.near||o>I.far?null:{distance:o,point:IC.clone(),object:A}}(A,g,I,t,vt,Vt,Wt,gC);if(h){i&&(_t.fromBufferAttribute(i,o),$t.fromBufferAttribute(i,E),AC.fromBufferAttribute(i,n),h.uv=pt.getUV(gC,vt,Vt,Wt,_t,$t,AC,new Lg)),Q&&(_t.fromBufferAttribute(Q,o),$t.fromBufferAttribute(Q,E),AC.fromBufferAttribute(Q,n),h.uv2=pt.getUV(gC,vt,Vt,Wt,_t,$t,AC,new Lg));const A={a:o,b:E,c:n,normal:new oI,materialIndex:0};pt.getNormal(vt,Vt,Wt,A.normal),h.face=A}return h}class eC extends bt{constructor(A=1,g=1,I=1,t=1,C=1,e=1){super(),this.type="BoxGeometry",this.parameters={width:A,height:g,depth:I,widthSegments:t,heightSegments:C,depthSegments:e};const B=this;t=Math.floor(t),C=Math.floor(C),e=Math.floor(e);const i=[],Q=[],o=[],E=[];let n=0,s=0;function a(A,g,I,t,C,e,a,r,h,c,l){const D=e/h,u=a/c,w=e/2,d=a/2,p=r/2,y=h+1,G=c+1;let f=0,N=0;const F=new oI;for(let e=0;e<G;e++){const B=e*u-d;for(let i=0;i<y;i++){const n=i*D-w;F[A]=n*t,F[g]=B*C,F[I]=p,Q.push(F.x,F.y,F.z),F[A]=0,F[g]=0,F[I]=r>0?1:-1,o.push(F.x,F.y,F.z),E.push(i/h),E.push(1-e/c),f+=1}}for(let A=0;A<c;A++)for(let g=0;g<h;g++){const I=n+g+y*A,t=n+g+y*(A+1),C=n+(g+1)+y*(A+1),e=n+(g+1)+y*A;i.push(I,t,e),i.push(t,C,e),N+=6}B.addGroup(s,N,l),s+=N,n+=f}a("z","y","x",-1,-1,I,g,A,e,C,0),a("z","y","x",1,-1,I,g,-A,e,C,1),a("x","z","y",1,1,A,I,g,t,e,2),a("x","z","y",1,-1,A,I,-g,t,e,3),a("x","y","z",1,-1,A,g,I,t,C,4),a("x","y","z",-1,-1,A,g,-I,t,C,5),this.setIndex(i),this.setAttribute("position",new St(Q,3)),this.setAttribute("normal",new St(o,3)),this.setAttribute("uv",new St(E,2))}static fromJSON(A){return new eC(A.width,A.height,A.depth,A.widthSegments,A.heightSegments,A.depthSegments)}}function BC(A){const g={};for(const I in A){g[I]={};for(const t in A[I]){const C=A[I][t];C&&(C.isColor||C.isMatrix3||C.isMatrix4||C.isVector2||C.isVector3||C.isVector4||C.isTexture||C.isQuaternion)?g[I][t]=C.clone():Array.isArray(C)?g[I][t]=C.slice():g[I][t]=C}}return g}function iC(A){const g={};for(let I=0;I<A.length;I++){const t=BC(A[I]);for(const A in t)g[A]=t[A]}return g}const QC={clone:BC,merge:iC};class oC extends Gt{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==A&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=BC(A.uniforms),this.uniformsGroups=function(A){const g=[];for(let I=0;I<A.length;I++)g.push(A[I].clone());return g}(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const g=super.toJSON(A);g.glslVersion=this.glslVersion,g.uniforms={};for(const I in this.uniforms){const t=this.uniforms[I].value;t&&t.isTexture?g.uniforms[I]={type:"t",value:t.toJSON(A).uuid}:t&&t.isColor?g.uniforms[I]={type:"c",value:t.getHex()}:t&&t.isVector2?g.uniforms[I]={type:"v2",value:t.toArray()}:t&&t.isVector3?g.uniforms[I]={type:"v3",value:t.toArray()}:t&&t.isVector4?g.uniforms[I]={type:"v4",value:t.toArray()}:t&&t.isMatrix3?g.uniforms[I]={type:"m3",value:t.toArray()}:t&&t.isMatrix4?g.uniforms[I]={type:"m4",value:t.toArray()}:g.uniforms[I]={value:t}}Object.keys(this.defines).length>0&&(g.defines=this.defines),g.vertexShader=this.vertexShader,g.fragmentShader=this.fragmentShader;const I={};for(const A in this.extensions)!0===this.extensions[A]&&(I[A]=!0);return Object.keys(I).length>0&&(g.extensions=I),g}}class EC extends nt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new HI,this.projectionMatrix=new HI,this.projectionMatrixInverse=new HI}copy(A,g){return super.copy(A,g),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const g=this.matrixWorld.elements;return A.set(-g[8],-g[9],-g[10]).normalize()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,g){super.updateWorldMatrix(A,g),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class nC extends EC{constructor(A=50,g=1,I=.1,t=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=A,this.zoom=1,this.near=I,this.far=t,this.focus=10,this.aspect=g,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(A,g){return super.copy(A,g),this.fov=A.fov,this.zoom=A.zoom,this.near=A.near,this.far=A.far,this.focus=A.focus,this.aspect=A.aspect,this.view=null===A.view?null:Object.assign({},A.view),this.filmGauge=A.filmGauge,this.filmOffset=A.filmOffset,this}setFocalLength(A){const g=.5*this.getFilmHeight()/A;this.fov=2*Rg*Math.atan(g),this.updateProjectionMatrix()}getFocalLength(){const A=Math.tan(.5*Fg*this.fov);return.5*this.getFilmHeight()/A}getEffectiveFOV(){return 2*Rg*Math.atan(Math.tan(.5*Fg*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(A,g,I,t,C,e){this.aspect=A/g,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=g,this.view.offsetX=I,this.view.offsetY=t,this.view.width=C,this.view.height=e,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=this.near;let g=A*Math.tan(.5*Fg*this.fov)/this.zoom,I=2*g,t=this.aspect*I,C=-.5*t;const e=this.view;if(null!==this.view&&this.view.enabled){const A=e.fullWidth,B=e.fullHeight;C+=e.offsetX*t/A,g-=e.offsetY*I/B,t*=e.width/A,I*=e.height/B}const B=this.filmOffset;0!==B&&(C+=A*B/this.getFilmWidth()),this.projectionMatrix.makePerspective(C,C+t,g,g-I,A,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const g=super.toJSON(A);return g.object.fov=this.fov,g.object.zoom=this.zoom,g.object.near=this.near,g.object.far=this.far,g.object.focus=this.focus,g.object.aspect=this.aspect,null!==this.view&&(g.object.view=Object.assign({},this.view)),g.object.filmGauge=this.filmGauge,g.object.filmOffset=this.filmOffset,g}}const sC=90;class aC extends nt{constructor(A,g,I){super(),this.type="CubeCamera",this.renderTarget=I;const t=new nC(sC,1,A,g);t.layers=this.layers,t.up.set(0,-1,0),t.lookAt(new oI(1,0,0)),this.add(t);const C=new nC(sC,1,A,g);C.layers=this.layers,C.up.set(0,-1,0),C.lookAt(new oI(-1,0,0)),this.add(C);const e=new nC(sC,1,A,g);e.layers=this.layers,e.up.set(0,0,1),e.lookAt(new oI(0,1,0)),this.add(e);const B=new nC(sC,1,A,g);B.layers=this.layers,B.up.set(0,0,-1),B.lookAt(new oI(0,-1,0)),this.add(B);const i=new nC(sC,1,A,g);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new oI(0,0,1)),this.add(i);const Q=new nC(sC,1,A,g);Q.layers=this.layers,Q.up.set(0,-1,0),Q.lookAt(new oI(0,0,-1)),this.add(Q)}update(A,g){null===this.parent&&this.updateMatrixWorld();const I=this.renderTarget,[t,C,e,B,i,Q]=this.children,o=A.getRenderTarget(),E=A.toneMapping,n=A.xr.enabled;A.toneMapping=Z,A.xr.enabled=!1;const s=I.texture.generateMipmaps;I.texture.generateMipmaps=!1,A.setRenderTarget(I,0),A.render(g,t),A.setRenderTarget(I,1),A.render(g,C),A.setRenderTarget(I,2),A.render(g,e),A.setRenderTarget(I,3),A.render(g,B),A.setRenderTarget(I,4),A.render(g,i),I.texture.generateMipmaps=s,A.setRenderTarget(I,5),A.render(g,Q),A.setRenderTarget(o),A.toneMapping=E,A.xr.enabled=n,I.texture.needsPMREMUpdate=!0}}class rC extends tI{constructor(A,g,I,t,C,e,B,i,Q,o){super(A=void 0!==A?A:[],g=void 0!==g?g:$,I,t,C,e,B,i,Q,o),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(A){this.image=A}}class hC extends eI{constructor(A,g={}){super(A,A,g),this.isWebGLCubeRenderTarget=!0;const I={width:A,height:A,depth:1},t=[I,I,I,I,I,I];this.texture=new rC(t,g.mapping,g.wrapS,g.wrapT,g.magFilter,g.minFilter,g.format,g.type,g.anisotropy,g.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==g.generateMipmaps&&g.generateMipmaps,this.texture.minFilter=void 0!==g.minFilter?g.minFilter:EA}fromEquirectangularTexture(A,g){this.texture.type=g.type,this.texture.encoding=g.encoding,this.texture.generateMipmaps=g.generateMipmaps,this.texture.minFilter=g.minFilter,this.texture.magFilter=g.magFilter;const I={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},t=new eC(5,5,5),C=new oC({name:"CubemapFromEquirect",uniforms:BC(I.uniforms),vertexShader:I.vertexShader,fragmentShader:I.fragmentShader,side:s,blending:r});C.uniforms.tEquirect.value=g;const e=new tC(t,C),B=g.minFilter;g.minFilter===sA&&(g.minFilter=EA);return new aC(1,10,this).update(A,e),g.minFilter=B,e.geometry.dispose(),e.material.dispose(),this}clear(A,g,I,t){const C=A.getRenderTarget();for(let C=0;C<6;C++)A.setRenderTarget(this,C),A.clear(g,I,t);A.setRenderTarget(C)}}const cC=new oI,lC=new oI,DC=new xg;class uC{constructor(A=new oI(1,0,0),g=0){this.isPlane=!0,this.normal=A,this.constant=g}set(A,g){return this.normal.copy(A),this.constant=g,this}setComponents(A,g,I,t){return this.normal.set(A,g,I),this.constant=t,this}setFromNormalAndCoplanarPoint(A,g){return this.normal.copy(A),this.constant=-g.dot(this.normal),this}setFromCoplanarPoints(A,g,I){const t=cC.subVectors(I,g).cross(lC.subVectors(A,g)).normalize();return this.setFromNormalAndCoplanarPoint(t,A),this}copy(A){return this.normal.copy(A.normal),this.constant=A.constant,this}normalize(){const A=1/this.normal.length();return this.normal.multiplyScalar(A),this.constant*=A,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(A){return this.normal.dot(A)+this.constant}distanceToSphere(A){return this.distanceToPoint(A.center)-A.radius}projectPoint(A,g){return g.copy(this.normal).multiplyScalar(-this.distanceToPoint(A)).add(A)}intersectLine(A,g){const I=A.delta(cC),t=this.normal.dot(I);if(0===t)return 0===this.distanceToPoint(A.start)?g.copy(A.start):null;const C=-(A.start.dot(this.normal)+this.constant)/t;return C<0||C>1?null:g.copy(I).multiplyScalar(C).add(A.start)}intersectsLine(A){const g=this.distanceToPoint(A.start),I=this.distanceToPoint(A.end);return g<0&&I>0||I<0&&g>0}intersectsBox(A){return A.intersectsPlane(this)}intersectsSphere(A){return A.intersectsPlane(this)}coplanarPoint(A){return A.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(A,g){const I=g||DC.getNormalMatrix(A),t=this.coplanarPoint(cC).applyMatrix4(A),C=this.normal.applyMatrix3(I).normalize();return this.constant=-t.dot(C),this}translate(A){return this.constant-=A.dot(this.normal),this}equals(A){return A.normal.equals(this.normal)&&A.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const wC=new SI,dC=new oI;class pC{constructor(A=new uC,g=new uC,I=new uC,t=new uC,C=new uC,e=new uC){this.planes=[A,g,I,t,C,e]}set(A,g,I,t,C,e){const B=this.planes;return B[0].copy(A),B[1].copy(g),B[2].copy(I),B[3].copy(t),B[4].copy(C),B[5].copy(e),this}copy(A){const g=this.planes;for(let I=0;I<6;I++)g[I].copy(A.planes[I]);return this}setFromProjectionMatrix(A){const g=this.planes,I=A.elements,t=I[0],C=I[1],e=I[2],B=I[3],i=I[4],Q=I[5],o=I[6],E=I[7],n=I[8],s=I[9],a=I[10],r=I[11],h=I[12],c=I[13],l=I[14],D=I[15];return g[0].setComponents(B-t,E-i,r-n,D-h).normalize(),g[1].setComponents(B+t,E+i,r+n,D+h).normalize(),g[2].setComponents(B+C,E+Q,r+s,D+c).normalize(),g[3].setComponents(B-C,E-Q,r-s,D-c).normalize(),g[4].setComponents(B-e,E-o,r-a,D-l).normalize(),g[5].setComponents(B+e,E+o,r+a,D+l).normalize(),this}intersectsObject(A){const g=A.geometry;return null===g.boundingSphere&&g.computeBoundingSphere(),wC.copy(g.boundingSphere).applyMatrix4(A.matrixWorld),this.intersectsSphere(wC)}intersectsSprite(A){return wC.center.set(0,0,0),wC.radius=.7071067811865476,wC.applyMatrix4(A.matrixWorld),this.intersectsSphere(wC)}intersectsSphere(A){const g=this.planes,I=A.center,t=-A.radius;for(let A=0;A<6;A++){if(g[A].distanceToPoint(I)<t)return!1}return!0}intersectsBox(A){const g=this.planes;for(let I=0;I<6;I++){const t=g[I];if(dC.x=t.normal.x>0?A.max.x:A.min.x,dC.y=t.normal.y>0?A.max.y:A.min.y,dC.z=t.normal.z>0?A.max.z:A.min.z,t.distanceToPoint(dC)<0)return!1}return!0}containsPoint(A){const g=this.planes;for(let I=0;I<6;I++)if(g[I].distanceToPoint(A)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function yC(){let A=null,g=!1,I=null,t=null;function C(g,e){I(g,e),t=A.requestAnimationFrame(C)}return{start:function(){!0!==g&&null!==I&&(t=A.requestAnimationFrame(C),g=!0)},stop:function(){A.cancelAnimationFrame(t),g=!1},setAnimationLoop:function(A){I=A},setContext:function(g){A=g}}}function GC(A,g){const I=g.isWebGL2,t=new WeakMap;return{get:function(A){return A.isInterleavedBufferAttribute&&(A=A.data),t.get(A)},remove:function(g){g.isInterleavedBufferAttribute&&(g=g.data);const I=t.get(g);I&&(A.deleteBuffer(I.buffer),t.delete(g))},update:function(g,C){if(g.isGLBufferAttribute){const A=t.get(g);return void((!A||A.version<g.version)&&t.set(g,{buffer:g.buffer,type:g.type,bytesPerElement:g.elementSize,version:g.version}))}g.isInterleavedBufferAttribute&&(g=g.data);const e=t.get(g);void 0===e?t.set(g,function(g,t){const C=g.array,e=g.usage,B=A.createBuffer();let i;if(A.bindBuffer(t,B),A.bufferData(t,C,e),g.onUploadCallback(),C instanceof Float32Array)i=5126;else if(C instanceof Uint16Array)if(g.isFloat16BufferAttribute){if(!I)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");i=5131}else i=5123;else if(C instanceof Int16Array)i=5122;else if(C instanceof Uint32Array)i=5125;else if(C instanceof Int32Array)i=5124;else if(C instanceof Int8Array)i=5120;else if(C instanceof Uint8Array)i=5121;else{if(!(C instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+C);i=5121}return{buffer:B,type:i,bytesPerElement:C.BYTES_PER_ELEMENT,version:g.version}}(g,C)):e.version<g.version&&(!function(g,t,C){const e=t.array,B=t.updateRange;A.bindBuffer(C,g),-1===B.count?A.bufferSubData(C,0,e):(I?A.bufferSubData(C,B.offset*e.BYTES_PER_ELEMENT,e,B.offset,B.count):A.bufferSubData(C,B.offset*e.BYTES_PER_ELEMENT,e.subarray(B.offset,B.offset+B.count)),B.count=-1)}(e.buffer,g,C),e.version=g.version)}}}class fC extends bt{constructor(A=1,g=1,I=1,t=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:g,widthSegments:I,heightSegments:t};const C=A/2,e=g/2,B=Math.floor(I),i=Math.floor(t),Q=B+1,o=i+1,E=A/B,n=g/i,s=[],a=[],r=[],h=[];for(let A=0;A<o;A++){const g=A*n-e;for(let I=0;I<Q;I++){const t=I*E-C;a.push(t,-g,0),r.push(0,0,1),h.push(I/B),h.push(1-A/i)}}for(let A=0;A<i;A++)for(let g=0;g<B;g++){const I=g+Q*A,t=g+Q*(A+1),C=g+1+Q*(A+1),e=g+1+Q*A;s.push(I,t,e),s.push(t,C,e)}this.setIndex(s),this.setAttribute("position",new St(a,3)),this.setAttribute("normal",new St(r,3)),this.setAttribute("uv",new St(h,2))}static fromJSON(A){return new fC(A.width,A.height,A.widthSegments,A.heightSegments)}}const NC={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},FC={common:{diffuse:{value:new zg(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new xg},uv2Transform:{value:new xg},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Lg(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new zg(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new zg(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xg}},sprite:{diffuse:{value:new zg(16777215)},opacity:{value:1},center:{value:new Lg(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xg}}},RC={basic:{uniforms:iC([FC.common,FC.specularmap,FC.envmap,FC.aomap,FC.lightmap,FC.fog]),vertexShader:NC.meshbasic_vert,fragmentShader:NC.meshbasic_frag},lambert:{uniforms:iC([FC.common,FC.specularmap,FC.envmap,FC.aomap,FC.lightmap,FC.emissivemap,FC.bumpmap,FC.normalmap,FC.displacementmap,FC.fog,FC.lights,{emissive:{value:new zg(0)}}]),vertexShader:NC.meshlambert_vert,fragmentShader:NC.meshlambert_frag},phong:{uniforms:iC([FC.common,FC.specularmap,FC.envmap,FC.aomap,FC.lightmap,FC.emissivemap,FC.bumpmap,FC.normalmap,FC.displacementmap,FC.fog,FC.lights,{emissive:{value:new zg(0)},specular:{value:new zg(1118481)},shininess:{value:30}}]),vertexShader:NC.meshphong_vert,fragmentShader:NC.meshphong_frag},standard:{uniforms:iC([FC.common,FC.envmap,FC.aomap,FC.lightmap,FC.emissivemap,FC.bumpmap,FC.normalmap,FC.displacementmap,FC.roughnessmap,FC.metalnessmap,FC.fog,FC.lights,{emissive:{value:new zg(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:NC.meshphysical_vert,fragmentShader:NC.meshphysical_frag},toon:{uniforms:iC([FC.common,FC.aomap,FC.lightmap,FC.emissivemap,FC.bumpmap,FC.normalmap,FC.displacementmap,FC.gradientmap,FC.fog,FC.lights,{emissive:{value:new zg(0)}}]),vertexShader:NC.meshtoon_vert,fragmentShader:NC.meshtoon_frag},matcap:{uniforms:iC([FC.common,FC.bumpmap,FC.normalmap,FC.displacementmap,FC.fog,{matcap:{value:null}}]),vertexShader:NC.meshmatcap_vert,fragmentShader:NC.meshmatcap_frag},points:{uniforms:iC([FC.points,FC.fog]),vertexShader:NC.points_vert,fragmentShader:NC.points_frag},dashed:{uniforms:iC([FC.common,FC.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:NC.linedashed_vert,fragmentShader:NC.linedashed_frag},depth:{uniforms:iC([FC.common,FC.displacementmap]),vertexShader:NC.depth_vert,fragmentShader:NC.depth_frag},normal:{uniforms:iC([FC.common,FC.bumpmap,FC.normalmap,FC.displacementmap,{opacity:{value:1}}]),vertexShader:NC.meshnormal_vert,fragmentShader:NC.meshnormal_frag},sprite:{uniforms:iC([FC.sprite,FC.fog]),vertexShader:NC.sprite_vert,fragmentShader:NC.sprite_frag},background:{uniforms:{uvTransform:{value:new xg},t2D:{value:null}},vertexShader:NC.background_vert,fragmentShader:NC.background_frag},cube:{uniforms:iC([FC.envmap,{opacity:{value:1}}]),vertexShader:NC.cube_vert,fragmentShader:NC.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:NC.equirect_vert,fragmentShader:NC.equirect_frag},distanceRGBA:{uniforms:iC([FC.common,FC.displacementmap,{referencePosition:{value:new oI},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:NC.distanceRGBA_vert,fragmentShader:NC.distanceRGBA_frag},shadow:{uniforms:iC([FC.lights,FC.fog,{color:{value:new zg(0)},opacity:{value:1}}]),vertexShader:NC.shadow_vert,fragmentShader:NC.shadow_frag}};function mC(A,g,I,t,C,e){const B=new zg(0);let i,Q,o=!0===C?0:1,E=null,a=0,r=null;function h(A,g){I.buffers.color.setClear(A.r,A.g,A.b,g,e)}return{getClearColor:function(){return B},setClearColor:function(A,g=1){B.set(A),o=g,h(B,o)},getClearAlpha:function(){return o},setClearAlpha:function(A){o=A,h(B,o)},render:function(I,C){let e=!1,c=!0===C.isScene?C.background:null;c&&c.isTexture&&(c=g.get(c));const l=A.xr,D=l.getSession&&l.getSession();D&&"additive"===D.environmentBlendMode&&(c=null),null===c?h(B,o):c&&c.isColor&&(h(c,1),e=!0),(A.autoClear||e)&&A.clear(A.autoClearColor,A.autoClearDepth,A.autoClearStencil),c&&(c.isCubeTexture||c.mapping===tA)?(void 0===Q&&(Q=new tC(new eC(1,1,1),new oC({name:"BackgroundCubeMaterial",uniforms:BC(RC.cube.uniforms),vertexShader:RC.cube.vertexShader,fragmentShader:RC.cube.fragmentShader,side:s,depthTest:!1,depthWrite:!1,fog:!1})),Q.geometry.deleteAttribute("normal"),Q.geometry.deleteAttribute("uv"),Q.onBeforeRender=function(A,g,I){this.matrixWorld.copyPosition(I.matrixWorld)},Object.defineProperty(Q.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),t.update(Q)),Q.material.uniforms.envMap.value=c,Q.material.uniforms.flipEnvMap.value=c.isCubeTexture&&!1===c.isRenderTargetTexture?-1:1,E===c&&a===c.version&&r===A.toneMapping||(Q.material.needsUpdate=!0,E=c,a=c.version,r=A.toneMapping),Q.layers.enableAll(),I.unshift(Q,Q.geometry,Q.material,0,0,null)):c&&c.isTexture&&(void 0===i&&(i=new tC(new fC(2,2),new oC({name:"BackgroundMaterial",uniforms:BC(RC.background.uniforms),vertexShader:RC.background.vertexShader,fragmentShader:RC.background.fragmentShader,side:n,depthTest:!1,depthWrite:!1,fog:!1})),i.geometry.deleteAttribute("normal"),Object.defineProperty(i.material,"map",{get:function(){return this.uniforms.t2D.value}}),t.update(i)),i.material.uniforms.t2D.value=c,!0===c.matrixAutoUpdate&&c.updateMatrix(),i.material.uniforms.uvTransform.value.copy(c.matrix),E===c&&a===c.version&&r===A.toneMapping||(i.material.needsUpdate=!0,E=c,a=c.version,r=A.toneMapping),i.layers.enableAll(),I.unshift(i,i.geometry,i.material,0,0,null))}}}function kC(A,g,I,t){const C=A.getParameter(34921),e=t.isWebGL2?null:g.get("OES_vertex_array_object"),B=t.isWebGL2||null!==e,i={},Q=a(null);let o=Q,E=!1;function n(g){return t.isWebGL2?A.bindVertexArray(g):e.bindVertexArrayOES(g)}function s(g){return t.isWebGL2?A.deleteVertexArray(g):e.deleteVertexArrayOES(g)}function a(A){const g=[],I=[],t=[];for(let A=0;A<C;A++)g[A]=0,I[A]=0,t[A]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:g,enabledAttributes:I,attributeDivisors:t,object:A,attributes:{},index:null}}function r(){const A=o.newAttributes;for(let g=0,I=A.length;g<I;g++)A[g]=0}function h(A){c(A,0)}function c(I,C){const e=o.newAttributes,B=o.enabledAttributes,i=o.attributeDivisors;if(e[I]=1,0===B[I]&&(A.enableVertexAttribArray(I),B[I]=1),i[I]!==C){(t.isWebGL2?A:g.get("ANGLE_instanced_arrays"))[t.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](I,C),i[I]=C}}function l(){const g=o.newAttributes,I=o.enabledAttributes;for(let t=0,C=I.length;t<C;t++)I[t]!==g[t]&&(A.disableVertexAttribArray(t),I[t]=0)}function D(g,I,C,e,B,i){!0!==t.isWebGL2||5124!==C&&5125!==C?A.vertexAttribPointer(g,I,C,e,B,i):A.vertexAttribIPointer(g,I,C,B,i)}function u(){w(),E=!0,o!==Q&&(o=Q,n(o.object))}function w(){Q.geometry=null,Q.program=null,Q.wireframe=!1}return{setup:function(C,Q,s,u,w){let d=!1;if(B){const g=function(g,I,C){const B=!0===C.wireframe;let Q=i[g.id];void 0===Q&&(Q={},i[g.id]=Q);let o=Q[I.id];void 0===o&&(o={},Q[I.id]=o);let E=o[B];void 0===E&&(E=a(t.isWebGL2?A.createVertexArray():e.createVertexArrayOES()),o[B]=E);return E}(u,s,Q);o!==g&&(o=g,n(o.object)),d=function(A,g,I,t){const C=o.attributes,e=g.attributes;let B=0;const i=I.getAttributes();for(const g in i){if(i[g].location>=0){const I=C[g];let t=e[g];if(void 0===t&&("instanceMatrix"===g&&A.instanceMatrix&&(t=A.instanceMatrix),"instanceColor"===g&&A.instanceColor&&(t=A.instanceColor)),void 0===I)return!0;if(I.attribute!==t)return!0;if(t&&I.data!==t.data)return!0;B++}}return o.attributesNum!==B||o.index!==t}(C,u,s,w),d&&function(A,g,I,t){const C={},e=g.attributes;let B=0;const i=I.getAttributes();for(const g in i){if(i[g].location>=0){let I=e[g];void 0===I&&("instanceMatrix"===g&&A.instanceMatrix&&(I=A.instanceMatrix),"instanceColor"===g&&A.instanceColor&&(I=A.instanceColor));const t={};t.attribute=I,I&&I.data&&(t.data=I.data),C[g]=t,B++}}o.attributes=C,o.attributesNum=B,o.index=t}(C,u,s,w)}else{const A=!0===Q.wireframe;o.geometry===u.id&&o.program===s.id&&o.wireframe===A||(o.geometry=u.id,o.program=s.id,o.wireframe=A,d=!0)}null!==w&&I.update(w,34963),(d||E)&&(E=!1,function(C,e,B,i){if(!1===t.isWebGL2&&(C.isInstancedMesh||i.isInstancedBufferGeometry)&&null===g.get("ANGLE_instanced_arrays"))return;r();const Q=i.attributes,o=B.getAttributes(),E=e.defaultAttributeValues;for(const g in o){const t=o[g];if(t.location>=0){let e=Q[g];if(void 0===e&&("instanceMatrix"===g&&C.instanceMatrix&&(e=C.instanceMatrix),"instanceColor"===g&&C.instanceColor&&(e=C.instanceColor)),void 0!==e){const g=e.normalized,B=e.itemSize,Q=I.get(e);if(void 0===Q)continue;const o=Q.buffer,E=Q.type,n=Q.bytesPerElement;if(e.isInterleavedBufferAttribute){const I=e.data,Q=I.stride,s=e.offset;if(I.isInstancedInterleavedBuffer){for(let A=0;A<t.locationSize;A++)c(t.location+A,I.meshPerAttribute);!0!==C.isInstancedMesh&&void 0===i._maxInstanceCount&&(i._maxInstanceCount=I.meshPerAttribute*I.count)}else for(let A=0;A<t.locationSize;A++)h(t.location+A);A.bindBuffer(34962,o);for(let A=0;A<t.locationSize;A++)D(t.location+A,B/t.locationSize,E,g,Q*n,(s+B/t.locationSize*A)*n)}else{if(e.isInstancedBufferAttribute){for(let A=0;A<t.locationSize;A++)c(t.location+A,e.meshPerAttribute);!0!==C.isInstancedMesh&&void 0===i._maxInstanceCount&&(i._maxInstanceCount=e.meshPerAttribute*e.count)}else for(let A=0;A<t.locationSize;A++)h(t.location+A);A.bindBuffer(34962,o);for(let A=0;A<t.locationSize;A++)D(t.location+A,B/t.locationSize,E,g,B*n,B/t.locationSize*A*n)}}else if(void 0!==E){const I=E[g];if(void 0!==I)switch(I.length){case 2:A.vertexAttrib2fv(t.location,I);break;case 3:A.vertexAttrib3fv(t.location,I);break;case 4:A.vertexAttrib4fv(t.location,I);break;default:A.vertexAttrib1fv(t.location,I)}}}}l()}(C,Q,s,u),null!==w&&A.bindBuffer(34963,I.get(w).buffer))},reset:u,resetDefaultState:w,dispose:function(){u();for(const A in i){const g=i[A];for(const A in g){const I=g[A];for(const A in I)s(I[A].object),delete I[A];delete g[A]}delete i[A]}},releaseStatesOfGeometry:function(A){if(void 0===i[A.id])return;const g=i[A.id];for(const A in g){const I=g[A];for(const A in I)s(I[A].object),delete I[A];delete g[A]}delete i[A.id]},releaseStatesOfProgram:function(A){for(const g in i){const I=i[g];if(void 0===I[A.id])continue;const t=I[A.id];for(const A in t)s(t[A].object),delete t[A];delete I[A.id]}},initAttributes:r,enableAttribute:h,disableUnusedAttributes:l}}function SC(A,g,I,t){const C=t.isWebGL2;let e;this.setMode=function(A){e=A},this.render=function(g,t){A.drawArrays(e,g,t),I.update(t,e,1)},this.renderInstances=function(t,B,i){if(0===i)return;let Q,o;if(C)Q=A,o="drawArraysInstanced";else if(Q=g.get("ANGLE_instanced_arrays"),o="drawArraysInstancedANGLE",null===Q)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");Q[o](e,t,B,i),I.update(B,e,i)}}function MC(A,g,I){let t;function C(g){if("highp"===g){if(A.getShaderPrecisionFormat(35633,36338).precision>0&&A.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";g="mediump"}return"mediump"===g&&A.getShaderPrecisionFormat(35633,36337).precision>0&&A.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const e="undefined"!=typeof WebGL2RenderingContext&&A instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&A instanceof WebGL2ComputeRenderingContext;let B=void 0!==I.precision?I.precision:"highp";const i=C(B);i!==B&&(console.warn("THREE.WebGLRenderer:",B,"not supported, using",i,"instead."),B=i);const Q=e||g.has("WEBGL_draw_buffers"),o=!0===I.logarithmicDepthBuffer,E=A.getParameter(34930),n=A.getParameter(35660),s=A.getParameter(3379),a=A.getParameter(34076),r=A.getParameter(34921),h=A.getParameter(36347),c=A.getParameter(36348),l=A.getParameter(36349),D=n>0,u=e||g.has("OES_texture_float");return{isWebGL2:e,drawBuffers:Q,getMaxAnisotropy:function(){if(void 0!==t)return t;if(!0===g.has("EXT_texture_filter_anisotropic")){const I=g.get("EXT_texture_filter_anisotropic");t=A.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else t=0;return t},getMaxPrecision:C,precision:B,logarithmicDepthBuffer:o,maxTextures:E,maxVertexTextures:n,maxTextureSize:s,maxCubemapSize:a,maxAttributes:r,maxVertexUniforms:h,maxVaryings:c,maxFragmentUniforms:l,vertexTextures:D,floatFragmentTextures:u,floatVertexTextures:D&&u,maxSamples:e?A.getParameter(36183):0}}function UC(A){const g=this;let I=null,t=0,C=!1,e=!1;const B=new uC,i=new xg,Q={value:null,needsUpdate:!1};function o(){Q.value!==I&&(Q.value=I,Q.needsUpdate=t>0),g.numPlanes=t,g.numIntersection=0}function E(A,I,t,C){const e=null!==A?A.length:0;let o=null;if(0!==e){if(o=Q.value,!0!==C||null===o){const g=t+4*e,C=I.matrixWorldInverse;i.getNormalMatrix(C),(null===o||o.length<g)&&(o=new Float32Array(g));for(let g=0,I=t;g!==e;++g,I+=4)B.copy(A[g]).applyMatrix4(C,i),B.normal.toArray(o,I),o[I+3]=B.constant}Q.value=o,Q.needsUpdate=!0}return g.numPlanes=e,g.numIntersection=0,o}this.uniform=Q,this.numPlanes=0,this.numIntersection=0,this.init=function(A,g,e){const B=0!==A.length||g||0!==t||C;return C=g,I=E(A,e,0),t=A.length,B},this.beginShadows=function(){e=!0,E(null)},this.endShadows=function(){e=!1,o()},this.setState=function(g,B,i){const n=g.clippingPlanes,s=g.clipIntersection,a=g.clipShadows,r=A.get(g);if(!C||null===n||0===n.length||e&&!a)e?E(null):o();else{const A=e?0:t,g=4*A;let C=r.clippingState||null;Q.value=C,C=E(n,B,g,i);for(let A=0;A!==g;++A)C[A]=I[A];r.clippingState=C,this.numIntersection=s?this.numPlanes:0,this.numPlanes+=A}}}function KC(A){let g=new WeakMap;function I(A,g){return g===gA?A.mapping=$:g===IA&&(A.mapping=AA),A}function t(A){const I=A.target;I.removeEventListener("dispose",t);const C=g.get(I);void 0!==C&&(g.delete(I),C.dispose())}return{get:function(C){if(C&&C.isTexture&&!1===C.isRenderTargetTexture){const e=C.mapping;if(e===gA||e===IA){if(g.has(C)){return I(g.get(C).texture,C.mapping)}{const e=C.image;if(e&&e.height>0){const B=new hC(e.height/2);return B.fromEquirectangularTexture(A,C),g.set(C,B),C.addEventListener("dispose",t),I(B.texture,C.mapping)}return null}}}return C},dispose:function(){g=new WeakMap}}}RC.physical={uniforms:iC([RC.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Lg(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new zg(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Lg},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new zg(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new zg(1,1,1)},specularColorMap:{value:null}}]),vertexShader:NC.meshphysical_vert,fragmentShader:NC.meshphysical_frag};class JC extends EC{constructor(A=-1,g=1,I=1,t=-1,C=.1,e=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=A,this.right=g,this.top=I,this.bottom=t,this.near=C,this.far=e,this.updateProjectionMatrix()}copy(A,g){return super.copy(A,g),this.left=A.left,this.right=A.right,this.top=A.top,this.bottom=A.bottom,this.near=A.near,this.far=A.far,this.zoom=A.zoom,this.view=null===A.view?null:Object.assign({},A.view),this}setViewOffset(A,g,I,t,C,e){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=g,this.view.offsetX=I,this.view.offsetY=t,this.view.width=C,this.view.height=e,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=(this.right-this.left)/(2*this.zoom),g=(this.top-this.bottom)/(2*this.zoom),I=(this.right+this.left)/2,t=(this.top+this.bottom)/2;let C=I-A,e=I+A,B=t+g,i=t-g;if(null!==this.view&&this.view.enabled){const A=(this.right-this.left)/this.view.fullWidth/this.zoom,g=(this.top-this.bottom)/this.view.fullHeight/this.zoom;C+=A*this.view.offsetX,e=C+A*this.view.width,B-=g*this.view.offsetY,i=B-g*this.view.height}this.projectionMatrix.makeOrthographic(C,e,B,i,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const g=super.toJSON(A);return g.object.zoom=this.zoom,g.object.left=this.left,g.object.right=this.right,g.object.top=this.top,g.object.bottom=this.bottom,g.object.near=this.near,g.object.far=this.far,null!==this.view&&(g.object.view=Object.assign({},this.view)),g}}const YC=[.125,.215,.35,.446,.526,.582],LC=20,xC=new JC,bC=new zg;let HC=null;const qC=(1+Math.sqrt(5))/2,TC=1/qC,vC=[new oI(1,1,1),new oI(-1,1,1),new oI(1,1,-1),new oI(-1,1,-1),new oI(0,qC,TC),new oI(0,qC,-TC),new oI(TC,0,qC),new oI(-TC,0,qC),new oI(qC,TC,0),new oI(-qC,TC,0)];class VC{constructor(A){this._renderer=A,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(A,g=0,I=.1,t=100){HC=this._renderer.getRenderTarget(),this._setSize(256);const C=this._allocateTargets();return C.depthBuffer=!0,this._sceneToCubeUV(A,I,t,C),g>0&&this._blur(C,0,0,g),this._applyPMREM(C),this._cleanup(C),C}fromEquirectangular(A,g=null){return this._fromTexture(A,g)}fromCubemap(A,g=null){return this._fromTexture(A,g)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=PC(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=ZC(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(A){this._lodMax=Math.floor(Math.log2(A)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let A=0;A<this._lodPlanes.length;A++)this._lodPlanes[A].dispose()}_cleanup(A){this._renderer.setRenderTarget(HC),A.scissorTest=!1,OC(A,0,0,A.width,A.height)}_fromTexture(A,g){A.mapping===$||A.mapping===AA?this._setSize(0===A.image.length?16:A.image[0].width||A.image[0].image.width):this._setSize(A.image.width/4),HC=this._renderer.getRenderTarget();const I=g||this._allocateTargets();return this._textureToCubeUV(A,I),this._applyPMREM(I),this._cleanup(I),I}_allocateTargets(){const A=3*Math.max(this._cubeSize,112),g=4*this._cubeSize,I={magFilter:EA,minFilter:EA,generateMipmaps:!1,type:wA,format:NA,encoding:rg,depthBuffer:!1},t=WC(A,g,I);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==A){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=WC(A,g,I);const{_lodMax:t}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(A){const g=[],I=[],t=[];let C=A;const e=A-4+1+YC.length;for(let B=0;B<e;B++){const e=Math.pow(2,C);I.push(e);let i=1/e;B>A-4?i=YC[B-A+4-1]:0===B&&(i=0),t.push(i);const Q=1/(e-2),o=-Q,E=1+Q,n=[o,o,E,o,E,E,o,o,E,E,o,E],s=6,a=6,r=3,h=2,c=1,l=new Float32Array(r*a*s),D=new Float32Array(h*a*s),u=new Float32Array(c*a*s);for(let A=0;A<s;A++){const g=A%3*2/3-1,I=A>2?0:-1,t=[g,I,0,g+2/3,I,0,g+2/3,I+1,0,g,I,0,g+2/3,I+1,0,g,I+1,0];l.set(t,r*a*A),D.set(n,h*a*A);const C=[A,A,A,A,A,A];u.set(C,c*a*A)}const w=new bt;w.setAttribute("position",new Rt(l,r)),w.setAttribute("uv",new Rt(D,h)),w.setAttribute("faceIndex",new Rt(u,c)),g.push(w),C>4&&C--}return{lodPlanes:g,sizeLods:I,sigmas:t}}(t)),this._blurMaterial=function(A,g,I){const t=new Float32Array(LC),C=new oI(0,1,0),e=new oC({name:"SphericalGaussianBlur",defines:{n:LC,CUBEUV_TEXEL_WIDTH:1/g,CUBEUV_TEXEL_HEIGHT:1/I,CUBEUV_MAX_MIP:`${A}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:C}},vertexShader:XC(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:r,depthTest:!1,depthWrite:!1});return e}(t,A,g)}return t}_compileMaterial(A){const g=new tC(this._lodPlanes[0],A);this._renderer.compile(g,xC)}_sceneToCubeUV(A,g,I,t){const C=new nC(90,1,g,I),e=[1,-1,1,1,1,1],B=[1,1,1,-1,-1,-1],i=this._renderer,Q=i.autoClear,o=i.toneMapping;i.getClearColor(bC),i.toneMapping=Z,i.autoClear=!1;const E=new ft({name:"PMREM.Background",side:s,depthWrite:!1,depthTest:!1}),n=new tC(new eC,E);let a=!1;const r=A.background;r?r.isColor&&(E.color.copy(r),A.background=null,a=!0):(E.color.copy(bC),a=!0);for(let g=0;g<6;g++){const I=g%3;0===I?(C.up.set(0,e[g],0),C.lookAt(B[g],0,0)):1===I?(C.up.set(0,0,e[g]),C.lookAt(0,B[g],0)):(C.up.set(0,e[g],0),C.lookAt(0,0,B[g]));const Q=this._cubeSize;OC(t,I*Q,g>2?Q:0,Q,Q),i.setRenderTarget(t),a&&i.render(n,C),i.render(A,C)}n.geometry.dispose(),n.material.dispose(),i.toneMapping=o,i.autoClear=Q,A.background=r}_textureToCubeUV(A,g){const I=this._renderer,t=A.mapping===$||A.mapping===AA;t?(null===this._cubemapMaterial&&(this._cubemapMaterial=PC()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===A.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=ZC());const C=t?this._cubemapMaterial:this._equirectMaterial,e=new tC(this._lodPlanes[0],C);C.uniforms.envMap.value=A;const B=this._cubeSize;OC(g,0,0,3*B,2*B),I.setRenderTarget(g),I.render(e,xC)}_applyPMREM(A){const g=this._renderer,I=g.autoClear;g.autoClear=!1;for(let g=1;g<this._lodPlanes.length;g++){const I=Math.sqrt(this._sigmas[g]*this._sigmas[g]-this._sigmas[g-1]*this._sigmas[g-1]),t=vC[(g-1)%vC.length];this._blur(A,g-1,g,I,t)}g.autoClear=I}_blur(A,g,I,t,C){const e=this._pingPongRenderTarget;this._halfBlur(A,e,g,I,t,"latitudinal",C),this._halfBlur(e,A,I,I,t,"longitudinal",C)}_halfBlur(A,g,I,t,C,e,B){const i=this._renderer,Q=this._blurMaterial;"latitudinal"!==e&&"longitudinal"!==e&&console.error("blur direction must be either latitudinal or longitudinal!");const o=new tC(this._lodPlanes[t],Q),E=Q.uniforms,n=this._sizeLods[I]-1,s=isFinite(C)?Math.PI/(2*n):2*Math.PI/39,a=C/s,r=isFinite(C)?1+Math.floor(3*a):LC;r>LC&&console.warn(`sigmaRadians, ${C}, is too large and will clip, as it requested ${r} samples when the maximum is set to 20`);const h=[];let c=0;for(let A=0;A<LC;++A){const g=A/a,I=Math.exp(-g*g/2);h.push(I),0===A?c+=I:A<r&&(c+=2*I)}for(let A=0;A<h.length;A++)h[A]=h[A]/c;E.envMap.value=A.texture,E.samples.value=r,E.weights.value=h,E.latitudinal.value="latitudinal"===e,B&&(E.poleAxis.value=B);const{_lodMax:l}=this;E.dTheta.value=s,E.mipInt.value=l-I;const D=this._sizeLods[t];OC(g,3*D*(t>l-4?t-l+4:0),4*(this._cubeSize-D),3*D,2*D),i.setRenderTarget(g),i.render(o,xC)}}function WC(A,g,I){const t=new eI(A,g,I);return t.texture.mapping=tA,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function OC(A,g,I,t,C){A.viewport.set(g,I,t,C),A.scissor.set(g,I,t,C)}function ZC(){return new oC({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:XC(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:r,depthTest:!1,depthWrite:!1})}function PC(){return new oC({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:XC(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:r,depthTest:!1,depthWrite:!1})}function XC(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function jC(A){let g=new WeakMap,I=null;function t(A){const I=A.target;I.removeEventListener("dispose",t);const C=g.get(I);void 0!==C&&(g.delete(I),C.dispose())}return{get:function(C){if(C&&C.isTexture){const e=C.mapping,B=e===gA||e===IA,i=e===$||e===AA;if(B||i){if(C.isRenderTargetTexture&&!0===C.needsPMREMUpdate){C.needsPMREMUpdate=!1;let t=g.get(C);return null===I&&(I=new VC(A)),t=B?I.fromEquirectangular(C,t):I.fromCubemap(C,t),g.set(C,t),t.texture}if(g.has(C))return g.get(C).texture;{const e=C.image;if(B&&e&&e.height>0||i&&e&&function(A){let g=0;const I=6;for(let t=0;t<I;t++)void 0!==A[t]&&g++;return g===I}(e)){null===I&&(I=new VC(A));const e=B?I.fromEquirectangular(C):I.fromCubemap(C);return g.set(C,e),C.addEventListener("dispose",t),e.texture}return null}}}return C},dispose:function(){g=new WeakMap,null!==I&&(I.dispose(),I=null)}}}function zC(A){const g={};function I(I){if(void 0!==g[I])return g[I];let t;switch(I){case"WEBGL_depth_texture":t=A.getExtension("WEBGL_depth_texture")||A.getExtension("MOZ_WEBGL_depth_texture")||A.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":t=A.getExtension("EXT_texture_filter_anisotropic")||A.getExtension("MOZ_EXT_texture_filter_anisotropic")||A.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":t=A.getExtension("WEBGL_compressed_texture_s3tc")||A.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":t=A.getExtension("WEBGL_compressed_texture_pvrtc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:t=A.getExtension(I)}return g[I]=t,t}return{has:function(A){return null!==I(A)},init:function(A){A.isWebGL2?I("EXT_color_buffer_float"):(I("WEBGL_depth_texture"),I("OES_texture_float"),I("OES_texture_half_float"),I("OES_texture_half_float_linear"),I("OES_standard_derivatives"),I("OES_element_index_uint"),I("OES_vertex_array_object"),I("ANGLE_instanced_arrays")),I("OES_texture_float_linear"),I("EXT_color_buffer_half_float"),I("WEBGL_multisampled_render_to_texture")},get:function(A){const g=I(A);return null===g&&console.warn("THREE.WebGLRenderer: "+A+" extension not supported."),g}}}function _C(A,g,I,t){const C={},e=new WeakMap;function B(A){const i=A.target;null!==i.index&&g.remove(i.index);for(const A in i.attributes)g.remove(i.attributes[A]);i.removeEventListener("dispose",B),delete C[i.id];const Q=e.get(i);Q&&(g.remove(Q),e.delete(i)),t.releaseStatesOfGeometry(i),!0===i.isInstancedBufferGeometry&&delete i._maxInstanceCount,I.memory.geometries--}function i(A){const I=[],t=A.index,C=A.attributes.position;let B=0;if(null!==t){const A=t.array;B=t.version;for(let g=0,t=A.length;g<t;g+=3){const t=A[g+0],C=A[g+1],e=A[g+2];I.push(t,C,C,e,e,t)}}else{const A=C.array;B=C.version;for(let g=0,t=A.length/3-1;g<t;g+=3){const A=g+0,t=g+1,C=g+2;I.push(A,t,t,C,C,A)}}const i=new(bg(I)?kt:mt)(I,1);i.version=B;const Q=e.get(A);Q&&g.remove(Q),e.set(A,i)}return{get:function(A,g){return!0===C[g.id]||(g.addEventListener("dispose",B),C[g.id]=!0,I.memory.geometries++),g},update:function(A){const I=A.attributes;for(const A in I)g.update(I[A],34962);const t=A.morphAttributes;for(const A in t){const I=t[A];for(let A=0,t=I.length;A<t;A++)g.update(I[A],34962)}},getWireframeAttribute:function(A){const g=e.get(A);if(g){const I=A.index;null!==I&&g.version<I.version&&i(A)}else i(A);return e.get(A)}}}function $C(A,g,I,t){const C=t.isWebGL2;let e,B,i;this.setMode=function(A){e=A},this.setIndex=function(A){B=A.type,i=A.bytesPerElement},this.render=function(g,t){A.drawElements(e,t,B,g*i),I.update(t,e,1)},this.renderInstances=function(t,Q,o){if(0===o)return;let E,n;if(C)E=A,n="drawElementsInstanced";else if(E=g.get("ANGLE_instanced_arrays"),n="drawElementsInstancedANGLE",null===E)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");E[n](e,Q,B,t*i,o),I.update(Q,e,o)}}function Ae(A){const g={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:g,programs:null,autoReset:!0,reset:function(){g.frame++,g.calls=0,g.triangles=0,g.points=0,g.lines=0},update:function(A,I,t){switch(g.calls++,I){case 4:g.triangles+=t*(A/3);break;case 1:g.lines+=t*(A/2);break;case 3:g.lines+=t*(A-1);break;case 2:g.lines+=t*A;break;case 0:g.points+=t*A;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",I)}}}}function ge(A,g){return A[0]-g[0]}function Ie(A,g){return Math.abs(g[1])-Math.abs(A[1])}function te(A,g,I){const t={},C=new Float32Array(8),e=new WeakMap,B=new CI,i=[];for(let A=0;A<8;A++)i[A]=[A,0];return{update:function(Q,o,E,n){const s=Q.morphTargetInfluences;if(!0===g.isWebGL2){const a=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,r=void 0!==a?a.length:0;let h=e.get(o);if(void 0===h||h.count!==r){void 0!==h&&h.texture.dispose();const D=void 0!==o.morphAttributes.position,u=void 0!==o.morphAttributes.normal,w=void 0!==o.morphAttributes.color,d=o.morphAttributes.position||[],p=o.morphAttributes.normal||[],y=o.morphAttributes.color||[];let G=0;!0===D&&(G=1),!0===u&&(G=2),!0===w&&(G=3);let f=o.attributes.position.count*G,N=1;f>g.maxTextureSize&&(N=Math.ceil(f/g.maxTextureSize),f=g.maxTextureSize);const F=new Float32Array(f*N*4*r),R=new BI(F,f,N,r);R.type=uA,R.needsUpdate=!0;const m=4*G;for(let S=0;S<r;S++){const M=d[S],U=p[S],K=y[S],J=f*N*4*S;for(let Y=0;Y<M.count;Y++){const L=Y*m;!0===D&&(B.fromBufferAttribute(M,Y),F[J+L+0]=B.x,F[J+L+1]=B.y,F[J+L+2]=B.z,F[J+L+3]=0),!0===u&&(B.fromBufferAttribute(U,Y),F[J+L+4]=B.x,F[J+L+5]=B.y,F[J+L+6]=B.z,F[J+L+7]=0),!0===w&&(B.fromBufferAttribute(K,Y),F[J+L+8]=B.x,F[J+L+9]=B.y,F[J+L+10]=B.z,F[J+L+11]=4===K.itemSize?B.w:1)}}function k(){R.dispose(),e.delete(o),o.removeEventListener("dispose",k)}h={count:r,texture:R,size:new Lg(f,N)},e.set(o,h),o.addEventListener("dispose",k)}let c=0;for(let x=0;x<s.length;x++)c+=s[x];const l=o.morphTargetsRelative?1:1-c;n.getUniforms().setValue(A,"morphTargetBaseInfluence",l),n.getUniforms().setValue(A,"morphTargetInfluences",s),n.getUniforms().setValue(A,"morphTargetsTexture",h.texture,I),n.getUniforms().setValue(A,"morphTargetsTextureSize",h.size)}else{const b=void 0===s?0:s.length;let H=t[o.id];if(void 0===H||H.length!==b){H=[];for(let W=0;W<b;W++)H[W]=[W,0];t[o.id]=H}for(let O=0;O<b;O++){const Z=H[O];Z[0]=O,Z[1]=s[O]}H.sort(Ie);for(let P=0;P<8;P++)P<b&&H[P][1]?(i[P][0]=H[P][0],i[P][1]=H[P][1]):(i[P][0]=Number.MAX_SAFE_INTEGER,i[P][1]=0);i.sort(ge);const q=o.morphAttributes.position,T=o.morphAttributes.normal;let v=0;for(let X=0;X<8;X++){const j=i[X],z=j[0],_=j[1];z!==Number.MAX_SAFE_INTEGER&&_?(q&&o.getAttribute("morphTarget"+X)!==q[z]&&o.setAttribute("morphTarget"+X,q[z]),T&&o.getAttribute("morphNormal"+X)!==T[z]&&o.setAttribute("morphNormal"+X,T[z]),C[X]=_,v+=_):(q&&!0===o.hasAttribute("morphTarget"+X)&&o.deleteAttribute("morphTarget"+X),T&&!0===o.hasAttribute("morphNormal"+X)&&o.deleteAttribute("morphNormal"+X),C[X]=0)}const V=o.morphTargetsRelative?1:1-v;n.getUniforms().setValue(A,"morphTargetBaseInfluence",V),n.getUniforms().setValue(A,"morphTargetInfluences",C)}}}}function Ce(A,g,I,t){let C=new WeakMap;function e(A){const g=A.target;g.removeEventListener("dispose",e),I.remove(g.instanceMatrix),null!==g.instanceColor&&I.remove(g.instanceColor)}return{update:function(A){const B=t.render.frame,i=A.geometry,Q=g.get(A,i);return C.get(Q)!==B&&(g.update(Q),C.set(Q,B)),A.isInstancedMesh&&(!1===A.hasEventListener("dispose",e)&&A.addEventListener("dispose",e),I.update(A.instanceMatrix,34962),null!==A.instanceColor&&I.update(A.instanceColor,34962)),Q},dispose:function(){C=new WeakMap}}}const ee=new tI,Be=new BI,ie=new iI,Qe=new rC,oe=[],Ee=[],ne=new Float32Array(16),se=new Float32Array(9),ae=new Float32Array(4);function re(A,g,I){const t=A[0];if(t<=0||t>0)return A;const C=g*I;let e=oe[C];if(void 0===e&&(e=new Float32Array(C),oe[C]=e),0!==g){t.toArray(e,0);for(let t=1,C=0;t!==g;++t)C+=I,A[t].toArray(e,C)}return e}function he(A,g){if(A.length!==g.length)return!1;for(let I=0,t=A.length;I<t;I++)if(A[I]!==g[I])return!1;return!0}function ce(A,g){for(let I=0,t=g.length;I<t;I++)A[I]=g[I]}function le(A,g){let I=Ee[g];void 0===I&&(I=new Int32Array(g),Ee[g]=I);for(let t=0;t!==g;++t)I[t]=A.allocateTextureUnit();return I}function De(A,g){const I=this.cache;I[0]!==g&&(A.uniform1f(this.addr,g),I[0]=g)}function ue(A,g){const I=this.cache;if(void 0!==g.x)I[0]===g.x&&I[1]===g.y||(A.uniform2f(this.addr,g.x,g.y),I[0]=g.x,I[1]=g.y);else{if(he(I,g))return;A.uniform2fv(this.addr,g),ce(I,g)}}function we(A,g){const I=this.cache;if(void 0!==g.x)I[0]===g.x&&I[1]===g.y&&I[2]===g.z||(A.uniform3f(this.addr,g.x,g.y,g.z),I[0]=g.x,I[1]=g.y,I[2]=g.z);else if(void 0!==g.r)I[0]===g.r&&I[1]===g.g&&I[2]===g.b||(A.uniform3f(this.addr,g.r,g.g,g.b),I[0]=g.r,I[1]=g.g,I[2]=g.b);else{if(he(I,g))return;A.uniform3fv(this.addr,g),ce(I,g)}}function de(A,g){const I=this.cache;if(void 0!==g.x)I[0]===g.x&&I[1]===g.y&&I[2]===g.z&&I[3]===g.w||(A.uniform4f(this.addr,g.x,g.y,g.z,g.w),I[0]=g.x,I[1]=g.y,I[2]=g.z,I[3]=g.w);else{if(he(I,g))return;A.uniform4fv(this.addr,g),ce(I,g)}}function pe(A,g){const I=this.cache,t=g.elements;if(void 0===t){if(he(I,g))return;A.uniformMatrix2fv(this.addr,!1,g),ce(I,g)}else{if(he(I,t))return;ae.set(t),A.uniformMatrix2fv(this.addr,!1,ae),ce(I,t)}}function ye(A,g){const I=this.cache,t=g.elements;if(void 0===t){if(he(I,g))return;A.uniformMatrix3fv(this.addr,!1,g),ce(I,g)}else{if(he(I,t))return;se.set(t),A.uniformMatrix3fv(this.addr,!1,se),ce(I,t)}}function Ge(A,g){const I=this.cache,t=g.elements;if(void 0===t){if(he(I,g))return;A.uniformMatrix4fv(this.addr,!1,g),ce(I,g)}else{if(he(I,t))return;ne.set(t),A.uniformMatrix4fv(this.addr,!1,ne),ce(I,t)}}function fe(A,g){const I=this.cache;I[0]!==g&&(A.uniform1i(this.addr,g),I[0]=g)}function Ne(A,g){const I=this.cache;he(I,g)||(A.uniform2iv(this.addr,g),ce(I,g))}function Fe(A,g){const I=this.cache;he(I,g)||(A.uniform3iv(this.addr,g),ce(I,g))}function Re(A,g){const I=this.cache;he(I,g)||(A.uniform4iv(this.addr,g),ce(I,g))}function me(A,g){const I=this.cache;I[0]!==g&&(A.uniform1ui(this.addr,g),I[0]=g)}function ke(A,g){const I=this.cache;he(I,g)||(A.uniform2uiv(this.addr,g),ce(I,g))}function Se(A,g){const I=this.cache;he(I,g)||(A.uniform3uiv(this.addr,g),ce(I,g))}function Me(A,g){const I=this.cache;he(I,g)||(A.uniform4uiv(this.addr,g),ce(I,g))}function Ue(A,g,I){const t=this.cache,C=I.allocateTextureUnit();t[0]!==C&&(A.uniform1i(this.addr,C),t[0]=C),I.setTexture2D(g||ee,C)}function Ke(A,g,I){const t=this.cache,C=I.allocateTextureUnit();t[0]!==C&&(A.uniform1i(this.addr,C),t[0]=C),I.setTexture3D(g||ie,C)}function Je(A,g,I){const t=this.cache,C=I.allocateTextureUnit();t[0]!==C&&(A.uniform1i(this.addr,C),t[0]=C),I.setTextureCube(g||Qe,C)}function Ye(A,g,I){const t=this.cache,C=I.allocateTextureUnit();t[0]!==C&&(A.uniform1i(this.addr,C),t[0]=C),I.setTexture2DArray(g||Be,C)}function Le(A,g){A.uniform1fv(this.addr,g)}function xe(A,g){const I=re(g,this.size,2);A.uniform2fv(this.addr,I)}function be(A,g){const I=re(g,this.size,3);A.uniform3fv(this.addr,I)}function He(A,g){const I=re(g,this.size,4);A.uniform4fv(this.addr,I)}function qe(A,g){const I=re(g,this.size,4);A.uniformMatrix2fv(this.addr,!1,I)}function Te(A,g){const I=re(g,this.size,9);A.uniformMatrix3fv(this.addr,!1,I)}function ve(A,g){const I=re(g,this.size,16);A.uniformMatrix4fv(this.addr,!1,I)}function Ve(A,g){A.uniform1iv(this.addr,g)}function We(A,g){A.uniform2iv(this.addr,g)}function Oe(A,g){A.uniform3iv(this.addr,g)}function Ze(A,g){A.uniform4iv(this.addr,g)}function Pe(A,g){A.uniform1uiv(this.addr,g)}function Xe(A,g){A.uniform2uiv(this.addr,g)}function je(A,g){A.uniform3uiv(this.addr,g)}function ze(A,g){A.uniform4uiv(this.addr,g)}function _e(A,g,I){const t=this.cache,C=g.length,e=le(I,C);he(t,e)||(A.uniform1iv(this.addr,e),ce(t,e));for(let A=0;A!==C;++A)I.setTexture2D(g[A]||ee,e[A])}function $e(A,g,I){const t=this.cache,C=g.length,e=le(I,C);he(t,e)||(A.uniform1iv(this.addr,e),ce(t,e));for(let A=0;A!==C;++A)I.setTexture3D(g[A]||ie,e[A])}function AB(A,g,I){const t=this.cache,C=g.length,e=le(I,C);he(t,e)||(A.uniform1iv(this.addr,e),ce(t,e));for(let A=0;A!==C;++A)I.setTextureCube(g[A]||Qe,e[A])}function gB(A,g,I){const t=this.cache,C=g.length,e=le(I,C);he(t,e)||(A.uniform1iv(this.addr,e),ce(t,e));for(let A=0;A!==C;++A)I.setTexture2DArray(g[A]||Be,e[A])}class IB{constructor(A,g,I){this.id=A,this.addr=I,this.cache=[],this.setValue=function(A){switch(A){case 5126:return De;case 35664:return ue;case 35665:return we;case 35666:return de;case 35674:return pe;case 35675:return ye;case 35676:return Ge;case 5124:case 35670:return fe;case 35667:case 35671:return Ne;case 35668:case 35672:return Fe;case 35669:case 35673:return Re;case 5125:return me;case 36294:return ke;case 36295:return Se;case 36296:return Me;case 35678:case 36198:case 36298:case 36306:case 35682:return Ue;case 35679:case 36299:case 36307:return Ke;case 35680:case 36300:case 36308:case 36293:return Je;case 36289:case 36303:case 36311:case 36292:return Ye}}(g.type)}}class tB{constructor(A,g,I){this.id=A,this.addr=I,this.cache=[],this.size=g.size,this.setValue=function(A){switch(A){case 5126:return Le;case 35664:return xe;case 35665:return be;case 35666:return He;case 35674:return qe;case 35675:return Te;case 35676:return ve;case 5124:case 35670:return Ve;case 35667:case 35671:return We;case 35668:case 35672:return Oe;case 35669:case 35673:return Ze;case 5125:return Pe;case 36294:return Xe;case 36295:return je;case 36296:return ze;case 35678:case 36198:case 36298:case 36306:case 35682:return _e;case 35679:case 36299:case 36307:return $e;case 35680:case 36300:case 36308:case 36293:return AB;case 36289:case 36303:case 36311:case 36292:return gB}}(g.type)}}class CB{constructor(A){this.id=A,this.seq=[],this.map={}}setValue(A,g,I){const t=this.seq;for(let C=0,e=t.length;C!==e;++C){const e=t[C];e.setValue(A,g[e.id],I)}}}const eB=/(\w+)(\])?(\[|\.)?/g;function BB(A,g){A.seq.push(g),A.map[g.id]=g}function iB(A,g,I){const t=A.name,C=t.length;for(eB.lastIndex=0;;){const e=eB.exec(t),B=eB.lastIndex;let i=e[1];const Q="]"===e[2],o=e[3];if(Q&&(i|=0),void 0===o||"["===o&&B+2===C){BB(I,void 0===o?new IB(i,A,g):new tB(i,A,g));break}{let A=I.map[i];void 0===A&&(A=new CB(i),BB(I,A)),I=A}}}class QB{constructor(A,g){this.seq=[],this.map={};const I=A.getProgramParameter(g,35718);for(let t=0;t<I;++t){const I=A.getActiveUniform(g,t);iB(I,A.getUniformLocation(g,I.name),this)}}setValue(A,g,I,t){const C=this.map[g];void 0!==C&&C.setValue(A,I,t)}setOptional(A,g,I){const t=g[I];void 0!==t&&this.setValue(A,I,t)}static upload(A,g,I,t){for(let C=0,e=g.length;C!==e;++C){const e=g[C],B=I[e.id];!1!==B.needsUpdate&&e.setValue(A,B.value,t)}}static seqWithValue(A,g){const I=[];for(let t=0,C=A.length;t!==C;++t){const C=A[t];C.id in g&&I.push(C)}return I}}function oB(A,g,I){const t=A.createShader(g);return A.shaderSource(t,I),A.compileShader(t),t}let EB=0;function nB(A,g,I){const t=A.getShaderParameter(g,35713),C=A.getShaderInfoLog(g).trim();if(t&&""===C)return"";const e=/ERROR: 0:(\d+)/.exec(C);if(e){const t=parseInt(e[1]);return I.toUpperCase()+"\n\n"+C+"\n\n"+function(A,g){const I=A.split("\n"),t=[],C=Math.max(g-6,0),e=Math.min(g+6,I.length);for(let A=C;A<e;A++){const C=A+1;t.push(`${C===g?">":" "} ${C}: ${I[A]}`)}return t.join("\n")}(A.getShaderSource(g),t)}return C}function sB(A,g){const I=function(A){switch(A){case rg:return["Linear","( value )"];case hg:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",A),["Linear","( value )"]}}(g);return"vec4 "+A+"( vec4 value ) { return LinearTo"+I[0]+I[1]+"; }"}function aB(A,g){let I;switch(g){case P:I="Linear";break;case X:I="Reinhard";break;case j:I="OptimizedCineon";break;case z:I="ACESFilmic";break;case _:I="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",g),I="Linear"}return"vec3 "+A+"( vec3 color ) { return "+I+"ToneMapping( color ); }"}function rB(A){return""!==A}function hB(A,g){const I=g.numSpotLightShadows+g.numSpotLightMaps-g.numSpotLightShadowsWithMaps;return A.replace(/NUM_DIR_LIGHTS/g,g.numDirLights).replace(/NUM_SPOT_LIGHTS/g,g.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,g.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,I).replace(/NUM_RECT_AREA_LIGHTS/g,g.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,g.numPointLights).replace(/NUM_HEMI_LIGHTS/g,g.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,g.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,g.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,g.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,g.numPointLightShadows)}function cB(A,g){return A.replace(/NUM_CLIPPING_PLANES/g,g.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,g.numClippingPlanes-g.numClipIntersection)}const lB=/^[ \t]*#include +<([\w\d./]+)>/gm;function DB(A){return A.replace(lB,uB)}function uB(A,g){const I=NC[g];if(void 0===I)throw new Error("Can not resolve #include <"+g+">");return DB(I)}const wB=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function dB(A){return A.replace(wB,pB)}function pB(A,g,I,t){let C="";for(let A=parseInt(g);A<parseInt(I);A++)C+=t.replace(/\[\s*i\s*\]/g,"[ "+A+" ]").replace(/UNROLLED_LOOP_INDEX/g,A);return C}function yB(A){let g="precision "+A.precision+" float;\nprecision "+A.precision+" int;";return"highp"===A.precision?g+="\n#define HIGH_PRECISION":"mediump"===A.precision?g+="\n#define MEDIUM_PRECISION":"lowp"===A.precision&&(g+="\n#define LOW_PRECISION"),g}function GB(A,g,I,t){const C=A.getContext(),e=I.defines;let B=I.vertexShader,i=I.fragmentShader;const n=function(A){let g="SHADOWMAP_TYPE_BASIC";return A.shadowMapType===Q?g="SHADOWMAP_TYPE_PCF":A.shadowMapType===o?g="SHADOWMAP_TYPE_PCF_SOFT":A.shadowMapType===E&&(g="SHADOWMAP_TYPE_VSM"),g}(I),s=function(A){let g="ENVMAP_TYPE_CUBE";if(A.envMap)switch(A.envMapMode){case $:case AA:g="ENVMAP_TYPE_CUBE";break;case tA:g="ENVMAP_TYPE_CUBE_UV"}return g}(I),a=function(A){let g="ENVMAP_MODE_REFLECTION";A.envMap&&A.envMapMode===AA&&(g="ENVMAP_MODE_REFRACTION");return g}(I),r=function(A){let g="ENVMAP_BLENDING_NONE";if(A.envMap)switch(A.combine){case V:g="ENVMAP_BLENDING_MULTIPLY";break;case W:g="ENVMAP_BLENDING_MIX";break;case O:g="ENVMAP_BLENDING_ADD"}return g}(I),h=function(A){const g=A.envMapCubeUVHeight;if(null===g)return null;const I=Math.log2(g)-2,t=1/g;return{texelWidth:1/(3*Math.max(Math.pow(2,I),112)),texelHeight:t,maxMip:I}}(I),c=I.isWebGL2?"":function(A){return[A.extensionDerivatives||A.envMapCubeUVHeight||A.bumpMap||A.tangentSpaceNormalMap||A.clearcoatNormalMap||A.flatShading||"physical"===A.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(A.extensionFragDepth||A.logarithmicDepthBuffer)&&A.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",A.extensionDrawBuffers&&A.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(A.extensionShaderTextureLOD||A.envMap||A.transmission)&&A.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(rB).join("\n")}(I),l=function(A){const g=[];for(const I in A){const t=A[I];!1!==t&&g.push("#define "+I+" "+t)}return g.join("\n")}(e),D=C.createProgram();let u,w,d=I.glslVersion?"#version "+I.glslVersion+"\n":"";I.isRawShaderMaterial?(u=[l].filter(rB).join("\n"),u.length>0&&(u+="\n"),w=[c,l].filter(rB).join("\n"),w.length>0&&(w+="\n")):(u=[yB(I),"#define SHADER_NAME "+I.shaderName,l,I.instancing?"#define USE_INSTANCING":"",I.instancingColor?"#define USE_INSTANCING_COLOR":"",I.supportsVertexTextures?"#define VERTEX_TEXTURES":"",I.useFog&&I.fog?"#define USE_FOG":"",I.useFog&&I.fogExp2?"#define FOG_EXP2":"",I.map?"#define USE_MAP":"",I.envMap?"#define USE_ENVMAP":"",I.envMap?"#define "+a:"",I.lightMap?"#define USE_LIGHTMAP":"",I.aoMap?"#define USE_AOMAP":"",I.emissiveMap?"#define USE_EMISSIVEMAP":"",I.bumpMap?"#define USE_BUMPMAP":"",I.normalMap?"#define USE_NORMALMAP":"",I.normalMap&&I.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",I.normalMap&&I.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",I.clearcoatMap?"#define USE_CLEARCOATMAP":"",I.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",I.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",I.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",I.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",I.displacementMap&&I.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",I.specularMap?"#define USE_SPECULARMAP":"",I.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",I.specularColorMap?"#define USE_SPECULARCOLORMAP":"",I.roughnessMap?"#define USE_ROUGHNESSMAP":"",I.metalnessMap?"#define USE_METALNESSMAP":"",I.alphaMap?"#define USE_ALPHAMAP":"",I.transmission?"#define USE_TRANSMISSION":"",I.transmissionMap?"#define USE_TRANSMISSIONMAP":"",I.thicknessMap?"#define USE_THICKNESSMAP":"",I.sheenColorMap?"#define USE_SHEENCOLORMAP":"",I.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",I.vertexTangents?"#define USE_TANGENT":"",I.vertexColors?"#define USE_COLOR":"",I.vertexAlphas?"#define USE_COLOR_ALPHA":"",I.vertexUvs?"#define USE_UV":"",I.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",I.flatShading?"#define FLAT_SHADED":"",I.skinning?"#define USE_SKINNING":"",I.morphTargets?"#define USE_MORPHTARGETS":"",I.morphNormals&&!1===I.flatShading?"#define USE_MORPHNORMALS":"",I.morphColors&&I.isWebGL2?"#define USE_MORPHCOLORS":"",I.morphTargetsCount>0&&I.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",I.morphTargetsCount>0&&I.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+I.morphTextureStride:"",I.morphTargetsCount>0&&I.isWebGL2?"#define MORPHTARGETS_COUNT "+I.morphTargetsCount:"",I.doubleSided?"#define DOUBLE_SIDED":"",I.flipSided?"#define FLIP_SIDED":"",I.shadowMapEnabled?"#define USE_SHADOWMAP":"",I.shadowMapEnabled?"#define "+n:"",I.sizeAttenuation?"#define USE_SIZEATTENUATION":"",I.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",I.logarithmicDepthBuffer&&I.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(rB).join("\n"),w=[c,yB(I),"#define SHADER_NAME "+I.shaderName,l,I.useFog&&I.fog?"#define USE_FOG":"",I.useFog&&I.fogExp2?"#define FOG_EXP2":"",I.map?"#define USE_MAP":"",I.matcap?"#define USE_MATCAP":"",I.envMap?"#define USE_ENVMAP":"",I.envMap?"#define "+s:"",I.envMap?"#define "+a:"",I.envMap?"#define "+r:"",h?"#define CUBEUV_TEXEL_WIDTH "+h.texelWidth:"",h?"#define CUBEUV_TEXEL_HEIGHT "+h.texelHeight:"",h?"#define CUBEUV_MAX_MIP "+h.maxMip+".0":"",I.lightMap?"#define USE_LIGHTMAP":"",I.aoMap?"#define USE_AOMAP":"",I.emissiveMap?"#define USE_EMISSIVEMAP":"",I.bumpMap?"#define USE_BUMPMAP":"",I.normalMap?"#define USE_NORMALMAP":"",I.normalMap&&I.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",I.normalMap&&I.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",I.clearcoat?"#define USE_CLEARCOAT":"",I.clearcoatMap?"#define USE_CLEARCOATMAP":"",I.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",I.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",I.iridescence?"#define USE_IRIDESCENCE":"",I.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",I.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",I.specularMap?"#define USE_SPECULARMAP":"",I.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",I.specularColorMap?"#define USE_SPECULARCOLORMAP":"",I.roughnessMap?"#define USE_ROUGHNESSMAP":"",I.metalnessMap?"#define USE_METALNESSMAP":"",I.alphaMap?"#define USE_ALPHAMAP":"",I.alphaTest?"#define USE_ALPHATEST":"",I.sheen?"#define USE_SHEEN":"",I.sheenColorMap?"#define USE_SHEENCOLORMAP":"",I.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",I.transmission?"#define USE_TRANSMISSION":"",I.transmissionMap?"#define USE_TRANSMISSIONMAP":"",I.thicknessMap?"#define USE_THICKNESSMAP":"",I.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",I.vertexTangents?"#define USE_TANGENT":"",I.vertexColors||I.instancingColor?"#define USE_COLOR":"",I.vertexAlphas?"#define USE_COLOR_ALPHA":"",I.vertexUvs?"#define USE_UV":"",I.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",I.gradientMap?"#define USE_GRADIENTMAP":"",I.flatShading?"#define FLAT_SHADED":"",I.doubleSided?"#define DOUBLE_SIDED":"",I.flipSided?"#define FLIP_SIDED":"",I.shadowMapEnabled?"#define USE_SHADOWMAP":"",I.shadowMapEnabled?"#define "+n:"",I.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",I.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",I.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",I.logarithmicDepthBuffer&&I.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",I.toneMapping!==Z?"#define TONE_MAPPING":"",I.toneMapping!==Z?NC.tonemapping_pars_fragment:"",I.toneMapping!==Z?aB("toneMapping",I.toneMapping):"",I.dithering?"#define DITHERING":"",I.opaque?"#define OPAQUE":"",NC.encodings_pars_fragment,sB("linearToOutputTexel",I.outputEncoding),I.useDepthPacking?"#define DEPTH_PACKING "+I.depthPacking:"","\n"].filter(rB).join("\n")),B=DB(B),B=hB(B,I),B=cB(B,I),i=DB(i),i=hB(i,I),i=cB(i,I),B=dB(B),i=dB(i),I.isWebGL2&&!0!==I.isRawShaderMaterial&&(d="#version 300 es\n",u=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+u,w=["#define varying in",I.glslVersion===yg?"":"layout(location = 0) out highp vec4 pc_fragColor;",I.glslVersion===yg?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+w);const p=d+w+i,y=oB(C,35633,d+u+B),G=oB(C,35632,p);if(C.attachShader(D,y),C.attachShader(D,G),void 0!==I.index0AttributeName?C.bindAttribLocation(D,0,I.index0AttributeName):!0===I.morphTargets&&C.bindAttribLocation(D,0,"position"),C.linkProgram(D),A.debug.checkShaderErrors){const A=C.getProgramInfoLog(D).trim(),g=C.getShaderInfoLog(y).trim(),I=C.getShaderInfoLog(G).trim();let t=!0,e=!0;if(!1===C.getProgramParameter(D,35714)){t=!1;const g=nB(C,y,"vertex"),I=nB(C,G,"fragment");console.error("THREE.WebGLProgram: Shader Error "+C.getError()+" - VALIDATE_STATUS "+C.getProgramParameter(D,35715)+"\n\nProgram Info Log: "+A+"\n"+g+"\n"+I)}else""!==A?console.warn("THREE.WebGLProgram: Program Info Log:",A):""!==g&&""!==I||(e=!1);e&&(this.diagnostics={runnable:t,programLog:A,vertexShader:{log:g,prefix:u},fragmentShader:{log:I,prefix:w}})}let f,N;return C.deleteShader(y),C.deleteShader(G),this.getUniforms=function(){return void 0===f&&(f=new QB(C,D)),f},this.getAttributes=function(){return void 0===N&&(N=function(A,g){const I={},t=A.getProgramParameter(g,35721);for(let C=0;C<t;C++){const t=A.getActiveAttrib(g,C),e=t.name;let B=1;35674===t.type&&(B=2),35675===t.type&&(B=3),35676===t.type&&(B=4),I[e]={type:t.type,location:A.getAttribLocation(g,e),locationSize:B}}return I}(C,D)),N},this.destroy=function(){t.releaseStatesOfProgram(this),C.deleteProgram(D),this.program=void 0},this.name=I.shaderName,this.id=EB++,this.cacheKey=g,this.usedTimes=1,this.program=D,this.vertexShader=y,this.fragmentShader=G,this}let fB=0;class NB{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(A){const g=A.vertexShader,I=A.fragmentShader,t=this._getShaderStage(g),C=this._getShaderStage(I),e=this._getShaderCacheForMaterial(A);return!1===e.has(t)&&(e.add(t),t.usedTimes++),!1===e.has(C)&&(e.add(C),C.usedTimes++),this}remove(A){const g=this.materialCache.get(A);for(const A of g)A.usedTimes--,0===A.usedTimes&&this.shaderCache.delete(A.code);return this.materialCache.delete(A),this}getVertexShaderID(A){return this._getShaderStage(A.vertexShader).id}getFragmentShaderID(A){return this._getShaderStage(A.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(A){const g=this.materialCache;let I=g.get(A);return void 0===I&&(I=new Set,g.set(A,I)),I}_getShaderStage(A){const g=this.shaderCache;let I=g.get(A);return void 0===I&&(I=new FB(A),g.set(A,I)),I}}class FB{constructor(A){this.id=fB++,this.code=A,this.usedTimes=0}}function RB(A,g,I,t,C,e,B){const i=new zI,Q=new NB,o=[],E=C.isWebGL2,n=C.logarithmicDepthBuffer,r=C.vertexTextures;let c=C.precision;const l={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(e,i,o,D,u){const w=D.fog,d=u.geometry,p=e.isMeshStandardMaterial?D.environment:null,y=(e.isMeshStandardMaterial?I:g).get(e.envMap||p),G=y&&y.mapping===tA?y.image.height:null,f=l[e.type];null!==e.precision&&(c=C.getMaxPrecision(e.precision),c!==e.precision&&console.warn("THREE.WebGLProgram.getParameters:",e.precision,"not supported, using",c,"instead."));const N=d.morphAttributes.position||d.morphAttributes.normal||d.morphAttributes.color,F=void 0!==N?N.length:0;let R,m,k,S,M=0;if(void 0!==d.morphAttributes.position&&(M=1),void 0!==d.morphAttributes.normal&&(M=2),void 0!==d.morphAttributes.color&&(M=3),f){const A=RC[f];R=A.vertexShader,m=A.fragmentShader}else R=e.vertexShader,m=e.fragmentShader,Q.update(e),k=Q.getVertexShaderID(e),S=Q.getFragmentShaderID(e);const U=A.getRenderTarget(),K=e.alphaTest>0,J=e.clearcoat>0,Y=e.iridescence>0;return{isWebGL2:E,shaderID:f,shaderName:e.type,vertexShader:R,fragmentShader:m,defines:e.defines,customVertexShaderID:k,customFragmentShaderID:S,isRawShaderMaterial:!0===e.isRawShaderMaterial,glslVersion:e.glslVersion,precision:c,instancing:!0===u.isInstancedMesh,instancingColor:!0===u.isInstancedMesh&&null!==u.instanceColor,supportsVertexTextures:r,outputEncoding:null===U?A.outputEncoding:!0===U.isXRRenderTarget?U.texture.encoding:rg,map:!!e.map,matcap:!!e.matcap,envMap:!!y,envMapMode:y&&y.mapping,envMapCubeUVHeight:G,lightMap:!!e.lightMap,aoMap:!!e.aoMap,emissiveMap:!!e.emissiveMap,bumpMap:!!e.bumpMap,normalMap:!!e.normalMap,objectSpaceNormalMap:e.normalMapType===Dg,tangentSpaceNormalMap:e.normalMapType===lg,decodeVideoTexture:!!e.map&&!0===e.map.isVideoTexture&&e.map.encoding===hg,clearcoat:J,clearcoatMap:J&&!!e.clearcoatMap,clearcoatRoughnessMap:J&&!!e.clearcoatRoughnessMap,clearcoatNormalMap:J&&!!e.clearcoatNormalMap,iridescence:Y,iridescenceMap:Y&&!!e.iridescenceMap,iridescenceThicknessMap:Y&&!!e.iridescenceThicknessMap,displacementMap:!!e.displacementMap,roughnessMap:!!e.roughnessMap,metalnessMap:!!e.metalnessMap,specularMap:!!e.specularMap,specularIntensityMap:!!e.specularIntensityMap,specularColorMap:!!e.specularColorMap,opaque:!1===e.transparent&&e.blending===h,alphaMap:!!e.alphaMap,alphaTest:K,gradientMap:!!e.gradientMap,sheen:e.sheen>0,sheenColorMap:!!e.sheenColorMap,sheenRoughnessMap:!!e.sheenRoughnessMap,transmission:e.transmission>0,transmissionMap:!!e.transmissionMap,thicknessMap:!!e.thicknessMap,combine:e.combine,vertexTangents:!!e.normalMap&&!!d.attributes.tangent,vertexColors:e.vertexColors,vertexAlphas:!0===e.vertexColors&&!!d.attributes.color&&4===d.attributes.color.itemSize,vertexUvs:!!(e.map||e.bumpMap||e.normalMap||e.specularMap||e.alphaMap||e.emissiveMap||e.roughnessMap||e.metalnessMap||e.clearcoatMap||e.clearcoatRoughnessMap||e.clearcoatNormalMap||e.iridescenceMap||e.iridescenceThicknessMap||e.displacementMap||e.transmissionMap||e.thicknessMap||e.specularIntensityMap||e.specularColorMap||e.sheenColorMap||e.sheenRoughnessMap),uvsVertexOnly:!(e.map||e.bumpMap||e.normalMap||e.specularMap||e.alphaMap||e.emissiveMap||e.roughnessMap||e.metalnessMap||e.clearcoatNormalMap||e.iridescenceMap||e.iridescenceThicknessMap||e.transmission>0||e.transmissionMap||e.thicknessMap||e.specularIntensityMap||e.specularColorMap||e.sheen>0||e.sheenColorMap||e.sheenRoughnessMap||!e.displacementMap),fog:!!w,useFog:!0===e.fog,fogExp2:w&&w.isFogExp2,flatShading:!!e.flatShading,sizeAttenuation:e.sizeAttenuation,logarithmicDepthBuffer:n,skinning:!0===u.isSkinnedMesh,morphTargets:void 0!==d.morphAttributes.position,morphNormals:void 0!==d.morphAttributes.normal,morphColors:void 0!==d.morphAttributes.color,morphTargetsCount:F,morphTextureStride:M,numDirLights:i.directional.length,numPointLights:i.point.length,numSpotLights:i.spot.length,numSpotLightMaps:i.spotLightMap.length,numRectAreaLights:i.rectArea.length,numHemiLights:i.hemi.length,numDirLightShadows:i.directionalShadowMap.length,numPointLightShadows:i.pointShadowMap.length,numSpotLightShadows:i.spotShadowMap.length,numSpotLightShadowsWithMaps:i.numSpotLightShadowsWithMaps,numClippingPlanes:B.numPlanes,numClipIntersection:B.numIntersection,dithering:e.dithering,shadowMapEnabled:A.shadowMap.enabled&&o.length>0,shadowMapType:A.shadowMap.type,toneMapping:e.toneMapped?A.toneMapping:Z,physicallyCorrectLights:A.physicallyCorrectLights,premultipliedAlpha:e.premultipliedAlpha,doubleSided:e.side===a,flipSided:e.side===s,useDepthPacking:!!e.depthPacking,depthPacking:e.depthPacking||0,index0AttributeName:e.index0AttributeName,extensionDerivatives:e.extensions&&e.extensions.derivatives,extensionFragDepth:e.extensions&&e.extensions.fragDepth,extensionDrawBuffers:e.extensions&&e.extensions.drawBuffers,extensionShaderTextureLOD:e.extensions&&e.extensions.shaderTextureLOD,rendererExtensionFragDepth:E||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:E||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:E||t.has("EXT_shader_texture_lod"),customProgramCacheKey:e.customProgramCacheKey()}},getProgramCacheKey:function(g){const I=[];if(g.shaderID?I.push(g.shaderID):(I.push(g.customVertexShaderID),I.push(g.customFragmentShaderID)),void 0!==g.defines)for(const A in g.defines)I.push(A),I.push(g.defines[A]);return!1===g.isRawShaderMaterial&&(!function(A,g){A.push(g.precision),A.push(g.outputEncoding),A.push(g.envMapMode),A.push(g.envMapCubeUVHeight),A.push(g.combine),A.push(g.vertexUvs),A.push(g.fogExp2),A.push(g.sizeAttenuation),A.push(g.morphTargetsCount),A.push(g.morphAttributeCount),A.push(g.numDirLights),A.push(g.numPointLights),A.push(g.numSpotLights),A.push(g.numSpotLightMaps),A.push(g.numHemiLights),A.push(g.numRectAreaLights),A.push(g.numDirLightShadows),A.push(g.numPointLightShadows),A.push(g.numSpotLightShadows),A.push(g.numSpotLightShadowsWithMaps),A.push(g.shadowMapType),A.push(g.toneMapping),A.push(g.numClippingPlanes),A.push(g.numClipIntersection),A.push(g.depthPacking)}(I,g),function(A,g){i.disableAll(),g.isWebGL2&&i.enable(0);g.supportsVertexTextures&&i.enable(1);g.instancing&&i.enable(2);g.instancingColor&&i.enable(3);g.map&&i.enable(4);g.matcap&&i.enable(5);g.envMap&&i.enable(6);g.lightMap&&i.enable(7);g.aoMap&&i.enable(8);g.emissiveMap&&i.enable(9);g.bumpMap&&i.enable(10);g.normalMap&&i.enable(11);g.objectSpaceNormalMap&&i.enable(12);g.tangentSpaceNormalMap&&i.enable(13);g.clearcoat&&i.enable(14);g.clearcoatMap&&i.enable(15);g.clearcoatRoughnessMap&&i.enable(16);g.clearcoatNormalMap&&i.enable(17);g.iridescence&&i.enable(18);g.iridescenceMap&&i.enable(19);g.iridescenceThicknessMap&&i.enable(20);g.displacementMap&&i.enable(21);g.specularMap&&i.enable(22);g.roughnessMap&&i.enable(23);g.metalnessMap&&i.enable(24);g.gradientMap&&i.enable(25);g.alphaMap&&i.enable(26);g.alphaTest&&i.enable(27);g.vertexColors&&i.enable(28);g.vertexAlphas&&i.enable(29);g.vertexUvs&&i.enable(30);g.vertexTangents&&i.enable(31);g.uvsVertexOnly&&i.enable(32);A.push(i.mask),i.disableAll(),g.fog&&i.enable(0);g.useFog&&i.enable(1);g.flatShading&&i.enable(2);g.logarithmicDepthBuffer&&i.enable(3);g.skinning&&i.enable(4);g.morphTargets&&i.enable(5);g.morphNormals&&i.enable(6);g.morphColors&&i.enable(7);g.premultipliedAlpha&&i.enable(8);g.shadowMapEnabled&&i.enable(9);g.physicallyCorrectLights&&i.enable(10);g.doubleSided&&i.enable(11);g.flipSided&&i.enable(12);g.useDepthPacking&&i.enable(13);g.dithering&&i.enable(14);g.specularIntensityMap&&i.enable(15);g.specularColorMap&&i.enable(16);g.transmission&&i.enable(17);g.transmissionMap&&i.enable(18);g.thicknessMap&&i.enable(19);g.sheen&&i.enable(20);g.sheenColorMap&&i.enable(21);g.sheenRoughnessMap&&i.enable(22);g.decodeVideoTexture&&i.enable(23);g.opaque&&i.enable(24);A.push(i.mask)}(I,g),I.push(A.outputEncoding)),I.push(g.customProgramCacheKey),I.join()},getUniforms:function(A){const g=l[A.type];let I;if(g){const A=RC[g];I=QC.clone(A.uniforms)}else I=A.uniforms;return I},acquireProgram:function(g,I){let t;for(let A=0,g=o.length;A<g;A++){const g=o[A];if(g.cacheKey===I){t=g,++t.usedTimes;break}}return void 0===t&&(t=new GB(A,I,g,e),o.push(t)),t},releaseProgram:function(A){if(0==--A.usedTimes){const g=o.indexOf(A);o[g]=o[o.length-1],o.pop(),A.destroy()}},releaseShaderCache:function(A){Q.remove(A)},programs:o,dispose:function(){Q.dispose()}}}function mB(){let A=new WeakMap;return{get:function(g){let I=A.get(g);return void 0===I&&(I={},A.set(g,I)),I},remove:function(g){A.delete(g)},update:function(g,I,t){A.get(g)[I]=t},dispose:function(){A=new WeakMap}}}function kB(A,g){return A.groupOrder!==g.groupOrder?A.groupOrder-g.groupOrder:A.renderOrder!==g.renderOrder?A.renderOrder-g.renderOrder:A.material.id!==g.material.id?A.material.id-g.material.id:A.z!==g.z?A.z-g.z:A.id-g.id}function SB(A,g){return A.groupOrder!==g.groupOrder?A.groupOrder-g.groupOrder:A.renderOrder!==g.renderOrder?A.renderOrder-g.renderOrder:A.z!==g.z?g.z-A.z:A.id-g.id}function MB(){const A=[];let g=0;const I=[],t=[],C=[];function e(I,t,C,e,B,i){let Q=A[g];return void 0===Q?(Q={id:I.id,object:I,geometry:t,material:C,groupOrder:e,renderOrder:I.renderOrder,z:B,group:i},A[g]=Q):(Q.id=I.id,Q.object=I,Q.geometry=t,Q.material=C,Q.groupOrder=e,Q.renderOrder=I.renderOrder,Q.z=B,Q.group=i),g++,Q}return{opaque:I,transmissive:t,transparent:C,init:function(){g=0,I.length=0,t.length=0,C.length=0},push:function(A,g,B,i,Q,o){const E=e(A,g,B,i,Q,o);B.transmission>0?t.push(E):!0===B.transparent?C.push(E):I.push(E)},unshift:function(A,g,B,i,Q,o){const E=e(A,g,B,i,Q,o);B.transmission>0?t.unshift(E):!0===B.transparent?C.unshift(E):I.unshift(E)},finish:function(){for(let I=g,t=A.length;I<t;I++){const g=A[I];if(null===g.id)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.group=null}},sort:function(A,g){I.length>1&&I.sort(A||kB),t.length>1&&t.sort(g||SB),C.length>1&&C.sort(g||SB)}}}function UB(){let A=new WeakMap;return{get:function(g,I){const t=A.get(g);let C;return void 0===t?(C=new MB,A.set(g,[C])):I>=t.length?(C=new MB,t.push(C)):C=t[I],C},dispose:function(){A=new WeakMap}}}function KB(){const A={};return{get:function(g){if(void 0!==A[g.id])return A[g.id];let I;switch(g.type){case"DirectionalLight":I={direction:new oI,color:new zg};break;case"SpotLight":I={position:new oI,direction:new oI,color:new zg,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":I={position:new oI,color:new zg,distance:0,decay:0};break;case"HemisphereLight":I={direction:new oI,skyColor:new zg,groundColor:new zg};break;case"RectAreaLight":I={color:new zg,position:new oI,halfWidth:new oI,halfHeight:new oI}}return A[g.id]=I,I}}}let JB=0;function YB(A,g){return(g.castShadow?2:0)-(A.castShadow?2:0)+(g.map?1:0)-(A.map?1:0)}function LB(A,g){const I=new KB,t=function(){const A={};return{get:function(g){if(void 0!==A[g.id])return A[g.id];let I;switch(g.type){case"DirectionalLight":case"SpotLight":I={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Lg};break;case"PointLight":I={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Lg,shadowCameraNear:1,shadowCameraFar:1e3}}return A[g.id]=I,I}}}(),C={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let A=0;A<9;A++)C.probe.push(new oI);const e=new oI,B=new HI,i=new HI;return{setup:function(e,B){let i=0,Q=0,o=0;for(let A=0;A<9;A++)C.probe[A].set(0,0,0);let E=0,n=0,s=0,a=0,r=0,h=0,c=0,l=0,D=0,u=0;e.sort(YB);const w=!0!==B?Math.PI:1;for(let A=0,g=e.length;A<g;A++){const g=e[A],B=g.color,d=g.intensity,p=g.distance,y=g.shadow&&g.shadow.map?g.shadow.map.texture:null;if(g.isAmbientLight)i+=B.r*d*w,Q+=B.g*d*w,o+=B.b*d*w;else if(g.isLightProbe)for(let A=0;A<9;A++)C.probe[A].addScaledVector(g.sh.coefficients[A],d);else if(g.isDirectionalLight){const A=I.get(g);if(A.color.copy(g.color).multiplyScalar(g.intensity*w),g.castShadow){const A=g.shadow,I=t.get(g);I.shadowBias=A.bias,I.shadowNormalBias=A.normalBias,I.shadowRadius=A.radius,I.shadowMapSize=A.mapSize,C.directionalShadow[E]=I,C.directionalShadowMap[E]=y,C.directionalShadowMatrix[E]=g.shadow.matrix,h++}C.directional[E]=A,E++}else if(g.isSpotLight){const A=I.get(g);A.position.setFromMatrixPosition(g.matrixWorld),A.color.copy(B).multiplyScalar(d*w),A.distance=p,A.coneCos=Math.cos(g.angle),A.penumbraCos=Math.cos(g.angle*(1-g.penumbra)),A.decay=g.decay,C.spot[s]=A;const e=g.shadow;if(g.map&&(C.spotLightMap[D]=g.map,D++,e.updateMatrices(g),g.castShadow&&u++),C.spotLightMatrix[s]=e.matrix,g.castShadow){const A=t.get(g);A.shadowBias=e.bias,A.shadowNormalBias=e.normalBias,A.shadowRadius=e.radius,A.shadowMapSize=e.mapSize,C.spotShadow[s]=A,C.spotShadowMap[s]=y,l++}s++}else if(g.isRectAreaLight){const A=I.get(g);A.color.copy(B).multiplyScalar(d),A.halfWidth.set(.5*g.width,0,0),A.halfHeight.set(0,.5*g.height,0),C.rectArea[a]=A,a++}else if(g.isPointLight){const A=I.get(g);if(A.color.copy(g.color).multiplyScalar(g.intensity*w),A.distance=g.distance,A.decay=g.decay,g.castShadow){const A=g.shadow,I=t.get(g);I.shadowBias=A.bias,I.shadowNormalBias=A.normalBias,I.shadowRadius=A.radius,I.shadowMapSize=A.mapSize,I.shadowCameraNear=A.camera.near,I.shadowCameraFar=A.camera.far,C.pointShadow[n]=I,C.pointShadowMap[n]=y,C.pointShadowMatrix[n]=g.shadow.matrix,c++}C.point[n]=A,n++}else if(g.isHemisphereLight){const A=I.get(g);A.skyColor.copy(g.color).multiplyScalar(d*w),A.groundColor.copy(g.groundColor).multiplyScalar(d*w),C.hemi[r]=A,r++}}a>0&&(g.isWebGL2||!0===A.has("OES_texture_float_linear")?(C.rectAreaLTC1=FC.LTC_FLOAT_1,C.rectAreaLTC2=FC.LTC_FLOAT_2):!0===A.has("OES_texture_half_float_linear")?(C.rectAreaLTC1=FC.LTC_HALF_1,C.rectAreaLTC2=FC.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),C.ambient[0]=i,C.ambient[1]=Q,C.ambient[2]=o;const d=C.hash;d.directionalLength===E&&d.pointLength===n&&d.spotLength===s&&d.rectAreaLength===a&&d.hemiLength===r&&d.numDirectionalShadows===h&&d.numPointShadows===c&&d.numSpotShadows===l&&d.numSpotMaps===D||(C.directional.length=E,C.spot.length=s,C.rectArea.length=a,C.point.length=n,C.hemi.length=r,C.directionalShadow.length=h,C.directionalShadowMap.length=h,C.pointShadow.length=c,C.pointShadowMap.length=c,C.spotShadow.length=l,C.spotShadowMap.length=l,C.directionalShadowMatrix.length=h,C.pointShadowMatrix.length=c,C.spotLightMatrix.length=l+D-u,C.spotLightMap.length=D,C.numSpotLightShadowsWithMaps=u,d.directionalLength=E,d.pointLength=n,d.spotLength=s,d.rectAreaLength=a,d.hemiLength=r,d.numDirectionalShadows=h,d.numPointShadows=c,d.numSpotShadows=l,d.numSpotMaps=D,C.version=JB++)},setupView:function(A,g){let I=0,t=0,Q=0,o=0,E=0;const n=g.matrixWorldInverse;for(let g=0,s=A.length;g<s;g++){const s=A[g];if(s.isDirectionalLight){const A=C.directional[I];A.direction.setFromMatrixPosition(s.matrixWorld),e.setFromMatrixPosition(s.target.matrixWorld),A.direction.sub(e),A.direction.transformDirection(n),I++}else if(s.isSpotLight){const A=C.spot[Q];A.position.setFromMatrixPosition(s.matrixWorld),A.position.applyMatrix4(n),A.direction.setFromMatrixPosition(s.matrixWorld),e.setFromMatrixPosition(s.target.matrixWorld),A.direction.sub(e),A.direction.transformDirection(n),Q++}else if(s.isRectAreaLight){const A=C.rectArea[o];A.position.setFromMatrixPosition(s.matrixWorld),A.position.applyMatrix4(n),i.identity(),B.copy(s.matrixWorld),B.premultiply(n),i.extractRotation(B),A.halfWidth.set(.5*s.width,0,0),A.halfHeight.set(0,.5*s.height,0),A.halfWidth.applyMatrix4(i),A.halfHeight.applyMatrix4(i),o++}else if(s.isPointLight){const A=C.point[t];A.position.setFromMatrixPosition(s.matrixWorld),A.position.applyMatrix4(n),t++}else if(s.isHemisphereLight){const A=C.hemi[E];A.direction.setFromMatrixPosition(s.matrixWorld),A.direction.transformDirection(n),E++}}},state:C}}function xB(A,g){const I=new LB(A,g),t=[],C=[];return{init:function(){t.length=0,C.length=0},state:{lightsArray:t,shadowsArray:C,lights:I},setupLights:function(A){I.setup(t,A)},setupLightsView:function(A){I.setupView(t,A)},pushLight:function(A){t.push(A)},pushShadow:function(A){C.push(A)}}}function bB(A,g){let I=new WeakMap;return{get:function(t,C=0){const e=I.get(t);let B;return void 0===e?(B=new xB(A,g),I.set(t,[B])):C>=e.length?(B=new xB(A,g),e.push(B)):B=e[C],B},dispose:function(){I=new WeakMap}}}class HB extends Gt{constructor(A){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(A)}copy(A){return super.copy(A),this.depthPacking=A.depthPacking,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this}}class qB extends Gt{constructor(A){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new oI,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(A)}copy(A){return super.copy(A),this.referencePosition.copy(A.referencePosition),this.nearDistance=A.nearDistance,this.farDistance=A.farDistance,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this}}const TB="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",vB="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function VB(A,g,I){let t=new pC;const C=new Lg,e=new Lg,B=new CI,i=new HB({depthPacking:cg}),o=new qB,h={},c=I.maxTextureSize,l={0:s,1:n,2:a},D=new oC({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Lg},radius:{value:4}},vertexShader:TB,fragmentShader:vB}),u=D.clone();u.defines.HORIZONTAL_PASS=1;const w=new bt;w.setAttribute("position",new Rt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const d=new tC(w,D),p=this;function y(I,t){const e=g.update(d);D.defines.VSM_SAMPLES!==I.blurSamples&&(D.defines.VSM_SAMPLES=I.blurSamples,u.defines.VSM_SAMPLES=I.blurSamples,D.needsUpdate=!0,u.needsUpdate=!0),null===I.mapPass&&(I.mapPass=new eI(C.x,C.y)),D.uniforms.shadow_pass.value=I.map.texture,D.uniforms.resolution.value=I.mapSize,D.uniforms.radius.value=I.radius,A.setRenderTarget(I.mapPass),A.clear(),A.renderBufferDirect(t,null,e,D,d,null),u.uniforms.shadow_pass.value=I.mapPass.texture,u.uniforms.resolution.value=I.mapSize,u.uniforms.radius.value=I.radius,A.setRenderTarget(I.map),A.clear(),A.renderBufferDirect(t,null,e,u,d,null)}function G(g,I,t,C,e,B){let Q=null;const n=!0===t.isPointLight?g.customDistanceMaterial:g.customDepthMaterial;if(Q=void 0!==n?n:!0===t.isPointLight?o:i,A.localClippingEnabled&&!0===I.clipShadows&&Array.isArray(I.clippingPlanes)&&0!==I.clippingPlanes.length||I.displacementMap&&0!==I.displacementScale||I.alphaMap&&I.alphaTest>0){const A=Q.uuid,g=I.uuid;let t=h[A];void 0===t&&(t={},h[A]=t);let C=t[g];void 0===C&&(C=Q.clone(),t[g]=C),Q=C}return Q.visible=I.visible,Q.wireframe=I.wireframe,Q.side=B===E?null!==I.shadowSide?I.shadowSide:I.side:null!==I.shadowSide?I.shadowSide:l[I.side],Q.alphaMap=I.alphaMap,Q.alphaTest=I.alphaTest,Q.clipShadows=I.clipShadows,Q.clippingPlanes=I.clippingPlanes,Q.clipIntersection=I.clipIntersection,Q.displacementMap=I.displacementMap,Q.displacementScale=I.displacementScale,Q.displacementBias=I.displacementBias,Q.wireframeLinewidth=I.wireframeLinewidth,Q.linewidth=I.linewidth,!0===t.isPointLight&&!0===Q.isMeshDistanceMaterial&&(Q.referencePosition.setFromMatrixPosition(t.matrixWorld),Q.nearDistance=C,Q.farDistance=e),Q}function f(I,C,e,B,i){if(!1===I.visible)return;if(I.layers.test(C.layers)&&(I.isMesh||I.isLine||I.isPoints)&&(I.castShadow||I.receiveShadow&&i===E)&&(!I.frustumCulled||t.intersectsObject(I))){I.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse,I.matrixWorld);const t=g.update(I),C=I.material;if(Array.isArray(C)){const g=t.groups;for(let Q=0,o=g.length;Q<o;Q++){const o=g[Q],E=C[o.materialIndex];if(E&&E.visible){const g=G(I,E,B,e.near,e.far,i);A.renderBufferDirect(e,null,t,g,I,o)}}}else if(C.visible){const g=G(I,C,B,e.near,e.far,i);A.renderBufferDirect(e,null,t,g,I,null)}}const Q=I.children;for(let A=0,g=Q.length;A<g;A++)f(Q[A],C,e,B,i)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Q,this.render=function(g,I,i){if(!1===p.enabled)return;if(!1===p.autoUpdate&&!1===p.needsUpdate)return;if(0===g.length)return;const Q=A.getRenderTarget(),o=A.getActiveCubeFace(),n=A.getActiveMipmapLevel(),s=A.state;s.setBlending(r),s.buffers.color.setClear(1,1,1,1),s.buffers.depth.setTest(!0),s.setScissorTest(!1);for(let Q=0,o=g.length;Q<o;Q++){const o=g[Q],n=o.shadow;if(void 0===n){console.warn("THREE.WebGLShadowMap:",o,"has no shadow.");continue}if(!1===n.autoUpdate&&!1===n.needsUpdate)continue;C.copy(n.mapSize);const a=n.getFrameExtents();if(C.multiply(a),e.copy(n.mapSize),(C.x>c||C.y>c)&&(C.x>c&&(e.x=Math.floor(c/a.x),C.x=e.x*a.x,n.mapSize.x=e.x),C.y>c&&(e.y=Math.floor(c/a.y),C.y=e.y*a.y,n.mapSize.y=e.y)),null===n.map){const A=this.type!==E?{minFilter:iA,magFilter:iA}:{};n.map=new eI(C.x,C.y,A),n.map.texture.name=o.name+".shadowMap",n.camera.updateProjectionMatrix()}A.setRenderTarget(n.map),A.clear();const r=n.getViewportCount();for(let A=0;A<r;A++){const g=n.getViewport(A);B.set(e.x*g.x,e.y*g.y,e.x*g.z,e.y*g.w),s.viewport(B),n.updateMatrices(o,A),t=n.getFrustum(),f(I,i,n.camera,o,this.type)}!0!==n.isPointLightShadow&&this.type===E&&y(n,i),n.needsUpdate=!1}p.needsUpdate=!1,A.setRenderTarget(Q,o,n)}}function WB(A,g,I){const t=I.isWebGL2;const C=new function(){let g=!1;const I=new CI;let t=null;const C=new CI(0,0,0,0);return{setMask:function(I){t===I||g||(A.colorMask(I,I,I,I),t=I)},setLocked:function(A){g=A},setClear:function(g,t,e,B,i){!0===i&&(g*=B,t*=B,e*=B),I.set(g,t,e,B),!1===C.equals(I)&&(A.clearColor(g,t,e,B),C.copy(I))},reset:function(){g=!1,t=null,C.set(-1,0,0,0)}}},Q=new function(){let g=!1,I=null,t=null,C=null;return{setTest:function(A){A?dA(2929):pA(2929)},setMask:function(t){I===t||g||(A.depthMask(t),I=t)},setFunc:function(g){if(t!==g){switch(g){case Y:A.depthFunc(512);break;case L:A.depthFunc(519);break;case x:A.depthFunc(513);break;case b:A.depthFunc(515);break;case H:A.depthFunc(514);break;case q:A.depthFunc(518);break;case T:A.depthFunc(516);break;case v:A.depthFunc(517);break;default:A.depthFunc(515)}t=g}},setLocked:function(A){g=A},setClear:function(g){C!==g&&(A.clearDepth(g),C=g)},reset:function(){g=!1,I=null,t=null,C=null}}},o=new function(){let g=!1,I=null,t=null,C=null,e=null,B=null,i=null,Q=null,o=null;return{setTest:function(A){g||(A?dA(2960):pA(2960))},setMask:function(t){I===t||g||(A.stencilMask(t),I=t)},setFunc:function(g,I,B){t===g&&C===I&&e===B||(A.stencilFunc(g,I,B),t=g,C=I,e=B)},setOp:function(g,I,t){B===g&&i===I&&Q===t||(A.stencilOp(g,I,t),B=g,i=I,Q=t)},setLocked:function(A){g=A},setClear:function(g){o!==g&&(A.clearStencil(g),o=g)},reset:function(){g=!1,I=null,t=null,C=null,e=null,B=null,i=null,Q=null,o=null}}},E=new WeakMap,n=new WeakMap;let V={},W={},O=new WeakMap,Z=[],P=null,X=!1,j=null,z=null,_=null,$=null,AA=null,gA=null,IA=null,tA=!1,CA=null,eA=null,BA=null,iA=null,QA=null;const oA=A.getParameter(35661);let EA=!1,nA=0;const sA=A.getParameter(7938);-1!==sA.indexOf("WebGL")?(nA=parseFloat(/^WebGL (\d)/.exec(sA)[1]),EA=nA>=1):-1!==sA.indexOf("OpenGL ES")&&(nA=parseFloat(/^OpenGL ES (\d)/.exec(sA)[1]),EA=nA>=2);let aA=null,rA={};const hA=A.getParameter(3088),cA=A.getParameter(2978),lA=(new CI).fromArray(hA),DA=(new CI).fromArray(cA);function uA(g,I,t){const C=new Uint8Array(4),e=A.createTexture();A.bindTexture(g,e),A.texParameteri(g,10241,9728),A.texParameteri(g,10240,9728);for(let g=0;g<t;g++)A.texImage2D(I+g,0,6408,1,1,0,6408,5121,C);return e}const wA={};function dA(g){!0!==V[g]&&(A.enable(g),V[g]=!0)}function pA(g){!1!==V[g]&&(A.disable(g),V[g]=!1)}wA[3553]=uA(3553,3553,1),wA[34067]=uA(34067,34069,6),C.setClear(0,0,0,1),Q.setClear(1),o.setClear(0),dA(2929),Q.setFunc(b),NA(!1),FA(B),dA(2884),fA(r);const yA={[w]:32774,[d]:32778,[p]:32779};if(t)yA[y]=32775,yA[G]=32776;else{const A=g.get("EXT_blend_minmax");null!==A&&(yA[y]=A.MIN_EXT,yA[G]=A.MAX_EXT)}const GA={[f]:0,[N]:1,[F]:768,[m]:770,[J]:776,[U]:774,[S]:772,[R]:769,[k]:771,[K]:775,[M]:773};function fA(g,I,t,C,e,B,i,Q){if(g!==r){if(!1===X&&(dA(3042),X=!0),g===u)e=e||I,B=B||t,i=i||C,I===z&&e===AA||(A.blendEquationSeparate(yA[I],yA[e]),z=I,AA=e),t===_&&C===$&&B===gA&&i===IA||(A.blendFuncSeparate(GA[t],GA[C],GA[B],GA[i]),_=t,$=C,gA=B,IA=i),j=g,tA=null;else if(g!==j||Q!==tA){if(z===w&&AA===w||(A.blendEquation(32774),z=w,AA=w),Q)switch(g){case h:A.blendFuncSeparate(1,771,1,771);break;case c:A.blendFunc(1,1);break;case l:A.blendFuncSeparate(0,769,0,1);break;case D:A.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",g)}else switch(g){case h:A.blendFuncSeparate(770,771,1,771);break;case c:A.blendFunc(770,1);break;case l:A.blendFuncSeparate(0,769,0,1);break;case D:A.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",g)}_=null,$=null,gA=null,IA=null,j=g,tA=Q}}else!0===X&&(pA(3042),X=!1)}function NA(g){CA!==g&&(g?A.frontFace(2304):A.frontFace(2305),CA=g)}function FA(g){g!==e?(dA(2884),g!==eA&&(g===B?A.cullFace(1029):g===i?A.cullFace(1028):A.cullFace(1032))):pA(2884),eA=g}function RA(g,I,t){g?(dA(32823),iA===I&&QA===t||(A.polygonOffset(I,t),iA=I,QA=t)):pA(32823)}return{buffers:{color:C,depth:Q,stencil:o},enable:dA,disable:pA,bindFramebuffer:function(g,I){return W[g]!==I&&(A.bindFramebuffer(g,I),W[g]=I,t&&(36009===g&&(W[36160]=I),36160===g&&(W[36009]=I)),!0)},drawBuffers:function(t,C){let e=Z,B=!1;if(t)if(e=O.get(C),void 0===e&&(e=[],O.set(C,e)),t.isWebGLMultipleRenderTargets){const A=t.texture;if(e.length!==A.length||36064!==e[0]){for(let g=0,I=A.length;g<I;g++)e[g]=36064+g;e.length=A.length,B=!0}}else 36064!==e[0]&&(e[0]=36064,B=!0);else 1029!==e[0]&&(e[0]=1029,B=!0);B&&(I.isWebGL2?A.drawBuffers(e):g.get("WEBGL_draw_buffers").drawBuffersWEBGL(e))},useProgram:function(g){return P!==g&&(A.useProgram(g),P=g,!0)},setBlending:fA,setMaterial:function(A,g){A.side===a?pA(2884):dA(2884);let I=A.side===s;g&&(I=!I),NA(I),A.blending===h&&!1===A.transparent?fA(r):fA(A.blending,A.blendEquation,A.blendSrc,A.blendDst,A.blendEquationAlpha,A.blendSrcAlpha,A.blendDstAlpha,A.premultipliedAlpha),Q.setFunc(A.depthFunc),Q.setTest(A.depthTest),Q.setMask(A.depthWrite),C.setMask(A.colorWrite);const t=A.stencilWrite;o.setTest(t),t&&(o.setMask(A.stencilWriteMask),o.setFunc(A.stencilFunc,A.stencilRef,A.stencilFuncMask),o.setOp(A.stencilFail,A.stencilZFail,A.stencilZPass)),RA(A.polygonOffset,A.polygonOffsetFactor,A.polygonOffsetUnits),!0===A.alphaToCoverage?dA(32926):pA(32926)},setFlipSided:NA,setCullFace:FA,setLineWidth:function(g){g!==BA&&(EA&&A.lineWidth(g),BA=g)},setPolygonOffset:RA,setScissorTest:function(A){A?dA(3089):pA(3089)},activeTexture:function(g){void 0===g&&(g=33984+oA-1),aA!==g&&(A.activeTexture(g),aA=g)},bindTexture:function(g,I,t){void 0===t&&(t=null===aA?33984+oA-1:aA);let C=rA[t];void 0===C&&(C={type:void 0,texture:void 0},rA[t]=C),C.type===g&&C.texture===I||(aA!==t&&(A.activeTexture(t),aA=t),A.bindTexture(g,I||wA[g]),C.type=g,C.texture=I)},unbindTexture:function(){const g=rA[aA];void 0!==g&&void 0!==g.type&&(A.bindTexture(g.type,null),g.type=void 0,g.texture=void 0)},compressedTexImage2D:function(){try{A.compressedTexImage2D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},texImage2D:function(){try{A.texImage2D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},texImage3D:function(){try{A.texImage3D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},updateUBOMapping:function(g,I){let t=n.get(I);void 0===t&&(t=new WeakMap,n.set(I,t));let C=t.get(g);void 0===C&&(C=A.getUniformBlockIndex(I,g.name),t.set(g,C))},uniformBlockBinding:function(g,I){const t=n.get(I).get(g);E.get(g)!==t&&(A.uniformBlockBinding(I,t,g.__bindingPointIndex),E.set(g,t))},texStorage2D:function(){try{A.texStorage2D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},texStorage3D:function(){try{A.texStorage3D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},texSubImage2D:function(){try{A.texSubImage2D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},texSubImage3D:function(){try{A.texSubImage3D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},compressedTexSubImage2D:function(){try{A.compressedTexSubImage2D.apply(A,arguments)}catch(A){console.error("THREE.WebGLState:",A)}},scissor:function(g){!1===lA.equals(g)&&(A.scissor(g.x,g.y,g.z,g.w),lA.copy(g))},viewport:function(g){!1===DA.equals(g)&&(A.viewport(g.x,g.y,g.z,g.w),DA.copy(g))},reset:function(){A.disable(3042),A.disable(2884),A.disable(2929),A.disable(32823),A.disable(3089),A.disable(2960),A.disable(32926),A.blendEquation(32774),A.blendFunc(1,0),A.blendFuncSeparate(1,0,1,0),A.colorMask(!0,!0,!0,!0),A.clearColor(0,0,0,0),A.depthMask(!0),A.depthFunc(513),A.clearDepth(1),A.stencilMask(4294967295),A.stencilFunc(519,0,4294967295),A.stencilOp(7680,7680,7680),A.clearStencil(0),A.cullFace(1029),A.frontFace(2305),A.polygonOffset(0,0),A.activeTexture(33984),A.bindFramebuffer(36160,null),!0===t&&(A.bindFramebuffer(36009,null),A.bindFramebuffer(36008,null)),A.useProgram(null),A.lineWidth(1),A.scissor(0,0,A.canvas.width,A.canvas.height),A.viewport(0,0,A.canvas.width,A.canvas.height),V={},aA=null,rA={},W={},O=new WeakMap,Z=[],P=null,X=!1,j=null,z=null,_=null,$=null,AA=null,gA=null,IA=null,tA=!1,CA=null,eA=null,BA=null,iA=null,QA=null,lA.set(0,0,A.canvas.width,A.canvas.height),DA.set(0,0,A.canvas.width,A.canvas.height),C.reset(),Q.reset(),o.reset()}}}function OB(A,g,I,t,C,e,B){const i=C.isWebGL2,Q=C.maxTextures,o=C.maxCubemapSize,E=C.maxTextureSize,n=C.maxSamples,s=g.has("WEBGL_multisampled_render_to_texture")?g.get("WEBGL_multisampled_render_to_texture"):null,a=/OculusBrowser/g.test(navigator.userAgent),r=new WeakMap;let h;const c=new WeakMap;let l=!1;try{l="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(A){}function D(A,g){return l?new OffscreenCanvas(A,g):Hg("canvas")}function u(A,g,I,t){let C=1;if((A.width>t||A.height>t)&&(C=t/Math.max(A.width,A.height)),C<1||!0===g){if("undefined"!=typeof HTMLImageElement&&A instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&A instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&A instanceof ImageBitmap){const t=g?Kg:Math.floor,e=t(C*A.width),B=t(C*A.height);void 0===h&&(h=D(e,B));const i=I?D(e,B):h;i.width=e,i.height=B;return i.getContext("2d").drawImage(A,0,0,e,B),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+A.width+"x"+A.height+") to ("+e+"x"+B+")."),i}return"data"in A&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+A.width+"x"+A.height+")."),A}return A}function w(A){return Ug(A.width)&&Ug(A.height)}function d(A,g){return A.generateMipmaps&&g&&A.minFilter!==iA&&A.minFilter!==EA}function p(g){A.generateMipmap(g)}function y(I,t,C,e,B=!1){if(!1===i)return t;if(null!==I){if(void 0!==A[I])return A[I];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+I+"'")}let Q=t;return 6403===t&&(5126===C&&(Q=33326),5131===C&&(Q=33325),5121===C&&(Q=33321)),33319===t&&(5126===C&&(Q=33328),5131===C&&(Q=33327),5121===C&&(Q=33323)),6408===t&&(5126===C&&(Q=34836),5131===C&&(Q=34842),5121===C&&(Q=e===hg&&!1===B?35907:32856),32819===C&&(Q=32854),32820===C&&(Q=32855)),33325!==Q&&33326!==Q&&33327!==Q&&33328!==Q&&34842!==Q&&34836!==Q||g.get("EXT_color_buffer_float"),Q}function G(A,g,I){return!0===d(A,I)||A.isFramebufferTexture&&A.minFilter!==iA&&A.minFilter!==EA?Math.log2(Math.max(g.width,g.height))+1:void 0!==A.mipmaps&&A.mipmaps.length>0?A.mipmaps.length:A.isCompressedTexture&&Array.isArray(A.image)?g.mipmaps.length:1}function f(A){return A===iA||A===QA||A===oA?9728:9729}function N(A){const g=A.target;g.removeEventListener("dispose",N),function(A){const g=t.get(A);if(void 0===g.__webglInit)return;const I=A.source,C=c.get(I);if(C){const t=C[g.__cacheKey];t.usedTimes--,0===t.usedTimes&&R(A),0===Object.keys(C).length&&c.delete(I)}t.remove(A)}(g),g.isVideoTexture&&r.delete(g)}function F(g){const I=g.target;I.removeEventListener("dispose",F),function(g){const I=g.texture,C=t.get(g),e=t.get(I);void 0!==e.__webglTexture&&(A.deleteTexture(e.__webglTexture),B.memory.textures--);g.depthTexture&&g.depthTexture.dispose();if(g.isWebGLCubeRenderTarget)for(let g=0;g<6;g++)A.deleteFramebuffer(C.__webglFramebuffer[g]),C.__webglDepthbuffer&&A.deleteRenderbuffer(C.__webglDepthbuffer[g]);else{if(A.deleteFramebuffer(C.__webglFramebuffer),C.__webglDepthbuffer&&A.deleteRenderbuffer(C.__webglDepthbuffer),C.__webglMultisampledFramebuffer&&A.deleteFramebuffer(C.__webglMultisampledFramebuffer),C.__webglColorRenderbuffer)for(let g=0;g<C.__webglColorRenderbuffer.length;g++)C.__webglColorRenderbuffer[g]&&A.deleteRenderbuffer(C.__webglColorRenderbuffer[g]);C.__webglDepthRenderbuffer&&A.deleteRenderbuffer(C.__webglDepthRenderbuffer)}if(g.isWebGLMultipleRenderTargets)for(let g=0,C=I.length;g<C;g++){const C=t.get(I[g]);C.__webglTexture&&(A.deleteTexture(C.__webglTexture),B.memory.textures--),t.remove(I[g])}t.remove(I),t.remove(g)}(I)}function R(g){const I=t.get(g);A.deleteTexture(I.__webglTexture);const C=g.source;delete c.get(C)[I.__cacheKey],B.memory.textures--}let m=0;function k(A,g){const C=t.get(A);if(A.isVideoTexture&&function(A){const g=B.render.frame;r.get(A)!==g&&(r.set(A,g),A.update())}(A),!1===A.isRenderTargetTexture&&A.version>0&&C.__version!==A.version){const I=A.image;if(null===I)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==I.complete)return void J(C,A,g);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}I.bindTexture(3553,C.__webglTexture,33984+g)}const S={[CA]:10497,[eA]:33071,[BA]:33648},M={[iA]:9728,[QA]:9984,[oA]:9986,[EA]:9729,[nA]:9985,[sA]:9987};function U(I,e,B){if(B?(A.texParameteri(I,10242,S[e.wrapS]),A.texParameteri(I,10243,S[e.wrapT]),32879!==I&&35866!==I||A.texParameteri(I,32882,S[e.wrapR]),A.texParameteri(I,10240,M[e.magFilter]),A.texParameteri(I,10241,M[e.minFilter])):(A.texParameteri(I,10242,33071),A.texParameteri(I,10243,33071),32879!==I&&35866!==I||A.texParameteri(I,32882,33071),e.wrapS===eA&&e.wrapT===eA||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),A.texParameteri(I,10240,f(e.magFilter)),A.texParameteri(I,10241,f(e.minFilter)),e.minFilter!==iA&&e.minFilter!==EA&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===g.has("EXT_texture_filter_anisotropic")){const B=g.get("EXT_texture_filter_anisotropic");if(e.type===uA&&!1===g.has("OES_texture_float_linear"))return;if(!1===i&&e.type===wA&&!1===g.has("OES_texture_half_float_linear"))return;(e.anisotropy>1||t.get(e).__currentAnisotropy)&&(A.texParameterf(I,B.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(e.anisotropy,C.getMaxAnisotropy())),t.get(e).__currentAnisotropy=e.anisotropy)}}function K(g,I){let t=!1;void 0===g.__webglInit&&(g.__webglInit=!0,I.addEventListener("dispose",N));const C=I.source;let e=c.get(C);void 0===e&&(e={},c.set(C,e));const i=function(A){const g=[];return g.push(A.wrapS),g.push(A.wrapT),g.push(A.magFilter),g.push(A.minFilter),g.push(A.anisotropy),g.push(A.internalFormat),g.push(A.format),g.push(A.type),g.push(A.generateMipmaps),g.push(A.premultiplyAlpha),g.push(A.flipY),g.push(A.unpackAlignment),g.push(A.encoding),g.join()}(I);if(i!==g.__cacheKey){void 0===e[i]&&(e[i]={texture:A.createTexture(),usedTimes:0},B.memory.textures++,t=!0),e[i].usedTimes++;const C=e[g.__cacheKey];void 0!==C&&(e[g.__cacheKey].usedTimes--,0===C.usedTimes&&R(I)),g.__cacheKey=i,g.__webglTexture=e[i].texture}return t}function J(g,C,B){let Q=3553;C.isDataArrayTexture&&(Q=35866),C.isData3DTexture&&(Q=32879);const o=K(g,C),n=C.source;I.bindTexture(Q,g.__webglTexture,33984+B);const s=t.get(n);if(n.version!==s.__version||!0===o){I.activeTexture(33984+B),A.pixelStorei(37440,C.flipY),A.pixelStorei(37441,C.premultiplyAlpha),A.pixelStorei(3317,C.unpackAlignment),A.pixelStorei(37443,0);const g=function(A){return!i&&(A.wrapS!==eA||A.wrapT!==eA||A.minFilter!==iA&&A.minFilter!==EA)}(C)&&!1===w(C.image);let t=u(C.image,g,!1,E);t=q(C,t);const a=w(t)||i,r=e.convert(C.format,C.encoding);let h,c=e.convert(C.type),l=y(C.internalFormat,r,c,C.encoding,C.isVideoTexture);U(Q,C,a);const D=C.mipmaps,f=i&&!0!==C.isVideoTexture,N=void 0===s.__version||!0===o,F=G(C,t,a);if(C.isDepthTexture)l=6402,i?l=C.type===uA?36012:C.type===DA?33190:C.type===yA?35056:33189:C.type===uA&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),C.format===mA&&6402===l&&C.type!==cA&&C.type!==DA&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),C.type=DA,c=e.convert(C.type)),C.format===kA&&6402===l&&(l=34041,C.type!==yA&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),C.type=yA,c=e.convert(C.type))),N&&(f?I.texStorage2D(3553,1,l,t.width,t.height):I.texImage2D(3553,0,l,t.width,t.height,0,r,c,null));else if(C.isDataTexture)if(D.length>0&&a){f&&N&&I.texStorage2D(3553,F,l,D[0].width,D[0].height);for(let A=0,g=D.length;A<g;A++)h=D[A],f?I.texSubImage2D(3553,A,0,0,h.width,h.height,r,c,h.data):I.texImage2D(3553,A,l,h.width,h.height,0,r,c,h.data);C.generateMipmaps=!1}else f?(N&&I.texStorage2D(3553,F,l,t.width,t.height),I.texSubImage2D(3553,0,0,0,t.width,t.height,r,c,t.data)):I.texImage2D(3553,0,l,t.width,t.height,0,r,c,t.data);else if(C.isCompressedTexture){f&&N&&I.texStorage2D(3553,F,l,D[0].width,D[0].height);for(let A=0,g=D.length;A<g;A++)h=D[A],C.format!==NA?null!==r?f?I.compressedTexSubImage2D(3553,A,0,0,h.width,h.height,r,h.data):I.compressedTexImage2D(3553,A,l,h.width,h.height,0,h.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):f?I.texSubImage2D(3553,A,0,0,h.width,h.height,r,c,h.data):I.texImage2D(3553,A,l,h.width,h.height,0,r,c,h.data)}else if(C.isDataArrayTexture)f?(N&&I.texStorage3D(35866,F,l,t.width,t.height,t.depth),I.texSubImage3D(35866,0,0,0,0,t.width,t.height,t.depth,r,c,t.data)):I.texImage3D(35866,0,l,t.width,t.height,t.depth,0,r,c,t.data);else if(C.isData3DTexture)f?(N&&I.texStorage3D(32879,F,l,t.width,t.height,t.depth),I.texSubImage3D(32879,0,0,0,0,t.width,t.height,t.depth,r,c,t.data)):I.texImage3D(32879,0,l,t.width,t.height,t.depth,0,r,c,t.data);else if(C.isFramebufferTexture){if(N)if(f)I.texStorage2D(3553,F,l,t.width,t.height);else{let A=t.width,g=t.height;for(let t=0;t<F;t++)I.texImage2D(3553,t,l,A,g,0,r,c,null),A>>=1,g>>=1}}else if(D.length>0&&a){f&&N&&I.texStorage2D(3553,F,l,D[0].width,D[0].height);for(let A=0,g=D.length;A<g;A++)h=D[A],f?I.texSubImage2D(3553,A,0,0,r,c,h):I.texImage2D(3553,A,l,r,c,h);C.generateMipmaps=!1}else f?(N&&I.texStorage2D(3553,F,l,t.width,t.height),I.texSubImage2D(3553,0,0,0,r,c,t)):I.texImage2D(3553,0,l,r,c,t);d(C,a)&&p(Q),s.__version=n.version,C.onUpdate&&C.onUpdate(C)}g.__version=C.version}function Y(g,C,B,i,Q){const o=e.convert(B.format,B.encoding),E=e.convert(B.type),n=y(B.internalFormat,o,E,B.encoding);t.get(C).__hasExternalTextures||(32879===Q||35866===Q?I.texImage3D(Q,0,n,C.width,C.height,C.depth,0,o,E,null):I.texImage2D(Q,0,n,C.width,C.height,0,o,E,null)),I.bindFramebuffer(36160,g),H(C)?s.framebufferTexture2DMultisampleEXT(36160,i,Q,t.get(B).__webglTexture,0,b(C)):A.framebufferTexture2D(36160,i,Q,t.get(B).__webglTexture,0),I.bindFramebuffer(36160,null)}function L(g,I,t){if(A.bindRenderbuffer(36161,g),I.depthBuffer&&!I.stencilBuffer){let C=33189;if(t||H(I)){const g=I.depthTexture;g&&g.isDepthTexture&&(g.type===uA?C=36012:g.type===DA&&(C=33190));const t=b(I);H(I)?s.renderbufferStorageMultisampleEXT(36161,t,C,I.width,I.height):A.renderbufferStorageMultisample(36161,t,C,I.width,I.height)}else A.renderbufferStorage(36161,C,I.width,I.height);A.framebufferRenderbuffer(36160,36096,36161,g)}else if(I.depthBuffer&&I.stencilBuffer){const C=b(I);t&&!1===H(I)?A.renderbufferStorageMultisample(36161,C,35056,I.width,I.height):H(I)?s.renderbufferStorageMultisampleEXT(36161,C,35056,I.width,I.height):A.renderbufferStorage(36161,34041,I.width,I.height),A.framebufferRenderbuffer(36160,33306,36161,g)}else{const g=!0===I.isWebGLMultipleRenderTargets?I.texture:[I.texture];for(let C=0;C<g.length;C++){const B=g[C],i=e.convert(B.format,B.encoding),Q=e.convert(B.type),o=y(B.internalFormat,i,Q,B.encoding),E=b(I);t&&!1===H(I)?A.renderbufferStorageMultisample(36161,E,o,I.width,I.height):H(I)?s.renderbufferStorageMultisampleEXT(36161,E,o,I.width,I.height):A.renderbufferStorage(36161,o,I.width,I.height)}}A.bindRenderbuffer(36161,null)}function x(g){const C=t.get(g),e=!0===g.isWebGLCubeRenderTarget;if(g.depthTexture&&!C.__autoAllocateDepthBuffer){if(e)throw new Error("target.depthTexture not supported in Cube render targets");!function(g,C){if(C&&C.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(I.bindFramebuffer(36160,g),!C.depthTexture||!C.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");t.get(C.depthTexture).__webglTexture&&C.depthTexture.image.width===C.width&&C.depthTexture.image.height===C.height||(C.depthTexture.image.width=C.width,C.depthTexture.image.height=C.height,C.depthTexture.needsUpdate=!0),k(C.depthTexture,0);const e=t.get(C.depthTexture).__webglTexture,B=b(C);if(C.depthTexture.format===mA)H(C)?s.framebufferTexture2DMultisampleEXT(36160,36096,3553,e,0,B):A.framebufferTexture2D(36160,36096,3553,e,0);else{if(C.depthTexture.format!==kA)throw new Error("Unknown depthTexture format");H(C)?s.framebufferTexture2DMultisampleEXT(36160,33306,3553,e,0,B):A.framebufferTexture2D(36160,33306,3553,e,0)}}(C.__webglFramebuffer,g)}else if(e){C.__webglDepthbuffer=[];for(let t=0;t<6;t++)I.bindFramebuffer(36160,C.__webglFramebuffer[t]),C.__webglDepthbuffer[t]=A.createRenderbuffer(),L(C.__webglDepthbuffer[t],g,!1)}else I.bindFramebuffer(36160,C.__webglFramebuffer),C.__webglDepthbuffer=A.createRenderbuffer(),L(C.__webglDepthbuffer,g,!1);I.bindFramebuffer(36160,null)}function b(A){return Math.min(n,A.samples)}function H(A){const I=t.get(A);return i&&A.samples>0&&!0===g.has("WEBGL_multisampled_render_to_texture")&&!1!==I.__useRenderToTexture}function q(A,I){const t=A.encoding,C=A.format,e=A.type;return!0===A.isCompressedTexture||!0===A.isVideoTexture||A.format===Gg||t!==rg&&(t===hg?!1===i?!0===g.has("EXT_sRGB")&&C===NA?(A.format=Gg,A.minFilter=EA,A.generateMipmaps=!1):I=$g.sRGBToLinear(I):C===NA&&e===aA||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",t)),I}this.allocateTextureUnit=function(){const A=m;return A>=Q&&console.warn("THREE.WebGLTextures: Trying to use "+A+" texture units while this GPU supports only "+Q),m+=1,A},this.resetTextureUnits=function(){m=0},this.setTexture2D=k,this.setTexture2DArray=function(A,g){const C=t.get(A);A.version>0&&C.__version!==A.version?J(C,A,g):I.bindTexture(35866,C.__webglTexture,33984+g)},this.setTexture3D=function(A,g){const C=t.get(A);A.version>0&&C.__version!==A.version?J(C,A,g):I.bindTexture(32879,C.__webglTexture,33984+g)},this.setTextureCube=function(g,C){const B=t.get(g);g.version>0&&B.__version!==g.version?function(g,C,B){if(6!==C.image.length)return;const Q=K(g,C),E=C.source;I.bindTexture(34067,g.__webglTexture,33984+B);const n=t.get(E);if(E.version!==n.__version||!0===Q){I.activeTexture(33984+B),A.pixelStorei(37440,C.flipY),A.pixelStorei(37441,C.premultiplyAlpha),A.pixelStorei(3317,C.unpackAlignment),A.pixelStorei(37443,0);const g=C.isCompressedTexture||C.image[0].isCompressedTexture,t=C.image[0]&&C.image[0].isDataTexture,s=[];for(let A=0;A<6;A++)s[A]=g||t?t?C.image[A].image:C.image[A]:u(C.image[A],!1,!0,o),s[A]=q(C,s[A]);const a=s[0],r=w(a)||i,h=e.convert(C.format,C.encoding),c=e.convert(C.type),l=y(C.internalFormat,h,c,C.encoding),D=i&&!0!==C.isVideoTexture,f=void 0===n.__version||!0===Q;let N,F=G(C,a,r);if(U(34067,C,r),g){D&&f&&I.texStorage2D(34067,F,l,a.width,a.height);for(let A=0;A<6;A++){N=s[A].mipmaps;for(let g=0;g<N.length;g++){const t=N[g];C.format!==NA?null!==h?D?I.compressedTexSubImage2D(34069+A,g,0,0,t.width,t.height,h,t.data):I.compressedTexImage2D(34069+A,g,l,t.width,t.height,0,t.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):D?I.texSubImage2D(34069+A,g,0,0,t.width,t.height,h,c,t.data):I.texImage2D(34069+A,g,l,t.width,t.height,0,h,c,t.data)}}}else{N=C.mipmaps,D&&f&&(N.length>0&&F++,I.texStorage2D(34067,F,l,s[0].width,s[0].height));for(let A=0;A<6;A++)if(t){D?I.texSubImage2D(34069+A,0,0,0,s[A].width,s[A].height,h,c,s[A].data):I.texImage2D(34069+A,0,l,s[A].width,s[A].height,0,h,c,s[A].data);for(let g=0;g<N.length;g++){const t=N[g].image[A].image;D?I.texSubImage2D(34069+A,g+1,0,0,t.width,t.height,h,c,t.data):I.texImage2D(34069+A,g+1,l,t.width,t.height,0,h,c,t.data)}}else{D?I.texSubImage2D(34069+A,0,0,0,h,c,s[A]):I.texImage2D(34069+A,0,l,h,c,s[A]);for(let g=0;g<N.length;g++){const t=N[g];D?I.texSubImage2D(34069+A,g+1,0,0,h,c,t.image[A]):I.texImage2D(34069+A,g+1,l,h,c,t.image[A])}}}d(C,r)&&p(34067),n.__version=E.version,C.onUpdate&&C.onUpdate(C)}g.__version=C.version}(B,g,C):I.bindTexture(34067,B.__webglTexture,33984+C)},this.rebindTextures=function(A,g,I){const C=t.get(A);void 0!==g&&Y(C.__webglFramebuffer,A,A.texture,36064,3553),void 0!==I&&x(A)},this.setupRenderTarget=function(g){const Q=g.texture,o=t.get(g),E=t.get(Q);g.addEventListener("dispose",F),!0!==g.isWebGLMultipleRenderTargets&&(void 0===E.__webglTexture&&(E.__webglTexture=A.createTexture()),E.__version=Q.version,B.memory.textures++);const n=!0===g.isWebGLCubeRenderTarget,s=!0===g.isWebGLMultipleRenderTargets,a=w(g)||i;if(n){o.__webglFramebuffer=[];for(let g=0;g<6;g++)o.__webglFramebuffer[g]=A.createFramebuffer()}else{if(o.__webglFramebuffer=A.createFramebuffer(),s)if(C.drawBuffers){const I=g.texture;for(let g=0,C=I.length;g<C;g++){const C=t.get(I[g]);void 0===C.__webglTexture&&(C.__webglTexture=A.createTexture(),B.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(i&&g.samples>0&&!1===H(g)){const t=s?Q:[Q];o.__webglMultisampledFramebuffer=A.createFramebuffer(),o.__webglColorRenderbuffer=[],I.bindFramebuffer(36160,o.__webglMultisampledFramebuffer);for(let I=0;I<t.length;I++){const C=t[I];o.__webglColorRenderbuffer[I]=A.createRenderbuffer(),A.bindRenderbuffer(36161,o.__webglColorRenderbuffer[I]);const B=e.convert(C.format,C.encoding),i=e.convert(C.type),Q=y(C.internalFormat,B,i,C.encoding,!0===g.isXRRenderTarget),E=b(g);A.renderbufferStorageMultisample(36161,E,Q,g.width,g.height),A.framebufferRenderbuffer(36160,36064+I,36161,o.__webglColorRenderbuffer[I])}A.bindRenderbuffer(36161,null),g.depthBuffer&&(o.__webglDepthRenderbuffer=A.createRenderbuffer(),L(o.__webglDepthRenderbuffer,g,!0)),I.bindFramebuffer(36160,null)}}if(n){I.bindTexture(34067,E.__webglTexture),U(34067,Q,a);for(let A=0;A<6;A++)Y(o.__webglFramebuffer[A],g,Q,36064,34069+A);d(Q,a)&&p(34067),I.unbindTexture()}else if(s){const A=g.texture;for(let C=0,e=A.length;C<e;C++){const e=A[C],B=t.get(e);I.bindTexture(3553,B.__webglTexture),U(3553,e,a),Y(o.__webglFramebuffer,g,e,36064+C,3553),d(e,a)&&p(3553)}I.unbindTexture()}else{let A=3553;(g.isWebGL3DRenderTarget||g.isWebGLArrayRenderTarget)&&(i?A=g.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),I.bindTexture(A,E.__webglTexture),U(A,Q,a),Y(o.__webglFramebuffer,g,Q,36064,A),d(Q,a)&&p(A),I.unbindTexture()}g.depthBuffer&&x(g)},this.updateRenderTargetMipmap=function(A){const g=w(A)||i,C=!0===A.isWebGLMultipleRenderTargets?A.texture:[A.texture];for(let e=0,B=C.length;e<B;e++){const B=C[e];if(d(B,g)){const g=A.isWebGLCubeRenderTarget?34067:3553,C=t.get(B).__webglTexture;I.bindTexture(g,C),p(g),I.unbindTexture()}}},this.updateMultisampleRenderTarget=function(g){if(i&&g.samples>0&&!1===H(g)){const C=g.isWebGLMultipleRenderTargets?g.texture:[g.texture],e=g.width,B=g.height;let i=16384;const Q=[],o=g.stencilBuffer?33306:36096,E=t.get(g),n=!0===g.isWebGLMultipleRenderTargets;if(n)for(let g=0;g<C.length;g++)I.bindFramebuffer(36160,E.__webglMultisampledFramebuffer),A.framebufferRenderbuffer(36160,36064+g,36161,null),I.bindFramebuffer(36160,E.__webglFramebuffer),A.framebufferTexture2D(36009,36064+g,3553,null,0);I.bindFramebuffer(36008,E.__webglMultisampledFramebuffer),I.bindFramebuffer(36009,E.__webglFramebuffer);for(let I=0;I<C.length;I++){Q.push(36064+I),g.depthBuffer&&Q.push(o);const s=void 0!==E.__ignoreDepthValues&&E.__ignoreDepthValues;if(!1===s&&(g.depthBuffer&&(i|=256),g.stencilBuffer&&(i|=1024)),n&&A.framebufferRenderbuffer(36008,36064,36161,E.__webglColorRenderbuffer[I]),!0===s&&(A.invalidateFramebuffer(36008,[o]),A.invalidateFramebuffer(36009,[o])),n){const g=t.get(C[I]).__webglTexture;A.framebufferTexture2D(36009,36064,3553,g,0)}A.blitFramebuffer(0,0,e,B,0,0,e,B,i,9728),a&&A.invalidateFramebuffer(36008,Q)}if(I.bindFramebuffer(36008,null),I.bindFramebuffer(36009,null),n)for(let g=0;g<C.length;g++){I.bindFramebuffer(36160,E.__webglMultisampledFramebuffer),A.framebufferRenderbuffer(36160,36064+g,36161,E.__webglColorRenderbuffer[g]);const e=t.get(C[g]).__webglTexture;I.bindFramebuffer(36160,E.__webglFramebuffer),A.framebufferTexture2D(36009,36064+g,3553,e,0)}I.bindFramebuffer(36009,E.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=x,this.setupFrameBufferTexture=Y,this.useMultisampledRTT=H}function ZB(A,g,I){const t=I.isWebGL2;return{convert:function(I,C=null){let e;if(I===aA)return 5121;if(I===dA)return 32819;if(I===pA)return 32820;if(I===rA)return 5120;if(I===hA)return 5122;if(I===cA)return 5123;if(I===lA)return 5124;if(I===DA)return 5125;if(I===uA)return 5126;if(I===wA)return t?5131:(e=g.get("OES_texture_half_float"),null!==e?e.HALF_FLOAT_OES:null);if(I===GA)return 6406;if(I===NA)return 6408;if(I===FA)return 6409;if(I===RA)return 6410;if(I===mA)return 6402;if(I===kA)return 34041;if(I===SA)return 6403;if(I===fA)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(I===Gg)return e=g.get("EXT_sRGB"),null!==e?e.SRGB_ALPHA_EXT:null;if(I===MA)return 36244;if(I===UA)return 33319;if(I===KA)return 33320;if(I===JA)return 36249;if(I===YA||I===LA||I===xA||I===bA)if(C===hg){if(e=g.get("WEBGL_compressed_texture_s3tc_srgb"),null===e)return null;if(I===YA)return e.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(I===LA)return e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(I===xA)return e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(I===bA)return e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(e=g.get("WEBGL_compressed_texture_s3tc"),null===e)return null;if(I===YA)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;if(I===LA)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(I===xA)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(I===bA)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(I===HA||I===qA||I===TA||I===vA){if(e=g.get("WEBGL_compressed_texture_pvrtc"),null===e)return null;if(I===HA)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(I===qA)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(I===TA)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(I===vA)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(I===VA)return e=g.get("WEBGL_compressed_texture_etc1"),null!==e?e.COMPRESSED_RGB_ETC1_WEBGL:null;if(I===WA||I===OA){if(e=g.get("WEBGL_compressed_texture_etc"),null===e)return null;if(I===WA)return C===hg?e.COMPRESSED_SRGB8_ETC2:e.COMPRESSED_RGB8_ETC2;if(I===OA)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:e.COMPRESSED_RGBA8_ETC2_EAC}if(I===ZA||I===PA||I===XA||I===jA||I===zA||I===_A||I===$A||I===Ag||I===gg||I===Ig||I===tg||I===Cg||I===eg||I===Bg){if(e=g.get("WEBGL_compressed_texture_astc"),null===e)return null;if(I===ZA)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:e.COMPRESSED_RGBA_ASTC_4x4_KHR;if(I===PA)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:e.COMPRESSED_RGBA_ASTC_5x4_KHR;if(I===XA)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:e.COMPRESSED_RGBA_ASTC_5x5_KHR;if(I===jA)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:e.COMPRESSED_RGBA_ASTC_6x5_KHR;if(I===zA)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:e.COMPRESSED_RGBA_ASTC_6x6_KHR;if(I===_A)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:e.COMPRESSED_RGBA_ASTC_8x5_KHR;if(I===$A)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:e.COMPRESSED_RGBA_ASTC_8x6_KHR;if(I===Ag)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:e.COMPRESSED_RGBA_ASTC_8x8_KHR;if(I===gg)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:e.COMPRESSED_RGBA_ASTC_10x5_KHR;if(I===Ig)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:e.COMPRESSED_RGBA_ASTC_10x6_KHR;if(I===tg)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:e.COMPRESSED_RGBA_ASTC_10x8_KHR;if(I===Cg)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:e.COMPRESSED_RGBA_ASTC_10x10_KHR;if(I===eg)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:e.COMPRESSED_RGBA_ASTC_12x10_KHR;if(I===Bg)return C===hg?e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:e.COMPRESSED_RGBA_ASTC_12x12_KHR}if(I===ig){if(e=g.get("EXT_texture_compression_bptc"),null===e)return null;if(I===ig)return C===hg?e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:e.COMPRESSED_RGBA_BPTC_UNORM_EXT}return I===yA?t?34042:(e=g.get("WEBGL_depth_texture"),null!==e?e.UNSIGNED_INT_24_8_WEBGL:null):void 0!==A[I]?A[I]:null}}}class PB extends nC{constructor(A=[]){super(),this.isArrayCamera=!0,this.cameras=A}}class XB extends nt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const jB={type:"move"};class zB{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new XB,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new XB,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new oI,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new oI),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new XB,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new oI,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new oI),this._grip}dispatchEvent(A){return null!==this._targetRay&&this._targetRay.dispatchEvent(A),null!==this._grip&&this._grip.dispatchEvent(A),null!==this._hand&&this._hand.dispatchEvent(A),this}disconnect(A){return this.dispatchEvent({type:"disconnected",data:A}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(A,g,I){let t=null,C=null,e=null;const B=this._targetRay,i=this._grip,Q=this._hand;if(A&&"visible-blurred"!==g.session.visibilityState){if(Q&&A.hand){e=!0;for(const t of A.hand.values()){const A=g.getJointPose(t,I);if(void 0===Q.joints[t.jointName]){const A=new XB;A.matrixAutoUpdate=!1,A.visible=!1,Q.joints[t.jointName]=A,Q.add(A)}const C=Q.joints[t.jointName];null!==A&&(C.matrix.fromArray(A.transform.matrix),C.matrix.decompose(C.position,C.rotation,C.scale),C.jointRadius=A.radius),C.visible=null!==A}const t=Q.joints["index-finger-tip"],C=Q.joints["thumb-tip"],B=t.position.distanceTo(C.position),i=.02,o=.005;Q.inputState.pinching&&B>i+o?(Q.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:A.handedness,target:this})):!Q.inputState.pinching&&B<=i-o&&(Q.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:A.handedness,target:this}))}else null!==i&&A.gripSpace&&(C=g.getPose(A.gripSpace,I),null!==C&&(i.matrix.fromArray(C.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),C.linearVelocity?(i.hasLinearVelocity=!0,i.linearVelocity.copy(C.linearVelocity)):i.hasLinearVelocity=!1,C.angularVelocity?(i.hasAngularVelocity=!0,i.angularVelocity.copy(C.angularVelocity)):i.hasAngularVelocity=!1));null!==B&&(t=g.getPose(A.targetRaySpace,I),null===t&&null!==C&&(t=C),null!==t&&(B.matrix.fromArray(t.transform.matrix),B.matrix.decompose(B.position,B.rotation,B.scale),t.linearVelocity?(B.hasLinearVelocity=!0,B.linearVelocity.copy(t.linearVelocity)):B.hasLinearVelocity=!1,t.angularVelocity?(B.hasAngularVelocity=!0,B.angularVelocity.copy(t.angularVelocity)):B.hasAngularVelocity=!1,this.dispatchEvent(jB)))}return null!==B&&(B.visible=null!==t),null!==i&&(i.visible=null!==C),null!==Q&&(Q.visible=null!==e),this}}class _B extends tI{constructor(A,g,I,t,C,e,B,i,Q,o){if((o=void 0!==o?o:mA)!==mA&&o!==kA)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===I&&o===mA&&(I=DA),void 0===I&&o===kA&&(I=yA),super(null,t,C,e,B,i,o,I,Q),this.isDepthTexture=!0,this.image={width:A,height:g},this.magFilter=void 0!==B?B:iA,this.minFilter=void 0!==i?i:iA,this.flipY=!1,this.generateMipmaps=!1}}class $B extends fg{constructor(A,g){super();const I=this;let t=null,C=1,e=null,B="local-floor",i=null,Q=null,o=null,E=null,n=null,s=null;const a=g.getContextAttributes();let r=null,h=null;const c=[],l=[],D=new nC;D.layers.enable(1),D.viewport=new CI;const u=new nC;u.layers.enable(2),u.viewport=new CI;const w=[D,u],d=new PB;d.layers.enable(1),d.layers.enable(2);let p=null,y=null;function G(A){const g=l.indexOf(A.inputSource);if(-1===g)return;const I=c[g];void 0!==I&&I.dispatchEvent({type:A.type,data:A.inputSource})}function f(){t.removeEventListener("select",G),t.removeEventListener("selectstart",G),t.removeEventListener("selectend",G),t.removeEventListener("squeeze",G),t.removeEventListener("squeezestart",G),t.removeEventListener("squeezeend",G),t.removeEventListener("end",f),t.removeEventListener("inputsourceschange",N);for(let A=0;A<c.length;A++){const g=l[A];null!==g&&(l[A]=null,c[A].disconnect(g))}p=null,y=null,A.setRenderTarget(r),n=null,E=null,o=null,t=null,h=null,S.stop(),I.isPresenting=!1,I.dispatchEvent({type:"sessionend"})}function N(A){for(let g=0;g<A.removed.length;g++){const I=A.removed[g],t=l.indexOf(I);t>=0&&(l[t]=null,c[t].dispatchEvent({type:"disconnected",data:I}))}for(let g=0;g<A.added.length;g++){const I=A.added[g];let t=l.indexOf(I);if(-1===t){for(let A=0;A<c.length;A++){if(A>=l.length){l.push(I),t=A;break}if(null===l[A]){l[A]=I,t=A;break}}if(-1===t)break}const C=c[t];C&&C.dispatchEvent({type:"connected",data:I})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(A){let g=c[A];return void 0===g&&(g=new zB,c[A]=g),g.getTargetRaySpace()},this.getControllerGrip=function(A){let g=c[A];return void 0===g&&(g=new zB,c[A]=g),g.getGripSpace()},this.getHand=function(A){let g=c[A];return void 0===g&&(g=new zB,c[A]=g),g.getHandSpace()},this.setFramebufferScaleFactor=function(A){C=A,!0===I.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(A){B=A,!0===I.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i||e},this.setReferenceSpace=function(A){i=A},this.getBaseLayer=function(){return null!==E?E:n},this.getBinding=function(){return o},this.getFrame=function(){return s},this.getSession=function(){return t},this.setSession=async function(Q){if(t=Q,null!==t){if(r=A.getRenderTarget(),t.addEventListener("select",G),t.addEventListener("selectstart",G),t.addEventListener("selectend",G),t.addEventListener("squeeze",G),t.addEventListener("squeezestart",G),t.addEventListener("squeezeend",G),t.addEventListener("end",f),t.addEventListener("inputsourceschange",N),!0!==a.xrCompatible&&await g.makeXRCompatible(),void 0===t.renderState.layers||!1===A.capabilities.isWebGL2){const I={antialias:void 0!==t.renderState.layers||a.antialias,alpha:a.alpha,depth:a.depth,stencil:a.stencil,framebufferScaleFactor:C};n=new XRWebGLLayer(t,g,I),t.updateRenderState({baseLayer:n}),h=new eI(n.framebufferWidth,n.framebufferHeight,{format:NA,type:aA,encoding:A.outputEncoding,stencilBuffer:a.stencil})}else{let I=null,e=null,B=null;a.depth&&(B=a.stencil?35056:33190,I=a.stencil?kA:mA,e=a.stencil?yA:DA);const i={colorFormat:32856,depthFormat:B,scaleFactor:C};o=new XRWebGLBinding(t,g),E=o.createProjectionLayer(i),t.updateRenderState({layers:[E]}),h=new eI(E.textureWidth,E.textureHeight,{format:NA,type:aA,depthTexture:new _B(E.textureWidth,E.textureHeight,e,void 0,void 0,void 0,void 0,void 0,void 0,I),stencilBuffer:a.stencil,encoding:A.outputEncoding,samples:a.antialias?4:0});A.properties.get(h).__ignoreDepthValues=E.ignoreDepthValues}h.isXRRenderTarget=!0,this.setFoveation(1),i=null,e=await t.requestReferenceSpace(B),S.setContext(t),S.start(),I.isPresenting=!0,I.dispatchEvent({type:"sessionstart"})}};const F=new oI,R=new oI;function m(A,g){null===g?A.matrixWorld.copy(A.matrix):A.matrixWorld.multiplyMatrices(g.matrixWorld,A.matrix),A.matrixWorldInverse.copy(A.matrixWorld).invert()}this.updateCamera=function(A){if(null===t)return;d.near=u.near=D.near=A.near,d.far=u.far=D.far=A.far,p===d.near&&y===d.far||(t.updateRenderState({depthNear:d.near,depthFar:d.far}),p=d.near,y=d.far);const g=A.parent,I=d.cameras;m(d,g);for(let A=0;A<I.length;A++)m(I[A],g);d.matrixWorld.decompose(d.position,d.quaternion,d.scale),A.matrix.copy(d.matrix),A.matrix.decompose(A.position,A.quaternion,A.scale);const C=A.children;for(let A=0,g=C.length;A<g;A++)C[A].updateMatrixWorld(!0);2===I.length?function(A,g,I){F.setFromMatrixPosition(g.matrixWorld),R.setFromMatrixPosition(I.matrixWorld);const t=F.distanceTo(R),C=g.projectionMatrix.elements,e=I.projectionMatrix.elements,B=C[14]/(C[10]-1),i=C[14]/(C[10]+1),Q=(C[9]+1)/C[5],o=(C[9]-1)/C[5],E=(C[8]-1)/C[0],n=(e[8]+1)/e[0],s=B*E,a=B*n,r=t/(-E+n),h=r*-E;g.matrixWorld.decompose(A.position,A.quaternion,A.scale),A.translateX(h),A.translateZ(r),A.matrixWorld.compose(A.position,A.quaternion,A.scale),A.matrixWorldInverse.copy(A.matrixWorld).invert();const c=B+r,l=i+r,D=s-h,u=a+(t-h),w=Q*i/l*c,d=o*i/l*c;A.projectionMatrix.makePerspective(D,u,w,d,c,l)}(d,D,u):d.projectionMatrix.copy(D.projectionMatrix)},this.getCamera=function(){return d},this.getFoveation=function(){return null!==E?E.fixedFoveation:null!==n?n.fixedFoveation:void 0},this.setFoveation=function(A){null!==E&&(E.fixedFoveation=A),null!==n&&void 0!==n.fixedFoveation&&(n.fixedFoveation=A)};let k=null;const S=new yC;S.setAnimationLoop((function(g,I){if(Q=I.getViewerPose(i||e),s=I,null!==Q){const g=Q.views;null!==n&&(A.setRenderTargetFramebuffer(h,n.framebuffer),A.setRenderTarget(h));let I=!1;g.length!==d.cameras.length&&(d.cameras.length=0,I=!0);for(let t=0;t<g.length;t++){const C=g[t];let e=null;if(null!==n)e=n.getViewport(C);else{const g=o.getViewSubImage(E,C);e=g.viewport,0===t&&(A.setRenderTargetTextures(h,g.colorTexture,E.ignoreDepthValues?void 0:g.depthStencilTexture),A.setRenderTarget(h))}let B=w[t];void 0===B&&(B=new nC,B.layers.enable(t),B.viewport=new CI,w[t]=B),B.matrix.fromArray(C.transform.matrix),B.projectionMatrix.fromArray(C.projectionMatrix),B.viewport.set(e.x,e.y,e.width,e.height),0===t&&d.matrix.copy(B.matrix),!0===I&&d.cameras.push(B)}}for(let A=0;A<c.length;A++){const g=l[A],t=c[A];null!==g&&void 0!==t&&t.update(g,I,i||e)}k&&k(g,I),s=null})),this.setAnimationLoop=function(A){k=A},this.dispose=function(){}}}function Ai(A,g){function I(I,t){I.opacity.value=t.opacity,t.color&&I.diffuse.value.copy(t.color),t.emissive&&I.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),t.map&&(I.map.value=t.map),t.alphaMap&&(I.alphaMap.value=t.alphaMap),t.bumpMap&&(I.bumpMap.value=t.bumpMap,I.bumpScale.value=t.bumpScale,t.side===s&&(I.bumpScale.value*=-1)),t.displacementMap&&(I.displacementMap.value=t.displacementMap,I.displacementScale.value=t.displacementScale,I.displacementBias.value=t.displacementBias),t.emissiveMap&&(I.emissiveMap.value=t.emissiveMap),t.normalMap&&(I.normalMap.value=t.normalMap,I.normalScale.value.copy(t.normalScale),t.side===s&&I.normalScale.value.negate()),t.specularMap&&(I.specularMap.value=t.specularMap),t.alphaTest>0&&(I.alphaTest.value=t.alphaTest);const C=g.get(t).envMap;if(C&&(I.envMap.value=C,I.flipEnvMap.value=C.isCubeTexture&&!1===C.isRenderTargetTexture?-1:1,I.reflectivity.value=t.reflectivity,I.ior.value=t.ior,I.refractionRatio.value=t.refractionRatio),t.lightMap){I.lightMap.value=t.lightMap;const g=!0!==A.physicallyCorrectLights?Math.PI:1;I.lightMapIntensity.value=t.lightMapIntensity*g}let e,B;t.aoMap&&(I.aoMap.value=t.aoMap,I.aoMapIntensity.value=t.aoMapIntensity),t.map?e=t.map:t.specularMap?e=t.specularMap:t.displacementMap?e=t.displacementMap:t.normalMap?e=t.normalMap:t.bumpMap?e=t.bumpMap:t.roughnessMap?e=t.roughnessMap:t.metalnessMap?e=t.metalnessMap:t.alphaMap?e=t.alphaMap:t.emissiveMap?e=t.emissiveMap:t.clearcoatMap?e=t.clearcoatMap:t.clearcoatNormalMap?e=t.clearcoatNormalMap:t.clearcoatRoughnessMap?e=t.clearcoatRoughnessMap:t.iridescenceMap?e=t.iridescenceMap:t.iridescenceThicknessMap?e=t.iridescenceThicknessMap:t.specularIntensityMap?e=t.specularIntensityMap:t.specularColorMap?e=t.specularColorMap:t.transmissionMap?e=t.transmissionMap:t.thicknessMap?e=t.thicknessMap:t.sheenColorMap?e=t.sheenColorMap:t.sheenRoughnessMap&&(e=t.sheenRoughnessMap),void 0!==e&&(e.isWebGLRenderTarget&&(e=e.texture),!0===e.matrixAutoUpdate&&e.updateMatrix(),I.uvTransform.value.copy(e.matrix)),t.aoMap?B=t.aoMap:t.lightMap&&(B=t.lightMap),void 0!==B&&(B.isWebGLRenderTarget&&(B=B.texture),!0===B.matrixAutoUpdate&&B.updateMatrix(),I.uv2Transform.value.copy(B.matrix))}return{refreshFogUniforms:function(A,g){A.fogColor.value.copy(g.color),g.isFog?(A.fogNear.value=g.near,A.fogFar.value=g.far):g.isFogExp2&&(A.fogDensity.value=g.density)},refreshMaterialUniforms:function(A,t,C,e,B){t.isMeshBasicMaterial||t.isMeshLambertMaterial?I(A,t):t.isMeshToonMaterial?(I(A,t),function(A,g){g.gradientMap&&(A.gradientMap.value=g.gradientMap)}(A,t)):t.isMeshPhongMaterial?(I(A,t),function(A,g){A.specular.value.copy(g.specular),A.shininess.value=Math.max(g.shininess,1e-4)}(A,t)):t.isMeshStandardMaterial?(I(A,t),function(A,I){A.roughness.value=I.roughness,A.metalness.value=I.metalness,I.roughnessMap&&(A.roughnessMap.value=I.roughnessMap);I.metalnessMap&&(A.metalnessMap.value=I.metalnessMap);const t=g.get(I).envMap;t&&(A.envMapIntensity.value=I.envMapIntensity)}(A,t),t.isMeshPhysicalMaterial&&function(A,g,I){A.ior.value=g.ior,g.sheen>0&&(A.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),A.sheenRoughness.value=g.sheenRoughness,g.sheenColorMap&&(A.sheenColorMap.value=g.sheenColorMap),g.sheenRoughnessMap&&(A.sheenRoughnessMap.value=g.sheenRoughnessMap));g.clearcoat>0&&(A.clearcoat.value=g.clearcoat,A.clearcoatRoughness.value=g.clearcoatRoughness,g.clearcoatMap&&(A.clearcoatMap.value=g.clearcoatMap),g.clearcoatRoughnessMap&&(A.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap),g.clearcoatNormalMap&&(A.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),A.clearcoatNormalMap.value=g.clearcoatNormalMap,g.side===s&&A.clearcoatNormalScale.value.negate()));g.iridescence>0&&(A.iridescence.value=g.iridescence,A.iridescenceIOR.value=g.iridescenceIOR,A.iridescenceThicknessMinimum.value=g.iridescenceThicknessRange[0],A.iridescenceThicknessMaximum.value=g.iridescenceThicknessRange[1],g.iridescenceMap&&(A.iridescenceMap.value=g.iridescenceMap),g.iridescenceThicknessMap&&(A.iridescenceThicknessMap.value=g.iridescenceThicknessMap));g.transmission>0&&(A.transmission.value=g.transmission,A.transmissionSamplerMap.value=I.texture,A.transmissionSamplerSize.value.set(I.width,I.height),g.transmissionMap&&(A.transmissionMap.value=g.transmissionMap),A.thickness.value=g.thickness,g.thicknessMap&&(A.thicknessMap.value=g.thicknessMap),A.attenuationDistance.value=g.attenuationDistance,A.attenuationColor.value.copy(g.attenuationColor));A.specularIntensity.value=g.specularIntensity,A.specularColor.value.copy(g.specularColor),g.specularIntensityMap&&(A.specularIntensityMap.value=g.specularIntensityMap);g.specularColorMap&&(A.specularColorMap.value=g.specularColorMap)}(A,t,B)):t.isMeshMatcapMaterial?(I(A,t),function(A,g){g.matcap&&(A.matcap.value=g.matcap)}(A,t)):t.isMeshDepthMaterial?I(A,t):t.isMeshDistanceMaterial?(I(A,t),function(A,g){A.referencePosition.value.copy(g.referencePosition),A.nearDistance.value=g.nearDistance,A.farDistance.value=g.farDistance}(A,t)):t.isMeshNormalMaterial?I(A,t):t.isLineBasicMaterial?(function(A,g){A.diffuse.value.copy(g.color),A.opacity.value=g.opacity}(A,t),t.isLineDashedMaterial&&function(A,g){A.dashSize.value=g.dashSize,A.totalSize.value=g.dashSize+g.gapSize,A.scale.value=g.scale}(A,t)):t.isPointsMaterial?function(A,g,I,t){A.diffuse.value.copy(g.color),A.opacity.value=g.opacity,A.size.value=g.size*I,A.scale.value=.5*t,g.map&&(A.map.value=g.map);g.alphaMap&&(A.alphaMap.value=g.alphaMap);g.alphaTest>0&&(A.alphaTest.value=g.alphaTest);let C;g.map?C=g.map:g.alphaMap&&(C=g.alphaMap);void 0!==C&&(!0===C.matrixAutoUpdate&&C.updateMatrix(),A.uvTransform.value.copy(C.matrix))}(A,t,C,e):t.isSpriteMaterial?function(A,g){A.diffuse.value.copy(g.color),A.opacity.value=g.opacity,A.rotation.value=g.rotation,g.map&&(A.map.value=g.map);g.alphaMap&&(A.alphaMap.value=g.alphaMap);g.alphaTest>0&&(A.alphaTest.value=g.alphaTest);let I;g.map?I=g.map:g.alphaMap&&(I=g.alphaMap);void 0!==I&&(!0===I.matrixAutoUpdate&&I.updateMatrix(),A.uvTransform.value.copy(I.matrix))}(A,t):t.isShadowMaterial?(A.color.value.copy(t.color),A.opacity.value=t.opacity):t.isShaderMaterial&&(t.uniformsNeedUpdate=!1)}}}function gi(A,g,I,t){let C={},e={},B=[];const i=I.isWebGL2?A.getParameter(35375):0;function Q(A,g,I){const t=A.value;if(void 0===I[g])return I[g]="number"==typeof t?t:t.clone(),!0;if("number"==typeof t){if(I[g]!==t)return I[g]=t,!0}else{const A=I[g];if(!1===A.equals(t))return A.copy(t),!0}return!1}function o(A){const g=A.value,I={boundary:0,storage:0};return"number"==typeof g?(I.boundary=4,I.storage=4):g.isVector2?(I.boundary=8,I.storage=8):g.isVector3||g.isColor?(I.boundary=16,I.storage=12):g.isVector4?(I.boundary=16,I.storage=16):g.isMatrix3?(I.boundary=48,I.storage=48):g.isMatrix4?(I.boundary=64,I.storage=64):g.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",g),I}function E(g){const I=g.target;I.removeEventListener("dispose",E);const t=B.indexOf(I.__bindingPointIndex);B.splice(t,1),A.deleteBuffer(C[I.id]),delete C[I.id],delete e[I.id]}return{bind:function(A,g){const I=g.program;t.uniformBlockBinding(A,I)},update:function(I,n){let s=C[I.id];void 0===s&&(!function(A){const g=A.uniforms;let I=0;const t=16;let C=0;for(let A=0,e=g.length;A<e;A++){const e=g[A],B=o(e);if(e.__data=new Float32Array(B.storage/Float32Array.BYTES_PER_ELEMENT),e.__offset=I,A>0){C=I%t;0!==C&&t-C-B.boundary<0&&(I+=t-C,e.__offset=I)}I+=B.storage}C=I%t,C>0&&(I+=t-C);A.__size=I,A.__cache={}}(I),s=function(g){const I=function(){for(let A=0;A<i;A++)if(-1===B.indexOf(A))return B.push(A),A;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();g.__bindingPointIndex=I;const t=A.createBuffer(),C=g.__size,e=g.usage;return A.bindBuffer(35345,t),A.bufferData(35345,C,e),A.bindBuffer(35345,null),A.bindBufferBase(35345,I,t),t}(I),C[I.id]=s,I.addEventListener("dispose",E));const a=n.program;t.updateUBOMapping(I,a);const r=g.render.frame;e[I.id]!==r&&(!function(g){const I=C[g.id],t=g.uniforms,e=g.__cache;A.bindBuffer(35345,I);for(let g=0,I=t.length;g<I;g++){const I=t[g];if(!0===Q(I,g,e)){const g=I.value,t=I.__offset;"number"==typeof g?(I.__data[0]=g,A.bufferSubData(35345,t,I.__data)):(I.value.isMatrix3?(I.__data[0]=I.value.elements[0],I.__data[1]=I.value.elements[1],I.__data[2]=I.value.elements[2],I.__data[3]=I.value.elements[0],I.__data[4]=I.value.elements[3],I.__data[5]=I.value.elements[4],I.__data[6]=I.value.elements[5],I.__data[7]=I.value.elements[0],I.__data[8]=I.value.elements[6],I.__data[9]=I.value.elements[7],I.__data[10]=I.value.elements[8],I.__data[11]=I.value.elements[0]):g.toArray(I.__data),A.bufferSubData(35345,t,I.__data))}}A.bindBuffer(35345,null)}(I),e[I.id]=r)},dispose:function(){for(const g in C)A.deleteBuffer(C[g]);B=[],C={},e={}}}}function Ii(A={}){this.isWebGLRenderer=!0;const g=void 0!==A.canvas?A.canvas:function(){const A=Hg("canvas");return A.style.display="block",A}(),I=void 0!==A.context?A.context:null,t=void 0===A.depth||A.depth,e=void 0===A.stencil||A.stencil,B=void 0!==A.antialias&&A.antialias,i=void 0===A.premultipliedAlpha||A.premultipliedAlpha,Q=void 0!==A.preserveDrawingBuffer&&A.preserveDrawingBuffer,o=void 0!==A.powerPreference?A.powerPreference:"default",E=void 0!==A.failIfMajorPerformanceCaveat&&A.failIfMajorPerformanceCaveat;let r;r=null!==I?I.getContextAttributes().alpha:void 0!==A.alpha&&A.alpha;let h=null,c=null;const l=[],D=[];this.domElement=g,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=rg,this.physicallyCorrectLights=!1,this.toneMapping=Z,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const u=this;let w=!1,d=0,p=0,y=null,G=-1,f=null;const N=new CI,F=new CI;let R=null,m=g.width,k=g.height,S=1,M=null,U=null;const K=new CI(0,0,m,k),J=new CI(0,0,m,k);let Y=!1;const L=new pC;let x=!1,b=!1,H=null;const q=new HI,T=new Lg,v=new oI,V={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function W(){return null===y?S:1}let O,P,X,j,z,_,$,AA,gA,IA,tA,CA,eA,BA,iA,QA,oA,EA,nA,rA,hA,cA,lA,DA,dA=I;function pA(A,I){for(let t=0;t<A.length;t++){const C=A[t],e=g.getContext(C,I);if(null!==e)return e}return null}try{const A={alpha:!0,depth:t,stencil:e,antialias:B,premultipliedAlpha:i,preserveDrawingBuffer:Q,powerPreference:o,failIfMajorPerformanceCaveat:E};if("setAttribute"in g&&g.setAttribute("data-engine",`three.js r${C}`),g.addEventListener("webglcontextlost",fA,!1),g.addEventListener("webglcontextrestored",FA,!1),g.addEventListener("webglcontextcreationerror",RA,!1),null===dA){const g=["webgl2","webgl","experimental-webgl"];if(!0===u.isWebGL1Renderer&&g.shift(),dA=pA(g,A),null===dA)throw pA(g)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===dA.getShaderPrecisionFormat&&(dA.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(A){throw console.error("THREE.WebGLRenderer: "+A.message),A}function yA(){O=new zC(dA),P=new MC(dA,O,A),O.init(P),cA=new ZB(dA,O,P),X=new WB(dA,O,P),j=new Ae,z=new mB,_=new OB(dA,O,X,z,P,cA,j),$=new KC(u),AA=new jC(u),gA=new GC(dA,P),lA=new kC(dA,O,gA,P),IA=new _C(dA,gA,j,lA),tA=new Ce(dA,IA,gA,j),nA=new te(dA,P,_),QA=new UC(z),CA=new RB(u,$,AA,O,P,lA,QA),eA=new Ai(u,z),BA=new UB,iA=new bB(O,P),EA=new mC(u,$,X,tA,r,i),oA=new VB(u,tA,P),DA=new gi(dA,j,P,X),rA=new SC(dA,O,j,P),hA=new $C(dA,O,j,P),j.programs=CA.programs,u.capabilities=P,u.extensions=O,u.properties=z,u.renderLists=BA,u.shadowMap=oA,u.state=X,u.info=j}yA();const GA=new $B(u,dA);function fA(A){A.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function FA(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const A=j.autoReset,g=oA.enabled,I=oA.autoUpdate,t=oA.needsUpdate,C=oA.type;yA(),j.autoReset=A,oA.enabled=g,oA.autoUpdate=I,oA.needsUpdate=t,oA.type=C}function RA(A){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",A.statusMessage)}function mA(A){const g=A.target;g.removeEventListener("dispose",mA),function(A){(function(A){const g=z.get(A).programs;void 0!==g&&(g.forEach((function(A){CA.releaseProgram(A)})),A.isShaderMaterial&&CA.releaseShaderCache(A))})(A),z.remove(A)}(g)}this.xr=GA,this.getContext=function(){return dA},this.getContextAttributes=function(){return dA.getContextAttributes()},this.forceContextLoss=function(){const A=O.get("WEBGL_lose_context");A&&A.loseContext()},this.forceContextRestore=function(){const A=O.get("WEBGL_lose_context");A&&A.restoreContext()},this.getPixelRatio=function(){return S},this.setPixelRatio=function(A){void 0!==A&&(S=A,this.setSize(m,k,!1))},this.getSize=function(A){return A.set(m,k)},this.setSize=function(A,I,t){GA.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(m=A,k=I,g.width=Math.floor(A*S),g.height=Math.floor(I*S),!1!==t&&(g.style.width=A+"px",g.style.height=I+"px"),this.setViewport(0,0,A,I))},this.getDrawingBufferSize=function(A){return A.set(m*S,k*S).floor()},this.setDrawingBufferSize=function(A,I,t){m=A,k=I,S=t,g.width=Math.floor(A*t),g.height=Math.floor(I*t),this.setViewport(0,0,A,I)},this.getCurrentViewport=function(A){return A.copy(N)},this.getViewport=function(A){return A.copy(K)},this.setViewport=function(A,g,I,t){A.isVector4?K.set(A.x,A.y,A.z,A.w):K.set(A,g,I,t),X.viewport(N.copy(K).multiplyScalar(S).floor())},this.getScissor=function(A){return A.copy(J)},this.setScissor=function(A,g,I,t){A.isVector4?J.set(A.x,A.y,A.z,A.w):J.set(A,g,I,t),X.scissor(F.copy(J).multiplyScalar(S).floor())},this.getScissorTest=function(){return Y},this.setScissorTest=function(A){X.setScissorTest(Y=A)},this.setOpaqueSort=function(A){M=A},this.setTransparentSort=function(A){U=A},this.getClearColor=function(A){return A.copy(EA.getClearColor())},this.setClearColor=function(){EA.setClearColor.apply(EA,arguments)},this.getClearAlpha=function(){return EA.getClearAlpha()},this.setClearAlpha=function(){EA.setClearAlpha.apply(EA,arguments)},this.clear=function(A=!0,g=!0,I=!0){let t=0;A&&(t|=16384),g&&(t|=256),I&&(t|=1024),dA.clear(t)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){g.removeEventListener("webglcontextlost",fA,!1),g.removeEventListener("webglcontextrestored",FA,!1),g.removeEventListener("webglcontextcreationerror",RA,!1),BA.dispose(),iA.dispose(),z.dispose(),$.dispose(),AA.dispose(),tA.dispose(),lA.dispose(),DA.dispose(),CA.dispose(),GA.dispose(),GA.removeEventListener("sessionstart",SA),GA.removeEventListener("sessionend",MA),H&&(H.dispose(),H=null),UA.stop()},this.renderBufferDirect=function(A,g,I,t,C,e){null===g&&(g=V);const B=C.isMesh&&C.matrixWorld.determinant()<0,i=function(A,g,I,t,C){!0!==g.isScene&&(g=V);_.resetTextureUnits();const e=g.fog,B=t.isMeshStandardMaterial?g.environment:null,i=null===y?u.outputEncoding:!0===y.isXRRenderTarget?y.texture.encoding:rg,Q=(t.isMeshStandardMaterial?AA:$).get(t.envMap||B),o=!0===t.vertexColors&&!!I.attributes.color&&4===I.attributes.color.itemSize,E=!!t.normalMap&&!!I.attributes.tangent,n=!!I.morphAttributes.position,s=!!I.morphAttributes.normal,a=!!I.morphAttributes.color,r=t.toneMapped?u.toneMapping:Z,h=I.morphAttributes.position||I.morphAttributes.normal||I.morphAttributes.color,l=void 0!==h?h.length:0,D=z.get(t),w=c.state.lights;if(!0===x&&(!0===b||A!==f)){const g=A===f&&t.id===G;QA.setState(t,A,g)}let d=!1;t.version===D.__version?D.needsLights&&D.lightsStateVersion!==w.state.version||D.outputEncoding!==i||C.isInstancedMesh&&!1===D.instancing?d=!0:C.isInstancedMesh||!0!==D.instancing?C.isSkinnedMesh&&!1===D.skinning?d=!0:C.isSkinnedMesh||!0!==D.skinning?D.envMap!==Q||!0===t.fog&&D.fog!==e?d=!0:void 0===D.numClippingPlanes||D.numClippingPlanes===QA.numPlanes&&D.numIntersection===QA.numIntersection?(D.vertexAlphas!==o||D.vertexTangents!==E||D.morphTargets!==n||D.morphNormals!==s||D.morphColors!==a||D.toneMapping!==r||!0===P.isWebGL2&&D.morphTargetsCount!==l)&&(d=!0):d=!0:d=!0:d=!0:(d=!0,D.__version=t.version);let p=D.currentProgram;!0===d&&(p=xA(t,g,C));let N=!1,F=!1,R=!1;const m=p.getUniforms(),M=D.uniforms;X.useProgram(p.program)&&(N=!0,F=!0,R=!0);t.id!==G&&(G=t.id,F=!0);if(N||f!==A){if(m.setValue(dA,"projectionMatrix",A.projectionMatrix),P.logarithmicDepthBuffer&&m.setValue(dA,"logDepthBufFC",2/(Math.log(A.far+1)/Math.LN2)),f!==A&&(f=A,F=!0,R=!0),t.isShaderMaterial||t.isMeshPhongMaterial||t.isMeshToonMaterial||t.isMeshStandardMaterial||t.envMap){const g=m.map.cameraPosition;void 0!==g&&g.setValue(dA,v.setFromMatrixPosition(A.matrixWorld))}(t.isMeshPhongMaterial||t.isMeshToonMaterial||t.isMeshLambertMaterial||t.isMeshBasicMaterial||t.isMeshStandardMaterial||t.isShaderMaterial)&&m.setValue(dA,"isOrthographic",!0===A.isOrthographicCamera),(t.isMeshPhongMaterial||t.isMeshToonMaterial||t.isMeshLambertMaterial||t.isMeshBasicMaterial||t.isMeshStandardMaterial||t.isShaderMaterial||t.isShadowMaterial||C.isSkinnedMesh)&&m.setValue(dA,"viewMatrix",A.matrixWorldInverse)}if(C.isSkinnedMesh){m.setOptional(dA,C,"bindMatrix"),m.setOptional(dA,C,"bindMatrixInverse");const A=C.skeleton;A&&(P.floatVertexTextures?(null===A.boneTexture&&A.computeBoneTexture(),m.setValue(dA,"boneTexture",A.boneTexture,_),m.setValue(dA,"boneTextureSize",A.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const U=I.morphAttributes;(void 0!==U.position||void 0!==U.normal||void 0!==U.color&&!0===P.isWebGL2)&&nA.update(C,I,t,p);(F||D.receiveShadow!==C.receiveShadow)&&(D.receiveShadow=C.receiveShadow,m.setValue(dA,"receiveShadow",C.receiveShadow));t.isMeshGouraudMaterial&&null!==t.envMap&&(M.envMap.value=Q,M.flipEnvMap.value=Q.isCubeTexture&&!1===Q.isRenderTargetTexture?-1:1);F&&(m.setValue(dA,"toneMappingExposure",u.toneMappingExposure),D.needsLights&&(J=R,(K=M).ambientLightColor.needsUpdate=J,K.lightProbe.needsUpdate=J,K.directionalLights.needsUpdate=J,K.directionalLightShadows.needsUpdate=J,K.pointLights.needsUpdate=J,K.pointLightShadows.needsUpdate=J,K.spotLights.needsUpdate=J,K.spotLightShadows.needsUpdate=J,K.rectAreaLights.needsUpdate=J,K.hemisphereLights.needsUpdate=J),e&&!0===t.fog&&eA.refreshFogUniforms(M,e),eA.refreshMaterialUniforms(M,t,S,k,H),QB.upload(dA,D.uniformsList,M,_));var K,J;t.isShaderMaterial&&!0===t.uniformsNeedUpdate&&(QB.upload(dA,D.uniformsList,M,_),t.uniformsNeedUpdate=!1);t.isSpriteMaterial&&m.setValue(dA,"center",C.center);if(m.setValue(dA,"modelViewMatrix",C.modelViewMatrix),m.setValue(dA,"normalMatrix",C.normalMatrix),m.setValue(dA,"modelMatrix",C.matrixWorld),t.isShaderMaterial||t.isRawShaderMaterial){const A=t.uniformsGroups;for(let g=0,I=A.length;g<I;g++)if(P.isWebGL2){const I=A[g];DA.update(I,p),DA.bind(I,p)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return p}(A,g,I,t,C);X.setMaterial(t,B);let Q=I.index;const o=I.attributes.position;if(null===Q){if(void 0===o||0===o.count)return}else if(0===Q.count)return;let E,n=1;!0===t.wireframe&&(Q=IA.getWireframeAttribute(I),n=2),lA.setup(C,t,i,I,Q);let s=rA;null!==Q&&(E=gA.get(Q),s=hA,s.setIndex(E));const a=null!==Q?Q.count:o.count,r=I.drawRange.start*n,h=I.drawRange.count*n,l=null!==e?e.start*n:0,D=null!==e?e.count*n:1/0,w=Math.max(r,l),d=Math.min(a,r+h,l+D)-1,p=Math.max(0,d-w+1);if(0!==p){if(C.isMesh)!0===t.wireframe?(X.setLineWidth(t.wireframeLinewidth*W()),s.setMode(1)):s.setMode(4);else if(C.isLine){let A=t.linewidth;void 0===A&&(A=1),X.setLineWidth(A*W()),C.isLineSegments?s.setMode(1):C.isLineLoop?s.setMode(2):s.setMode(3)}else C.isPoints?s.setMode(0):C.isSprite&&s.setMode(4);if(C.isInstancedMesh)s.renderInstances(w,p,C.count);else if(I.isInstancedBufferGeometry){const A=Math.min(I.instanceCount,I._maxInstanceCount);s.renderInstances(w,p,A)}else s.render(w,p)}},this.compile=function(A,g){function I(A,g,I){!0===A.transparent&&A.side===a?(A.side=s,A.needsUpdate=!0,xA(A,g,I),A.side=n,A.needsUpdate=!0,xA(A,g,I),A.side=a):xA(A,g,I)}c=iA.get(A),c.init(),D.push(c),A.traverseVisible((function(A){A.isLight&&A.layers.test(g.layers)&&(c.pushLight(A),A.castShadow&&c.pushShadow(A))})),c.setupLights(u.physicallyCorrectLights),A.traverse((function(g){const t=g.material;if(t)if(Array.isArray(t))for(let C=0;C<t.length;C++){I(t[C],A,g)}else I(t,A,g)})),D.pop(),c=null};let kA=null;function SA(){UA.stop()}function MA(){UA.start()}const UA=new yC;function KA(A,g,I,t){if(!1===A.visible)return;if(A.layers.test(g.layers))if(A.isGroup)I=A.renderOrder;else if(A.isLOD)!0===A.autoUpdate&&A.update(g);else if(A.isLight)c.pushLight(A),A.castShadow&&c.pushShadow(A);else if(A.isSprite){if(!A.frustumCulled||L.intersectsSprite(A)){t&&v.setFromMatrixPosition(A.matrixWorld).applyMatrix4(q);const g=tA.update(A),C=A.material;C.visible&&h.push(A,g,C,I,v.z,null)}}else if((A.isMesh||A.isLine||A.isPoints)&&(A.isSkinnedMesh&&A.skeleton.frame!==j.render.frame&&(A.skeleton.update(),A.skeleton.frame=j.render.frame),!A.frustumCulled||L.intersectsObject(A))){t&&v.setFromMatrixPosition(A.matrixWorld).applyMatrix4(q);const g=tA.update(A),C=A.material;if(Array.isArray(C)){const t=g.groups;for(let e=0,B=t.length;e<B;e++){const B=t[e],i=C[B.materialIndex];i&&i.visible&&h.push(A,g,i,I,v.z,B)}}else C.visible&&h.push(A,g,C,I,v.z,null)}const C=A.children;for(let A=0,e=C.length;A<e;A++)KA(C[A],g,I,t)}function JA(A,g,I,t){const C=A.opaque,e=A.transmissive,i=A.transparent;c.setupLightsView(I),e.length>0&&function(A,g,I){const t=P.isWebGL2;null===H&&(H=new eI(1,1,{generateMipmaps:!0,type:O.has("EXT_color_buffer_half_float")?wA:aA,minFilter:sA,samples:t&&!0===B?4:0}));u.getDrawingBufferSize(T),t?H.setSize(T.x,T.y):H.setSize(Kg(T.x),Kg(T.y));const C=u.getRenderTarget();u.setRenderTarget(H),u.clear();const e=u.toneMapping;u.toneMapping=Z,YA(A,g,I),u.toneMapping=e,_.updateMultisampleRenderTarget(H),_.updateRenderTargetMipmap(H),u.setRenderTarget(C)}(C,g,I),t&&X.viewport(N.copy(t)),C.length>0&&YA(C,g,I),e.length>0&&YA(e,g,I),i.length>0&&YA(i,g,I),X.buffers.depth.setTest(!0),X.buffers.depth.setMask(!0),X.buffers.color.setMask(!0),X.setPolygonOffset(!1)}function YA(A,g,I){const t=!0===g.isScene?g.overrideMaterial:null;for(let C=0,e=A.length;C<e;C++){const e=A[C],B=e.object,i=e.geometry,Q=null===t?e.material:t,o=e.group;B.layers.test(I.layers)&&LA(B,g,I,i,Q,o)}}function LA(A,g,I,t,C,e){A.onBeforeRender(u,g,I,t,C,e),A.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,A.matrixWorld),A.normalMatrix.getNormalMatrix(A.modelViewMatrix),C.onBeforeRender(u,g,I,t,A,e),!0===C.transparent&&C.side===a?(C.side=s,C.needsUpdate=!0,u.renderBufferDirect(I,g,t,C,A,e),C.side=n,C.needsUpdate=!0,u.renderBufferDirect(I,g,t,C,A,e),C.side=a):u.renderBufferDirect(I,g,t,C,A,e),A.onAfterRender(u,g,I,t,C,e)}function xA(A,g,I){!0!==g.isScene&&(g=V);const t=z.get(A),C=c.state.lights,e=c.state.shadowsArray,B=C.state.version,i=CA.getParameters(A,C.state,e,g,I),Q=CA.getProgramCacheKey(i);let o=t.programs;t.environment=A.isMeshStandardMaterial?g.environment:null,t.fog=g.fog,t.envMap=(A.isMeshStandardMaterial?AA:$).get(A.envMap||t.environment),void 0===o&&(A.addEventListener("dispose",mA),o=new Map,t.programs=o);let E=o.get(Q);if(void 0!==E){if(t.currentProgram===E&&t.lightsStateVersion===B)return bA(A,i),E}else i.uniforms=CA.getUniforms(A),A.onBuild(I,i,u),A.onBeforeCompile(i,u),E=CA.acquireProgram(i,Q),o.set(Q,E),t.uniforms=i.uniforms;const n=t.uniforms;(A.isShaderMaterial||A.isRawShaderMaterial)&&!0!==A.clipping||(n.clippingPlanes=QA.uniform),bA(A,i),t.needsLights=function(A){return A.isMeshLambertMaterial||A.isMeshToonMaterial||A.isMeshPhongMaterial||A.isMeshStandardMaterial||A.isShadowMaterial||A.isShaderMaterial&&!0===A.lights}(A),t.lightsStateVersion=B,t.needsLights&&(n.ambientLightColor.value=C.state.ambient,n.lightProbe.value=C.state.probe,n.directionalLights.value=C.state.directional,n.directionalLightShadows.value=C.state.directionalShadow,n.spotLights.value=C.state.spot,n.spotLightShadows.value=C.state.spotShadow,n.rectAreaLights.value=C.state.rectArea,n.ltc_1.value=C.state.rectAreaLTC1,n.ltc_2.value=C.state.rectAreaLTC2,n.pointLights.value=C.state.point,n.pointLightShadows.value=C.state.pointShadow,n.hemisphereLights.value=C.state.hemi,n.directionalShadowMap.value=C.state.directionalShadowMap,n.directionalShadowMatrix.value=C.state.directionalShadowMatrix,n.spotShadowMap.value=C.state.spotShadowMap,n.spotLightMatrix.value=C.state.spotLightMatrix,n.spotLightMap.value=C.state.spotLightMap,n.pointShadowMap.value=C.state.pointShadowMap,n.pointShadowMatrix.value=C.state.pointShadowMatrix);const s=E.getUniforms(),a=QB.seqWithValue(s.seq,n);return t.currentProgram=E,t.uniformsList=a,E}function bA(A,g){const I=z.get(A);I.outputEncoding=g.outputEncoding,I.instancing=g.instancing,I.skinning=g.skinning,I.morphTargets=g.morphTargets,I.morphNormals=g.morphNormals,I.morphColors=g.morphColors,I.morphTargetsCount=g.morphTargetsCount,I.numClippingPlanes=g.numClippingPlanes,I.numIntersection=g.numClipIntersection,I.vertexAlphas=g.vertexAlphas,I.vertexTangents=g.vertexTangents,I.toneMapping=g.toneMapping}UA.setAnimationLoop((function(A){kA&&kA(A)})),"undefined"!=typeof self&&UA.setContext(self),this.setAnimationLoop=function(A){kA=A,GA.setAnimationLoop(A),null===A?UA.stop():UA.start()},GA.addEventListener("sessionstart",SA),GA.addEventListener("sessionend",MA),this.render=function(A,g){if(void 0!==g&&!0!==g.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===w)return;!0===A.matrixWorldAutoUpdate&&A.updateMatrixWorld(),null===g.parent&&!0===g.matrixWorldAutoUpdate&&g.updateMatrixWorld(),!0===GA.enabled&&!0===GA.isPresenting&&(!0===GA.cameraAutoUpdate&&GA.updateCamera(g),g=GA.getCamera()),!0===A.isScene&&A.onBeforeRender(u,A,g,y),c=iA.get(A,D.length),c.init(),D.push(c),q.multiplyMatrices(g.projectionMatrix,g.matrixWorldInverse),L.setFromProjectionMatrix(q),b=this.localClippingEnabled,x=QA.init(this.clippingPlanes,b,g),h=BA.get(A,l.length),h.init(),l.push(h),KA(A,g,0,u.sortObjects),h.finish(),!0===u.sortObjects&&h.sort(M,U),!0===x&&QA.beginShadows();const I=c.state.shadowsArray;if(oA.render(I,A,g),!0===x&&QA.endShadows(),!0===this.info.autoReset&&this.info.reset(),EA.render(h,A),c.setupLights(u.physicallyCorrectLights),g.isArrayCamera){const I=g.cameras;for(let g=0,t=I.length;g<t;g++){const t=I[g];JA(h,A,t,t.viewport)}}else JA(h,A,g);null!==y&&(_.updateMultisampleRenderTarget(y),_.updateRenderTargetMipmap(y)),!0===A.isScene&&A.onAfterRender(u,A,g),lA.resetDefaultState(),G=-1,f=null,D.pop(),c=D.length>0?D[D.length-1]:null,l.pop(),h=l.length>0?l[l.length-1]:null},this.getActiveCubeFace=function(){return d},this.getActiveMipmapLevel=function(){return p},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(A,g,I){z.get(A.texture).__webglTexture=g,z.get(A.depthTexture).__webglTexture=I;const t=z.get(A);t.__hasExternalTextures=!0,t.__hasExternalTextures&&(t.__autoAllocateDepthBuffer=void 0===I,t.__autoAllocateDepthBuffer||!0===O.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),t.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(A,g){const I=z.get(A);I.__webglFramebuffer=g,I.__useDefaultFramebuffer=void 0===g},this.setRenderTarget=function(A,g=0,I=0){y=A,d=g,p=I;let t=!0;if(A){const g=z.get(A);void 0!==g.__useDefaultFramebuffer?(X.bindFramebuffer(36160,null),t=!1):void 0===g.__webglFramebuffer?_.setupRenderTarget(A):g.__hasExternalTextures&&_.rebindTextures(A,z.get(A.texture).__webglTexture,z.get(A.depthTexture).__webglTexture)}let C=null,e=!1,B=!1;if(A){const I=A.texture;(I.isData3DTexture||I.isDataArrayTexture)&&(B=!0);const t=z.get(A).__webglFramebuffer;A.isWebGLCubeRenderTarget?(C=t[g],e=!0):C=P.isWebGL2&&A.samples>0&&!1===_.useMultisampledRTT(A)?z.get(A).__webglMultisampledFramebuffer:t,N.copy(A.viewport),F.copy(A.scissor),R=A.scissorTest}else N.copy(K).multiplyScalar(S).floor(),F.copy(J).multiplyScalar(S).floor(),R=Y;if(X.bindFramebuffer(36160,C)&&P.drawBuffers&&t&&X.drawBuffers(A,C),X.viewport(N),X.scissor(F),X.setScissorTest(R),e){const t=z.get(A.texture);dA.framebufferTexture2D(36160,36064,34069+g,t.__webglTexture,I)}else if(B){const t=z.get(A.texture),C=g||0;dA.framebufferTextureLayer(36160,36064,t.__webglTexture,I||0,C)}G=-1},this.readRenderTargetPixels=function(A,g,I,t,C,e,B){if(!A||!A.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let i=z.get(A).__webglFramebuffer;if(A.isWebGLCubeRenderTarget&&void 0!==B&&(i=i[B]),i){X.bindFramebuffer(36160,i);try{const B=A.texture,i=B.format,Q=B.type;if(i!==NA&&cA.convert(i)!==dA.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const o=Q===wA&&(O.has("EXT_color_buffer_half_float")||P.isWebGL2&&O.has("EXT_color_buffer_float"));if(!(Q===aA||cA.convert(Q)===dA.getParameter(35738)||Q===uA&&(P.isWebGL2||O.has("OES_texture_float")||O.has("WEBGL_color_buffer_float"))||o))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");g>=0&&g<=A.width-t&&I>=0&&I<=A.height-C&&dA.readPixels(g,I,t,C,cA.convert(i),cA.convert(Q),e)}finally{const A=null!==y?z.get(y).__webglFramebuffer:null;X.bindFramebuffer(36160,A)}}},this.copyFramebufferToTexture=function(A,g,I=0){const t=Math.pow(2,-I),C=Math.floor(g.image.width*t),e=Math.floor(g.image.height*t);_.setTexture2D(g,0),dA.copyTexSubImage2D(3553,I,0,0,A.x,A.y,C,e),X.unbindTexture()},this.copyTextureToTexture=function(A,g,I,t=0){const C=g.image.width,e=g.image.height,B=cA.convert(I.format),i=cA.convert(I.type);_.setTexture2D(I,0),dA.pixelStorei(37440,I.flipY),dA.pixelStorei(37441,I.premultiplyAlpha),dA.pixelStorei(3317,I.unpackAlignment),g.isDataTexture?dA.texSubImage2D(3553,t,A.x,A.y,C,e,B,i,g.image.data):g.isCompressedTexture?dA.compressedTexSubImage2D(3553,t,A.x,A.y,g.mipmaps[0].width,g.mipmaps[0].height,B,g.mipmaps[0].data):dA.texSubImage2D(3553,t,A.x,A.y,B,i,g.image),0===t&&I.generateMipmaps&&dA.generateMipmap(3553),X.unbindTexture()},this.copyTextureToTexture3D=function(A,g,I,t,C=0){if(u.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const e=A.max.x-A.min.x+1,B=A.max.y-A.min.y+1,i=A.max.z-A.min.z+1,Q=cA.convert(t.format),o=cA.convert(t.type);let E;if(t.isData3DTexture)_.setTexture3D(t,0),E=32879;else{if(!t.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");_.setTexture2DArray(t,0),E=35866}dA.pixelStorei(37440,t.flipY),dA.pixelStorei(37441,t.premultiplyAlpha),dA.pixelStorei(3317,t.unpackAlignment);const n=dA.getParameter(3314),s=dA.getParameter(32878),a=dA.getParameter(3316),r=dA.getParameter(3315),h=dA.getParameter(32877),c=I.isCompressedTexture?I.mipmaps[0]:I.image;dA.pixelStorei(3314,c.width),dA.pixelStorei(32878,c.height),dA.pixelStorei(3316,A.min.x),dA.pixelStorei(3315,A.min.y),dA.pixelStorei(32877,A.min.z),I.isDataTexture||I.isData3DTexture?dA.texSubImage3D(E,C,g.x,g.y,g.z,e,B,i,Q,o,c.data):I.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),dA.compressedTexSubImage3D(E,C,g.x,g.y,g.z,e,B,i,Q,c.data)):dA.texSubImage3D(E,C,g.x,g.y,g.z,e,B,i,Q,o,c),dA.pixelStorei(3314,n),dA.pixelStorei(32878,s),dA.pixelStorei(3316,a),dA.pixelStorei(3315,r),dA.pixelStorei(32877,h),0===C&&t.generateMipmaps&&dA.generateMipmap(E),X.unbindTexture()},this.initTexture=function(A){A.isCubeTexture?_.setTextureCube(A,0):A.isData3DTexture?_.setTexture3D(A,0):A.isDataArrayTexture?_.setTexture2DArray(A,0):_.setTexture2D(A,0),X.unbindTexture()},this.resetState=function(){d=0,p=0,y=null,X.reset(),lA.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}(class extends Ii{}).prototype.isWebGL1Renderer=!0;function ti(A,g,I){return ei(A)?new A.constructor(A.subarray(g,void 0!==I?I:A.length)):A.slice(g,I)}function Ci(A,g,I){return!A||!I&&A.constructor===g?A:"number"==typeof g.BYTES_PER_ELEMENT?new g(A):Array.prototype.slice.call(A)}function ei(A){return ArrayBuffer.isView(A)&&!(A instanceof DataView)}class Bi{constructor(A,g,I,t){this.parameterPositions=A,this._cachedIndex=0,this.resultBuffer=void 0!==t?t:new g.constructor(I),this.sampleValues=g,this.valueSize=I,this.settings=null,this.DefaultSettings_={}}evaluate(A){const g=this.parameterPositions;let I=this._cachedIndex,t=g[I],C=g[I-1];A:{g:{let e;I:{t:if(!(A<t)){for(let e=I+2;;){if(void 0===t){if(A<C)break t;return I=g.length,this._cachedIndex=I,this.copySampleValue_(I-1)}if(I===e)break;if(C=t,t=g[++I],A<t)break g}e=g.length;break I}if(A>=C)break A;{const B=g[1];A<B&&(I=2,C=B);for(let e=I-2;;){if(void 0===C)return this._cachedIndex=0,this.copySampleValue_(0);if(I===e)break;if(t=C,C=g[--I-1],A>=C)break g}e=I,I=0}}for(;I<e;){const t=I+e>>>1;A<g[t]?e=t:I=t+1}if(t=g[I],C=g[I-1],void 0===C)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===t)return I=g.length,this._cachedIndex=I,this.copySampleValue_(I-1)}this._cachedIndex=I,this.intervalChanged_(I,C,t)}return this.interpolate_(I,C,A,t)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(A){const g=this.resultBuffer,I=this.sampleValues,t=this.valueSize,C=A*t;for(let A=0;A!==t;++A)g[A]=I[C+A];return g}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class ii extends Bi{constructor(A,g,I,t){super(A,g,I,t),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ng,endingEnd:ng}}intervalChanged_(A,g,I){const t=this.parameterPositions;let C=A-2,e=A+1,B=t[C],i=t[e];if(void 0===B)switch(this.getSettings_().endingStart){case sg:C=A,B=2*g-I;break;case ag:C=t.length-2,B=g+t[C]-t[C+1];break;default:C=A,B=I}if(void 0===i)switch(this.getSettings_().endingEnd){case sg:e=A,i=2*I-g;break;case ag:e=1,i=I+t[1]-t[0];break;default:e=A-1,i=g}const Q=.5*(I-g),o=this.valueSize;this._weightPrev=Q/(g-B),this._weightNext=Q/(i-I),this._offsetPrev=C*o,this._offsetNext=e*o}interpolate_(A,g,I,t){const C=this.resultBuffer,e=this.sampleValues,B=this.valueSize,i=A*B,Q=i-B,o=this._offsetPrev,E=this._offsetNext,n=this._weightPrev,s=this._weightNext,a=(I-g)/(t-g),r=a*a,h=r*a,c=-n*h+2*n*r-n*a,l=(1+n)*h+(-1.5-2*n)*r+(-.5+n)*a+1,D=(-1-s)*h+(1.5+s)*r+.5*a,u=s*h-s*r;for(let A=0;A!==B;++A)C[A]=c*e[o+A]+l*e[Q+A]+D*e[i+A]+u*e[E+A];return C}}class Qi extends Bi{constructor(A,g,I,t){super(A,g,I,t)}interpolate_(A,g,I,t){const C=this.resultBuffer,e=this.sampleValues,B=this.valueSize,i=A*B,Q=i-B,o=(I-g)/(t-g),E=1-o;for(let A=0;A!==B;++A)C[A]=e[Q+A]*E+e[i+A]*o;return C}}class oi extends Bi{constructor(A,g,I,t){super(A,g,I,t)}interpolate_(A){return this.copySampleValue_(A-1)}}class Ei{constructor(A,g,I,t){if(void 0===A)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===g||0===g.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+A);this.name=A,this.times=Ci(g,this.TimeBufferType),this.values=Ci(I,this.ValueBufferType),this.setInterpolation(t||this.DefaultInterpolation)}static toJSON(A){const g=A.constructor;let I;if(g.toJSON!==this.toJSON)I=g.toJSON(A);else{I={name:A.name,times:Ci(A.times,Array),values:Ci(A.values,Array)};const g=A.getInterpolation();g!==A.DefaultInterpolation&&(I.interpolation=g)}return I.type=A.ValueTypeName,I}InterpolantFactoryMethodDiscrete(A){return new oi(this.times,this.values,this.getValueSize(),A)}InterpolantFactoryMethodLinear(A){return new Qi(this.times,this.values,this.getValueSize(),A)}InterpolantFactoryMethodSmooth(A){return new ii(this.times,this.values,this.getValueSize(),A)}setInterpolation(A){let g;switch(A){case Qg:g=this.InterpolantFactoryMethodDiscrete;break;case og:g=this.InterpolantFactoryMethodLinear;break;case Eg:g=this.InterpolantFactoryMethodSmooth}if(void 0===g){const g="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(A===this.DefaultInterpolation)throw new Error(g);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",g),this}return this.createInterpolant=g,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Qg;case this.InterpolantFactoryMethodLinear:return og;case this.InterpolantFactoryMethodSmooth:return Eg}}getValueSize(){return this.values.length/this.times.length}shift(A){if(0!==A){const g=this.times;for(let I=0,t=g.length;I!==t;++I)g[I]+=A}return this}scale(A){if(1!==A){const g=this.times;for(let I=0,t=g.length;I!==t;++I)g[I]*=A}return this}trim(A,g){const I=this.times,t=I.length;let C=0,e=t-1;for(;C!==t&&I[C]<A;)++C;for(;-1!==e&&I[e]>g;)--e;if(++e,0!==C||e!==t){C>=e&&(e=Math.max(e,1),C=e-1);const A=this.getValueSize();this.times=ti(I,C,e),this.values=ti(this.values,C*A,e*A)}return this}validate(){let A=!0;const g=this.getValueSize();g-Math.floor(g)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),A=!1);const I=this.times,t=this.values,C=I.length;0===C&&(console.error("THREE.KeyframeTrack: Track is empty.",this),A=!1);let e=null;for(let g=0;g!==C;g++){const t=I[g];if("number"==typeof t&&isNaN(t)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,g,t),A=!1;break}if(null!==e&&e>t){console.error("THREE.KeyframeTrack: Out of order keys.",this,g,t,e),A=!1;break}e=t}if(void 0!==t&&ei(t))for(let g=0,I=t.length;g!==I;++g){const I=t[g];if(isNaN(I)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,g,I),A=!1;break}}return A}optimize(){const A=ti(this.times),g=ti(this.values),I=this.getValueSize(),t=this.getInterpolation()===Eg,C=A.length-1;let e=1;for(let B=1;B<C;++B){let C=!1;const i=A[B];if(i!==A[B+1]&&(1!==B||i!==A[0]))if(t)C=!0;else{const A=B*I,t=A-I,e=A+I;for(let B=0;B!==I;++B){const I=g[A+B];if(I!==g[t+B]||I!==g[e+B]){C=!0;break}}}if(C){if(B!==e){A[e]=A[B];const t=B*I,C=e*I;for(let A=0;A!==I;++A)g[C+A]=g[t+A]}++e}}if(C>0){A[e]=A[C];for(let A=C*I,t=e*I,B=0;B!==I;++B)g[t+B]=g[A+B];++e}return e!==A.length?(this.times=ti(A,0,e),this.values=ti(g,0,e*I)):(this.times=A,this.values=g),this}clone(){const A=ti(this.times,0),g=ti(this.values,0),I=new(0,this.constructor)(this.name,A,g);return I.createInterpolant=this.createInterpolant,I}}Ei.prototype.TimeBufferType=Float32Array,Ei.prototype.ValueBufferType=Float32Array,Ei.prototype.DefaultInterpolation=og;class ni extends Ei{}ni.prototype.ValueTypeName="bool",ni.prototype.ValueBufferType=Array,ni.prototype.DefaultInterpolation=Qg,ni.prototype.InterpolantFactoryMethodLinear=void 0,ni.prototype.InterpolantFactoryMethodSmooth=void 0;class si extends Ei{}si.prototype.ValueTypeName="color";class ai extends Ei{}ai.prototype.ValueTypeName="number";class ri extends Bi{constructor(A,g,I,t){super(A,g,I,t)}interpolate_(A,g,I,t){const C=this.resultBuffer,e=this.sampleValues,B=this.valueSize,i=(I-g)/(t-g);let Q=A*B;for(let A=Q+B;Q!==A;Q+=4)QI.slerpFlat(C,0,e,Q-B,e,Q,i);return C}}class hi extends Ei{InterpolantFactoryMethodLinear(A){return new ri(this.times,this.values,this.getValueSize(),A)}}hi.prototype.ValueTypeName="quaternion",hi.prototype.DefaultInterpolation=og,hi.prototype.InterpolantFactoryMethodSmooth=void 0;class ci extends Ei{}ci.prototype.ValueTypeName="string",ci.prototype.ValueBufferType=Array,ci.prototype.DefaultInterpolation=Qg,ci.prototype.InterpolantFactoryMethodLinear=void 0,ci.prototype.InterpolantFactoryMethodSmooth=void 0;class li extends Ei{}li.prototype.ValueTypeName="vector";const Di="\\[\\]\\.:\\/",ui=new RegExp("["+Di+"]","g"),wi="[^"+Di+"]",di="[^"+Di.replace("\\.","")+"]",pi=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",wi)+/(WCOD+)?/.source.replace("WCOD",di)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",wi)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",wi)+"$"),yi=["material","materials","bones","map"];class Gi{constructor(A,g,I){this.path=g,this.parsedPath=I||Gi.parseTrackName(g),this.node=Gi.findNode(A,this.parsedPath.nodeName)||A,this.rootNode=A,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(A,g,I){return A&&A.isAnimationObjectGroup?new Gi.Composite(A,g,I):new Gi(A,g,I)}static sanitizeNodeName(A){return A.replace(/\s/g,"_").replace(ui,"")}static parseTrackName(A){const g=pi.exec(A);if(null===g)throw new Error("PropertyBinding: Cannot parse trackName: "+A);const I={nodeName:g[2],objectName:g[3],objectIndex:g[4],propertyName:g[5],propertyIndex:g[6]},t=I.nodeName&&I.nodeName.lastIndexOf(".");if(void 0!==t&&-1!==t){const A=I.nodeName.substring(t+1);-1!==yi.indexOf(A)&&(I.nodeName=I.nodeName.substring(0,t),I.objectName=A)}if(null===I.propertyName||0===I.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+A);return I}static findNode(A,g){if(void 0===g||""===g||"."===g||-1===g||g===A.name||g===A.uuid)return A;if(A.skeleton){const I=A.skeleton.getBoneByName(g);if(void 0!==I)return I}if(A.children){const I=function(A){for(let t=0;t<A.length;t++){const C=A[t];if(C.name===g||C.uuid===g)return C;const e=I(C.children);if(e)return e}return null},t=I(A.children);if(t)return t}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(A,g){A[g]=this.targetObject[this.propertyName]}_getValue_array(A,g){const I=this.resolvedProperty;for(let t=0,C=I.length;t!==C;++t)A[g++]=I[t]}_getValue_arrayElement(A,g){A[g]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(A,g){this.resolvedProperty.toArray(A,g)}_setValue_direct(A,g){this.targetObject[this.propertyName]=A[g]}_setValue_direct_setNeedsUpdate(A,g){this.targetObject[this.propertyName]=A[g],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(A,g){this.targetObject[this.propertyName]=A[g],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(A,g){const I=this.resolvedProperty;for(let t=0,C=I.length;t!==C;++t)I[t]=A[g++]}_setValue_array_setNeedsUpdate(A,g){const I=this.resolvedProperty;for(let t=0,C=I.length;t!==C;++t)I[t]=A[g++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(A,g){const I=this.resolvedProperty;for(let t=0,C=I.length;t!==C;++t)I[t]=A[g++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(A,g){this.resolvedProperty[this.propertyIndex]=A[g]}_setValue_arrayElement_setNeedsUpdate(A,g){this.resolvedProperty[this.propertyIndex]=A[g],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(A,g){this.resolvedProperty[this.propertyIndex]=A[g],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(A,g){this.resolvedProperty.fromArray(A,g)}_setValue_fromArray_setNeedsUpdate(A,g){this.resolvedProperty.fromArray(A,g),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(A,g){this.resolvedProperty.fromArray(A,g),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(A,g){this.bind(),this.getValue(A,g)}_setValue_unbound(A,g){this.bind(),this.setValue(A,g)}bind(){let A=this.node;const g=this.parsedPath,I=g.objectName,t=g.propertyName;let C=g.propertyIndex;if(A||(A=Gi.findNode(this.rootNode,g.nodeName)||this.rootNode,this.node=A),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!A)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(I){let t=g.objectIndex;switch(I){case"materials":if(!A.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!A.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);A=A.material.materials;break;case"bones":if(!A.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);A=A.skeleton.bones;for(let g=0;g<A.length;g++)if(A[g].name===t){t=g;break}break;case"map":if("map"in A){A=A.map;break}if(!A.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!A.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);A=A.material.map;break;default:if(void 0===A[I])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);A=A[I]}if(void 0!==t){if(void 0===A[t])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,A);A=A[t]}}const e=A[t];if(void 0===e){const I=g.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+I+"."+t+" but it wasn't found.",A)}let B=this.Versioning.None;this.targetObject=A,void 0!==A.needsUpdate?B=this.Versioning.NeedsUpdate:void 0!==A.matrixWorldNeedsUpdate&&(B=this.Versioning.MatrixWorldNeedsUpdate);let i=this.BindingType.Direct;if(void 0!==C){if("morphTargetInfluences"===t){if(!A.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!A.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==A.morphTargetDictionary[C]&&(C=A.morphTargetDictionary[C])}i=this.BindingType.ArrayElement,this.resolvedProperty=e,this.propertyIndex=C}else void 0!==e.fromArray&&void 0!==e.toArray?(i=this.BindingType.HasFromToArray,this.resolvedProperty=e):Array.isArray(e)?(i=this.BindingType.EntireArray,this.resolvedProperty=e):this.propertyName=t;this.getValue=this.GetterByBindingType[i],this.setValue=this.SetterByBindingTypeAndVersioning[i][B]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Gi.Composite=class{constructor(A,g,I){const t=I||Gi.parseTrackName(g);this._targetGroup=A,this._bindings=A.subscribe_(g,t)}getValue(A,g){this.bind();const I=this._targetGroup.nCachedObjects_,t=this._bindings[I];void 0!==t&&t.getValue(A,g)}setValue(A,g){const I=this._bindings;for(let t=this._targetGroup.nCachedObjects_,C=I.length;t!==C;++t)I[t].setValue(A,g)}bind(){const A=this._bindings;for(let g=this._targetGroup.nCachedObjects_,I=A.length;g!==I;++g)A[g].bind()}unbind(){const A=this._bindings;for(let g=this._targetGroup.nCachedObjects_,I=A.length;g!==I;++g)A[g].unbind()}},Gi.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Gi.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Gi.prototype.GetterByBindingType=[Gi.prototype._getValue_direct,Gi.prototype._getValue_array,Gi.prototype._getValue_arrayElement,Gi.prototype._getValue_toArray],Gi.prototype.SetterByBindingTypeAndVersioning=[[Gi.prototype._setValue_direct,Gi.prototype._setValue_direct_setNeedsUpdate,Gi.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Gi.prototype._setValue_array,Gi.prototype._setValue_array_setNeedsUpdate,Gi.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Gi.prototype._setValue_arrayElement,Gi.prototype._setValue_arrayElement_setNeedsUpdate,Gi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Gi.prototype._setValue_fromArray,Gi.prototype._setValue_fromArray_setNeedsUpdate,Gi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];new Float32Array(1);"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:C}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=C);const fi=require("react");var Ni=I.n(fi);const Fi=require("jotai");var Ri=I(970);const mi=require("@react-three/drei");var ki=I(557);const Si=require("react-webcam");var Mi=I.n(Si);function Ui(A,g){return function(A){if(Array.isArray(A))return A}(A)||function(A,g){var I=null==A?null:"undefined"!=typeof Symbol&&A[Symbol.iterator]||A["@@iterator"];if(null!=I){var t,C,e,B,i=[],Q=!0,o=!1;try{if(e=(I=I.call(A)).next,0===g){if(Object(I)!==I)return;Q=!1}else for(;!(Q=(t=e.call(I)).done)&&(i.push(t.value),i.length!==g);Q=!0);}catch(A){o=!0,C=A}finally{try{if(!Q&&null!=I.return&&(B=I.return(),Object(B)!==B))return}finally{if(o)throw C}}return i}}(A,g)||function(A,g){if(!A)return;if("string"==typeof A)return Ki(A,g);var I=Object.prototype.toString.call(A).slice(8,-1);"Object"===I&&A.constructor&&(I=A.constructor.name);if("Map"===I||"Set"===I)return Array.from(A);if("Arguments"===I||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(I))return Ki(A,g)}(A,g)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ki(A,g){(null==g||g>A.length)&&(g=A.length);for(var I=0,t=new Array(g);I<g;I++)t[I]=A[I];return t}function Ji(A){return Ji="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&"function"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?"symbol":typeof A},Ji(A)}var Yi=["children","autoplay","imageTargets","maxTrack","filterMinCF","filterBeta","warmupTolerance","missTolerance","flipUserCamera","onReady","onError"],Li=["children","target","onAnchorFound","onAnchorLost"],xi=["children","onFaceFound","onFaceLost"];function bi(){return bi=Object.assign?Object.assign.bind():function(A){for(var g=1;g<arguments.length;g++){var I=arguments[g];for(var t in I)Object.prototype.hasOwnProperty.call(I,t)&&(A[t]=I[t])}return A},bi.apply(this,arguments)}function Hi(A,g){if(null==A)return{};var I,t,C=function(A,g){if(null==A)return{};var I,t,C={},e=Object.keys(A);for(t=0;t<e.length;t++)I=e[t],g.indexOf(I)>=0||(C[I]=A[I]);return C}(A,g);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(A);for(t=0;t<e.length;t++)I=e[t],g.indexOf(I)>=0||Object.prototype.propertyIsEnumerable.call(A,I)&&(C[I]=A[I])}return C}function qi(){qi=function(){return g};var A,g={},I=Object.prototype,t=I.hasOwnProperty,C=Object.defineProperty||function(A,g,I){A[g]=I.value},e="function"==typeof Symbol?Symbol:{},B=e.iterator||"@@iterator",i=e.asyncIterator||"@@asyncIterator",Q=e.toStringTag||"@@toStringTag";function o(A,g,I){return Object.defineProperty(A,g,{value:I,enumerable:!0,configurable:!0,writable:!0}),A[g]}try{o({},"")}catch(A){o=function(A,g,I){return A[g]=I}}function E(A,g,I,t){var e=g&&g.prototype instanceof l?g:l,B=Object.create(e.prototype),i=new k(t||[]);return C(B,"_invoke",{value:N(A,I,i)}),B}function n(A,g,I){try{return{type:"normal",arg:A.call(g,I)}}catch(A){return{type:"throw",arg:A}}}g.wrap=E;var s="suspendedStart",a="suspendedYield",r="executing",h="completed",c={};function l(){}function D(){}function u(){}var w={};o(w,B,(function(){return this}));var d=Object.getPrototypeOf,p=d&&d(d(S([])));p&&p!==I&&t.call(p,B)&&(w=p);var y=u.prototype=l.prototype=Object.create(w);function G(A){["next","throw","return"].forEach((function(g){o(A,g,(function(A){return this._invoke(g,A)}))}))}function f(A,g){function I(C,e,B,i){var Q=n(A[C],A,e);if("throw"!==Q.type){var o=Q.arg,E=o.value;return E&&"object"==Ji(E)&&t.call(E,"__await")?g.resolve(E.__await).then((function(A){I("next",A,B,i)}),(function(A){I("throw",A,B,i)})):g.resolve(E).then((function(A){o.value=A,B(o)}),(function(A){return I("throw",A,B,i)}))}i(Q.arg)}var e;C(this,"_invoke",{value:function(A,t){function C(){return new g((function(g,C){I(A,t,g,C)}))}return e=e?e.then(C,C):C()}})}function N(g,I,t){var C=s;return function(e,B){if(C===r)throw new Error("Generator is already running");if(C===h){if("throw"===e)throw B;return{value:A,done:!0}}for(t.method=e,t.arg=B;;){var i=t.delegate;if(i){var Q=F(i,t);if(Q){if(Q===c)continue;return Q}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(C===s)throw C=h,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);C=r;var o=n(g,I,t);if("normal"===o.type){if(C=t.done?h:a,o.arg===c)continue;return{value:o.arg,done:t.done}}"throw"===o.type&&(C=h,t.method="throw",t.arg=o.arg)}}}function F(g,I){var t=I.method,C=g.iterator[t];if(C===A)return I.delegate=null,"throw"===t&&g.iterator.return&&(I.method="return",I.arg=A,F(g,I),"throw"===I.method)||"return"!==t&&(I.method="throw",I.arg=new TypeError("The iterator does not provide a '"+t+"' method")),c;var e=n(C,g.iterator,I.arg);if("throw"===e.type)return I.method="throw",I.arg=e.arg,I.delegate=null,c;var B=e.arg;return B?B.done?(I[g.resultName]=B.value,I.next=g.nextLoc,"return"!==I.method&&(I.method="next",I.arg=A),I.delegate=null,c):B:(I.method="throw",I.arg=new TypeError("iterator result is not an object"),I.delegate=null,c)}function R(A){var g={tryLoc:A[0]};1 in A&&(g.catchLoc=A[1]),2 in A&&(g.finallyLoc=A[2],g.afterLoc=A[3]),this.tryEntries.push(g)}function m(A){var g=A.completion||{};g.type="normal",delete g.arg,A.completion=g}function k(A){this.tryEntries=[{tryLoc:"root"}],A.forEach(R,this),this.reset(!0)}function S(g){if(g||""===g){var I=g[B];if(I)return I.call(g);if("function"==typeof g.next)return g;if(!isNaN(g.length)){var C=-1,e=function I(){for(;++C<g.length;)if(t.call(g,C))return I.value=g[C],I.done=!1,I;return I.value=A,I.done=!0,I};return e.next=e}}throw new TypeError(Ji(g)+" is not iterable")}return D.prototype=u,C(y,"constructor",{value:u,configurable:!0}),C(u,"constructor",{value:D,configurable:!0}),D.displayName=o(u,Q,"GeneratorFunction"),g.isGeneratorFunction=function(A){var g="function"==typeof A&&A.constructor;return!!g&&(g===D||"GeneratorFunction"===(g.displayName||g.name))},g.mark=function(A){return Object.setPrototypeOf?Object.setPrototypeOf(A,u):(A.__proto__=u,o(A,Q,"GeneratorFunction")),A.prototype=Object.create(y),A},g.awrap=function(A){return{__await:A}},G(f.prototype),o(f.prototype,i,(function(){return this})),g.AsyncIterator=f,g.async=function(A,I,t,C,e){void 0===e&&(e=Promise);var B=new f(E(A,I,t,C),e);return g.isGeneratorFunction(I)?B:B.next().then((function(A){return A.done?A.value:B.next()}))},G(y),o(y,Q,"Generator"),o(y,B,(function(){return this})),o(y,"toString",(function(){return"[object Generator]"})),g.keys=function(A){var g=Object(A),I=[];for(var t in g)I.push(t);return I.reverse(),function A(){for(;I.length;){var t=I.pop();if(t in g)return A.value=t,A.done=!1,A}return A.done=!0,A}},g.values=S,k.prototype={constructor:k,reset:function(g){if(this.prev=0,this.next=0,this.sent=this._sent=A,this.done=!1,this.delegate=null,this.method="next",this.arg=A,this.tryEntries.forEach(m),!g)for(var I in this)"t"===I.charAt(0)&&t.call(this,I)&&!isNaN(+I.slice(1))&&(this[I]=A)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if("throw"===A.type)throw A.arg;return this.rval},dispatchException:function(g){if(this.done)throw g;var I=this;function C(t,C){return i.type="throw",i.arg=g,I.next=t,C&&(I.method="next",I.arg=A),!!C}for(var e=this.tryEntries.length-1;e>=0;--e){var B=this.tryEntries[e],i=B.completion;if("root"===B.tryLoc)return C("end");if(B.tryLoc<=this.prev){var Q=t.call(B,"catchLoc"),o=t.call(B,"finallyLoc");if(Q&&o){if(this.prev<B.catchLoc)return C(B.catchLoc,!0);if(this.prev<B.finallyLoc)return C(B.finallyLoc)}else if(Q){if(this.prev<B.catchLoc)return C(B.catchLoc,!0)}else{if(!o)throw new Error("try statement without catch or finally");if(this.prev<B.finallyLoc)return C(B.finallyLoc)}}}},abrupt:function(A,g){for(var I=this.tryEntries.length-1;I>=0;--I){var C=this.tryEntries[I];if(C.tryLoc<=this.prev&&t.call(C,"finallyLoc")&&this.prev<C.finallyLoc){var e=C;break}}e&&("break"===A||"continue"===A)&&e.tryLoc<=g&&g<=e.finallyLoc&&(e=null);var B=e?e.completion:{};return B.type=A,B.arg=g,e?(this.method="next",this.next=e.finallyLoc,c):this.complete(B)},complete:function(A,g){if("throw"===A.type)throw A.arg;return"break"===A.type||"continue"===A.type?this.next=A.arg:"return"===A.type?(this.rval=this.arg=A.arg,this.method="return",this.next="end"):"normal"===A.type&&g&&(this.next=g),c},finish:function(A){for(var g=this.tryEntries.length-1;g>=0;--g){var I=this.tryEntries[g];if(I.finallyLoc===A)return this.complete(I.completion,I.afterLoc),m(I),c}},catch:function(A){for(var g=this.tryEntries.length-1;g>=0;--g){var I=this.tryEntries[g];if(I.tryLoc===A){var t=I.completion;if("throw"===t.type){var C=t.arg;m(I)}return C}}throw new Error("illegal catch attempt")},delegateYield:function(g,I,t){return this.delegate={iterator:S(g),resultName:I,nextLoc:t},"next"===this.method&&(this.arg=A),c}},g}function Ti(A){return function(A){if(Array.isArray(A))return ji(A)}(A)||function(A){if("undefined"!=typeof Symbol&&null!=A[Symbol.iterator]||null!=A["@@iterator"])return Array.from(A)}(A)||Xi(A)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function vi(A,g){var I=Object.keys(A);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(A);g&&(t=t.filter((function(g){return Object.getOwnPropertyDescriptor(A,g).enumerable}))),I.push.apply(I,t)}return I}function Vi(A){for(var g=1;g<arguments.length;g++){var I=null!=arguments[g]?arguments[g]:{};g%2?vi(Object(I),!0).forEach((function(g){Wi(A,g,I[g])})):Object.getOwnPropertyDescriptors?Object.defineProperties(A,Object.getOwnPropertyDescriptors(I)):vi(Object(I)).forEach((function(g){Object.defineProperty(A,g,Object.getOwnPropertyDescriptor(I,g))}))}return A}function Wi(A,g,I){return(g=function(A){var g=function(A,g){if("object"!==Ji(A)||null===A)return A;var I=A[Symbol.toPrimitive];if(void 0!==I){var t=I.call(A,g||"default");if("object"!==Ji(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===g?String:Number)(A)}(A,"string");return"symbol"===Ji(g)?g:String(g)}(g))in A?Object.defineProperty(A,g,{value:I,enumerable:!0,configurable:!0,writable:!0}):A[g]=I,A}function Oi(A,g,I,t,C,e,B){try{var i=A[e](B),Q=i.value}catch(A){return void I(A)}i.done?g(Q):Promise.resolve(Q).then(t,C)}function Zi(A){return function(){var g=this,I=arguments;return new Promise((function(t,C){var e=A.apply(g,I);function B(A){Oi(e,t,C,B,i,"next",A)}function i(A){Oi(e,t,C,B,i,"throw",A)}B(void 0)}))}}function Pi(A,g){return function(A){if(Array.isArray(A))return A}(A)||function(A,g){var I=null==A?null:"undefined"!=typeof Symbol&&A[Symbol.iterator]||A["@@iterator"];if(null!=I){var t,C,e,B,i=[],Q=!0,o=!1;try{if(e=(I=I.call(A)).next,0===g){if(Object(I)!==I)return;Q=!1}else for(;!(Q=(t=e.call(I)).done)&&(i.push(t.value),i.length!==g);Q=!0);}catch(A){o=!0,C=A}finally{try{if(!Q&&null!=I.return&&(B=I.return(),Object(B)!==B))return}finally{if(o)throw C}}return i}}(A,g)||Xi(A,g)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Xi(A,g){if(A){if("string"==typeof A)return ji(A,g);var I=Object.prototype.toString.call(A).slice(8,-1);return"Object"===I&&A.constructor&&(I=A.constructor.name),"Map"===I||"Set"===I?Array.from(A):"Arguments"===I||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(I)?ji(A,g):void 0}}function ji(A,g){(null==g||g>A.length)&&(g=A.length);for(var I=0,t=new Array(g);I<g;I++)t[I]=A[I];return t}var zi=(0,Fi.atom)(!1),_i=(0,Fi.atom)({}),$i=(0,Fi.atom)(),AQ=(0,Fi.atom)(!0),gQ=(0,fi.forwardRef)((function(g,I){var t=g.children,C=g.autoplay,e=g.imageTargets,B=g.maxTrack,i=g.filterMinCF,Q=void 0===i?null:i,o=g.filterBeta,E=void 0===o?null:o,n=g.warmupTolerance,s=void 0===n?null:n,a=g.missTolerance,r=void 0===a?null:a,h=g.flipUserCamera,c=void 0===h||h,l=g.onReady,D=void 0===l?null:l,u=g.onError,w=void 0===u?null:u,d=Pi((0,fi.useState)(!Boolean(e)),2),p=d[0],y=d[1],G=(0,fi.useRef)(null),f=Pi((0,fi.useState)(!1),2),N=f[0],F=f[1],R=(0,fi.useRef)(null),m=(0,A.useThree)().camera,k=(0,Fi.useSetAtom)(zi),S=(0,Fi.useSetAtom)(_i),M=(0,Fi.useSetAtom)($i),U=(0,Fi.useSetAtom)(AQ),K=function(){var A=Ui((0,fi.useState)({width:void 0,height:void 0}),2),g=A[0],I=A[1];return(0,fi.useEffect)((function(){function A(){I({width:window.innerWidth,height:window.innerHeight})}return window.addEventListener("resize",A),A(),function(){return window.removeEventListener("resize",A)}}),[]),g}(),J=K.width,Y=K.height;(0,fi.useEffect)((function(){return U(c)}),[c,U]),(0,fi.useEffect)((function(){k(Boolean(e))}),[e,k]);var L=(0,fi.useCallback)((function(){G.current&&G.current.video.addEventListener("loadedmetadata",(function(){return F(!0)}))}),[G]),x=(0,fi.useCallback)(Zi(qi().mark((function A(){var g,I,t,C,i,o,n,a,h,c,l,u,w,d;return qi().wrap((function(A){for(;;)switch(A.prev=A.next){case 0:if(!N){A.next=35;break}if(!e){A.next=20;break}return g=new ki.Controller({inputWidth:G.current.video.videoWidth,inputHeight:G.current.video.videoHeight,maxTrack:B,filterMinCF:Q,filterBeta:E,missTolerance:r,warmupTolerance:s}),A.next=5,g.addImageTargets(e);case 5:I=A.sent,t=I.dimensions,C=I.matchingDataList,i=I.trackingDataList,o=I.dataList,n=I.buffer,a=t.map((function(A){var g=Pi(A,2),I=g[0],t=g[1];return(new HI).compose(new oI(I/2,I/2+(t-I)/2),new QI,new oI(I,I,I))})),h=g.getProjectionMatrix(),m.fov=2*Math.atan(1/h[5])*180/Math.PI,m.near=h[14]/(h[10]-1),m.far=h[14]/(h[10]+1),m.updateProjectionMatrix(),g.onUpdate=function(A){var g=A.type,I=A.targetIndex,t=A.worldMatrix;"updateMatrix"===g&&S((function(A){return Vi(Vi({otherData:{matchingDataList:C,trackingDataList:i,dataList:o,buffer:n}},A),{},Wi({},I,null!==t?(new HI).fromArray(Ti(t)).multiply(a[I]).toArray():null))}))},A.next=30;break;case 20:return(g=new Ri.Controller({filterMinCF:Q,filterBeta:E})).onUpdate=function(A){var g=A.hasFace,I=A.estimateResult;return M(g?I:null)},A.next=24,g.setup(G.current.video);case 24:c=g.getCameraParams(),l=c.fov,u=c.aspect,w=c.near,d=c.far,m.fov=l,m.aspect=u,m.near=w,m.far=d,m.updateProjectionMatrix();case 30:return A.next=32,g.dummyRun(G.current.video);case 32:g.processVideo(G.current.video),R.current=g,D&&D();case 35:case"end":return A.stop()}}),A)}))),[N,e,D,B,Q,E,r,s,m,S,M]),b=(0,fi.useCallback)((function(){R.current&&R.current.stopProcessVideo()}),[R]);(0,fi.useImperativeHandle)(I,(function(){return{startTracking:x,stopTracking:b,switchCamera:function(){var A=R.current&&R.current.processingVideo;A&&b(),F(!1),y((function(A){return!A})),A&&x()}}}),[x,b]),(0,fi.useEffect)((function(){N&&C&&x()}),[C,N,x]);var H=(0,fi.useMemo)((function(){var A;return{width:"auto",maxWidth:"none",height:"inherit",marginLeft:"".concat((null===(A=G.current)||void 0===A||null===(A=A.video)||void 0===A?void 0:A.clientWidth)>0&&N?parseInt((J-G.current.video.clientWidth)/2):0,"px")}}),[J,N,G]);return Ni().createElement(Ni().Fragment,null,Ni().createElement(mi.Html,{fullscreen:!0,zIndexRange:[-1,-1],calculatePosition:function(){return[0,0]},style:{top:0,left:0}},Ni().createElement(Mi(),{ref:G,onUserMedia:L,onUserMediaError:function(A){w&&w(A)},height:Y,width:J,videoConstraints:{facingMode:p?"user":"environment"},style:H,mirrored:p&&c})),t)})),IQ=(0,fi.forwardRef)((function(g,I){var t=g.children,C=g.autoplay,e=void 0===C||C,B=g.imageTargets,i=g.maxTrack,Q=void 0===i?1:i,o=g.filterMinCF,E=g.filterBeta,n=g.warmupTolerance,s=g.missTolerance,a=g.flipUserCamera,r=void 0===a||a,h=g.onReady,c=g.onError,l=Hi(g,Yi),D=(0,fi.useRef)(null),u=(0,fi.useRef)(null);return(0,fi.useImperativeHandle)(I,(function(){return{startTracking:function(){var A;return null==u||null===(A=u.current)||void 0===A?void 0:A.startTracking()},stopTracking:function(){var A;return null==u||null===(A=u.current)||void 0===A?void 0:A.stopTracking()},switchCamera:function(){var A;return null==u||null===(A=u.current)||void 0===A?void 0:A.switchCamera()},current:D.current}})),Ni().createElement(A.Canvas,bi({style:{position:"absolute",minWidth:"100vw",minHeight:"100vh"}},l,{ref:D}),Ni().createElement(fi.Suspense,{fallback:null},Ni().createElement(gQ,{autoplay:e,imageTargets:B,maxTrack:Q,filterMinCF:o,filterBeta:E,warmupTolerance:n,missTolerance:s,flipUserCamera:r,onReady:h,onError:c,ref:u},t)))})),tQ=function(A){var g=A.children,I=A.target,t=void 0===I?0:I,C=A.onAnchorFound,e=A.onAnchorLost,B=Hi(A,Li),i=(0,fi.useRef)(),Q=(0,Fi.useAtomValue)(_i),o=(0,Fi.useAtomValue)(zi),E=(0,Fi.useAtomValue)($i),n=(0,Fi.useAtomValue)(AQ);return(0,fi.useEffect)((function(){if(i.current)if(o)Q[t]?(!0!==i.current.visible&&C&&C({anchor:Q,ref:i}),i.current.visible=!0,i.current.matrix=(new HI).fromArray(Q[t])):(!1!==i.current.visible&&e&&e(),i.current.visible=!1);else if(E){var A;!0!==i.current.visible&&C&&C({anchor:Q,ref:i}),i.current.visible=!0;var g=E.faceMatrix,I=E.faceScale,B=[E.metricLandmarks[t][0],E.metricLandmarks[t][1],E.metricLandmarks[t][2]];(A=i.current.matrix).set.apply(A,[g[0]*I,g[1]*I,g[2]*I,g[0]*B[0]+g[1]*B[1]+g[2]*B[2]+g[3],g[4]*I,g[5]*I,g[6]*I,g[4]*B[0]+g[5]*B[1]+g[6]*B[2]+g[7],g[8]*I,g[9]*I,g[10]*I,g[8]*B[0]+g[9]*B[1]+g[10]*B[2]+g[11],g[12]*I,g[13]*I,g[14]*I,g[12]*B[0]+g[13]*B[1]+g[14]*B[2]+g[15]])}else!1!==i.current.visible&&e&&e(),i.current.visible=!1}),[Q,t,C,e,o,E]),Ni().createElement("group",{scale:[n?-1:1,1,1]},Ni().createElement("group",bi({ref:i,visible:!1,matrixAutoUpdate:!1},B),g))},CQ=function(A){var I=A.children,t=A.onFaceFound,C=A.onFaceLost,e=Hi(A,xi),B=(0,fi.useRef)(),i=(0,Fi.useAtomValue)($i),Q=(0,Fi.useAtomValue)(AQ),o=(0,fi.useMemo)((function(){for(var A=new Float32Array(3*g.uvs.length),I=new Float32Array(2*g.uvs.length),t=new Uint32Array(g.faces),C=0;C<g.uvs.length;C++)I[2*C]=g.uvs[C][0],I[2*C+1]=g.uvs[C][1];return[A,I,t]}),[]),E=Pi(o,3),n=E[0],s=E[1],a=E[2];return(0,fi.useEffect)((function(){if(B.current)if(i){var A;!0!==B.current.visible&&t&&t(),B.current.visible=!0,(A=B.current.matrix).set.apply(A,Ti(i.faceMatrix));for(var I=0;I<g.uvs.length;I++)B.current.geometry.attributes.position.set(i.metricLandmarks[I],3*I);B.current.geometry.attributes.position.needsUpdate=!0,B.current.geometry.computeVertexNormals()}else!1!==B.current.visible&&C&&C(),B.current.visible=!1}),[t,C,i]),Ni().createElement("group",{scale:[Q?-1:1,1,1]},Ni().createElement("mesh",bi({ref:B,visible:!1,matrixAutoUpdate:!1},e),Ni().createElement("bufferGeometry",{attach:"geometry"},Ni().createElement("bufferAttribute",{attach:"index",array:a,count:a.length,itemSize:1}),Ni().createElement("bufferAttribute",{attach:"attributes-position",count:n.length/3,itemSize:3,array:n}),Ni().createElement("bufferAttribute",{attach:"attributes-uv",count:s.length/2,itemSize:2,array:s})),I))}})(),module.exports=t})();